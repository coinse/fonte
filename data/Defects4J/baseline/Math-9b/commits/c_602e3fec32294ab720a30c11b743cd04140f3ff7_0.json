{"sha": "602e3fec32294ab720a30c11b743cd04140f3ff7", "log": "Added Genetic Algorithm implementation. JIRA: MATH-207 Contributed by David Stefka  ", "commit": "\n--- /dev/null\n+++ b/src/java/org/apache/commons/math/genetics/AbstractListChromosome.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.genetics;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.List;\n+\n+/**\n+ * Chromosome represented by an immutable list of a fixed length.\n+ * \n+ * @param <T> type of the representation list\n+ * @version $Revision:$ $Date:$\n+ * @since 2.0\n+ */\n+public abstract class AbstractListChromosome<T> extends Chromosome {\n+    \n+    /** List representing the chromosome */\n+    private final List<T> representation;\n+    \n+    /**\n+     * Constructor.\n+     * @param representation inner representation of the chromosome\n+     */\n+    public AbstractListChromosome(final List<T> representation) {\n+        try {\n+            checkValidity(representation);\n+        } catch (InvalidRepresentationException e) {\n+            throw new IllegalArgumentException(String.format(\"Invalid representation for %s\", getClass().getSimpleName()), e);\n+        }\n+        this.representation = Collections.unmodifiableList(new ArrayList<T> (representation));\n+    }\n+    \n+    /**\n+     * Constructor.\n+     * @param representation inner representation of the chromosome\n+     */\n+    public AbstractListChromosome(final T[] representation) {\n+        this(Arrays.asList(representation));\n+    }\n+\n+    /**\n+     * \n+     * Asserts that <code>representation</code> can represent a valid chromosome.\n+     * @param representation representation of the chromosome\n+     * @throws InvalidRepresentationException iff the <code>representation</code> can not represent\n+     *         a valid chromosome\n+     */\n+    protected abstract void checkValidity(List<T> representation) throws InvalidRepresentationException;\n+\n+    /**\n+     * Returns the (immutable) inner representation of the chromosome.\n+     * @return the representation of the chromosome\n+     */\n+    protected List<T> getRepresentation() {\n+        return representation;\n+    }\n+\n+    /**\n+     * Returns the length of the chromosome.\n+     * @return the length of the chromosome\n+     */\n+    public int getLength() {\n+        return getRepresentation().size();\n+    }\n+\n+    /**\n+     * Creates a new instance of the same class as <code>this</code> is, with a\n+     * given <code>arrayRepresentation</code>. This is needed in crossover and\n+     * mutation operators, where we need a new instance of the same class, but\n+     * with different array representation.\n+     * \n+     * Usually, this method just calls a constructor of the class.\n+     * \n+     * @param representation\n+     *            the inner array representation of the new chromosome.\n+     * @return new instance extended from FixedLengthChromosome with the given\n+     *         arrayRepresentation\n+     */\n+    public abstract AbstractListChromosome<T> newFixedLengthChromosome(final List<T> representation);\n+    \n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public String toString() {\n+        return String.format(\"(f=%s %s)\", getFitness(), getRepresentation());\n+    }\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/math/genetics/BinaryChromosome.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.genetics;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+\n+/**\n+ * Chromosome represented by a vector of 0s and 1s.\n+ * \n+ * @version $Revision:$ $Date:$\n+ * @since 2.0\n+ */\n+public abstract class BinaryChromosome extends AbstractListChromosome<Integer> {\n+    \n+    /**\n+     * Constructor.\n+     * @param representation list of {0,1} values representing the chromosome\n+     */\n+    public BinaryChromosome(List<Integer> representation) {\n+        super(representation);\n+    }\n+    \n+    /**\n+     * Constructor.\n+     * @param representation array of {0,1} values representing the chromosome\n+     */\n+    public BinaryChromosome(Integer[] representation) {\n+        super(representation);\n+    }\n+     \n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    protected void checkValidity(List<Integer> representation) throws InvalidRepresentationException {\n+        for (int i : representation) {\n+            if (i < 0 || i >1)\n+                throw new InvalidRepresentationException(\"Elements can be only 0 or 1.\");\n+        }\n+    }\n+\n+    /**\n+     * Returns a representation of a random binary array of length <code>length</code>.\n+     * @param length length of the array\n+     * @return a random binary array of length <code>length</code>\n+     */\n+    public static List<Integer> randomBinaryRepresentation(int length) {\n+        // random binary list\n+        List<Integer> rList= new ArrayList<Integer> (length);\n+        for (int j=0; j<length; j++) {\n+            rList.add(GeneticAlgorithm.getRandomGenerator().nextInt(2));\n+        }\n+        return rList;\n+    }\n+    \n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    protected boolean isSame(Chromosome another) {\n+        // type check\n+        if (! (another instanceof BinaryChromosome))\n+            return false;\n+        BinaryChromosome anotherBc = (BinaryChromosome) another;\n+        // size check\n+        if (getLength() != anotherBc.getLength())\n+            return false;\n+        \n+        for (int i=0; i< getRepresentation().size(); i++) {\n+            if (!(getRepresentation().get(i).equals(anotherBc.getRepresentation().get(i))))\n+                return false;\n+        }\n+        // all is ok\n+        return true;\n+    }\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/math/genetics/BinaryMutation.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.genetics;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+/**\n+ * Mutation for {@link BinaryChromosome}s. Randomly changes one gene.\n+ *\n+ * @version $Revision:$ $Date:$\n+ * @since 2.0\n+ */\n+public class BinaryMutation implements MutationPolicy {\n+\n+    /**\n+     * Mutate the given chromosome. Randomly changes one gene.\n+     * @param original the original chromosome.\n+     * @return the mutated chromomsome.\n+     */\n+    public Chromosome mutate(Chromosome original) {\n+        if (!(original instanceof BinaryChromosome)) {\n+            throw new IllegalArgumentException(\"Binary mutation works on BinaryChromosome only.\"); \n+        }\n+        \n+        BinaryChromosome origChrom = (BinaryChromosome) original;\n+        List<Integer> newRepr = new ArrayList<Integer>(origChrom.getRepresentation());\n+        \n+        // randomly select a gene\n+        int geneIndex = GeneticAlgorithm.getRandomGenerator().nextInt(origChrom.getLength());\n+        // and change it\n+        newRepr.set(geneIndex, origChrom.getRepresentation().get(geneIndex) == 0 ? 1 : 0);\n+        \n+        Chromosome newChrom = origChrom.newFixedLengthChromosome(newRepr);\n+        return newChrom;\n+    }\n+\n+}\n--- a/src/java/org/apache/commons/math/genetics/Chromosome.java\n+++ b/src/java/org/apache/commons/math/genetics/Chromosome.java\n \n /**\n  * Individual in a population. Chromosomes are compared based on their fitness.\n- * @version $Revision$ $Date$\n+ * \n+ * The chromosomes are IMMUTABLE, and so their fitness is also immutable and\n+ * therefore it can be cached.\n+ * \n+ * @since 2.0\n+ * @version $Revision:$ $Date:$\n  */\n-public interface Chromosome {\n+public abstract class Chromosome implements Comparable<Chromosome>,Fitness {\n+    \n     /**\n-     * Access the fitness of this chromosome.\n+     * Cached value of the fitness of this chromosome.\n+     */\n+    private double fitness = Double.MIN_VALUE;\n+    \n+    /**\n+     * Access the fitness of this chromosome. The bigger the fitness, the better\n+     * the chromosome.\n+     * \n+     * Computation of fitness is usually very time-consuming task, therefore the\n+     * fitness is cached.\n      * \n      * @return the fitness.\n      */\n-    Fitness getFitness();\n+    public double getFitness() {\n+        if (this.fitness == Double.MIN_VALUE) {\n+            // no cache - compute the fitness\n+            this.fitness = fitness();\n+        }\n+        return this.fitness;\n+    }\n+        \n+    /**\n+     * Compares two chromosomes based on their fitness. The bigger the fitness,\n+     * the better the chromosome.\n+     * \n+     * @param another another chromosome to compare\n+     * @return\n+     * <ul>\n+     *     <li>-1 if <code>another</code> is better than <code>this</code></li>\n+     *     <li>1 if <code>another</code> is worse than <code>this</code></li>\n+     *     <li>0 if the two chromosomes have the same fitness</li>\n+     * </ul>\n+     */\n+    public int compareTo(Chromosome another) {\n+        return ((Double)this.getFitness()).compareTo(another.getFitness());\n+    }\n+\n+    /**\n+     * Returns <code>true<code> iff <code>another</code> has the same\n+     * representation and therefore the same fitness. By default, it returns\n+     * false -- override it in your implementation if you need it. \n+     * @param another chromosome to compare\n+     * @return true if <code>another</code> is equivalent to this chromosome\n+     */\n+    protected boolean isSame(Chromosome another) {\n+        return false;\n+    }\n+\n+    /**\n+     * Searches the <code>population</code> for another chromosome with the same\n+     * representation. If such chromosome is found, it is returned, if no such\n+     * chromosome exists, returns <code>null</code>.\n+     * \n+     * @param population\n+     *            Population to search\n+     * @return Chromosome with the same representation, or <code>null</code> if\n+     *         no such chromosome exists.\n+     */\n+    protected Chromosome findSameChromosome(Population population) {\n+        for (Chromosome anotherChr : population) {\n+            if (this.isSame(anotherChr))\n+                return anotherChr;\n+        }\n+        return null;\n+    }\n+\n+    /**\n+     * Searches the population for a chromosome representing the same solution,\n+     * and if it finds one, updates the fitness to its value.\n+     * \n+     * @param population\n+     *            Population to search\n+     */\n+    public void searchForFitnessUpdate(Population population) {\n+        Chromosome sameChromosome = findSameChromosome(population);\n+        if (sameChromosome != null) {\n+            fitness = sameChromosome.getFitness();\n+        }\n+    }\n+    \n }\n--- a/src/java/org/apache/commons/math/genetics/ChromosomePair.java\n+++ b/src/java/org/apache/commons/math/genetics/ChromosomePair.java\n \n /**\n  * A pair of {@link Chromosome} objects.\n+ * @since 2.0\n+ * \n  * @version $Revision$ $Date$\n  */\n public class ChromosomePair {\n     /** the first chromosome in the pair. */\n-    private Chromosome first;\n+    private final Chromosome first;\n \n     /** the second chromosome in the pair. */\n-    private Chromosome second;\n+    private final Chromosome second;\n \n     /**\n      * Create a chromosome pair.\n      * @param c1 the first chromosome.\n      * @param c2 the second chromosome.\n      */\n-    public ChromosomePair(Chromosome c1, Chromosome c2) {\n+    public ChromosomePair(final Chromosome c1, final Chromosome c2) {\n         super();\n         first = c1;\n         second = c2;\n     public Chromosome getSecond() {\n         return second;\n     }\n+    \n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public String toString() {        \n+        return String.format(\"(%s,%s)\", getFirst(), getSecond());\n+    }\n }\n--- a/src/java/org/apache/commons/math/genetics/CrossoverPolicy.java\n+++ b/src/java/org/apache/commons/math/genetics/CrossoverPolicy.java\n /**\n  * Policy used to create a pair of new chromosomes by performing a crossover\n  * operation on a source pair of chromosomes.\n+ * \n+ * @since 2.0\n  * @version $Revision$ $Date$\n  */\n public interface CrossoverPolicy {\n--- /dev/null\n+++ b/src/java/org/apache/commons/math/genetics/ElitisticListPopulation.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.genetics;\n+\n+import java.util.Collections;\n+import java.util.List;\n+\n+/**\n+ * Population of chromosomes which uses elitism (certain percentace of the best\n+ * chromosomes is directly copied to the next generation).\n+ * \n+ * @version $Revision:$ $Date:$\n+ * @since 2.0\n+ */\n+public class ElitisticListPopulation extends ListPopulation {\n+    \n+    /** percentage of chromosomes copied to the next generation */\n+    private double elitismRate = 0.9;\n+\n+    /**\n+     * Creates a new ElitisticListPopulation instance.\n+     * \n+     * @param chromosomes\n+     *            list of chromosomes in the population\n+     * @param populationLimit\n+     *            maximal size of the population\n+     * @param elitismRate\n+     *            how many best chromosomes will be directly transferred to the\n+     *            next generation [in %]\n+     */\n+    public ElitisticListPopulation(List<Chromosome> chromosomes, int populationLimit, double elitismRate) {\n+        super(chromosomes, populationLimit);\n+        this.elitismRate = elitismRate;\n+    }\n+\n+    /**\n+     * Creates a new ListPopulation instance and initializes its inner\n+     * chromosome list.\n+     * \n+     * @param populationLimit maximal size of the population\n+     * @param elitismRate\n+     *            how many best chromosomes will be directly transferred to the\n+     *            next generation [in %] \n+     */\n+    public ElitisticListPopulation(int populationLimit, double elitismRate) {\n+        super(populationLimit);\n+        this.elitismRate = elitismRate;\n+    }\n+\n+    /**\n+     * Start the population for the next generation. The\n+     * <code>{@link #elitismRate}<code> percents of the best \n+     * chromosomes are directly copied to the next generation.\n+     * \n+     * @return the beginnings of the next generation.\n+     */\n+    public Population nextGeneration() {\n+        // initialize a new generation with the same parameters\n+        ElitisticListPopulation nextGeneration = new ElitisticListPopulation(this.getPopulationLimit(), this.getElitismRate());\n+        \n+        List<Chromosome> oldChromosomes = this.getChromosomes();\n+        Collections.sort(oldChromosomes);\n+        \n+        // index of the last \"not good enough\" chromosome \n+        int boundIndex = (int) Math.ceil((1.0 - this.getElitismRate()) * oldChromosomes.size());\n+        for (int i=boundIndex; i<oldChromosomes.size(); i++) {\n+            nextGeneration.addChromosome(oldChromosomes.get(i));\n+        }\n+        return nextGeneration;\n+    }\n+\n+    /**\n+     * Sets the elitism rate, i.e. how many best chromosomes will be directly\n+     * transferred to the next generation [in %].\n+     * \n+     * @param elitismRate\n+     *            how many best chromosomes will be directly transferred to the\n+     *            next generation [in %]\n+     */\n+    public void setElitismRate(double elitismRate) {\n+        if (elitismRate < 0 || elitismRate > 1)\n+            throw new IllegalArgumentException(\"Elitism rate has to be in [0,1]\");\n+        this.elitismRate = elitismRate;\n+    }\n+\n+    /**\n+     * Access the elitism rate.\n+     * @return the elitism rate\n+     */\n+    public double getElitismRate() {\n+        return this.elitismRate;\n+    }\n+\n+}\n--- a/src/java/org/apache/commons/math/genetics/Fitness.java\n+++ b/src/java/org/apache/commons/math/genetics/Fitness.java\n package org.apache.commons.math.genetics;\n \n /**\n- * Interface used to compare chromosomes.\n- * @version $Revision$ $Date$\n+ * Fitness of a chromosome.\n+ *\n+ * @version $Revision:$ $Date:$\n  * @since 2.0\n  */\n-public interface Fitness extends Comparable<Fitness> {\n+public interface Fitness {\n+    /**\n+     * Compute the fitness. This is usually very time-consuming, so the value\n+     * should be cached.\n+     * \n+     * @return fitness\n+     */\n+    public double fitness();\n }\n--- /dev/null\n+++ b/src/java/org/apache/commons/math/genetics/FixedGenerationCount.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.genetics;\n+\n+/**\n+ * Stops after a fixed number of generations.  Each time \n+ * {@link #isSatisfied(Population)} is invoked, a generation counter is\n+ * incremented.  Once the counter reaches the configured \n+ * <code>maxGenerations</code> value, {@link #isSatisfied(Population)} returns\n+ * true.\n+ * \n+ * @version $Revision:$ $Date:$\n+ * @since 2.0\n+ */\n+public class FixedGenerationCount implements StoppingCondition {\n+    /** Number of generations that have passed */\n+    private int numGenerations = 0;\n+    \n+    /** Maximum number of generations (stopping criteria) */\n+    private final int maxGenerations;\n+    \n+    /**\n+     * Create a new FixedGenerationCount instance.\n+     * \n+     * @param maxGenerations number of generations to evolve\n+     */\n+    public FixedGenerationCount(int maxGenerations) {\n+        if (maxGenerations <= 0) \n+            throw new IllegalArgumentException(\"The number of generations has to be >= 0\");\n+        this.maxGenerations = maxGenerations;\n+    }\n+    \n+    /**\n+     * Determine whether or not the given number of generations have passed.\n+     * Increments the number of generations counter if the maximum has not\n+     * been reached.\n+     * \n+     * @param population ignored (no impact on result)\n+     * @return <code>true</code> IFF the maximum number of generations has been exceeded\n+     */\n+    public boolean isSatisfied(Population population) {\n+        if (this.numGenerations < this.maxGenerations) {\n+            numGenerations++;\n+            return false;\n+        }\n+        return true;\n+    }\n+\n+    /**\n+     * @return the number of generations that have passed\n+     */\n+    public int getNumGenerations() {\n+        return numGenerations;\n+    }\n+\n+}\n--- a/src/java/org/apache/commons/math/genetics/GeneticAlgorithm.java\n+++ b/src/java/org/apache/commons/math/genetics/GeneticAlgorithm.java\n  */\n package org.apache.commons.math.genetics;\n \n+import org.apache.commons.math.random.RandomGenerator;\n+import org.apache.commons.math.random.JDKRandomGenerator;\n+\n /**\n  * Implementation of a genetic algorithm. All factors that govern the operation\n  * of the algorithm can be configured for a specific problem.\n- * \n- * @version $Revision$ $Date$\n+ *\n+ * @since 2.0\n+ * @version $Revision:$ $Date:$\n  */\n public class GeneticAlgorithm {\n+\n+    /**\n+     * Static random number generator shared by GA implementation classes.\n+     * Set the randomGenerator seed to get reproducible results.  \n+     * Use {@link #setRandomGenerator(RandomGenerator)} to supply an alternative\n+     * to the default JDK-provided PRNG.\n+     */\n+    private static RandomGenerator randomGenerator = new JDKRandomGenerator();\n+    \n+    /**\n+     * Set the (static) random generator.\n+     * \n+     * @param random random generator\n+     */\n+    public synchronized static void setRandomGenerator(RandomGenerator random) {\n+        randomGenerator = random;\n+    }\n+    \n+    /**\n+     * Returns the (static) random generator.\n+     * \n+     * @return the static random generator shared by GA implementation classes\n+     */\n+    public synchronized static RandomGenerator getRandomGenerator() {\n+        return randomGenerator;\n+    }\n+      \n     /** the crossover policy used by the algorithm. */\n-    private CrossoverPolicy crossoverPolicy;\n+    protected final CrossoverPolicy crossoverPolicy;\n \n     /** the rate of crossover for the algorithm. */\n-    private double crossoverRate;\n+    protected final double crossoverRate;\n \n     /** the mutation policy used by the algorithm. */\n-    private MutationPolicy mutationPolicy;\n+    protected final MutationPolicy mutationPolicy;\n \n     /** the rate of mutation for the algorithm. */\n-    private double mutationRate;\n+    protected final double mutationRate;\n \n     /** the selection policy used by the algorithm. */\n-    private SelectionPolicy selectionPolicy;\n-\n+    protected final SelectionPolicy selectionPolicy;\n+    \n+    /**\n+     * @param crossoverPolicy The {@link CrossoverPolicy}\n+     * @param crossoverRate The crossover rate as a percentage (0-1 inclusive)\n+     * @param mutationPolicy The {@link MutationPolicy}\n+     * @param mutationRate The mutation rate as a percentage (0-1 inclusive)\n+     * @param selectionPolicy The {@link selectionPolicy}\n+     */\n+    public GeneticAlgorithm(\n+            CrossoverPolicy crossoverPolicy, double crossoverRate,\n+            MutationPolicy mutationPolicy, double mutationRate,\n+            SelectionPolicy selectionPolicy) {\n+        if (crossoverRate < 0 || crossoverRate > 1) {\n+            throw new IllegalArgumentException(\"crossoverRate must be between 0 and 1\");\n+        }\n+        if (mutationRate < 0 || mutationRate > 1) {\n+            throw new IllegalArgumentException(\"mutationRate must be between 0 and 1\");\n+        }\n+        this.crossoverPolicy = crossoverPolicy;\n+        this.crossoverRate = crossoverRate;\n+        this.mutationPolicy = mutationPolicy;\n+        this.mutationRate = mutationRate;\n+        this.selectionPolicy = selectionPolicy;\n+    }\n+    \n     /**\n      * Evolve the given population. Evolution stops when the stopping condition\n      * is satisfied.\n             current = nextGeneration(current);\n         }\n         return current;\n-    }\n-\n-    /**\n-     * Access the crossover policy.\n-     * \n-     * @return the crossover policy.\n-     */\n-    private CrossoverPolicy getCrossoverPolicy() {\n-        return crossoverPolicy;\n-    }\n-\n-    /**\n-     * Access the crossover rate.\n-     * \n-     * @return the crossover rate.\n-     */\n-    private double getCrossoverRate() {\n-        return crossoverRate;\n-    }\n-\n-    /**\n-     * Access the mutation policy.\n-     * \n-     * @return the mutation policy.\n-     */\n-    private MutationPolicy getMutationPolicy() {\n-        return mutationPolicy;\n-    }\n-\n-    /**\n-     * Access the mutation rate.\n-     * \n-     * @return the mutation rate.\n-     */\n-    private double getMutationRate() {\n-        return mutationRate;\n-    }\n-\n-    /**\n-     * Access the selection policy.\n-     * \n-     * @return the selection policy.\n-     */\n-    private SelectionPolicy getSelectionPolicy() {\n-        return selectionPolicy;\n     }\n \n     /**\n      *    </ol>\n      * </p>\n      * \n-     * \n      * @param current the current population.\n      * @return the population for the next generation.\n      */\n-    private Population nextGeneration(Population current) {\n+    public Population nextGeneration(Population current) {\n         Population nextGeneration = current.nextGeneration();\n \n-        while (nextGeneration.getPopulationSize() < nextGeneration\n-                .getPopulationLimit()) {\n+        while (nextGeneration.getPopulationSize() < nextGeneration.getPopulationLimit()) {\n             // select parent chromosomes\n             ChromosomePair pair = getSelectionPolicy().select(current);\n \n             // crossover?\n-            if (Math.random() < getCrossoverRate()) {\n+            if (randomGenerator.nextDouble() < getCrossoverRate()) {\n                 // apply crossover policy to create two offspring\n-                pair = getCrossoverPolicy().crossover(pair.getFirst(),\n-                        pair.getSecond());\n+                pair = getCrossoverPolicy().crossover(pair.getFirst(), pair.getSecond());\n             }\n \n             // mutation?\n-            if (Math.random() < getMutationRate()) {\n+            if (randomGenerator.nextDouble() < getMutationRate()) {\n                 // apply mutation policy to the chromosomes\n                 pair = new ChromosomePair(\n-                              getMutationPolicy().mutate(pair.getFirst()),\n-                              getMutationPolicy().mutate(pair.getSecond())\n-                           );\n+                    getMutationPolicy().mutate(pair.getFirst()),\n+                    getMutationPolicy().mutate(pair.getSecond()));\n             }\n \n             // add the first chromosome to the population\n             nextGeneration.addChromosome(pair.getFirst());\n             // is there still a place for the second chromosome?\n-            if (nextGeneration.getPopulationSize() < nextGeneration\n-                    .getPopulationLimit()) {\n+            if (nextGeneration.getPopulationSize() < nextGeneration.getPopulationLimit()) {\n                 // add the second chromosome to the population\n                 nextGeneration.addChromosome(pair.getSecond());\n             }\n         }\n \n         return nextGeneration;\n-    }\n-\n-    /**\n-     * Modify the crossover policy.\n-     * \n-     * @param value the new crossover policy.\n-     */\n-    public void setCrossoverPolicy(CrossoverPolicy value) {\n-        this.crossoverPolicy = value;\n-    }\n-\n-    /**\n-     * Modify the crossover rate.\n-     * \n-     * @param value the new crossover rate.\n-     */\n-    public void setCrossoverRate(double value) {\n-        this.crossoverRate = value;\n-    }\n-\n-    /**\n-     * Modify the mutation policy.\n-     * \n-     * @param value the new mutation policy.\n-     */\n-    public void setMutationPolicy(MutationPolicy value) {\n-        this.mutationPolicy = value;\n-    }\n-\n-    /**\n-     * Modify the mutation rate.\n-     * \n-     * @param value the new mutation rate.\n-     */\n-    public void setMutationRate(double value) {\n-        this.mutationRate = value;\n-    }\n-\n-    /**\n-     * Modify the selection policy.\n-     * \n-     * @param value the new selection policy.\n-     */\n-    public void setSelectionPolicy(SelectionPolicy value) {\n-        this.selectionPolicy = value;\n-    }\n+    }    \n+    \n+    /**\n+     * Returns the crossover policy.\n+     * @return crossover policy\n+     */\n+    public CrossoverPolicy getCrossoverPolicy() {\n+        return crossoverPolicy;\n+    }\n+\n+    /**\n+     * Returns the crossover rate.\n+     * @return crossover rate\n+     */\n+    public double getCrossoverRate() {\n+        return crossoverRate;\n+    }\n+\n+    /**\n+     * Returns the mutation policy.\n+     * @return mutation policy\n+     */\n+    public MutationPolicy getMutationPolicy() {\n+        return mutationPolicy;\n+    }\n+\n+    /**\n+     * Returns the mutation rate.\n+     * @return mutation rate\n+     */\n+    public double getMutationRate() {\n+        return mutationRate;\n+    }\n+\n+    /**\n+     * Returns the selection policy.\n+     * @return selection policy\n+     */\n+    public SelectionPolicy getSelectionPolicy() {\n+        return selectionPolicy;\n+    }\n+        \n }\n--- /dev/null\n+++ b/src/java/org/apache/commons/math/genetics/InvalidRepresentationException.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.genetics;\n+\n+/**\n+ * Exception indicating that the representation of a chromosome is not valid.\n+ * \n+ * @version $Revision:$ $Date:$\n+ * @since 2.0\n+ */\n+public class InvalidRepresentationException extends Exception {\n+\n+    /** Serialization version id */\n+    private static final long serialVersionUID = 1L;\n+\n+    /**\n+     * Constructor\n+     */\n+    public InvalidRepresentationException() {\n+        super();\n+    }\n+\n+    /**\n+     * Construct an InvalidRepresentationException\n+     * @param arg0 exception message\n+     */\n+    public InvalidRepresentationException(String arg0) {\n+        super(arg0);\n+    }\n+\n+    /**\n+     * Construct an InvalidRepresentationException\n+     * @param arg0 cause\n+     */\n+    public InvalidRepresentationException(Throwable arg0) {\n+        super(arg0);\n+    }\n+\n+    /**\n+     * Construct an InvalidRepresentationException\n+     * \n+     * @param arg0 exception message\n+     * @param arg1 cause\n+     */\n+    public InvalidRepresentationException(String arg0, Throwable arg1) {\n+        super(arg0, arg1);\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/math/genetics/ListPopulation.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.genetics;\n+\n+import java.util.ArrayList;\n+import java.util.Iterator;\n+import java.util.List;\n+\n+/**\n+ * Population of chromosomes represented by a {@link List}.\n+ *\n+ * @since 2.0\n+ * @version $Revision:$ $Date:$\n+ */\n+public abstract class ListPopulation implements Population {\n+    \n+    /** List of chromosomes */\n+    private List<Chromosome> chromosomes;\n+    \n+    /** maximial size of the population */\n+    private int populationLimit;\n+    \n+    \n+    /**\n+     * Creates a new ListPopulation instance.\n+     * \n+     * @param chromosomes list of chromosomes in the population\n+     * @param populationLimit maximal size of the population\n+     */\n+    public ListPopulation (List<Chromosome> chromosomes, int populationLimit) {\n+        if (chromosomes.size() > populationLimit) {\n+            throw new IllegalArgumentException(\"List of chromosomes bigger than maxPopulationSize.\");\n+        }\n+        if (populationLimit < 0) {\n+            throw new IllegalArgumentException(\"Population limit has to be >= 0\");\n+        }\n+            \n+        this.chromosomes = chromosomes;\n+        this.populationLimit = populationLimit;\n+    }\n+    \n+    /**\n+     * Creates a new ListPopulation instance and initializes its inner\n+     * chromosome list.\n+     * \n+     * @param populationLimit maximal size of the population\n+     */\n+    public ListPopulation (int populationLimit) {\n+        if (populationLimit < 0) {\n+            throw new IllegalArgumentException(\"Population limit has to be >= 0\");\n+        }\n+        this.populationLimit = populationLimit;\n+        this.chromosomes = new ArrayList<Chromosome>(populationLimit);\n+    }\n+\n+    /**\n+     * Sets the list of chromosomes.\n+     * @param chromosomes the list of chromosomes\n+     */\n+    public void setChromosomes(List<Chromosome> chromosomes) {\n+        this.chromosomes = chromosomes;\n+    }\n+    \n+    /**\n+     * Access the list of chromosomes.\n+     * @return the list of chromosomes\n+     */\n+    public List<Chromosome> getChromosomes() {\n+        return chromosomes;\n+    }\n+\n+    /**\n+     * Add the given chromosome to the population.\n+     * @param chromosome the chromosome to add.\n+     */\n+    public void addChromosome(Chromosome chromosome) {\n+        this.chromosomes.add(chromosome);\n+    }\n+\n+    /**\n+     * Access the fittest chromosome in this population.\n+     * @return the fittest chromosome.\n+     */\n+    public Chromosome getFittestChromosome() {\n+        // best so far\n+        Chromosome bestChromosome = this.chromosomes.get(0);    \n+        for (Chromosome chromosome : this.chromosomes) {\n+            if (chromosome.compareTo(bestChromosome) > 0) {\n+                // better chromosome found\n+                bestChromosome = chromosome;\n+            }\n+        }\n+        return bestChromosome;\n+    }\n+    \n+    /**\n+     * Access the maximum population size.\n+     * @return the maximum population size.\n+     */\n+    public int getPopulationLimit() {\n+        return this.populationLimit;\n+    }\n+    \n+    /**\n+     * Sets the maximal population size.\n+     * @param populationLimit maximal population size.\n+     */\n+    public void setPopulationLimit(int populationLimit) {\n+        this.populationLimit = populationLimit;\n+    }\n+\n+    /**\n+     * Access the current population size.\n+     * @return the current population size.\n+     */\n+    public int getPopulationSize() {        \n+        return this.chromosomes.size();\n+    }\n+    \n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public String toString() {\n+        return this.chromosomes.toString();\n+    }\n+    \n+    /**\n+     * Chromosome list iterator\n+     * \n+     * @return chromosome iterator\n+     */\n+    public Iterator<Chromosome> iterator() {        \n+        return chromosomes.iterator();\n+    }\n+}\n--- a/src/java/org/apache/commons/math/genetics/MutationPolicy.java\n+++ b/src/java/org/apache/commons/math/genetics/MutationPolicy.java\n \n /**\n  * Algorithm used to mutate a chrommosome.\n+ * \n+ * @since 2.0\n  * @version $Revision$ $Date$\n  */\n public interface MutationPolicy {\n--- /dev/null\n+++ b/src/java/org/apache/commons/math/genetics/OnePointCrossover.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.genetics;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+\n+/**\n+ * One point crossover policy. A random crossover point is selected and the\n+ * first part from each parent is copied to the corresponding child, and the\n+ * second parts are copied crosswise.\n+ * \n+ * Example:\n+ * <pre>\n+ * -C- denotes a crossover point\n+ *                   -C-                                -C-\n+ * p1 = (1 0 1 0 0 1  | 0 1 1)    X    p2 = (0 1 1 0 1 0  | 1 1 1)\n+ *         \\------------/ \\-----/              \\------------/ \\-----/\n+ *            ||         (*)                       ||        (**)\n+ *            VV         (**)                      VV        (*)\n+ *      /------------\\ /-----\\              /------------\\ /-----\\\n+ * c1 = (1 0 1 0 0 1  | 1 1 1)    X    p2 = (0 1 1 0 1 0  | 0 1 1)\n+ * </pre>\n+ * \n+ * This policy works only on {@link AbstractListChromosome}, and therefore it \n+ * is parametrized by T. Moreover, the chromosomes must have same lengths.\n+ * \n+ * @param <T> generic type of the {@link AbstractListChromosome}s for crossover\n+ * @since 2.0\n+ * @version $Revision:$ $Date:$\n+ * \n+ */\n+public class OnePointCrossover<T> implements CrossoverPolicy {\n+    \n+    /**\n+     * Performs one point crossover. A random crossover point is selected and the\n+     * first part from each parent is copied to the corresponding child, and the\n+     * second parts are copied crosswise.\n+     * \n+     * Example:\n+     * -C- denotes a crossover point\n+     *                   -C-                                -C-\n+     * p1 = (1 0 1 0 0 1  | 0 1 1)    X    p2 = (0 1 1 0 1 0  | 1 1 1)\n+     *         \\------------/ \\-----/              \\------------/ \\-----/\n+     *            ||         (*)                       ||        (**)\n+     *            VV         (**)                      VV        (*)\n+     *      /------------\\ /-----\\              /------------\\ /-----\\\n+     * c1 = (1 0 1 0 0 1  | 1 1 1)    X    p2 = (0 1 1 0 1 0  | 0 1 1)\n+     * \n+     * @param first first parent (p1)\n+     * @param second second parent (p2)\n+     * @return pair of two children (c1,c2)\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    public ChromosomePair crossover(Chromosome first, Chromosome second) {\n+        if (! (first instanceof AbstractListChromosome && second instanceof AbstractListChromosome)) {\n+            throw new IllegalArgumentException(\"One point crossover works on FixedLengthChromosomes only.\");\n+        }\n+        return crossover((AbstractListChromosome<T>) first, (AbstractListChromosome<T>) second);\n+    }\n+\n+\n+    /**\n+     * Helper for {@link #crossover(Chromosome, Chromosome)}. Performs the actual crossover.\n+     * \n+     * @param first the first chromosome.\n+     * @param second the second chromosome.\n+     * @return the pair of new chromosomes that resulted from the crossover.\n+     */\n+    private ChromosomePair crossover(AbstractListChromosome<T> first, AbstractListChromosome<T> second) {\n+        int length = first.getLength();\n+        if (length != second.getLength()) \n+            throw new IllegalArgumentException(\"Both chromosomes must have same lengths.\");\n+        \n+        // array representations of the parents\n+        List<T> parent1Rep = first.getRepresentation();\n+        List<T> parent2Rep = second.getRepresentation();\n+        // and of the children\n+        ArrayList<T> child1Rep = new ArrayList<T> (first.getLength());\n+        ArrayList<T> child2Rep = new ArrayList<T> (second.getLength());\n+        \n+        // select a crossover point at random (0 and length makes no sense)\n+        int crossoverIndex = 1 + (GeneticAlgorithm.getRandomGenerator().nextInt(length-2));\n+\n+        // copy the first part\n+        for (int i = 0; i < crossoverIndex; i++) {\n+            child1Rep.add(parent1Rep.get(i));\n+            child2Rep.add(parent2Rep.get(i));\n+        }\n+        // and switch the second part\n+        for (int i = crossoverIndex; i < length; i++) {\n+            child1Rep.add(parent2Rep.get(i));\n+            child2Rep.add(parent1Rep.get(i));\n+        }\n+        \n+        return new ChromosomePair(\n+                first.newFixedLengthChromosome(child1Rep),\n+                second.newFixedLengthChromosome(child2Rep)\n+                );\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/math/genetics/PermutationChromosome.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.genetics;\n+\n+import java.util.List;\n+\n+/**\n+ * Interface indicating that the chromosome represents a permutation of objects.\n+ * \n+ * @param <T>\n+ *            type of the permuted objects\n+ * @since 2.0\n+ * @version $Revision:$ $Date:$\n+ */\n+public interface PermutationChromosome<T> {\n+\n+    /**\n+     * Permutes the <code>sequence</code> of objects of type T according to the\n+     * permutation this chromosome represents. For example, if this chromosome\n+     * represents a permutation (3,0,1,2), and the unpermuted sequence is\n+     * (a,b,c,d), this yields (d,a,b,c).\n+     * \n+     * @param sequence\n+     *            the unpermuted (original) sequence of objects\n+     * @return permutation of <code>sequence</code> represented by this\n+     *         permutation\n+     */\n+    public List<T> decode(List<T> sequence);\n+    \n+}\n--- a/src/java/org/apache/commons/math/genetics/Population.java\n+++ b/src/java/org/apache/commons/math/genetics/Population.java\n \n /**\n  * A collection of chromosomes that facilitates generational evolution.\n- * @version $Revision$ $Date$\n+ * \n+ * @since 2.0\n+ * @version $Revision:$ $Date:$\n  */\n-public interface Population {\n+public interface Population extends Iterable<Chromosome> {\n     /**\n      * Access the current population size.\n      * @return the current population size.\n--- /dev/null\n+++ b/src/java/org/apache/commons/math/genetics/RandomKey.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.genetics;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.List;\n+\n+/**\n+ * <p>\n+ * Random Key chromosome is used for permutation representation. It is a vector\n+ * of a fixed length of real numbers in [0,1] interval. The index of the i-th\n+ * smallest value in the vector represents an i-th member of the permutation.\n+ * </p>\n+ * \n+ * <p>\n+ * For example, the random key [0.2, 0.3, 0.8, 0.1] corresponds to the\n+ * permutation of indices (3,0,1,2). If the original (unpermuted) sequence would\n+ * be (a,b,c,d), this would mean the sequence (d,a,b,c).\n+ * </p>\n+ * \n+ * <p>\n+ * With this representation, common operators like n-point crossover can be\n+ * used, because any such chromosome represents a valid permutation.\n+ * </p>\n+ * \n+ * <p>\n+ * Since the chromosome (and thus its arrayRepresentation) is immutable, the\n+ * array representation is sorted only once in the constructor.\n+ * </p>\n+ * \n+ * <p>\n+ * For details, see:\n+ * <ul>\n+ * <li>Bean, J.C.: Genetic algorithms and random keys for sequencing and\n+ * optimization. ORSA Journal on Computing 6 (1994) 154\u2013160</li>\n+ * <li>Rothlauf, F.: Representations for Genetic and Evolutionary Algorithms.\n+ * Volume 104 of Studies in Fuzziness and Soft Computing. Physica-Verlag,\n+ * Heidelberg (2002)</li>\n+ * </ul>\n+ * </p>\n+ * \n+ * @param <T>\n+ *            type of the permuted objects\n+ * @since 2.0\n+ * @version $Revision:$ $Date:$\n+ */\n+public abstract class RandomKey<T> extends AbstractListChromosome<Double> implements PermutationChromosome<T> {\n+    \n+    /**\n+     * Cache of sorted representation (unmodifiable).\n+     */\n+    private final List<Double> sortedRepresentation;\n+    \n+    /**\n+     * Base sequence [0,1,...,n-1], permuted accorting to the representation (unmodifiable).\n+     */\n+    private final List<Integer> baseSeqPermutation;\n+    \n+    /**\n+     * Constructor.\n+     * \n+     * @param representation list of [0,1] values representing the permutation\n+     */\n+    public RandomKey(List<Double> representation) {\n+        super(representation);\n+        // store the sorted representation\n+        List<Double> sortedRepr = new ArrayList<Double> (getRepresentation());\n+        Collections.sort(sortedRepr);\n+        sortedRepresentation = Collections.unmodifiableList(sortedRepr);\n+        // store the permutation of [0,1,...,n-1] list for toString() and isSame() methods\n+        baseSeqPermutation = Collections.unmodifiableList(\n+            decodeGeneric(baseSequence(getLength()), getRepresentation(), sortedRepresentation)\n+        );\n+    }\n+    \n+    /**\n+     * Constructor.\n+     * \n+     * @param representation array of [0,1] values representing the permutation\n+     */\n+    public RandomKey(Double[] representation) {\n+        this(Arrays.asList(representation));\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    public List<T> decode(List<T> sequence) {\n+        return decodeGeneric(sequence, getRepresentation(), sortedRepresentation);\n+    }\n+\n+    /**\n+     * Decodes a permutation represented by <code>representation</code> and\n+     * returns a (generic) list with the permuted values.\n+     * \n+     * @param <S> generic type of the sequence values\n+     * @param sequence the unpermuted sequence\n+     * @param representation representation of the permutation ([0,1] vector)\n+     * @param sortedRepr sorted <code>representation</code>\n+     * @return list with the sequence values permuted according to the representation\n+     */\n+    private static <S> List<S> decodeGeneric(List<S> sequence, List<Double> representation, List<Double> sortedRepr) {\n+        int l = sequence.size();\n+        \n+        if (representation.size() != l) {\n+            throw new IllegalArgumentException(String.format(\"Length of sequence for decoding (%s) has to be equal to the length of the RandomKey (%s)\", l, representation.size()));\n+        }\n+        if (representation.size() != sortedRepr.size()) {\n+            throw new IllegalArgumentException(String.format(\"Representation and sortedRepr must have same sizes, %d != %d\", representation.size(), sortedRepr.size()));\n+        }\n+        \n+        List<Double> reprCopy = new ArrayList<Double> (representation);// do not modify the orig. representation\n+        \n+        // now find the indices in the original repr and use them for permuting\n+        List<S> res = new ArrayList<S> (l);\n+        for (int i=0; i<l; i++) {\n+            int index = reprCopy.indexOf(sortedRepr.get(i));\n+            res.add(sequence.get(index));\n+            reprCopy.set(index, null);\n+        }\n+        return res;\n+    }\n+\n+    /**\n+     * Returns <code>true</code> iff <code>another</code> is a RandomKey and\n+     * encodes the same permutation.\n+     * \n+     * @param another chromosome to compare\n+     * @return true iff chromosomes encode the same permutation\n+     */\n+    @Override\n+    protected boolean isSame(Chromosome another) {\n+        // type check\n+        if (! (another instanceof RandomKey))\n+            return false;\n+        RandomKey<?> anotherRk = (RandomKey<?>) another;\n+        // size check\n+        if (getLength() != anotherRk.getLength())\n+            return false;\n+        \n+        // two different representations can still encode the same permutation\n+        // the ordering is what counts\n+        List<Integer> thisPerm = this.baseSeqPermutation;\n+        List<Integer> anotherPerm = anotherRk.baseSeqPermutation;\n+        \n+        for (int i=0; i<getLength(); i++) {\n+            if (thisPerm.get(i) != anotherPerm.get(i))\n+                return false;\n+        }\n+        // the permutations are the same\n+        return true;\n+    }\n+    \n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override    \n+    protected void checkValidity(java.util.List<Double> representation) throws InvalidRepresentationException {\n+        for (double val : representation) {\n+            if (val < 0 || val > 1) {\n+                throw new InvalidRepresentationException(\"Values of representation must be in [0,1] interval\");\n+            }\n+        }\n+    };\n+    \n+\n+    /**\n+     * Generates a representation corresponding to a random permutation of\n+     * length l which can be passed to the RandomKey constructor.\n+     * \n+     * @param l\n+     *            length of the permutation\n+     * @return representation of a random permutation\n+     */\n+    public static final List<Double> randomPermutation(int l) {\n+        List<Double> repr = new ArrayList<Double>(l);\n+        for (int i=0; i<l; i++) {\n+            repr.add(GeneticAlgorithm.getRandomGenerator().nextDouble());\n+        }\n+        return repr;\n+    }\n+\n+    /**\n+     * Generates a representation corresponding to an identity permutation of\n+     * length l which can be passed to the RandomKey constructor.\n+     * \n+     * @param l\n+     *            length of the permutation\n+     * @return representation of an identity permutation\n+     */\n+    public static final List<Double> identityPermutation(int l) {\n+        List<Double> repr = new ArrayList<Double>(l);\n+        for (int i=0; i<l; i++) {\n+            repr.add((double)i/l);\n+        }\n+        return repr;\n+    }\n+\n+    /**\n+     * Generates a representation of a permutation corresponding to the\n+     * <code>data</code> sorted by <code>comparator</code>. The\n+     * <code>data</code> is not modified during the process.\n+     * \n+     * This is useful if you want to inject some permutations to the initial\n+     * population.\n+     * \n+     * @param <S> type of the data\n+     * @param data list of data determining the order\n+     * @param comparator how the data will be compared\n+     * @return list representation of the permutation corresponding to the parameters\n+     */\n+    public static <S> List<Double> comparatorPermutation(List<S> data, Comparator<S> comparator) {\n+        List<S> sortedData = new ArrayList<S> (data);\n+        Collections.sort(sortedData, comparator);\n+        \n+        return inducedPermutation(data, sortedData);\n+    }\n+\n+    /**\n+     * Generates a representation of a permutation corresponding to a\n+     * permutation which yields <code>permutedData</code> when applied to\n+     * <code>originalData</code>.\n+     * \n+     * This method can be viewed as an inverse to {@link #decode(List)}.\n+     * \n+     * @param <S> type of the data\n+     * @param originalData the original, unpermuted data\n+     * @param permutedData the data, somehow permuted\n+     * @return representation of a permutation corresponding to the permutation <code>originalData -> permutedData</code>\n+     * @throws IllegalArgumentException iff the <code>permutedData</code> and <code>originalData</code> contains different data \n+     */\n+    public static <S> List<Double> inducedPermutation(List<S> originalData, List<S> permutedData) throws IllegalArgumentException {\n+        if (originalData.size() != permutedData.size()) {\n+            throw new IllegalArgumentException(\"originalData and permutedData must have same length\");\n+        }\n+        int l = originalData.size();\n+        \n+        List<S> origDataCopy = new ArrayList<S> (originalData);\n+        \n+        Double[] res = new Double[l];\n+        for (int i=0; i<l; i++) {\n+            int index = origDataCopy.indexOf(permutedData.get(i));\n+            if (index == -1) {\n+                throw new IllegalArgumentException(\"originalData and permutedData must contain the same objects.\");\n+            }\n+            res[index] = (double) i / l;\n+            origDataCopy.set(index, null);\n+        }\n+        return Arrays.asList(res);\n+    }\n+    \n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public String toString() {\n+        return String.format(\"(f=%s pi=(%s))\", getFitness(), baseSeqPermutation);\n+    }\n+\n+    /**\n+     * Helper for constructor. Generates a list of natural numbers (0,1,...,l-1).\n+     * \n+     * @param l length of list to generate\n+     * @return list of integers from 0 to l-1\n+     */\n+    private static List<Integer> baseSequence(int l) {\n+        List<Integer> baseSequence = new ArrayList<Integer> (l);\n+        for (int i=0; i<l; i++) {\n+            baseSequence.add(i);\n+        }\n+        return baseSequence;\n+    }\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/math/genetics/RandomKeyMutation.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.genetics;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import org.apache.commons.math.MathRuntimeException;\n+\n+/**\n+ * Mutation operator for {@link RandomKey}s. Changes a randomly chosen element\n+ * of the array representation to a random value uniformly distributed in [0,1].\n+ * \n+ * @since 2.0\n+ * @version $Revision:$ $Date:$\n+ */\n+public class RandomKeyMutation implements MutationPolicy {\n+\n+    /**\n+     * {@inheritDoc}\n+     * \n+     * @throws IllegalArgumentException if <code>original</code> is not a \n+     * {@link RandomKeys} instance\n+     */\n+    public Chromosome mutate(Chromosome original) {\n+        if (!(original instanceof RandomKey)) {\n+            throw MathRuntimeException.createIllegalArgumentException(\n+                    \"RandomKeyMutation works only with RandomKeys, got \" +\n+                    original.getClass().getSimpleName());\n+        }\n+        \n+        RandomKey<?> originalRk = (RandomKey<?>) original;\n+        List<Double> repr = originalRk.getRepresentation();\n+        int rInd = GeneticAlgorithm.getRandomGenerator().nextInt(repr.size());\n+        \n+        List<Double> newRepr = new ArrayList<Double> (repr);\n+        newRepr.set(rInd, GeneticAlgorithm.getRandomGenerator().nextDouble());\n+        \n+        return originalRk.newFixedLengthChromosome(newRepr);\n+    }\n+\n+}\n--- a/src/java/org/apache/commons/math/genetics/SelectionPolicy.java\n+++ b/src/java/org/apache/commons/math/genetics/SelectionPolicy.java\n \n /**\n  * Algorithm used to select a chromosome pair from a population.\n- * @version $Revision$ $Date$\n+ * \n+ * @since 2.0\n+ * @version $Revision:$ $Date:$\n  */\n public interface SelectionPolicy {\n     /**\n--- a/src/java/org/apache/commons/math/genetics/StoppingCondition.java\n+++ b/src/java/org/apache/commons/math/genetics/StoppingCondition.java\n \n /**\n  * Algorithm used to determine when to stop evolution.\n- * @version $Revision$ $Date$\n+ * \n+ * @since 2.0\n+ * @version $Revision:$ $Date:$\n  */\n public interface StoppingCondition {\n     /**\n--- /dev/null\n+++ b/src/java/org/apache/commons/math/genetics/TournamentSelection.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.genetics;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+/**\n+ * Tournament selection scheme. Each of the two selected chromosomes is selected\n+ * based on n-ary tournament -- this is done by drawing {@link #arity} random\n+ * chromosomes without replacement from the population, and then selecting the\n+ * fittest chromosome among them. \n+ * \n+ * @since 2.0\n+ * @version $Revision:$ $Date:$\n+ */\n+public class TournamentSelection implements SelectionPolicy {\n+    \n+    /** number of chromosomes included in the tournament selections */\n+    private int arity;\n+    \n+    /**\n+     * Creates a new TournamentSelection instance.\n+     * \n+     * @param arity\n+     *            how many chromosomes will be drawn to the tournament\n+     */\n+    public TournamentSelection(int arity) {\n+        this.arity = arity;\n+    }\n+\n+    /**\n+     * Select two chromosomes from the population. Each of the two selected\n+     * chromosomes is selected based on n-ary tournament -- this is done by\n+     * drawing {@link #arity} random chromosomes without replacement from the\n+     * population, and then selecting the fittest chromosome among them.\n+     * \n+     * @param population\n+     *            the population from which the chromosomes are choosen.\n+     * @return the selected chromosomes.\n+     */\n+    public ChromosomePair select(Population population) {\n+        return new ChromosomePair(\n+                tournament((ListPopulation) population),\n+                tournament((ListPopulation)population)\n+                );\n+    }\n+    \n+    /**\n+     * Helper for {@link #select(Population)}. Draw {@link #arity} random\n+     * chromosomes without replacement from the population, and then select the\n+     * fittest chromosome among them.\n+     * \n+     * @param population\n+     *            the population from which the chromosomes are choosen.\n+     * @return the selected chromosome.\n+     */\n+    private Chromosome tournament(ListPopulation population) {\n+        if (population.getPopulationSize() < this.arity)\n+            throw new IllegalArgumentException(\"Tournament arity cannot be bigger than population size.\");\n+        // auxiliary population\n+        ListPopulation tournamentPopulation = new ListPopulation(this.arity) {\n+            public Population nextGeneration() {\n+                // not useful here\n+                return null;\n+            }\n+        };\n+        \n+        // create a copy of the chromosome list\n+        List<Chromosome> chromosomes = new ArrayList<Chromosome> (population.getChromosomes());\n+        for (int i=0; i<this.arity; i++) {\n+            // select a random individual and add it to the tournament\n+            int rind = GeneticAlgorithm.getRandomGenerator().nextInt(chromosomes.size());\n+            tournamentPopulation.addChromosome(chromosomes.get(rind));\n+            // do not select it again\n+            chromosomes.remove(rind);\n+        }\n+        // the winner takes it all\n+        return tournamentPopulation.getFittestChromosome();\n+    }\n+\n+    /**\n+     * Gets the arity (number of chromosomes drawn to the tournament).\n+     * \n+     * @return arity of the tournament\n+     */\n+    public int getArity() {\n+        return arity;\n+    }\n+\n+    /**\n+     * Sets the arity (number of chromosomes drawn to the tournament).\n+     * \n+     * @param arity arity of the tournament\n+     */\n+    public void setArity(int arity) {\n+        this.arity = arity;\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/test/org/apache/commons/math/genetics/BinaryChromosomeTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.genetics;\n+\n+import static org.junit.Assert.assertFalse;\n+import static org.junit.Assert.assertTrue;\n+import static org.junit.Assert.fail;\n+\n+import org.junit.Test;\n+\n+public class BinaryChromosomeTest {\n+    \n+    @Test\n+    public void testInvalidConstructor() {        \n+        Integer[][] reprs = new Integer[][] {\n+                new Integer[] {0,1,0,1,2},\n+                new Integer[] {0,1,0,1,-1}\n+        };\n+        \n+        for (Integer[] repr : reprs) {\n+            try {\n+                new DummyBinaryChromosome(repr);\n+                fail(\"Exception not caught\");\n+            } catch (IllegalArgumentException e) {\n+                \n+            }\n+        }\n+    }\n+    \n+    @Test\n+    public void testRandomConstructor() {\n+        for (int i=0; i<20; i++) {\n+            new DummyBinaryChromosome(BinaryChromosome.randomBinaryRepresentation(10));\n+        }\n+    }\n+    \n+    @Test\n+    public void testIsSame() {\n+        Chromosome c1 = new DummyBinaryChromosome(new Integer[] {0,1,0,1,0,1});\n+        Chromosome c2 = new DummyBinaryChromosome(new Integer[] {0,1,1,0,1});\n+        Chromosome c3 = new DummyBinaryChromosome(new Integer[] {0,1,0,1,0,1,1});\n+        Chromosome c4 = new DummyBinaryChromosome(new Integer[] {1,1,0,1,0,1});\n+        Chromosome c5 = new DummyBinaryChromosome(new Integer[] {0,1,0,1,0,0});\n+        Chromosome c6 = new DummyBinaryChromosome(new Integer[] {0,1,0,1,0,1});\n+        \n+        assertFalse(c1.isSame(c2));\n+        assertFalse(c1.isSame(c3));\n+        assertFalse(c1.isSame(c4));\n+        assertFalse(c1.isSame(c5));\n+        assertTrue(c1.isSame(c6));\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/test/org/apache/commons/math/genetics/BinaryMutationTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.genetics;\n+\n+import static org.junit.Assert.*;\n+\n+import org.junit.Test;\n+\n+public class BinaryMutationTest {\n+\n+    @Test\n+    public void testMutate() {\n+        BinaryMutation mutation = new BinaryMutation();\n+        \n+        // stochastic testing :)\n+        for (int i=0; i<20; i++) {\n+            DummyBinaryChromosome original = new DummyBinaryChromosome(BinaryChromosome.randomBinaryRepresentation(10));            \n+            DummyBinaryChromosome mutated = (DummyBinaryChromosome) mutation.mutate(original);\n+            \n+            // one gene should be different\n+            int numDifferent = 0;\n+            for (int j=0; j<original.getRepresentation().size(); j++) {\n+                if (original.getRepresentation().get(j) != mutated.getRepresentation().get(j))\n+                    numDifferent++;\n+            }\n+            assertEquals(1, numDifferent);\n+        }\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/test/org/apache/commons/math/genetics/ChromosomeTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.genetics;\n+\n+import static org.junit.Assert.*;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import org.junit.Test;\n+\n+public class ChromosomeTest {\n+\n+    @Test\n+    public void testCompareTo() {\n+        Chromosome c1 = new Chromosome() {\n+            public double fitness() {                \n+                return 0;\n+            }\n+        };\n+        Chromosome c2 = new Chromosome() {\n+            public double fitness() {                \n+                return 10;\n+            }\n+        };\n+        Chromosome c3 = new Chromosome() {\n+            public double fitness() {                \n+                return 10;\n+            }\n+        };\n+        \n+        assertTrue(c1.compareTo(c2) < 0);\n+        assertTrue(c2.compareTo(c1) > 0);\n+        assertEquals(0,c3.compareTo(c2));\n+        assertEquals(0,c2.compareTo(c3));\n+    }\n+    \n+    private abstract static class DummyChromosome extends Chromosome {\n+        private final int repr;\n+\n+        public DummyChromosome(final int repr) {\n+            this.repr = repr;\n+        }\n+        @Override\n+        protected boolean isSame(Chromosome another) {\n+            return ((DummyChromosome) another).repr == repr;\n+        }\n+    }\n+    \n+    @Test\n+    public void testFindSameChromosome() {\n+        Chromosome c1 = new DummyChromosome(1) {\n+            public double fitness() {\n+                return 1;\n+            }\n+        };\n+        Chromosome c2 = new DummyChromosome(2) {\n+            public double fitness() {\n+                return 2;\n+            }\n+        };\n+        Chromosome c3 = new DummyChromosome(3) {\n+            public double fitness() {\n+                return 3;\n+            }\n+        };\n+        Chromosome c4 = new DummyChromosome(1) {\n+            public double fitness() {\n+                return 5;\n+            }\n+        };\n+        Chromosome c5 = new DummyChromosome(15) {\n+            public double fitness() {\n+                return 15;\n+            }\n+        };\n+        \n+        List<Chromosome> popChr = new ArrayList<Chromosome>();\n+        popChr.add(c1);\n+        popChr.add(c2);\n+        popChr.add(c3);\n+        Population pop = new ListPopulation(popChr,3) {\n+            public Population nextGeneration() {\n+                // not important\n+                return null;\n+            }\n+        };\n+        \n+        assertNull(c5.findSameChromosome(pop));\n+        assertEquals(c1, c4.findSameChromosome(pop));\n+        \n+        c4.searchForFitnessUpdate(pop);\n+        assertEquals(1, c4.getFitness(),0);\n+    }\n+\n+}\n+\n--- /dev/null\n+++ b/src/test/org/apache/commons/math/genetics/DummyBinaryChromosome.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.genetics;\n+\n+import java.util.List;\n+\n+/**\n+ * Implementation of BinaryChromosome for testing purposes\n+ */\n+public class DummyBinaryChromosome extends BinaryChromosome {\n+\n+    public DummyBinaryChromosome(List<Integer> representation) {\n+        super(representation);\n+    }\n+    \n+    public DummyBinaryChromosome(Integer[] representation) {\n+        super(representation);\n+    }\n+\n+    @Override\n+    public AbstractListChromosome<Integer> newFixedLengthChromosome(List<Integer> representation) {\n+        return new DummyBinaryChromosome(representation);\n+    }\n+\n+    public double fitness() {\n+        // uninteresting\n+        return 0;\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/test/org/apache/commons/math/genetics/DummyRandomKey.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.genetics;\n+\n+import java.util.List;\n+\n+/**\n+ * Implementation of RandomKey for testing purposes\n+ */\n+public class DummyRandomKey extends RandomKey<String> {\n+\n+    public DummyRandomKey(List<Double> representation) {\n+        super(representation);\n+    }\n+    \n+    public DummyRandomKey(Double[] representation) {\n+        super(representation);\n+    }\n+\n+    @Override\n+    public AbstractListChromosome<Double> newFixedLengthChromosome(List<Double> representation) {\n+        return new DummyRandomKey(representation);\n+    }\n+\n+    public double fitness() {\n+        // unimportant\n+        return 0;\n+    }\n+    \n+}\n--- /dev/null\n+++ b/src/test/org/apache/commons/math/genetics/ElitisticListPopulationTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.genetics;\n+\n+import static org.junit.Assert.*;\n+\n+import org.junit.Test;\n+\n+public class ElitisticListPopulationTest {\n+    \n+    private static int counter = 0;\n+\n+    @Test\n+    public void testNextGeneration() {\n+        ElitisticListPopulation pop = new ElitisticListPopulation(100, 0.203);\n+        \n+        for (int i=0; i<pop.getPopulationLimit(); i++) {\n+            pop.addChromosome(new DummyChromosome());\n+        }\n+        \n+        Population nextGeneration = pop.nextGeneration();\n+        \n+        assertEquals(20, nextGeneration.getPopulationSize());\n+    }\n+    \n+    private static class DummyChromosome extends Chromosome {\n+        private final int fitness;\n+        \n+        public DummyChromosome() {\n+            this.fitness = counter;\n+            counter++;\n+        }\n+        \n+        public double fitness() {            \n+            return this.fitness;\n+        }\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/test/org/apache/commons/math/genetics/FitnessCachingTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.genetics;\n+\n+import static org.junit.Assert.*;\n+\n+import java.util.LinkedList;\n+import java.util.List;\n+import org.junit.Test;\n+\n+\n+public class FitnessCachingTest {\n+    \n+    // parameters for the GA\n+    private static final int DIMENSION = 50; \n+    private static final double CROSSOVER_RATE = 1;\n+    private static final double MUTATION_RATE = 0.1;\n+    private static final int TOURNAMENT_ARITY = 5;\n+    \n+    private static final int POPULATION_SIZE = 10;\n+    private static final int NUM_GENERATIONS = 50;\n+    private static final double ELITISM_RATE = 0.2;\n+\n+    // how many times was the fitness computed\n+    public static int fitnessCalls = 0;\n+\n+\n+    @Test\n+    public void testFitnessCaching() {\n+        // initialize a new genetic algorithm\n+        GeneticAlgorithm ga = new GeneticAlgorithm(\n+                new OnePointCrossover<Integer>(),\n+                CROSSOVER_RATE, // all selected chromosomes will be recombined (=crosssover)\n+                new BinaryMutation(),\n+                MUTATION_RATE, // no mutation\n+                new TournamentSelection(TOURNAMENT_ARITY)\n+        );\n+        \n+        // initial population\n+        Population initial = randomPopulation();\n+        // stopping conditions\n+        StoppingCondition stopCond = new FixedGenerationCount(NUM_GENERATIONS);\n+        \n+        // run the algorithm\n+        ga.evolve(initial, stopCond);\n+        \n+        int neededCalls =\n+            POPULATION_SIZE /*initial population*/ +\n+            (NUM_GENERATIONS - 1) /*for each population*/ * (int)(POPULATION_SIZE * (1.0 - ELITISM_RATE)) /*some chromosomes are copied*/\n+            ;\n+        assertTrue(fitnessCalls <= neededCalls); // some chromosomes after crossover may be the same os old ones\n+    }\n+\n+\n+    /**\n+     * Initializes a random population.\n+     */\n+    private static ElitisticListPopulation randomPopulation() {\n+        List<Chromosome> popList = new LinkedList<Chromosome>();\n+        \n+        for (int i=0; i<POPULATION_SIZE; i++) {\n+            BinaryChromosome randChrom = new DummyCountingBinaryChromosome(BinaryChromosome.randomBinaryRepresentation(DIMENSION));\n+            popList.add(randChrom);\n+        }        \n+        return new ElitisticListPopulation(popList, popList.size(), ELITISM_RATE);\n+    }\n+    \n+    private static class DummyCountingBinaryChromosome extends DummyBinaryChromosome {\n+\n+        public DummyCountingBinaryChromosome(List<Integer> representation) {\n+            super(representation);\n+        }        \n+\n+        @Override\n+        public double fitness() {\n+            fitnessCalls++;\n+            return 0;\n+        }\n+    }\n+}\n--- /dev/null\n+++ b/src/test/org/apache/commons/math/genetics/FixedGenerationCountTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.genetics;\n+\n+import static org.junit.Assert.*;\n+\n+import java.util.Iterator;\n+\n+import org.junit.Test;\n+\n+public class FixedGenerationCountTest {\n+\n+    @Test\n+    public void testIsSatisfied() {\n+        FixedGenerationCount fgc = new FixedGenerationCount(20);\n+        \n+        int cnt = 0;\n+        Population pop = new Population() {\n+            public void addChromosome(Chromosome chromosome) {\n+                // unimportant\n+            }\n+            public Chromosome getFittestChromosome() {\n+                // unimportant\n+                return null;\n+            }\n+            public int getPopulationLimit() {\n+                // unimportant\n+                return 0;\n+            }\n+            public int getPopulationSize() {\n+                // unimportant\n+                return 0;\n+            }\n+            public Population nextGeneration() {\n+                // unimportant\n+                return null;\n+            }\n+            public Iterator<Chromosome> iterator() {\n+                // unimportant\n+                return null;\n+            }\n+        };\n+        \n+        while (!fgc.isSatisfied(pop))\n+            cnt++;\n+        assertEquals(20, cnt);\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/test/org/apache/commons/math/genetics/GeneticAlgorithmTestBinary.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.genetics;\n+\n+import static org.junit.Assert.*;\n+\n+import java.util.LinkedList;\n+import java.util.List;\n+import org.junit.Test;\n+\n+/**\n+ * This is also an example of usage.\n+ */\n+public class GeneticAlgorithmTestBinary {\n+    \n+    // parameters for the GA\n+    private static final int DIMENSION = 50;    \n+    private static final int POPULATION_SIZE = 50; \n+    private static final int NUM_GENERATIONS = 50;\n+    private static final double ELITISM_RATE = 0.2;\n+    private static final double CROSSOVER_RATE = 1;\n+    private static final double MUTATION_RATE = 0.1;\n+    private static final int TOURNAMENT_ARITY = 2;\n+\n+    @Test\n+    public void test() {\n+        // to test a stochastic algorithm is hard, so this will rather be an usage example\n+        \n+        // initialize a new genetic algorithm\n+        GeneticAlgorithm ga = new GeneticAlgorithm(\n+                new OnePointCrossover<Integer>(),\n+                CROSSOVER_RATE, // all selected chromosomes will be recombined (=crosssover)\n+                new BinaryMutation(),\n+                MUTATION_RATE,\n+                new TournamentSelection(TOURNAMENT_ARITY)\n+        );\n+        \n+        // initial population\n+        Population initial = randomPopulation();\n+        // stopping conditions\n+        StoppingCondition stopCond = new FixedGenerationCount(NUM_GENERATIONS);\n+        \n+        // best initial chromosome\n+        Chromosome bestInitial = initial.getFittestChromosome();\n+        \n+        // run the algorithm\n+        Population finalPopulation = ga.evolve(initial, stopCond);\n+        \n+        // best chromosome from the final population\n+        Chromosome bestFinal = finalPopulation.getFittestChromosome();\n+        \n+        // the only thing we can test is whether the final solution is not worse than the initial one\n+        // however, for some implementations of GA, this need not be true :)\n+        \n+        assertTrue(bestFinal.compareTo(bestInitial) > 0);\n+        \n+        //System.out.println(bestInitial);\n+        //System.out.println(bestFinal);\n+    }\n+    \n+    \n+    \n+    \n+    /**\n+     * Initializes a random population.\n+     */\n+    private static ElitisticListPopulation randomPopulation() {\n+        List<Chromosome> popList = new LinkedList<Chromosome>();\n+        \n+        for (int i=0; i<POPULATION_SIZE; i++) {\n+            BinaryChromosome randChrom = new FindOnes(BinaryChromosome.randomBinaryRepresentation(DIMENSION));\n+            popList.add(randChrom);\n+        }        \n+        return new ElitisticListPopulation(popList, popList.size(), ELITISM_RATE);\n+    }\n+    \n+    /**\n+     * Chromosomes represented by a binary chromosome.\n+     * \n+     * The goal is to set all bits (genes) to 1.\n+     */\n+    private static class FindOnes extends BinaryChromosome {\n+\n+        public FindOnes(List<Integer> representation) {\n+            super(representation);\n+        }\n+\n+        /**\n+         * Returns number of elements != 0\n+         */\n+        public double fitness() {\n+            int num = 0;\n+            for (int val : this.getRepresentation()) {\n+                if (val != 0)\n+                    num++;\n+            }\n+            // number of elements >= 0\n+            return num;\n+        }\n+\n+        @Override\n+        public AbstractListChromosome<Integer> newFixedLengthChromosome(List<Integer> representation) {\n+            return new FindOnes(representation);\n+        }\n+\n+    }\n+}\n--- /dev/null\n+++ b/src/test/org/apache/commons/math/genetics/GeneticAlgorithmTestPermutations.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.genetics;\n+\n+import static org.junit.Assert.assertTrue;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import org.junit.Test;\n+\n+/**\n+ * This is also an example of usage.\n+ * \n+ * This algorithm does \"stochastic sorting\" of a sequence 0,...,N.\n+ * \n+ */\n+public class GeneticAlgorithmTestPermutations {\n+    \n+    // parameters for the GA\n+    private static final int DIMENSION = 20;    \n+    private static final int POPULATION_SIZE = 80; \n+    private static final int NUM_GENERATIONS = 200;\n+    private static final double ELITISM_RATE = 0.2;\n+    private static final double CROSSOVER_RATE = 1;\n+    private static final double MUTATION_RATE = 0.08;\n+    private static final int TOURNAMENT_ARITY = 2;\n+    \n+    // numbers from 0 to N-1\n+    private static List<Integer> sequence = new ArrayList<Integer>();\n+    static {\n+        for (int i=0; i<DIMENSION; i++) {\n+            sequence.add(i);\n+        }\n+    }\n+\n+    @Test\n+    public void test() {\n+        // to test a stochastic algorithm is hard, so this will rather be an usage example\n+        \n+        // initialize a new genetic algorithm\n+        GeneticAlgorithm ga = new GeneticAlgorithm(\n+                new OnePointCrossover<Integer>(),\n+                CROSSOVER_RATE,\n+                new RandomKeyMutation(),\n+                MUTATION_RATE,\n+                new TournamentSelection(TOURNAMENT_ARITY)\n+        );\n+        \n+        // initial population\n+        Population initial = randomPopulation();\n+        // stopping conditions\n+        StoppingCondition stopCond = new FixedGenerationCount(NUM_GENERATIONS);\n+        \n+        // best initial chromosome\n+        Chromosome bestInitial = initial.getFittestChromosome();\n+        \n+        // run the algorithm\n+        Population finalPopulation = ga.evolve(initial, stopCond);\n+        \n+        // best chromosome from the final population\n+        Chromosome bestFinal = finalPopulation.getFittestChromosome();\n+        \n+        // the only thing we can test is whether the final solution is not worse than the initial one\n+        // however, for some implementations of GA, this need not be true :)\n+        \n+        assertTrue(bestFinal.compareTo(bestInitial) > 0);\n+        \n+        //System.out.println(bestInitial);\n+        //System.out.println(bestFinal);\n+    }\n+    \n+    \n+    /**\n+     * Initializes a random population\n+     */\n+    private static ElitisticListPopulation randomPopulation() {\n+        List<Chromosome> popList = new ArrayList<Chromosome>();\n+        for (int i=0; i<POPULATION_SIZE; i++) {\n+            Chromosome randChrom = new MinPermutations(RandomKey.randomPermutation(DIMENSION));\n+            popList.add(randChrom);\n+        }\n+        return new ElitisticListPopulation(popList, popList.size(), ELITISM_RATE);\n+    }\n+    \n+    /**\n+     * Chromosomes representing a permutation of (0,1,2,...,DIMENSION-1).\n+     * \n+     * The goal is to sort the sequence.\n+     */\n+    private static class MinPermutations extends RandomKey<Integer> {\n+\n+        public MinPermutations(List<Double> representation) {\n+            super(representation);\n+            // TODO Auto-generated constructor stub\n+        }\n+\n+        public double fitness() {\n+            int res = 0;\n+            List<Integer> decoded = decode(sequence);\n+            for (int i=0; i<decoded.size(); i++) {\n+                int value = (Integer) decoded.get(i);\n+                if (value != i) {\n+                    // bad position found\n+                    res += Math.abs(value - i);\n+                }\n+            }\n+            // the most fitted chromosome is the one with minimal error\n+            // therefore we must return negative value\n+            return -res; \n+        }\n+\n+        @Override\n+        public AbstractListChromosome<Double> newFixedLengthChromosome(List<Double> representation) {\n+            return new MinPermutations(representation);\n+        }\n+    }\n+}\n--- /dev/null\n+++ b/src/test/org/apache/commons/math/genetics/ListPopulationTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.genetics;\n+\n+import static org.junit.Assert.*;\n+\n+import java.util.ArrayList;\n+\n+import org.junit.Test;\n+\n+public class ListPopulationTest {\n+\n+    @Test\n+    public void testGetFittestChromosome() {\n+        Chromosome c1 = new Chromosome() {\n+            public double fitness() {                \n+                return 0;\n+            }\n+        };\n+        Chromosome c2 = new Chromosome() {\n+            public double fitness() {                \n+                return 10;\n+            }\n+        };\n+        Chromosome c3 = new Chromosome() {\n+            public double fitness() {                \n+                return 15;\n+            }\n+        };\n+        \n+        ArrayList<Chromosome> chromosomes = new ArrayList<Chromosome> ();\n+        chromosomes.add(c1);\n+        chromosomes.add(c2);\n+        chromosomes.add(c3);\n+        \n+        ListPopulation population = new ListPopulation(chromosomes,10) {\n+\n+            public Population nextGeneration() {\n+                // not important\n+                return null;\n+            }\n+        };\n+        \n+        assertEquals(c3, population.getFittestChromosome());\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/test/org/apache/commons/math/genetics/OnePointCrossoverTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.genetics;\n+\n+import static org.junit.Assert.*;\n+import org.junit.Test;\n+\n+public class OnePointCrossoverTest {\n+\n+    @Test\n+    public void testCrossover() {\n+        Integer[] p1 = new Integer[] {1,0,1,0,0,1,0,1,1};\n+        Integer[] p2 = new Integer[] {0,1,1,0,1,0,1,1,1};\n+        \n+        BinaryChromosome p1c = new DummyBinaryChromosome(p1);\n+        BinaryChromosome p2c = new DummyBinaryChromosome(p2);\n+        \n+        OnePointCrossover<Integer> opc = new OnePointCrossover<Integer>();\n+        \n+        // how to test a stochastic method?\n+        for (int i=0; i<20; i++) {\n+            ChromosomePair pair = opc.crossover(p1c,p2c);\n+            \n+            Integer[] c1 = new Integer[p1.length];\n+            Integer[] c2 = new Integer[p2.length];\n+            \n+            c1 = ((BinaryChromosome) pair.getFirst()).getRepresentation().toArray(c1);\n+            c2 = ((BinaryChromosome) pair.getSecond()).getRepresentation().toArray(c2);\n+            \n+            // first and last values will be the same\n+            assertEquals((int) p1[0], (int) c1[0]);\n+            assertEquals((int) p2[0], (int) c2[0]);\n+            assertEquals((int) p1[p1.length-1], (int) c1[c1.length-1]);\n+            assertEquals((int) p2[p2.length-1], (int) c2[c2.length-1]);\n+            // moreover, in the above setting, the 2nd, 3rd and 7th values will be the same\n+            assertEquals((int) p1[2], (int) c1[2]);\n+            assertEquals((int) p2[2], (int) c2[2]);\n+            assertEquals((int) p1[3], (int) c1[3]);\n+            assertEquals((int) p2[3], (int) c2[3]);\n+            assertEquals((int) p1[7], (int) c1[7]);\n+            assertEquals((int) p2[7], (int) c2[7]);\n+        }\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/test/org/apache/commons/math/genetics/RandomKeyMutationTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.genetics;\n+\n+import static org.junit.Assert.*;\n+\n+import org.junit.Test;\n+\n+public class RandomKeyMutationTest {\n+\n+    @Test\n+    public void testMutate() {\n+        MutationPolicy mutation = new RandomKeyMutation();\n+        int l=10;\n+        for (int i=0; i<20; i++) {\n+            DummyRandomKey origRk = new DummyRandomKey(RandomKey.randomPermutation(l));\n+            Chromosome mutated = mutation.mutate(origRk);\n+            DummyRandomKey mutatedRk = (DummyRandomKey) mutated;\n+            \n+            int changes = 0;\n+            for (int j=0; j<origRk.getLength(); j++) {\n+                if (origRk.getRepresentation().get(j) != mutatedRk.getRepresentation().get(j)) {\n+                    changes++;\n+                }\n+            }\n+            assertEquals(1,changes);\n+        }\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/test/org/apache/commons/math/genetics/RandomKeyTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.genetics;\n+\n+import static org.junit.Assert.*;\n+\n+import java.util.Arrays;\n+import java.util.Comparator;\n+import java.util.List;\n+\n+import org.junit.Test;\n+\n+public class RandomKeyTest {\n+\n+    @Test(expected=IllegalArgumentException.class)\n+    public void testConstructor1() {\n+        @SuppressWarnings(\"unused\")\n+        DummyRandomKey drk = new DummyRandomKey(new Double[] {0.2, 0.3, 1.2});\n+    }\n+    \n+    @Test(expected=IllegalArgumentException.class)\n+    public void testConstructor2() {\n+        @SuppressWarnings(\"unused\")\n+        DummyRandomKey drk = new DummyRandomKey(new Double[] {0.2, 0.3, -0.2});\n+    }\n+\n+    @Test\n+    public void testIsSame() {\n+        DummyRandomKey drk1 = new DummyRandomKey(new Double[] {0.4, 0.1, 0.5, 0.8, 0.2});\n+        DummyRandomKey drk2 = new DummyRandomKey(new Double[] {0.4, 0.1, 0.5, 0.8, 0.2});\n+        DummyRandomKey drk3 = new DummyRandomKey(new Double[] {0.4, 0.15, 0.5, 0.8, 0.2});\n+        DummyRandomKey drk4 = new DummyRandomKey(new Double[] {0.4, 0.25, 0.5, 0.8, 0.2});\n+        DummyRandomKey drk5 = new DummyRandomKey(new Double[] {0.4, 0.25, 0.5, 0.8, 0.2, 0.5});\n+        \n+        assertTrue(drk1.isSame(drk2));\n+        assertTrue(drk2.isSame(drk3));\n+        assertFalse(drk3.isSame(drk4));\n+        assertFalse(drk4.isSame(drk5));\n+    }\n+\n+    @Test\n+    public void testDecode() {\n+        DummyRandomKey drk = new DummyRandomKey(new Double[] {0.4, 0.1, 0.5, 0.8, 0.2});\n+        List<String> decoded = drk.decode(Arrays.asList(new String[] {\"a\", \"b\", \"c\", \"d\", \"e\"}));\n+        \n+        assertEquals(\"b\", decoded.get(0));\n+        assertEquals(\"e\", decoded.get(1));\n+        assertEquals(\"a\", decoded.get(2));\n+        assertEquals(\"c\", decoded.get(3));\n+        assertEquals(\"d\", decoded.get(4));\n+    }\n+\n+    @Test\n+    public void testRandomPermutation() {\n+        // never generate an invalid one\n+        for (int i=0; i<10; i++) {\n+            @SuppressWarnings(\"unused\")\n+            DummyRandomKey drk = new DummyRandomKey(RandomKey.randomPermutation(20));\n+        }\n+    }\n+\n+    @Test\n+    public void testIdentityPermutation() {\n+        DummyRandomKey drk = new DummyRandomKey(RandomKey.identityPermutation(5));\n+        List<String> decoded = drk.decode(Arrays.asList(new String[] {\"a\", \"b\", \"c\", \"d\", \"e\"}));\n+        \n+        assertEquals(\"a\", decoded.get(0));\n+        assertEquals(\"b\", decoded.get(1));\n+        assertEquals(\"c\", decoded.get(2));\n+        assertEquals(\"d\", decoded.get(3));\n+        assertEquals(\"e\", decoded.get(4));\n+    }\n+\n+    @Test\n+    public void testComparatorPermutation() {\n+        List<String> data = Arrays.asList(new String[] {\"x\", \"b\", \"c\", \"z\", \"b\"});\n+        \n+        List<Double> permutation = RandomKey.comparatorPermutation(data, new Comparator<String>() {\n+            public int compare(String o1, String o2) {\n+                return o1.compareTo(o2);\n+            }\n+        });\n+        Double[] permArr = new Double[data.size()];\n+        permArr = permutation.toArray(permArr);\n+        assertArrayEquals(new Double[] {0.6,0.0,0.4,0.8,0.2}, permArr);\n+        List<String> decodedData = new DummyRandomKey(permutation).decode(data);\n+        assertEquals(\"b\", decodedData.get(0));\n+        assertEquals(\"b\", decodedData.get(1));\n+        assertEquals(\"c\", decodedData.get(2));\n+        assertEquals(\"x\", decodedData.get(3));\n+        assertEquals(\"z\", decodedData.get(4));\n+        \n+        permutation = RandomKey.comparatorPermutation(data, new Comparator<String>() {\n+            public int compare(String o1, String o2) {\n+                return o2.compareTo(o1);\n+            }\n+        });\n+        permArr = new Double[data.size()];\n+        permArr = permutation.toArray(permArr);\n+        assertArrayEquals(new Double[] {0.2,0.6,0.4,0.0,0.8}, permArr);\n+        decodedData = new DummyRandomKey(permutation).decode(data);\n+        assertEquals(\"z\", decodedData.get(0));\n+        assertEquals(\"x\", decodedData.get(1));\n+        assertEquals(\"c\", decodedData.get(2));\n+        assertEquals(\"b\", decodedData.get(3));\n+        assertEquals(\"b\", decodedData.get(4));\n+    }\n+    \n+    @Test\n+    public void testInducedPermutation() {\n+        List<String> origData = Arrays.asList(new String[] {\"a\", \"b\", \"c\", \"d\", \"d\"});\n+        List<String> permutedData = Arrays.asList(new String[] {\"d\", \"b\", \"c\", \"a\", \"d\"});\n+        \n+        DummyRandomKey drk = new DummyRandomKey(RandomKey.inducedPermutation(origData, permutedData));\n+        List<String> decoded = drk.decode(origData);\n+        \n+        assertEquals(\"d\", decoded.get(0));\n+        assertEquals(\"b\", decoded.get(1));\n+        assertEquals(\"c\", decoded.get(2));\n+        assertEquals(\"a\", decoded.get(3));\n+        assertEquals(\"d\", decoded.get(4));\n+\n+        try {\n+            RandomKey.inducedPermutation(\n+                    Arrays.asList(new String[] {\"a\", \"b\", \"c\", \"d\", \"d\"}),\n+                    Arrays.asList(new String[] {\"a\", \"b\", \"c\", \"d\"})\n+            );\n+            fail(\"Uncaught exception\");\n+        } catch (IllegalArgumentException e) {\n+            // no-op\n+        }\n+        try {\n+            RandomKey.inducedPermutation(\n+                    Arrays.asList(new String[] {\"a\", \"b\", \"c\", \"d\", \"d\"}),\n+                    Arrays.asList(new String[] {\"a\", \"b\", \"c\", \"d\", \"f\"})\n+            );\n+            fail(\"Uncaught exception\");\n+        } catch (IllegalArgumentException e) {\n+            // no-op\n+        }\n+    }\n+\n+    @Test\n+    public void testEqualRepr() {\n+        DummyRandomKey drk = new DummyRandomKey(new Double[] {0.2, 0.2, 0.5});\n+        List<String> decodedData = drk.decode(Arrays.asList(new String[] {\"a\", \"b\", \"c\"}));\n+        assertEquals(\"a\", decodedData.get(0));\n+        assertEquals(\"b\", decodedData.get(1));\n+        assertEquals(\"c\", decodedData.get(2));\n+    }\n+    \n+}\n--- /dev/null\n+++ b/src/test/org/apache/commons/math/genetics/TournamentSelectionTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.genetics;\n+\n+import static org.junit.Assert.*;\n+import org.junit.Test;\n+\n+public class TournamentSelectionTest {\n+    \n+    private static int counter = 0;\n+\n+    @Test\n+    public void testSelect() {\n+        TournamentSelection ts = new TournamentSelection(2);\n+        ElitisticListPopulation pop = new ElitisticListPopulation(100, 0.203);\n+        \n+        for (int i=0; i<pop.getPopulationLimit(); i++) {\n+            pop.addChromosome(new DummyChromosome());\n+        }\n+        // how to write a test for stochastic method?\n+        for (int i=0; i<20; i++) {\n+            ChromosomePair pair = ts.select(pop);\n+            // the worst chromosome should NEVER be selected\n+            assertTrue(pair.getFirst().getFitness() > 0);\n+            assertTrue(pair.getSecond().getFitness() > 0);\n+        }\n+    }\n+    \n+    private static class DummyChromosome extends Chromosome {\n+        private final int fitness;\n+        \n+        public DummyChromosome() {\n+            this.fitness = counter;\n+            counter++;\n+        }\n+        \n+        public double fitness() {            \n+            return this.fitness;\n+        }\n+    }\n+\n+}", "timestamp": 1245006272, "metainfo": ""}