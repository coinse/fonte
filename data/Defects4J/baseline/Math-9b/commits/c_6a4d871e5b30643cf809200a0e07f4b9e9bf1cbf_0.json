{"sha": "6a4d871e5b30643cf809200a0e07f4b9e9bf1cbf", "log": "In package transform, replaced FastFourierTransformer.transform2 and FastFourierTransformer.inverseTransform2 with a combination of transform()/inverseTransform(), combined with appropriate factory methods (MATH-677).  ", "commit": "\n--- a/src/main/java/org/apache/commons/math/transform/FastCosineTransformer.java\n+++ b/src/main/java/org/apache/commons/math/transform/FastCosineTransformer.java\n             x[n - i] = a + b;\n             t1 += c;\n         }\n-        FastFourierTransformer transformer = new FastFourierTransformer();\n+        FastFourierTransformer transformer = FastFourierTransformer.create();\n         Complex[] y = transformer.transform(x);\n \n         // reconstruct the FCT result for the original array\n--- a/src/main/java/org/apache/commons/math/transform/FastFourierTransformer.java\n+++ b/src/main/java/org/apache/commons/math/transform/FastFourierTransformer.java\n  * chapter 6.\n  * <p>\n  * There are several conventions for the definition of FFT and inverse FFT,\n- * mainly on different coefficient and exponent. Here the equations are listed\n- * in the comments of the corresponding methods.</p>\n+ * mainly on different coefficient and exponent. The conventions adopted in the\n+ * present implementation are specified in the comments of the two provided\n+ * factory methods, {@link #create()} and {@link #createUnitary()}.\n+ * </p>\n  * <p>\n  * We require the length of data set to be power of 2, this greatly simplifies\n  * and speeds up the code. Users can pad the data with zeros to meet this\n  * requirement. There are other flavors of FFT, for reference, see S. Winograd,\n- * <i>On computing the discrete Fourier transform</i>, Mathematics of Computation,\n- * 32 (1978), 175 - 199.</p>\n+ * <i>On computing the discrete Fourier transform</i>, Mathematics of\n+ * Computation, 32 (1978), 175 - 199.\n+ * </p>\n  *\n  * @version $Id$\n  * @since 1.2\n     /** Serializable version identifier. */\n     static final long serialVersionUID = 5138259215438106000L;\n \n+\n+    /**\n+     * {@code true} if the orthogonal version of the FFT should be used.\n+     *\n+     * @see #create()\n+     * @see #createUnitary()\n+     */\n+    private final boolean unitary;\n+\n     /** The roots of unity. */\n     private RootsOfUnity roots = new RootsOfUnity();\n \n     /** Construct a default transformer. */\n-    public FastFourierTransformer() {\n+    private FastFourierTransformer() {\n         super();\n-    }\n-\n-    /**\n-     * Transform the given real data set.\n+        this.unitary = false;\n+    }\n+\n+    /**\n+     * Creates a new instance of this class, with various normalization\n+     * conventions.\n+     *\n+     * @param unitary {@code false} if the direct Fourier transform is\n+     * <em>not</em> to be scaled, {@code true} if it is to be scaled so as to\n+     * make the transform unitary.\n+     * @see #create()\n+     * @see #createUnitary()\n+     */\n+    private FastFourierTransformer(final boolean unitary) {\n+        this.unitary = unitary;\n+    }\n+\n+    /**\n      * <p>\n-     * The formula is $ y_n = \\Sigma_{k=0}^{N-1} e^{-2 \\pi i nk/N} x_k $\n+     * Returns a new instance of this class. The returned transformer uses the\n+     * normalizing conventions described below.\n      * </p>\n+     * <ul>\n+     * <li>Forward transform:\n+     * y<sub>n</sub> = &sum;<sub>k=0</sub><sup>N-1</sup>\n+     * x<sub>k</sub> exp(-2&pi;i n k / N),</li>\n+     * <li>Inverse transform:\n+     * x<sub>k</sub> = N<sup>-1</sup> &sum;<sub>n=0</sub><sup>N-1</sup>\n+     * y<sub>n</sub> exp(2&pi;i n k / N).</li>\n+     * </ul>\n+     *\n+     * @return a new FFT transformer, with \"standard\" normalizing conventions\n+     */\n+    public static FastFourierTransformer create() {\n+        return new FastFourierTransformer(false);\n+    }\n+\n+    /**\n+     * <p>\n+     * Returns a new instance of this class. The returned transformer uses the\n+     * normalizing conventions described below.\n+     * <ul>\n+     * <li>Forward transform:\n+     * y<sub>n</sub> = N<sup>-1/2</sup> &sum;<sub>k=0</sub><sup>N-1</sup>\n+     * x<sub>k</sub> exp(-2&pi;i n k / N),</li>\n+     * <li>Inverse transform:\n+     * x<sub>k</sub> = N<sup>-1/2</sup> &sum;<sub>n=0</sub><sup>N-1</sup>\n+     * y<sub>n</sub> exp(2&pi;i n k / N),</li>\n+     * </ul>\n+     * which make the transform unitary.\n+     * </p>\n+     *\n+     * @return a new FFT transformer, with unitary normalizing conventions\n+     */\n+    public static FastFourierTransformer createUnitary() {\n+        return new FastFourierTransformer(true);\n+    }\n+\n+\n+    /**\n+     * Returns the forward transform of the specified real data set.\n      *\n      * @param f the real data array to be transformed\n      * @return the complex transformed array\n      */\n     public Complex[] transform(double[] f)\n         throws IllegalArgumentException {\n+        if (unitary) {\n+            final double s = 1.0 / FastMath.sqrt(f.length);\n+            return scaleArray(fft(f, false), s);\n+        }\n         return fft(f, false);\n     }\n \n     /**\n-     * Transform the given real function, sampled on the given interval.\n-     * <p>\n-     * The formula is $ y_n = \\Sigma_{k=0}^{N-1} e^{-2 \\pi i nk/N} x_k $\n-     * </p>\n+     * Returns the forward transform of the specified real function, sampled on\n+     * the specified interval.\n      *\n      * @param f the function to be sampled and transformed\n-     * @param min the lower bound for the interval\n-     * @param max the upper bound for the interval\n+     * @param min the (inclusive) lower bound for the interval\n+     * @param max the (exclusive) upper bound for the interval\n      * @param n the number of sample points\n      * @return the complex transformed array\n      * @throws IllegalArgumentException if any parameters are invalid\n     public Complex[] transform(UnivariateFunction f,\n                                double min, double max, int n)\n         throws IllegalArgumentException {\n-        double[] data = sample(f, min, max, n);\n+        final double[] data = sample(f, min, max, n);\n+        if (unitary) {\n+            final double s = 1.0 / FastMath.sqrt(n);\n+            return scaleArray(fft(data, false), s);\n+        }\n         return fft(data, false);\n     }\n \n     /**\n-     * Transform the given complex data set.\n-     * <p>\n-     * The formula is $ y_n = \\Sigma_{k=0}^{N-1} e^{-2 \\pi i nk/N} x_k $\n-     * </p>\n+     * Returns the forward transform of the specified complex data set.\n      *\n      * @param f the complex data array to be transformed\n      * @return the complex transformed array\n     public Complex[] transform(Complex[] f)\n         throws IllegalArgumentException {\n         roots.computeOmega(f.length);\n+        if (unitary) {\n+            final double s = 1.0 / FastMath.sqrt(f.length);\n+            return scaleArray(fft(f), s);\n+        }\n         return fft(f);\n     }\n \n     /**\n-     * Transform the given real data set.\n-     * <p>\n-     * The formula is $y_n = (1/\\sqrt{N}) \\Sigma_{k=0}^{N-1} e^{-2 \\pi i nk/N} x_k$\n-     * </p>\n-     *\n-     * @param f the real data array to be transformed\n-     * @return the complex transformed array\n-     * @throws IllegalArgumentException if any parameters are invalid\n-     */\n-    public Complex[] transform2(double[] f)\n-        throws IllegalArgumentException {\n-\n-        double scalingCoefficient = 1.0 / FastMath.sqrt(f.length);\n-        return scaleArray(fft(f, false), scalingCoefficient);\n-    }\n-\n-    /**\n-     * Transform the given real function, sampled on the given interval.\n-     * <p>\n-     * The formula is $y_n = (1/\\sqrt{N}) \\Sigma_{k=0}^{N-1} e^{-2 \\pi i nk/N} x_k$\n-     * </p>\n-     *\n-     * @param f the function to be sampled and transformed\n-     * @param min the lower bound for the interval\n-     * @param max the upper bound for the interval\n-     * @param n the number of sample points\n-     * @return the complex transformed array\n-     * @throws IllegalArgumentException if any parameters are invalid\n-     */\n-    public Complex[] transform2(UnivariateFunction f,\n-                                double min, double max, int n)\n-        throws IllegalArgumentException {\n-\n-        double[] data = sample(f, min, max, n);\n-        double scalingCoefficient = 1.0 / FastMath.sqrt(n);\n-        return scaleArray(fft(data, false), scalingCoefficient);\n-    }\n-\n-    /**\n-     * Transform the given complex data set.\n-     * <p>\n-     * The formula is $y_n = (1/\\sqrt{N}) \\Sigma_{k=0}^{N-1} e^{-2 \\pi i nk/N} x_k$\n-     * </p>\n-     *\n-     * @param f the complex data array to be transformed\n-     * @return the complex transformed array\n-     * @throws IllegalArgumentException if any parameters are invalid\n-     */\n-    public Complex[] transform2(Complex[] f)\n-        throws IllegalArgumentException {\n-\n-        roots.computeOmega(f.length);\n-        double scalingCoefficient = 1.0 / FastMath.sqrt(f.length);\n-        return scaleArray(fft(f), scalingCoefficient);\n-    }\n-\n-    /**\n-     * Inversely transform the given real data set.\n-     * <p>\n-     * The formula is $ x_k = (1/N) \\Sigma_{n=0}^{N-1} e^{2 \\pi i nk/N} y_n $\n-     * </p>\n+     * Returns the inverse transform of the specified real data set.\n      *\n      * @param f the real data array to be inversely transformed\n      * @return the complex inversely transformed array\n     public Complex[] inverseTransform(double[] f)\n         throws IllegalArgumentException {\n \n-        double scalingCoefficient = 1.0 / f.length;\n-        return scaleArray(fft(f, true), scalingCoefficient);\n-    }\n-\n-    /**\n-     * Inversely transform the given real function, sampled on the given interval.\n-     * <p>\n-     * The formula is $ x_k = (1/N) \\Sigma_{n=0}^{N-1} e^{2 \\pi i nk/N} y_n $\n-     * </p>\n+        final double s = 1.0 / (unitary ? FastMath.sqrt(f.length) : f.length);\n+        return scaleArray(fft(f, true), s);\n+    }\n+\n+    /**\n+     * Returns the inverse transform of the specified real function, sampled\n+     * on the given interval.\n      *\n      * @param f the function to be sampled and inversely transformed\n-     * @param min the lower bound for the interval\n-     * @param max the upper bound for the interval\n+     * @param min the (inclusive) lower bound for the interval\n+     * @param max the (exclusive) upper bound for the interval\n      * @param n the number of sample points\n      * @return the complex inversely transformed array\n      * @throws IllegalArgumentException if any parameters are invalid\n                                       double min, double max, int n)\n         throws IllegalArgumentException {\n \n-        double[] data = sample(f, min, max, n);\n-        double scalingCoefficient = 1.0 / n;\n-        return scaleArray(fft(data, true), scalingCoefficient);\n-    }\n-\n-    /**\n-     * Inversely transform the given complex data set.\n-     * <p>\n-     * The formula is $ x_k = (1/N) \\Sigma_{n=0}^{N-1} e^{2 \\pi i nk/N} y_n $\n-     * </p>\n+        final double[] data = sample(f, min, max, n);\n+        final double s = 1.0 / (unitary ? FastMath.sqrt(n) : n);\n+        return scaleArray(fft(data, true), s);\n+    }\n+\n+    /**\n+     * Returns the inverse transform of the specified complex data set.\n      *\n      * @param f the complex data array to be inversely transformed\n      * @return the complex inversely transformed array\n         throws IllegalArgumentException {\n \n         roots.computeOmega(-f.length);    // pass negative argument\n-        double scalingCoefficient = 1.0 / f.length;\n-        return scaleArray(fft(f), scalingCoefficient);\n-    }\n-\n-    /**\n-     * Inversely transform the given real data set.\n-     * <p>\n-     * The formula is $x_k = (1/\\sqrt{N}) \\Sigma_{n=0}^{N-1} e^{2 \\pi i nk/N} y_n$\n-     * </p>\n-     *\n-     * @param f the real data array to be inversely transformed\n-     * @return the complex inversely transformed array\n-     * @throws IllegalArgumentException if any parameters are invalid\n-     */\n-    public Complex[] inverseTransform2(double[] f)\n-        throws IllegalArgumentException {\n-\n-        double scalingCoefficient = 1.0 / FastMath.sqrt(f.length);\n-        return scaleArray(fft(f, true), scalingCoefficient);\n-    }\n-\n-    /**\n-     * Inversely transform the given real function, sampled on the given interval.\n-     * <p>\n-     * The formula is $x_k = (1/\\sqrt{N}) \\Sigma_{n=0}^{N-1} e^{2 \\pi i nk/N} y_n$\n-     * </p>\n-     *\n-     * @param f the function to be sampled and inversely transformed\n-     * @param min the lower bound for the interval\n-     * @param max the upper bound for the interval\n-     * @param n the number of sample points\n-     * @return the complex inversely transformed array\n-     * @throws IllegalArgumentException if any parameters are invalid\n-     */\n-    public Complex[] inverseTransform2(UnivariateFunction f,\n-                                       double min, double max, int n)\n-        throws IllegalArgumentException {\n-\n-        double[] data = sample(f, min, max, n);\n-        double scalingCoefficient = 1.0 / FastMath.sqrt(n);\n-        return scaleArray(fft(data, true), scalingCoefficient);\n-    }\n-\n-    /**\n-     * Inversely transform the given complex data set.\n-     * <p>\n-     * The formula is $x_k = (1/\\sqrt{N}) \\Sigma_{n=0}^{N-1} e^{2 \\pi i nk/N} y_n$\n-     * </p>\n-     *\n-     * @param f the complex data array to be inversely transformed\n-     * @return the complex inversely transformed array\n-     * @throws IllegalArgumentException if any parameters are invalid\n-     */\n-    public Complex[] inverseTransform2(Complex[] f)\n-        throws IllegalArgumentException {\n-\n-        roots.computeOmega(-f.length);    // pass negative argument\n-        double scalingCoefficient = 1.0 / FastMath.sqrt(f.length);\n-        return scaleArray(fft(f), scalingCoefficient);\n+        final double s = 1.0 / (unitary ? FastMath.sqrt(f.length) : f.length);\n+        return scaleArray(fft(f), s);\n     }\n \n     /**\n                     final double omegaKmImag = roots.getOmegaImaginary(km);\n                     //z = f[i+j+k].multiply(omega[k*m]);\n                     final Complex z = new Complex(\n-                        f[i + j + k].getReal() * omegaKmReal\n-                        - f[i + j + k].getImaginary() * omegaKmImag,\n-                        f[i + j + k].getReal() * omegaKmImag\n-                        + f[i + j + k].getImaginary() * omegaKmReal);\n+                        f[i + j + k].getReal() * omegaKmReal -\n+                        f[i + j + k].getImaginary() * omegaKmImag,\n+                        f[i + j + k].getReal() * omegaKmImag +\n+                        f[i + j + k].getImaginary() * omegaKmReal);\n \n                     f[i + j + k] = f[j + k].subtract(z);\n                     f[j + k] = f[j + k].add(z);\n      * require that.</p>\n      *\n      * @param f the function to be sampled\n-     * @param min the lower bound for the interval\n-     * @param max the upper bound for the interval\n+     * @param min the (inclusive) lower bound for the interval\n+     * @param max the (exclusive) upper bound for the interval\n      * @param n the number of sample points\n      * @return the samples array\n      * @throws IllegalArgumentException if any parameters are invalid\n     }\n \n     /**\n-     * Performs a multi-dimensional Fourier transform on a given array.\n-     * Use {@link #inverseTransform2(Complex[])} and\n-     * {@link #transform2(Complex[])} in a row-column implementation\n-     * in any number of dimensions with O(N&times;log(N)) complexity with\n-     * N=n<sub>1</sub>&times;n<sub>2</sub>&times;n<sub>3</sub>&times;...&times;n<sub>d</sub>,\n-     * n<sub>x</sub>=number of elements in dimension x,\n-     * and d=total number of dimensions.\n-     *\n-     * @param mdca Multi-Dimensional Complex Array id est Complex[][][][]\n-     * @param forward inverseTransform2 is preformed if this is false\n-     * @return transform of mdca as a Multi-Dimensional Complex Array id est Complex[][][][]\n+     * Performs a multi-dimensional Fourier transform on a given array. Use\n+     * {@link #transform(Complex[])} and {@link #inverseTransform(Complex[])} in\n+     * a row-column implementation in any number of dimensions with\n+     * O(N&times;log(N)) complexity with\n+     * N = n<sub>1</sub> &times; n<sub>2</sub> &times;n<sub>3</sub> &times; ...\n+     * &times; n<sub>d</sub>, where n<sub>k</sub> is the number of elements in\n+     * dimension k, and d is the total number of dimensions.\n+     *\n+     * @param mdca Multi-Dimensional Complex Array id est\n+     * {@code Complex[][][][]}\n+     * @param forward {@link #inverseTransform} is performed if this is\n+     * {@code false}\n+     * @return transform of {@code mdca} as a Multi-Dimensional Complex Array\n+     * id est {@code Complex[][][][]}\n      * @throws IllegalArgumentException if any dimension is not a power of two\n      */\n     public Object mdfft(Object mdca, boolean forward)\n      * Performs one dimension of a multi-dimensional Fourier transform.\n      *\n      * @param mdcm input matrix\n-     * @param forward inverseTransform2 is preformed if this is false\n+     * @param forward {@link #inverseTransform} is performed if this is\n+     * {@code false}\n      * @param d index of the dimension to process\n      * @param subVector recursion subvector\n      * @throws IllegalArgumentException if any dimension is not a power of two\n             }\n \n             if (forward) {\n-                temp = transform2(temp);\n+                temp = transform(temp);\n             } else {\n-                temp = inverseTransform2(temp);\n+                temp = inverseTransform(temp);\n             }\n \n             for (int i = 0; i < dimensionSize[d]; i++) {\n         omegaImaginaryForward[0] = 0.0;\n         omegaImaginaryInverse[0] = 0.0;\n         for (int i = 1; i < absN; i++) {\n-          omegaReal[i] = omegaReal[i - 1] * cosT\n-                         + omegaImaginaryForward[i - 1] * sinT;\n-          omegaImaginaryForward[i] = omegaImaginaryForward[i - 1] * cosT\n-                                     - omegaReal[i - 1] * sinT;\n+          omegaReal[i] = omegaReal[i - 1] * cosT +\n+                         omegaImaginaryForward[i - 1] * sinT;\n+          omegaImaginaryForward[i] = omegaImaginaryForward[i - 1] * cosT -\n+                                     omegaReal[i - 1] * sinT;\n           omegaImaginaryInverse[i] = -omegaImaginaryForward[i];\n         }\n         omegaCount = absN;\n--- a/src/main/java/org/apache/commons/math/transform/FastSineTransformer.java\n+++ b/src/main/java/org/apache/commons/math/transform/FastSineTransformer.java\n             x[i]     = a + b;\n             x[n - i] = a - b;\n         }\n-        FastFourierTransformer transformer = new FastFourierTransformer();\n+        FastFourierTransformer transformer = FastFourierTransformer.create();\n         Complex[] y = transformer.transform(x);\n \n         // reconstruct the FST result for the original array", "timestamp": 1323243309, "metainfo": ""}