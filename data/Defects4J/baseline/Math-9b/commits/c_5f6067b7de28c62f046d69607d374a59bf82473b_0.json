{"sha": "5f6067b7de28c62f046d69607d374a59bf82473b", "log": "MATH-413 Removed \"setConvergenceChecker\"; convergence checker is passed at construction.   ", "commit": "\n--- a/src/main/java/org/apache/commons/math/optimization/BaseMultiStartMultivariateRealOptimizer.java\n+++ b/src/main/java/org/apache/commons/math/optimization/BaseMultiStartMultivariateRealOptimizer.java\n     }\n \n     /** {@inheritDoc} */\n-    public void setConvergenceChecker(ConvergenceChecker<RealPointValuePair> checker) {\n-        optimizer.setConvergenceChecker(checker);\n-    }\n-\n-    /** {@inheritDoc} */\n     public ConvergenceChecker<RealPointValuePair> getConvergenceChecker() {\n         return optimizer.getConvergenceChecker();\n     }\n--- a/src/main/java/org/apache/commons/math/optimization/BaseMultiStartMultivariateVectorialOptimizer.java\n+++ b/src/main/java/org/apache/commons/math/optimization/BaseMultiStartMultivariateVectorialOptimizer.java\n     }\n \n     /** {@inheritDoc} */\n-    public void setConvergenceChecker(ConvergenceChecker<VectorialPointValuePair> checker) {\n-        optimizer.setConvergenceChecker(checker);\n-    }\n-\n-    /** {@inheritDoc} */\n     public ConvergenceChecker<VectorialPointValuePair> getConvergenceChecker() {\n         return optimizer.getConvergenceChecker();\n     }\n--- a/src/main/java/org/apache/commons/math/optimization/BaseOptimizer.java\n+++ b/src/main/java/org/apache/commons/math/optimization/BaseOptimizer.java\n     int getEvaluations();\n \n     /**\n-     * Set the convergence checker.\n-     *\n-     * @param checker Object to use to check for convergence.\n-     */\n-    void setConvergenceChecker(ConvergenceChecker<PAIR> checker);\n-\n-    /**\n      * Get the convergence checker.\n      *\n      * @return the object used to check for convergence.\n--- a/src/main/java/org/apache/commons/math/optimization/direct/BaseAbstractScalarOptimizer.java\n+++ b/src/main/java/org/apache/commons/math/optimization/direct/BaseAbstractScalarOptimizer.java\n     }\n \n     /** {@inheritDoc} */\n-    public void setConvergenceChecker(ConvergenceChecker<RealPointValuePair> convergenceChecker) {\n-        this.checker = convergenceChecker;\n-    }\n-\n-    /** {@inheritDoc} */\n     public ConvergenceChecker<RealPointValuePair> getConvergenceChecker() {\n         return checker;\n     }\n--- a/src/main/java/org/apache/commons/math/optimization/direct/BaseAbstractVectorialOptimizer.java\n+++ b/src/main/java/org/apache/commons/math/optimization/direct/BaseAbstractVectorialOptimizer.java\n     /** {@inheritDoc} */\n     public int getEvaluations() {\n         return evaluations.getCount();\n-    }\n-\n-    /** {@inheritDoc} */\n-    public void setConvergenceChecker(ConvergenceChecker<VectorialPointValuePair> convergenceChecker) {\n-        this.checker = convergenceChecker;\n     }\n \n     /** {@inheritDoc} */\n--- a/src/main/java/org/apache/commons/math/optimization/univariate/AbstractUnivariateRealOptimizer.java\n+++ b/src/main/java/org/apache/commons/math/optimization/univariate/AbstractUnivariateRealOptimizer.java\n public abstract class AbstractUnivariateRealOptimizer\n     implements UnivariateRealOptimizer {\n     /** Convergence checker. */\n-    private ConvergenceChecker<UnivariateRealPointValuePair> checker;\n+    private final ConvergenceChecker<UnivariateRealPointValuePair> checker;\n     /** Evaluations counter. */\n     private final Incrementor evaluations = new Incrementor();\n     /** Optimization type */\n     private double searchStart;\n     /** Function to optimize. */\n     private UnivariateRealFunction function;\n+\n+    /**\n+     * @param checker Convergence checking procedure.\n+     */\n+    protected AbstractUnivariateRealOptimizer(ConvergenceChecker<UnivariateRealPointValuePair> checker) {\n+        this.checker = checker;\n+    }\n \n     /** {@inheritDoc} */\n     public int getMaxEvaluations() {\n     /**\n      * {@inheritDoc}\n      */\n-    public void setConvergenceChecker(ConvergenceChecker<UnivariateRealPointValuePair> c) {\n-        checker = c;\n-    }\n-\n-    /**\n-     * {@inheritDoc}\n-     */\n     public ConvergenceChecker<UnivariateRealPointValuePair> getConvergenceChecker() {\n         return checker;\n     }\n--- a/src/main/java/org/apache/commons/math/optimization/univariate/BrentOptimizer.java\n+++ b/src/main/java/org/apache/commons/math/optimization/univariate/BrentOptimizer.java\n  * If the function is defined on some interval {@code (lo, hi)}, then\n  * this method finds an approximation {@code x} to the point at which\n  * the function attains its minimum.\n- * <br/>\n- * The user is responsible for calling {@link\n- * #setConvergenceChecker(ConvergenceChecker) ConvergenceChecker}\n- * prior to using the optimizer.\n  *\n  * @version $Id$\n  * @since 2.0\n      * Absolute threshold.\n      */\n     private final double absoluteThreshold;\n+\n+    /**\n+     * The arguments are used implement the original stopping criterion\n+     * of Brent's algorithm.\n+     * {@code abs} and {@code rel} define a tolerance\n+     * {@code tol = rel |x| + abs}. {@code rel} should be no smaller than\n+     * <em>2 macheps</em> and preferably not much less than <em>sqrt(macheps)</em>,\n+     * where <em>macheps</em> is the relative machine precision. {@code abs} must\n+     * be positive.\n+     *\n+     * @param rel Relative threshold.\n+     * @param abs Absolute threshold.\n+     * @param checker Additional, user-defined, convergence checking\n+     * procedure.\n+     * @throws NotStrictlyPositiveException if {@code abs <= 0}.\n+     * @throws NumberIsTooSmallException if {@code rel < 2 * Math.ulp(1d)}.\n+     */\n+    public BrentOptimizer(double rel,\n+                          double abs,\n+                          ConvergenceChecker<UnivariateRealPointValuePair> checker) {\n+        super(checker);\n+\n+        if (rel < MIN_RELATIVE_TOLERANCE) {\n+            throw new NumberIsTooSmallException(rel, MIN_RELATIVE_TOLERANCE, true);\n+        }\n+        if (abs <= 0) {\n+            throw new NotStrictlyPositiveException(abs);\n+        }\n+        relativeThreshold = rel;\n+        absoluteThreshold = abs;\n+    }\n \n     /**\n      * The arguments are used implement the original stopping criterion\n      */\n     public BrentOptimizer(double rel,\n                           double abs) {\n-        if (rel < MIN_RELATIVE_TOLERANCE) {\n-            throw new NumberIsTooSmallException(rel, MIN_RELATIVE_TOLERANCE, true);\n-        }\n-        if (abs <= 0) {\n-            throw new NotStrictlyPositiveException(abs);\n-        }\n-        relativeThreshold = rel;\n-        absoluteThreshold = abs;\n+        this(rel, abs, null);\n     }\n \n     /** {@inheritDoc} */\n--- a/src/main/java/org/apache/commons/math/optimization/univariate/MultiStartUnivariateRealOptimizer.java\n+++ b/src/main/java/org/apache/commons/math/optimization/univariate/MultiStartUnivariateRealOptimizer.java\n         this.optimizer = optimizer;\n         this.starts = starts;\n         this.generator = generator;\n-    }\n-\n-    /**\n-     * {@inheritDoc}\n-     */\n-    public void setConvergenceChecker(ConvergenceChecker<UnivariateRealPointValuePair> checker) {\n-        optimizer.setConvergenceChecker(checker);\n     }\n \n     /**\n--- a/src/test/java/org/apache/commons/math/optimization/MultiStartDifferentiableMultivariateRealOptimizerTest.java\n+++ b/src/test/java/org/apache/commons/math/optimization/MultiStartDifferentiableMultivariateRealOptimizerTest.java\n         circle.addPoint( 35.0,  15.0);\n         circle.addPoint( 45.0,  97.0);\n         NonLinearConjugateGradientOptimizer underlying =\n-            new NonLinearConjugateGradientOptimizer(ConjugateGradientFormula.POLAK_RIBIERE);\n+            new NonLinearConjugateGradientOptimizer(ConjugateGradientFormula.POLAK_RIBIERE,\n+                                                    new SimpleScalarValueChecker(1.0e-10, 1.0e-10));\n         JDKRandomGenerator g = new JDKRandomGenerator();\n         g.setSeed(753289573253l);\n         RandomVectorGenerator generator =\n                                                   new GaussianRandomGenerator(g));\n         MultiStartDifferentiableMultivariateRealOptimizer optimizer =\n             new MultiStartDifferentiableMultivariateRealOptimizer(underlying, 10, generator);\n-        optimizer.setConvergenceChecker(new SimpleScalarValueChecker(1.0e-10, 1.0e-10));\n         RealPointValuePair optimum =\n             optimizer.optimize(200, circle, GoalType.MINIMIZE, new double[] { 98.680, 47.345 });\n         Assert.assertEquals(200, optimizer.getMaxEvaluations());\n--- a/src/test/java/org/apache/commons/math/optimization/MultiStartDifferentiableMultivariateVectorialOptimizerTest.java\n+++ b/src/test/java/org/apache/commons/math/optimization/MultiStartDifferentiableMultivariateVectorialOptimizerTest.java\n         LinearProblem problem =\n             new LinearProblem(new double[][] { { 2 } }, new double[] { 3 });\n         DifferentiableMultivariateVectorialOptimizer underlyingOptimizer =\n-            new GaussNewtonOptimizer(true);\n+            new GaussNewtonOptimizer(true,\n+                                     new SimpleVectorialValueChecker(1.0e-6, 1.0e-6));\n         JDKRandomGenerator g = new JDKRandomGenerator();\n         g.setSeed(16069223052l);\n         RandomVectorGenerator generator =\n         MultiStartDifferentiableMultivariateVectorialOptimizer optimizer =\n             new MultiStartDifferentiableMultivariateVectorialOptimizer(underlyingOptimizer,\n                                                                        10, generator);\n-        optimizer.setConvergenceChecker(new SimpleVectorialValueChecker(1.0e-6, 1.0e-6));\n \n         // no optima before first optimization attempt\n         try {\n         Assert.assertEquals(100, optimizer.getMaxEvaluations());\n     }\n \n-    @Test(expected = TestException.class)\n+    @Test(expected=TestException.class)\n     public void testNoOptimum() {\n         DifferentiableMultivariateVectorialOptimizer underlyingOptimizer =\n-            new GaussNewtonOptimizer(true);\n+            new GaussNewtonOptimizer(true,\n+                                     new SimpleVectorialValueChecker(1.0e-6, 1.0e-6));\n         JDKRandomGenerator g = new JDKRandomGenerator();\n         g.setSeed(12373523445l);\n         RandomVectorGenerator generator =\n         MultiStartDifferentiableMultivariateVectorialOptimizer optimizer =\n             new MultiStartDifferentiableMultivariateVectorialOptimizer(underlyingOptimizer,\n                                                                        10, generator);\n-        optimizer.setConvergenceChecker(new SimpleVectorialValueChecker(1.0e-6, 1.0e-6));\n         optimizer.optimize(100, new DifferentiableMultivariateVectorialFunction() {\n                 public MultivariateMatrixFunction jacobian() {\n                     return null;\n--- a/src/test/java/org/apache/commons/math/optimization/MultiStartMultivariateRealOptimizerTest.java\n+++ b/src/test/java/org/apache/commons/math/optimization/MultiStartMultivariateRealOptimizerTest.java\n     @Test\n     public void testRosenbrock() {\n         Rosenbrock rosenbrock = new Rosenbrock();\n-        SimplexOptimizer underlying = new SimplexOptimizer();\n+        SimplexOptimizer underlying\n+            = new SimplexOptimizer(new SimpleScalarValueChecker(-1, 1.0e-3));\n         NelderMeadSimplex simplex = new NelderMeadSimplex(new double[][] {\n                 { -1.2,  1.0 }, { 0.9, 1.2 } , {  3.5, -2.3 }\n             });\n             new UncorrelatedRandomVectorGenerator(2, new GaussianRandomGenerator(g));\n         MultiStartMultivariateRealOptimizer optimizer =\n             new MultiStartMultivariateRealOptimizer(underlying, 10, generator);\n-        optimizer.setConvergenceChecker(new SimpleScalarValueChecker(-1, 1.0e-3));\n         RealPointValuePair optimum =\n             optimizer.optimize(1100, rosenbrock, GoalType.MINIMIZE, new double[] { -1.2, 1.0 });\n \n--- a/src/test/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizerTest.java\n+++ b/src/test/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizerTest.java\n         for (int i = 0; i < points.length; ++i) {\n             circle.addPoint(points[i][0], points[i][1]);\n         }\n-        LevenbergMarquardtOptimizer optimizer = new LevenbergMarquardtOptimizer();\n-        optimizer.setConvergenceChecker(new SimpleVectorialValueChecker(1.0e-8, 1.0e-8));\n+        LevenbergMarquardtOptimizer optimizer\n+            = new LevenbergMarquardtOptimizer(new SimpleVectorialValueChecker(1.0e-8, 1.0e-8));\n         VectorialPointValuePair optimum =\n             optimizer.optimize(100, circle, target, weights, new double[] { -12, -12 });\n         Point2D.Double center = new Point2D.Double(optimum.getPointRef()[0], optimum.getPointRef()[1]);", "timestamp": 1319722448, "metainfo": ""}