{"sha": "d50a175c5cfdea409519f1dd4662eee59f3340c8", "log": "In package o.a.c.m.transform, created enum DstNormalization to be passed to the constructor of FastSineTransformer (instead of boolean parameter). Made constructor public, and removed factory methods. See MATH-743  ", "commit": "\n--- a/src/main/java/org/apache/commons/math/transform/DctNormalization.java\n+++ b/src/main/java/org/apache/commons/math/transform/DctNormalization.java\n  * normalizations is detailed below.\n  *\n  * @see FastCosineTransformer\n- * @version $Id Revision$\n+ * @version $Id$\n  * @since 3.0\n  */\n public enum DctNormalization {\n--- a/src/main/java/org/apache/commons/math/transform/DftNormalization.java\n+++ b/src/main/java/org/apache/commons/math/transform/DftNormalization.java\n  * normalizations is detailed below.\n  *\n  * @see FastFourierTransformer\n- * @version $Id Revision$\n+ * @version $Id$\n  * @since 3.0\n  */\n public enum DftNormalization {\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/transform/DstNormalization.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.transform;\n+\n+/**\n+ * This enumeration defines the various types of normalizations that can be\n+ * applied to discrete sine transforms (DST). The exact definition of these\n+ * normalizations is detailed below.\n+ *\n+ * @see FastSineTransformer\n+ * @version $Id$\n+ * @since 3.0\n+ */\n+public enum DstNormalization {\n+    /**\n+     * <p>\n+     * Should be passed to the constructor of {@link FastSineTransformer} to\n+     * use the <em>standard</em> normalization convention. The standard DST-I\n+     * normalization convention is defined as follows\n+     * <ul>\n+     * <li>forward transform: y<sub>n</sub> = &sum;<sub>k=0</sub><sup>N-1</sup>\n+     * x<sub>k</sub> sin(&pi; nk / N),</li>\n+     * <li>inverse transform: x<sub>k</sub> = (2 / N)\n+     * &sum;<sub>n=0</sub><sup>N-1</sup> y<sub>n</sub> sin(&pi; nk / N),</li>\n+     * </ul>\n+     * where N is the size of the data sample, and x<sub>0</sub> = 0.\n+     * </p>\n+     */\n+    STANDARD_DST_I,\n+\n+    /**\n+     * <p>\n+     * Should be passed to the constructor of {@link FastSineTransformer} to\n+     * use the <em>orthogonal</em> normalization convention. The orthogonal\n+     * DCT-I normalization convention is defined as follows\n+     * <ul>\n+     * <li>Forward transform: y<sub>n</sub> = &radic;(2 / N)\n+     * &sum;<sub>k=0</sub><sup>N-1</sup> x<sub>k</sub> sin(&pi; nk / N),</li>\n+     * <li>Inverse transform: x<sub>k</sub> = &radic;(2 / N)\n+     * &sum;<sub>n=0</sub><sup>N-1</sup> y<sub>n</sub> sin(&pi; nk / N),</li>\n+     * </ul>\n+     * which makes the transform orthogonal. N is the size of the data sample,\n+     * and x<sub>0</sub> = 0.\n+     * </p>\n+     */\n+    ORTHOGONAL_DST_I\n+}\n--- a/src/main/java/org/apache/commons/math/transform/FastSineTransformer.java\n+++ b/src/main/java/org/apache/commons/math/transform/FastSineTransformer.java\n  * <p>\n  * There are several variants of the discrete sine transform. The present\n  * implementation corresponds to DST-I, with various normalization conventions,\n- * which are described below. <strong>It should be noted that regardless to the\n- * convention, the first element of the dataset to be transformed must be\n- * zero.</strong>\n+ * which are specified by the parameter {@link DstNormalization}.\n+ * <strong>It should be noted that regardless to the convention, the first\n+ * element of the dataset to be transformed must be zero.</strong>\n  * </p>\n- * <h3><a id=\"standard\">Standard DST-I</a></h3>\n- * <p>\n- * The standard normalization convention is defined as follows\n- * <ul>\n- * <li>forward transform: y<sub>n</sub> = &sum;<sub>k=0</sub><sup>N-1</sup>\n- * x<sub>k</sub> sin(&pi; nk / N),</li>\n- * <li>inverse transform: x<sub>k</sub> = (2 / N)\n- * &sum;<sub>n=0</sub><sup>N-1</sup> y<sub>n</sub> sin(&pi; nk / N),</li>\n- * </ul>\n- * where N is the size of the data sample, and x<sub>0</sub> = 0.\n- * </p>\n- * <p>\n- * {@link RealTransformer}s following this convention are returned by the\n- * factory method {@link #create()}.\n- * </p>\n- * <h3><a id=\"orthogonal\">Orthogonal DST-I</a></h3>\n- * <p>\n- * The orthogonal normalization convention is defined as follows\n- * <ul>\n- * <li>Forward transform: y<sub>n</sub> = &radic;(2 / N)\n- * &sum;<sub>k=0</sub><sup>N-1</sup> x<sub>k</sub> sin(&pi; nk / N),</li>\n- * <li>Inverse transform: x<sub>k</sub> = &radic;(2 / N)\n- * &sum;<sub>n=0</sub><sup>N-1</sup> y<sub>n</sub> sin(&pi; nk / N),</li>\n- * </ul>\n- * which makes the transform orthogonal. N is the size of the data sample, and\n- * x<sub>0</sub> = 0.\n- * </p>\n- * <p>\n- * {@link RealTransformer}s following this convention are returned by the\n- * factory method {@link #createOrthogonal()}.\n- * </p>\n- * <h3>Link with the DFT, and assumptions on the layout of the data set</h3>\n  * <p>\n  * DST-I is equivalent to DFT of an <em>odd extension</em> of the data series.\n  * More precisely, if x<sub>0</sub>, &hellip;, x<sub>N-1</sub> is the data set\n  * sampling.\n  * </p>\n  *\n- * @version $Id: FastSineTransformer.java 1213157 2011-12-12 07:19:23Z celestin$\n+ * @version $Id$\n  * @since 1.2\n  */\n public class FastSineTransformer implements RealTransformer, Serializable {\n     /** Serializable version identifier. */\n     static final long serialVersionUID = 20120211L;\n \n-    /**\n-     * {@code true} if the orthogonal version of the DCT should be used.\n-     *\n-     * @see #create()\n-     * @see #createOrthogonal()\n-     */\n-    private final boolean orthogonal;\n+    /** The type of DST to be performed. */\n+    private final DstNormalization normalization;\n \n     /**\n      * Creates a new instance of this class, with various normalization\n      * conventions.\n      *\n-     * @param orthogonal {@code false} if the DST is <em>not</em> to be scaled,\n-     * {@code true} if it is to be scaled so as to make the transform\n-     * orthogonal.\n-     * @see #create()\n-     * @see #createOrthogonal()\n+     * @param normalization the type of normalization to be applied to the\n+     * transformed data\n      */\n-    private FastSineTransformer(final boolean orthogonal) {\n-        this.orthogonal = orthogonal;\n-    }\n-\n-    /**\n-     * <p>\n-     * Returns a new instance of this class. The returned transformer uses the\n-     * <a href=\"#standard\">standard normalizing conventions</a>.\n-     * </p>\n-     *\n-     * @return a new DST transformer, with standard normalizing conventions\n-     */\n-    public static FastSineTransformer create() {\n-        return new FastSineTransformer(false);\n-    }\n-\n-    /**\n-     * <p>\n-     * Returns a new instance of this class. The returned transformer uses the\n-     * <a href=\"#orthogonal\">orthogonal normalizing conventions</a>.\n-     * </p>\n-     *\n-     * @return a new DST transformer, with orthogonal normalizing conventions\n-     */\n-    public static FastSineTransformer createOrthogonal() {\n-        return new FastSineTransformer(true);\n+    public FastSineTransformer(final DstNormalization normalization) {\n+        this.normalization = normalization;\n     }\n \n     /**\n      * not a power of two, or the first element of the data array is not zero\n      */\n     public double[] transform(final double[] f, final TransformType type) {\n-        if (orthogonal) {\n+        if (normalization == DstNormalization.ORTHOGONAL_DST_I) {\n             final double s = FastMath.sqrt(2.0 / f.length);\n             return TransformUtils.scaleArray(fst(f), s);\n         }", "timestamp": 1329150946, "metainfo": ""}