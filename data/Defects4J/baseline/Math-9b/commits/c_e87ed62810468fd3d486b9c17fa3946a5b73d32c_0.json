{"sha": "e87ed62810468fd3d486b9c17fa3946a5b73d32c", "log": "revamped Jacobians computation in ODE  ", "commit": "\n--- a/src/main/java/org/apache/commons/math/exception/util/LocalizedFormats.java\n+++ b/src/main/java/org/apache/commons/math/exception/util/LocalizedFormats.java\n     UNABLE_TO_SOLVE_SINGULAR_PROBLEM(\"unable to solve: singular problem\"),\n     UNBOUNDED_SOLUTION(\"unbounded solution\"),\n     UNKNOWN_MODE(\"unknown mode {0}, known modes: {1} ({2}), {3} ({4}), {5} ({6}), {7} ({8}), {9} ({10}) and {11} ({12})\"),\n+    UNKNOWN_ADDITIONAL_EQUATION(\"unknown additional equation\"),\n+    UNKNOWN_PARAMETER(\"unknown parameter {0}\"),\n+    UNMATCHED_ODE_IN_EXTENDED_SET(\"ode does not match the main ode set in the extended set\"),\n     CANNOT_PARSE_AS_TYPE(\"string {0} unparseable (from position {1}) as an object of type {2}\"), /* keep */\n     CANNOT_PARSE(\"string {0} unparseable (from position {1})\"), /* keep */\n     UNPARSEABLE_3D_VECTOR(\"unparseable 3D vector: \\\"{0}\\\"\"),\n--- a/src/main/java/org/apache/commons/math/ode/AbstractIntegrator.java\n+++ b/src/main/java/org/apache/commons/math/ode/AbstractIntegrator.java\n import org.apache.commons.math.analysis.solvers.BracketingNthOrderBrentSolver;\n import org.apache.commons.math.analysis.solvers.UnivariateRealSolver;\n import org.apache.commons.math.exception.DimensionMismatchException;\n+import org.apache.commons.math.exception.MathIllegalArgumentException;\n import org.apache.commons.math.exception.MathIllegalStateException;\n import org.apache.commons.math.exception.MaxCountExceededException;\n import org.apache.commons.math.exception.NumberIsTooSmallException;\n  * @version $Id$\n  * @since 2.0\n  */\n-public abstract class AbstractIntegrator implements FirstOrderIntegrator {\n+public abstract class AbstractIntegrator implements ExpandableFirstOrderIntegrator {\n \n     /** Step handler. */\n     protected Collection<StepHandler> stepHandlers;\n     private Incrementor evaluations;\n \n     /** Differential equations to integrate. */\n-    private transient FirstOrderDifferentialEquations equations;\n+    private transient ExpandableFirstOrderDifferentialEquations equations;\n \n     /** Build an instance.\n      * @param name name of the method\n      * @param equations differential equations to integrate\n      * @see #computeDerivatives(double, double[], double[])\n      */\n-    protected void setEquations(final FirstOrderDifferentialEquations equations) {\n+    protected void setEquations(final ExpandableFirstOrderDifferentialEquations equations) {\n         this.equations = equations;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public double integrate(FirstOrderDifferentialEquations equations,\n+                            double t0, double[] y0, double t, double[] y)\n+        throws MathIllegalStateException, MathIllegalArgumentException {\n+        return integrate(new ExpandableFirstOrderDifferentialEquations(equations), t0, y0, t, y);\n     }\n \n     /** Compute the derivatives and check the number of evaluations.\n      * @exception DimensionMismatchException if some inconsistency is detected\n      * @exception NumberIsTooSmallException if integration span is too small\n      */\n-    protected void sanityChecks(final FirstOrderDifferentialEquations ode,\n+    protected void sanityChecks(final ExpandableFirstOrderDifferentialEquations ode,\n                                 final double t0, final double[] y0,\n                                 final double t, final double[] y)\n         throws DimensionMismatchException, NumberIsTooSmallException {\n \n-        if (ode.getDimension() != y0.length) {\n+        if (ode.getMainSetDimension() != y0.length) {\n             throw new DimensionMismatchException(ode.getDimension(), y0.length);\n         }\n \n-        if (ode.getDimension() != y.length) {\n+        if (ode.getMainSetDimension() != y.length) {\n             throw new DimensionMismatchException(ode.getDimension(), y.length);\n         }\n \n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/ode/AbstractParameterizable.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.ode;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+\n+import org.apache.commons.math.exception.MathIllegalArgumentException;\n+import org.apache.commons.math.exception.util.LocalizedFormats;\n+\n+/** This abstract class provides boilerplate parameters list.\n+ *\n+ * @version $Id$\n+ * @since 3.0\n+ */\n+\n+public abstract class AbstractParameterizable implements Parameterizable {\n+\n+   /** List of the parameters names. */\n+    private final Collection<String> parametersNames;\n+\n+    /** Simple constructor.\n+     * @param names names of the supported parameters\n+     */\n+    protected AbstractParameterizable(final String ... names) {\n+        parametersNames = new ArrayList<String>();\n+        for (final String name : names) {\n+            parametersNames.add(name);\n+        }\n+    }\n+\n+    /** Simple constructor.\n+     * @param names names of the supported parameters\n+     */\n+    protected AbstractParameterizable(final Collection<String> names) {\n+        parametersNames = new ArrayList<String>();\n+        parametersNames.addAll(names);\n+    }\n+\n+    /** {@inheritDoc} */\n+    public Collection<String> getParametersNames() {\n+        return parametersNames;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public boolean isSupported(final String name) {\n+        for (final String supportedName : parametersNames) {\n+            if (supportedName.equals(name)) {\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    /** Check if a parameter is supported and throw an IllegalArgumentException if not.\n+     * @param name name of the parameter to check\n+     * @exception MathIllegalArgumentException if the parameter is not supported\n+     * @see #isSupported(String)\n+     */\n+    public void complainIfNotSupported(final String name)\n+        throws MathIllegalArgumentException {\n+        if (!isSupported(name)) {\n+            throw new MathIllegalArgumentException(LocalizedFormats.UNKNOWN_PARAMETER, name);\n+        }\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/ode/AdditionalEquations.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.ode;\n+\n+/**\n+ * This interface allows users to add their own differential equations to a main\n+ * set of differential equations.\n+ * <p>\n+ * In some cases users may need to integrate some problem-specific equations along\n+ * with a main set of differential equations. One example is optimal control where\n+ * adjoined parameters linked to the minimized hamiltonian must be integrated.\n+ * </p>\n+ * <p>\n+ * This interface allows users to add such equations to a main set of {@link\n+ * FirstOrderDifferentialEquations first order differential equations}\n+ * thanks to the {@link\n+ * ExpandableFirstOrderDifferentialEquations#addAdditionalEquations(AdditionalEquations)}\n+ * method.\n+ * </p>\n+ * @see ExpandableFirstOrderDifferentialEquations\n+ * @version $Id$\n+ * @since 3.0\n+ */\n+public interface AdditionalEquations {\n+\n+    /** Get the dimension of the additional state parameters.\n+     * @return dimension of the additional state parameters\n+     */\n+    int getDimension();\n+\n+    /** Compute the derivatives related to the additional state parameters.\n+     * @param t current value of the independent <I>time</I> variable\n+     * @param y array containing the current value of the main state vector\n+     * @param yDot array containing the derivative of the main state vector\n+     * @param z array containing the current value of the additional state vector\n+     * @param zDot placeholder array where to put the derivative of the additional state vector\n+     */\n+    void computeDerivatives(double t, double[] y, double[] yDot, double[] z, double[] zDot);\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/ode/AdditionalStateAndEquations.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.ode;\n+\n+\n+/**\n+ * This class is a container for additional state parameters and their associated\n+ * evolution equation.\n+ * <p>\n+ * It is a container allowing the integrator to keep constant consistency between\n+ * additional states and the corresponding equations. It allows to set additional\n+ * state values, get current additional state value and derivatives by reference\n+ * on the associated additional equations.\n+ * </p>\n+ *\n+ * @see ExpandableFirstOrderDifferentialEquations\n+ * @see AdditionalEquations\n+ *\n+ * @version $Id$\n+ * @since 3.0\n+ */\n+class AdditionalStateAndEquations {\n+\n+    /** Additional equations set. */\n+    private final AdditionalEquations addEquations;\n+\n+    /** Current additional state. */\n+    private double[] addState;\n+\n+    /** Current additional state derivatives. */\n+    private double[] addStateDot;\n+\n+    /** Create a new instance based on one set of additional equations.\n+     * @param addEqu additional equations.\n+     */\n+    public AdditionalStateAndEquations(final AdditionalEquations addEqu) {\n+        this.addEquations = addEqu;\n+    }\n+\n+    /** Get a reference to the current value of the additional state.\n+     * <p>The array returned is a true reference to the state array, so it may be\n+     * used to store data into it.</>\n+     * @return a reference current value of the additional state.\n+     */\n+    public double[] getAdditionalState() {\n+        return addState;\n+    }\n+\n+    /** Get a reference to the current value of the additional state derivatives.\n+     * <p>The array returned is a true reference to the state array, so it may be\n+     * used to store data into it.</>\n+     * @return a reference current value of the additional state derivatives.\n+     */\n+    public double[] getAdditionalStateDot() {\n+        return addStateDot;\n+    }\n+\n+    /** Get the instance of the current additional equations.\n+     * @return current value of the additional equations.\n+     */\n+    public AdditionalEquations getAdditionalEquations() {\n+        return addEquations;\n+    }\n+\n+    /** Set a value to additional state.\n+     * @param state additional state value.\n+     */\n+    public void setAdditionalState(final double[] state) {\n+        this.addState    = state.clone();\n+        this.addStateDot = new double[state.length];\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/ode/ExpandableFirstOrderDifferentialEquations.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.ode;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import org.apache.commons.math.exception.MathIllegalArgumentException;\n+import org.apache.commons.math.exception.util.LocalizedFormats;\n+\n+\n+/**\n+ * This class represents a combined set of first order differential equations,\n+ * with at least a main set of equations expandable by some sets of additional\n+ * equations.\n+ * <p>\n+ * This class extends the {@link FirstOrderDifferentialEquations}. It allows to\n+ * identify which part of a complete set of differential equations correspond to\n+ * the main set and which part correspond to the expansion sets.\n+ * </p>\n+ * <p>\n+ * One typical use case is the computation of the jacobian matrix for some ODE.\n+ * The main set of equations corresponds to the raw ODE, and we add to this set\n+ * another bunch of equations which represent the jacobian matrix of the main\n+ * set. In that case, we want the integrator to use <em>only</em> the main set\n+ * to estimate the errors and hence the step sizes. It should <em>not</em> use\n+ * the additional equations in this computation.\n+ * The {@link ExpandableFirstOrderIntegrator integrator} will be able to know\n+ * where the main set ends and so where the expansion sets begin.\n+ * </p>\n+ * <p>\n+ * We consider that the main set always corresponds to the first equations and\n+ * the expansion sets to the last equations.\n+ * </p>\n+ *\n+ * @see FirstOrderDifferentialEquations\n+ * @see JacobianMatrices\n+ *\n+ * @version $Id$\n+ * @since 3.0\n+ */\n+\n+public class ExpandableFirstOrderDifferentialEquations implements FirstOrderDifferentialEquations {\n+\n+    /** Main set of differential equations. */\n+    private final FirstOrderDifferentialEquations mainSet;\n+\n+    /** Additional sets of equations and associated states. */\n+    private final List<AdditionalStateAndEquations> addedSets;\n+\n+    /** Create a new instance of ExpandableFirstOrderDifferentialEquations.\n+     * @param fode the main set of differential equations to be integrated.\n+     */\n+    public ExpandableFirstOrderDifferentialEquations(final FirstOrderDifferentialEquations fode) {\n+        this.mainSet   = fode;\n+        this.addedSets = new ArrayList<AdditionalStateAndEquations>();\n+    }\n+\n+    /** Return the dimension of the whole state vector.\n+     * <p>\n+     * The whole state vector results in the assembly of the main set of\n+     * equations and, if there are some, the added sets of equations.\n+     * </p>\n+     * @return dimension of the whole state vector\n+     */\n+    public int getDimension()\n+        throws MathIllegalArgumentException {\n+        int dimension = this.getMainSetDimension();\n+        try {\n+            for (AdditionalStateAndEquations stateAndEqu : addedSets) {\n+                dimension += stateAndEqu.getAdditionalEquations().getDimension();\n+            }\n+            return dimension;\n+        } catch (Exception e) {\n+            // TODO we should not catch Exception, and we should identify the offending additional equation\n+            throw new MathIllegalArgumentException(LocalizedFormats.UNKNOWN_ADDITIONAL_EQUATION);\n+        }\n+    }\n+\n+    /** Return the dimension of the main set of equations.\n+     * <p>\n+     * The main set of equations represents the first part of an ODE state.\n+     * The error estimations and adaptive step size computation should be\n+     * done on this first part only, not on the final part of the state\n+     * which represents expansion sets of equations considered as secondary.\n+     * </p>\n+     * @return dimension of the main set of equations, must be lesser than or\n+     * equal to the {@link #getDimension() total dimension}\n+     */\n+    public int getMainSetDimension() {\n+        return mainSet.getDimension();\n+    }\n+\n+    /** Return the cumulated dimension of all added sets of equations.\n+     * @return dimension of all added sets of equations\n+     * @throws IllegalArgumentException if some additional equation is unknown\n+     */\n+    public int getAddedSetsDimension()\n+        throws IllegalArgumentException {\n+        int addDim = 0;\n+        try {\n+            for (AdditionalStateAndEquations stateAndEqu : addedSets) {\n+                addDim += stateAndEqu.getAdditionalEquations().getDimension();\n+            }\n+            return addDim;\n+        } catch (Exception e) {\n+            // TODO we should not catch Exception, and we should identify the offending additional equation\n+            throw new MathIllegalArgumentException(LocalizedFormats.UNKNOWN_ADDITIONAL_EQUATION);\n+        }\n+    }\n+\n+    /** Return the dimension of one added set of equations.\n+     * @param  addEqu Additional equations used as a reference for selection\n+     * @return dimension of the added set of equations\n+     * @throws IllegalArgumentException if additional equation is unknown\n+     */\n+    public int getAddedSetDimension(final AdditionalEquations addEqu) {\n+        return selectStateAndEquations(addEqu).getAdditionalEquations().getDimension();\n+    }\n+\n+    /** Get the current time derivative of the total state vector.\n+     * @param t current value of the independent <I>time</I> variable\n+     * @param y array containing the current value of the state vector\n+     * @param yDot placeholder array where to put the time derivative of the state vector\n+     */\n+    public void computeDerivatives(final double t, final double[] y, final double[] yDot) {\n+\n+        // Add contribution for the main set of equations\n+        int index = getMainSetDimension();\n+        double[] m = new double[index];\n+        double[] mDot = new double[index];\n+        // update current main state\n+        System.arraycopy(y, 0, m, 0, index);\n+      // compute derivatives\n+        mainSet.computeDerivatives(t, m, mDot);\n+        // update main state contribution in global array\n+        System.arraycopy(mDot, 0, yDot, 0, index);\n+\n+        // Add contribution for additional equations\n+        for (final AdditionalStateAndEquations stateAndEqu : addedSets) {\n+            final double[] p    = stateAndEqu.getAdditionalState();\n+            final double[] pDot = stateAndEqu.getAdditionalStateDot();\n+\n+            // update current additional state\n+            System.arraycopy(y, index, p, 0, p.length);\n+\n+            // compute additional derivatives\n+            stateAndEqu.getAdditionalEquations().computeDerivatives(t, m, mDot, p, pDot);\n+\n+            // update each additional state contribution in global array\n+            System.arraycopy(pDot, 0, yDot, index, p.length);\n+\n+            // incrementing index\n+            index += p.length;\n+        }\n+\n+    }\n+\n+    /** Add a set of user-specified equations to be integrated along with\n+     *  the main set of equations.\n+     *\n+     * @param addEqu additional equations\n+     * @see #setInitialAdditionalState(double[], AdditionalEquations)\n+     * @see #getCurrentAdditionalState(AdditionalEquations)\n+     */\n+    public void addAdditionalEquations(final AdditionalEquations addEqu) {\n+        addedSets.add(new AdditionalStateAndEquations(addEqu));\n+    }\n+\n+    /** Get the instance of the main set of equations.\n+     * @return current value of the main set of equations.\n+     */\n+    public FirstOrderDifferentialEquations getMainSet() {\n+        return mainSet;\n+    }\n+\n+    /** Set initial additional state.\n+     * @param addState additional state\n+     * @param addEqu additional equations used as a reference for selection\n+     * @throws IllegalArgumentException if additional equation is unknown\n+     */\n+    public void setInitialAdditionalState(final double[] addState, final AdditionalEquations addEqu) {\n+        selectStateAndEquations(addEqu).setAdditionalState(addState);\n+    }\n+\n+    /** Set current additional state.\n+     * <p>\n+     * The total current state computed by the integrator\n+     * is dispatched here to the various additional states.\n+     * </p>\n+     * @param currentState total current state\n+     * @throws IllegalArgumentException if additional equation is unknown\n+     */\n+    public void setCurrentAdditionalState(final double[] currentState)\n+    throws IllegalArgumentException {\n+        int index = getMainSetDimension();\n+        try {\n+            for (AdditionalStateAndEquations stateAndEqu : addedSets) {\n+                final int addDim = stateAndEqu.getAdditionalEquations().getDimension();\n+                final double[] addState = new double[addDim];\n+                System.arraycopy(currentState, index, addState, 0, addDim);\n+                stateAndEqu.setAdditionalState(addState);\n+                index += addDim;\n+            }\n+        } catch (Exception e) {\n+            // TODO we should not catch Exception, and we should identify the offending additional equation\n+            throw new MathIllegalArgumentException(LocalizedFormats.UNKNOWN_ADDITIONAL_EQUATION);\n+        }\n+    }\n+\n+    /** Get current additional state.\n+     * @param addEqu additional equations used as a reference for selection\n+     * @return current additional state\n+     * @throws IllegalArgumentException if additional equation is unknown\n+     */\n+    public double[] getCurrentAdditionalState(final AdditionalEquations addEqu) {\n+        return selectStateAndEquations(addEqu).getAdditionalState();\n+    }\n+\n+    /** Get all current additional states accumulated.\n+     * @return current additional states\n+     * @throws IllegalArgumentException if additional equation is unknown\n+     */\n+    public double[] getCurrentAdditionalStates()\n+        throws IllegalArgumentException {\n+        int index = 0;\n+        final double[] cumulState = new double[getAddedSetsDimension()];\n+        try {\n+            for (AdditionalStateAndEquations stateAndEqu : addedSets) {\n+                final int addDim = stateAndEqu.getAdditionalEquations().getDimension();\n+                final double[] addState = stateAndEqu.getAdditionalState();\n+                System.arraycopy(addState, 0, cumulState, index, addDim);\n+                index += addDim;\n+            }\n+            return cumulState;\n+        } catch (Exception e) {\n+            // TODO we should not catch Exception, and we should identify the offending additional equation\n+            throw new MathIllegalArgumentException(LocalizedFormats.UNKNOWN_ADDITIONAL_EQUATION);\n+        }\n+    }\n+\n+    /** Select additional state and equations pair in the list.\n+     * @param  addEqu Additional equations used as a reference for selection\n+     * @return additional state and equations pair\n+     * @throws IllegalArgumentException if additional equation is unknown\n+     */\n+    private AdditionalStateAndEquations selectStateAndEquations(final AdditionalEquations addEqu)\n+        throws IllegalArgumentException {\n+        for (AdditionalStateAndEquations stateAndEqu : addedSets) {\n+            if (stateAndEqu.getAdditionalEquations() == addEqu) {\n+                return stateAndEqu;\n+            }\n+        }\n+        // TODO we should not catch Exception, and we should identify the offending additional equation\n+        throw new MathIllegalArgumentException(LocalizedFormats.UNKNOWN_ADDITIONAL_EQUATION);\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/ode/ExpandableFirstOrderIntegrator.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.ode;\n+\n+import org.apache.commons.math.exception.MathIllegalArgumentException;\n+import org.apache.commons.math.exception.MathIllegalStateException;\n+\n+/**\n+ * This interface represents a first order integrator for expandable\n+ * differential equations.\n+ * <p>\n+ * The classes devoted to solve expandable first order differential equations\n+ * should implement this interface. The problems which can be handled should\n+ * implement the {@link ExpandableFirstOrderDifferentialEquations} interface.\n+ * </p>\n+ *\n+ * @see ExpandableFirstOrderDifferentialEquations\n+ *\n+ * @version $Id$\n+ * @since 3.0\n+ */\n+\n+public interface ExpandableFirstOrderIntegrator extends FirstOrderIntegrator {\n+\n+    /** Integrate a set of differential equations up to the given time.\n+     * <p>This method solves an Initial Value Problem (IVP).</p>\n+     * <p>The set of differential equations is composed of a main set, which\n+     * can be extended by some sets of additional equations.</p>\n+     * <p>Since this method stores some internal state variables made\n+     * available in its public interface during integration ({@link\n+     * #getCurrentSignedStepsize()}), it is <em>not</em> thread-safe.</p>\n+     * @param equations complete set of differential equations to integrate\n+     * @param t0 initial time\n+     * @param y0 initial value of the main state vector at t0\n+     * @param t target time for the integration\n+     * (can be set to a value smaller than <code>t0</code> for backward integration)\n+     * @param y placeholder where to put the main state vector at each successful\n+     *  step (and hence at the end of integration), can be the same object as y0\n+     * @return stop time, will be the same as target time if integration reached its\n+     * target, but may be different if some {@link\n+     * org.apache.commons.math.ode.events.EventHandler} stops it at some point.\n+     * @throws MathIllegalStateException if the integrator cannot perform integration\n+     * @throws MathIllegalArgumentException if integration parameters are wrong (typically\n+     * too small integration span)\n+     */\n+    double integrate(ExpandableFirstOrderDifferentialEquations equations,\n+                     double t0, double[] y0, double t, double[] y)\n+        throws MathIllegalStateException, MathIllegalArgumentException;\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/ode/JacobianMatrices.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.ode;\n+\n+import java.lang.reflect.Array;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import org.apache.commons.math.exception.DimensionMismatchException;\n+import org.apache.commons.math.exception.MathIllegalArgumentException;\n+import org.apache.commons.math.exception.util.LocalizedFormats;\n+\n+/**\n+ * This class defines a set of {@link AdditionalEquations additional equations} to\n+ * compute the jacobian matrices with respect to the initial state vector and, if\n+ * any, to some parameters of the main ODE set.\n+ * <p>\n+ * It is intended to be packed into an {@link ExpandableFirstOrderDifferentialEquations}\n+ * in conjunction with a main set of ODE, which may be:\n+ * <ul>\n+ * <li>a {@link FirstOrderDifferentialEquations}</li>\n+ * <li>a {@link MainStateJacobianProvider}</li>\n+ * </ul>\n+ * In order to compute jacobian matrices with respect to some parameters of the\n+ * main ODE set, the following parameter jacobian providers may be set:\n+ * <ul>\n+ * <li>a {@link ParameterJacobianProvider}</li>\n+ * <li>a {@link ParameterizedODE}</li>\n+ * </ul>\n+ * </p>\n+ *\n+ * @see ExpandableFirstOrderDifferentialEquations\n+ * @see FirstOrderDifferentialEquations\n+ * @see MainStateJacobianProvider\n+ * @see ParameterJacobianProvider\n+ * @see ParameterizedODE\n+ *\n+ * @version $Id$\n+ * @since 3.0\n+ */\n+public class JacobianMatrices implements AdditionalEquations {\n+\n+    /** Expandable first order differential equation. */\n+    private ExpandableFirstOrderDifferentialEquations efode;\n+\n+    /** FODE without exact main jacobian computation skill. */\n+    private FirstOrderDifferentialEquations fode = null;\n+\n+    /** FODE with exact main jacobian computation skill. */\n+    private MainStateJacobianProvider jode = null;\n+\n+    /** FODE without exact parameter jacobian computation skill. */\n+    private ParameterizedODE pode = null;\n+\n+    /** FODE with exact parameter jacobian computation skill. */\n+    private List<ParameterJacobianProvider> pjp = new ArrayList<ParameterJacobianProvider>();;\n+\n+    /** List of parameters selected for parameter jacobian computation. */\n+    private List<ParameterConfiguration> selectedParameters = null;\n+\n+    /** Main state vector dimension. */\n+    private int stateDim;\n+\n+    /** Parameters dimension. */\n+    private int paramDim = 0;\n+\n+    /** Current main state jacobian matrix in a row. */\n+    private double[] mainJacobianInARow;\n+\n+    /** Current parameters jacobian matrices in a row. */\n+    private double[] parameterJacobiansInARow = null;\n+\n+    /** Step used for finite difference computation of jacobian matrix\n+     *  w.r.t. main state vector. */\n+    private double[] hY = null;\n+\n+    /** Boolean for fode consistency. */\n+    private boolean dirtyMainState = false;\n+\n+    /** Boolean for selected parameters consistency. */\n+    private boolean dirtyParameter = false;\n+\n+    /** Simple constructor for an additional equations set computing jacobian matrices.\n+     * <p>This additional equations set is added internally to the expandable\n+     * first order differential equations set thanks to the\n+     * {@link ExpandableFirstOrderDifferentialEquations#addAdditionalEquations(AdditionalEquations)}\n+     * method.\n+     * @param extended the expandable first order differential equations set\n+     * @param jode the main first order differential equations set to extend\n+     * @exception IllegalArgumentException if jode does not match the main set to be extended given by\n+     *            {@link ExpandableFirstOrderDifferentialEquations#getMainSet() extended.getMainSet()}\n+     */\n+    public JacobianMatrices(final ExpandableFirstOrderDifferentialEquations extended,\n+                            final MainStateJacobianProvider jode)\n+        throws IllegalArgumentException {\n+\n+        checkCompatibility(extended, jode);\n+\n+        efode = extended;\n+        stateDim = efode.getMainSetDimension();\n+        mainJacobianInARow = new double[stateDim * stateDim];\n+        this.jode = jode;\n+        efode.addAdditionalEquations(this);\n+        setInitialMainStateJacobian();\n+    }\n+\n+    /** Simple constructor for an additional equations set computing jacobian matrices.\n+     * <p>This additional equations set is added internally to the expandable\n+     * first order differential equations set thanks to the\n+     * {@link ExpandableFirstOrderDifferentialEquations#addAdditionalEquations(AdditionalEquations)}\n+     * method.\n+     * @param extended the expandable first order differential equations set\n+     * @param fode the main first order differential equations set to extend\n+     * @exception IllegalArgumentException if fode does not match the main set to be extended given by\n+     *            {@link ExpandableFirstOrderDifferentialEquations#getMainSet() extended.getMainSet()}\n+     */\n+    public JacobianMatrices(final ExpandableFirstOrderDifferentialEquations extended,\n+                            final FirstOrderDifferentialEquations fode)\n+        throws IllegalArgumentException {\n+\n+        checkCompatibility(extended, fode);\n+\n+        efode = extended;\n+        stateDim = efode.getMainSetDimension();\n+        mainJacobianInARow = new double[stateDim * stateDim];\n+        this.fode = fode;\n+        dirtyMainState = true;\n+        efode.addAdditionalEquations(this);\n+        setInitialMainStateJacobian();\n+    }\n+\n+    /** Add a parameter jacobian provider.\n+     * @param pjp the parameter jacobian provider to compute exactly the parameter jacobian matrix\n+     */\n+    public void setParameterJacobianProvider(final ParameterJacobianProvider pjp) {\n+        this.pjp.add(pjp);\n+    }\n+\n+    /** Add a parameter jacobian provider.\n+     * @param pjp the parameterized ODE to compute by finite difference the parameter jacobian matrix\n+     */\n+    public void setParameterizedODE(final ParameterizedODE pode) {\n+        this.pode = pode;\n+        dirtyParameter = true;\n+    }\n+\n+    /** Select the parameters to consider for jacobian matrices processing.\n+     * <p>\n+     * Parameters must belong to the supported ones given by {@link\n+     * Parameterizable#getParametersNames()}, so the main set of differential\n+     * equations must be {@link Parameterizable}.\n+     * </p>\n+     * <p>Note that each selection clears the previous selected parameters.</p>\n+     *\n+     * @param parameters parameters to consider for jacobian matrices processing\n+     * @exception IllegalArgumentException if one parameter is not supported\n+     */\n+    public void selectParameters(final String... parameters) throws IllegalArgumentException {\n+        \n+        selectedParameters = new ArrayList<ParameterConfiguration>();\n+        for (String param : parameters) {\n+            selectedParameters.add(new ParameterConfiguration(param, Double.NaN));\n+        }\n+        paramDim = parameters.length;\n+        parameterJacobiansInARow = new double[paramDim * stateDim];\n+        setInitialParameterJacobians();\n+    }\n+\n+    /** Set the step associated to a parameter in order to compute by finite\n+     *  difference the jacobian matrix.\n+     * <p>\n+     * Needed if and only if the main ODE set is a {@link ParameterizedODE}\n+     * and the parameter has been {@link #selectParameters(String ...) selected}\n+     * </p>\n+     * <p>\n+     * For pval, a non zero value of the parameter, pval * Math.sqrt(MathUtils.EPSILON)\n+     * is a reasonable value for such a step.\n+     * </p>\n+     * <p>\n+     * A zero value for such a step doesn't enable to compute the parameter jacobian matrix.\n+     * </p>\n+     * @param parameter parameter to consider for jacobian processing\n+     * @param hP step for jacobian finite difference computation w.r.t. the specified parameter\n+     * @see ParameterizedODE\n+     * @exception IllegalArgumentException if the parameter is not supported\n+     */\n+    public void setParameterStep(final String parameter, final double hP) {\n+\n+        boolean found = false;\n+        for (ParameterConfiguration param: selectedParameters) {\n+            if (parameter.equals(param.getParameterName())) {\n+                param.setHP(hP);\n+                found = true;\n+                dirtyParameter = true;\n+                break;\n+            }\n+        }\n+        if (!found) {\n+            throw new MathIllegalArgumentException(LocalizedFormats.UNKNOWN_PARAMETER,\n+                                                   parameter);\n+        }\n+    }\n+\n+    /** Set the steps in order to compute by finite difference the jacobian\n+     *  matrix with respect to main state.\n+     * <p>\n+     * Needed if and only if the main set is a {@link FirstOrderDifferentialEquations}.\n+     * </p>\n+     * <p>\n+     * Zero values for those steps don't enable to compute the main state jacobian matrix.\n+     * </p>\n+     * @param hY step used for finite difference computation with respect to state vector\n+     * @exception IllegalArgumentException if the hY has not the dimension of the main state\n+     * given by {@link ExpandableFirstOrderDifferentialEquations#getMainSetDimension()}\n+     */\n+    public void setMainStateSteps(final double[] hY) {\n+\n+        if (fode != null) {\n+            // Check dimension\n+            checkDimension(stateDim, hY);\n+            this.hY = hY.clone();\n+            dirtyMainState = true;           \n+        }\n+    }\n+\n+    /** Set the initial value of the jacobian matrix with respect to state.\n+     * @param dYdY0 initial jacobian matrix w.r.t. state\n+     * @exception IllegalArgumentException if matrix dimensions are incorrect\n+     */\n+    public void setInitialMainStateJacobian(final double[][] dYdY0) {\n+\n+        // Check dimensions\n+        checkDimension(stateDim, dYdY0);\n+        checkDimension(stateDim, dYdY0[0]);\n+\n+        // store the matrix in row major order as a single dimension array\n+        int index = 0;\n+        for (final double[] row : dYdY0) {\n+            System.arraycopy(row, 0, mainJacobianInARow, index, stateDim);\n+            index += stateDim;\n+        }\n+        // set initial additional state value in expandable fode\n+        efode.setInitialAdditionalState(mainJacobianInARow, this);\n+    }\n+\n+    /** Set the initial value of the jacobian matrix with respect to one parameter.\n+     * <p>The parameter must be {@link #selectParameters(String...) selected}.</p>\n+     * @param pName parameter name\n+     * @param dYdP initial jacobian matrix w.r.t. the parameter\n+     * @exception IllegalArgumentException if matrix dimensions are incorrect\n+     */\n+    public void setInitialParameterJacobian(final String pName, final double[] dYdP) {\n+\n+        // Check dimensions\n+        checkDimension(stateDim, dYdP);\n+\n+        // store the matrix in a global single dimension array\n+        boolean found = false;\n+        int index = 0;\n+        for (ParameterConfiguration param: selectedParameters) {\n+            if (pName.equals(param.getParameterName())) {\n+                System.arraycopy(dYdP, 0, parameterJacobiansInARow, index, stateDim);\n+                double[] p = new double[this.getDimension()];\n+                index = stateDim * stateDim;\n+                System.arraycopy(mainJacobianInARow, 0, p, 0, index);\n+                System.arraycopy(parameterJacobiansInARow, 0, p, index, stateDim * paramDim);\n+                // set initial additional state value in expandable fode\n+                efode.setInitialAdditionalState(p, this);\n+                found = true;\n+                break;\n+            }\n+            index += stateDim;\n+        }\n+        if (! found) {\n+            throw new MathIllegalArgumentException(LocalizedFormats.UNKNOWN_PARAMETER,\n+                                                   pName);\n+        }\n+    }\n+\n+    /** Set the default initial value of the jacobian matrix with respect to state.\n+     * <p>dYdY0 is set to the identity matrix.</p>\n+     */\n+    public void setInitialMainStateJacobian() {\n+        final double[][] dYdY0 = new double[stateDim][stateDim];\n+        for (int i = 0; i < stateDim; ++i) {\n+            dYdY0[i][i] = 1.0;\n+        }\n+        setInitialMainStateJacobian(dYdY0);\n+    }\n+\n+    /** Set the default initial value of the jacobian matrix with respect to one parameter.\n+     * <p>The parameter must be {@link #selectParameters(String...) selected}.</p>\n+     * <p>dYdP is set to the null matrix.</p>\n+     * @param pName parameter name\n+     */\n+    public void setInitialParameterJacobian(final String pName) {\n+        setInitialParameterJacobian(pName, new double[stateDim]);\n+    }\n+\n+    /** Set the default initial values of jacobian matrices with respect to all parameters.\n+     */\n+    public void setInitialParameterJacobians() {\n+        for (ParameterConfiguration param: selectedParameters) {\n+            setInitialParameterJacobian(param.getParameterName());\n+        }\n+    }\n+\n+    /** Set default initial values for jacobian matrices.\n+     * <p>dYdY0 is set to the identity matrix and all dYdP are set to zero.</p>\n+     */\n+    public void setInitialJacobians() {\n+        setInitialMainStateJacobian();\n+        setInitialParameterJacobians();\n+    }\n+\n+    /** Get the current value of the jacobian matrix with respect to state.\n+     * @param dYdY0 current jacobian matrix with respect to state.\n+     */\n+    public void getCurrentMainSetJacobian(final double[][] dYdY0) {\n+\n+        // get current state for this set of equations from the expandable fode\n+        double[] p = efode.getCurrentAdditionalState(this);\n+\n+        int index = 0;\n+        for (int i = 0; i < stateDim; i++) {\n+            System.arraycopy(p, index, dYdY0[i], 0, stateDim);\n+            index += stateDim;\n+        }\n+\n+    }\n+\n+    /** Get the current value of the jacobian matrix with respect to one parameter.\n+     * @param pName name of the parameter for the computed jacobian matrix \n+     * @param dYdP current jacobian matrix with respect to the named parameter\n+     */\n+    public void getCurrentParameterJacobian(String pName, final double[] dYdP) {\n+\n+        // get current state for this set of equations from the expandable fode\n+        double[] p = efode.getCurrentAdditionalState(this);\n+\n+        int index = stateDim * stateDim;\n+        for (ParameterConfiguration param: selectedParameters) {\n+            if (param.getParameterName().equals(pName)) {\n+                System.arraycopy(p, index, dYdP, 0, stateDim);\n+                break;\n+            }\n+            index += stateDim;\n+        }\n+\n+    }\n+\n+    /** {@inheritDoc} */\n+    public int getDimension() {\n+        return stateDim * (stateDim + paramDim);\n+    }\n+\n+    /** {@inheritDoc} */\n+    public void computeDerivatives(final double t, final double[] y, final double[] yDot,\n+                                   final double[] z, final double[] zDot) {\n+\n+        // Lazy initialization\n+        if (dirtyMainState) {\n+            jode = new MainStateJacobianWrapper(fode, hY);\n+            dirtyMainState = false;\n+        }\n+        if (dirtyParameter && (paramDim != 0)) {\n+            pjp.add(new ParameterJacobianWrapper(jode, pode, selectedParameters));\n+            dirtyParameter = false;\n+        }\n+\n+        // variational equations:\n+        // from d[dy/dt]/dy0 and d[dy/dt]/dp to d[dy/dy0]/dt and d[dy/dp]/dt\n+\n+        // compute jacobian matrix with respect to main state\n+        double[][] dFdY = new double[stateDim][stateDim];\n+        jode.computeMainStateJacobian(t, y, yDot, dFdY);\n+\n+        // Dispatch jacobian matrix in the compound additional state vector\n+        for (int i = 0; i < stateDim; ++i) {\n+            final double[] dFdYi = dFdY[i];\n+            for (int j = 0; j < stateDim; ++j) {\n+                double s = 0;\n+                final int startIndex = j;\n+                int zIndex = startIndex;\n+                for (int l = 0; l < stateDim; ++l) {\n+                    s += dFdYi[l] * z[zIndex];\n+                    zIndex += stateDim;\n+                }\n+                zDot[startIndex + i * stateDim] = s;\n+            }\n+        }\n+\n+        if (paramDim != 0) {\n+            // compute jacobian matrices with respect to parameters\n+            double[] dFdP = new double[stateDim];\n+            int startIndex = stateDim * stateDim;\n+            for (ParameterConfiguration param: selectedParameters) {\n+                boolean found = false;\n+                for (ParameterJacobianProvider provider: pjp) {\n+                    if (provider.isSupported(param.getParameterName())) {\n+                        try {\n+                            provider.computeParameterJacobian(t, y, yDot, param.getParameterName(), dFdP);\n+                            for (int i = 0; i < stateDim; ++i) {\n+                                final double[] dFdYi = dFdY[i];\n+                                int zIndex = startIndex;\n+                                double s = dFdP[i];\n+                                for (int l = 0; l < stateDim; ++l) {\n+                                    s += dFdYi[l] * z[zIndex];\n+                                    zIndex++;\n+                                }\n+                                zDot[startIndex + i] = s;\n+                            }\n+                            startIndex += stateDim;\n+                            found = true;\n+                            break;\n+                        } catch (IllegalArgumentException iae) {\n+                        }\n+                    }\n+                }\n+                if (! found) {\n+                    throw new MathIllegalArgumentException(LocalizedFormats.UNKNOWN_PARAMETER,\n+                                                           param);\n+                }\n+            }\n+        }\n+\n+    }\n+\n+    /** Check compatibility between the main set in the expandable ode and an ordinary ode.\n+     * @param expended expandable ode containing a main set\n+     * @param ode single ode to check \n+     * @throws MathIllegalArgumentException if single ode doesn't match the main ode set in the extended ode\n+     */\n+    private void checkCompatibility(final ExpandableFirstOrderDifferentialEquations extended,\n+                                    final FirstOrderDifferentialEquations ode)\n+        throws MathIllegalArgumentException {\n+\n+        if (!(ode == extended.getMainSet())) {\n+            throw new MathIllegalArgumentException(LocalizedFormats.UNMATCHED_ODE_IN_EXTENDED_SET);\n+        }\n+    }\n+\n+    /** Check array dimensions.\n+     * @param expected expected dimension\n+     * @param array (may be null if expected is 0)\n+     * @throws DimensionMismatchException if the array dimension does not match the expected one\n+     */\n+    private void checkDimension(final int expected, final Object array)\n+        throws DimensionMismatchException {\n+        int arrayDimension = (array == null) ? 0 : Array.getLength(array);\n+        if (arrayDimension != expected) {\n+            throw new DimensionMismatchException(arrayDimension, expected);\n+        }\n+    }\n+\n+}\n+\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/ode/MainStateJacobianProvider.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.ode;\n+\n+/** Interface expanding {@link FirstOrderDifferentialEquations first order\n+ *  differential equations} in order to compute exactly the main state jacobian\n+ *  matrix for {@link JacobianMatrices partial derivatives equations}.\n+ * \n+ * @version $Id$\n+ * @since 3.0\n+ */\n+public interface MainStateJacobianProvider extends FirstOrderDifferentialEquations {\n+\n+    /** Compute the jacobian matrix of ODE with respect to main state.\n+     * @param t current value of the independent <I>time</I> variable\n+     * @param y array containing the current value of the main state vector\n+     * @param yDot array containing the current value of the time derivative of the main state vector\n+     * @param dFdY placeholder array where to put the jacobian matrix of the ODE w.r.t. the main state vector\n+     */\n+    void computeMainStateJacobian(double t, double[] y, double[] yDot, double[][] dFdY);\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/ode/MainStateJacobianWrapper.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.ode;\n+\n+/** Wrapper class to compute jacobian matrices by finite differences for ODE\n+ *  which do not compute them by themselves.\n+ *  \n+ * @version $Id$\n+ * @since 3.0\n+ */\n+class MainStateJacobianWrapper implements MainStateJacobianProvider {\n+\n+    /** Raw ODE without jacobians computation skill to be wrapped into a MainStateJacobianProvider. */\n+    private final FirstOrderDifferentialEquations ode;\n+\n+    /** Steps for finite difference computation of the jacobian df/dy w.r.t. state. */\n+    private final double[] hY;\n+\n+    /** Wrap a {@link FirstOrderDifferentialEquations} into a {@link MainStateJacobianProvider}.\n+     * @param ode original ODE problem, without jacobians computation skill\n+     * @param hY step sizes to compute the jacobian df/dy\n+     * @see JacobianMatrices#setMainStateSteps(double[])\n+     */\n+    public MainStateJacobianWrapper(final FirstOrderDifferentialEquations ode,\n+                                    final double[] hY) {\n+        this.ode = ode;\n+        this.hY = hY.clone();\n+    }\n+\n+    /** {@inheritDoc} */\n+    public int getDimension() {\n+        return ode.getDimension();\n+    }\n+\n+    /** {@inheritDoc} */\n+    public void computeDerivatives(double t, double[] y, double[] yDot) {\n+        ode.computeDerivatives(t, y, yDot);\n+    }\n+\n+    /** {@inheritDoc} */\n+    public void computeMainStateJacobian(double t, double[] y, double[] yDot,\n+                                         double[][] dFdY) {\n+\n+        final int n = ode.getDimension();\n+        final double[] tmpDot = new double[n];\n+\n+        for (int j = 0; j < n; ++j) {\n+            final double savedYj = y[j];\n+            y[j] += hY[j];\n+            ode.computeDerivatives(t, y, tmpDot);\n+            for (int i = 0; i < n; ++i) {\n+                dFdY[i][j] = (tmpDot[i] - yDot[i]) / hY[j];\n+            }\n+            y[j] = savedYj;\n+        }\n+    }\n+\n+}\n--- a/src/main/java/org/apache/commons/math/ode/MultistepIntegrator.java\n+++ b/src/main/java/org/apache/commons/math/ode/MultistepIntegrator.java\n     }\n \n     /** Wrapper for differential equations, ensuring start evaluations are counted. */\n-    private class CountingDifferentialEquations implements ExtendedFirstOrderDifferentialEquations {\n+    private class CountingDifferentialEquations implements FirstOrderDifferentialEquations {\n \n         /** Dimension of the problem. */\n         private final int dimension;\n             return dimension;\n         }\n \n-        /** {@inheritDoc} */\n-        public int getMainSetDimension() {\n-            return mainSetDimension;\n-        }\n     }\n \n }\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/ode/ParameterConfiguration.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.ode;\n+\n+import java.io.Serializable;\n+\n+/** Simple container pairing a parameter name with a step in order to compute\n+ *  the associated jacobian matrix by finite difference.\n+ * \n+ * @version $Id$\n+ * @since 3.0\n+ */\n+class ParameterConfiguration implements Serializable {\n+\n+    /** Serializable UID. */\n+    private static final long serialVersionUID = 2247518849090889379L;\n+\n+    /** Parameter name. */\n+    private String parameterName;\n+\n+    /** Parameter step for finite difference computation. */\n+    private double hP;\n+\n+    /** Parameter name and step pair constructor.\n+     * @param parameterName parameter name\n+     * @param hP parameter step */\n+    public ParameterConfiguration(final String parameterName, final double hP) {\n+        this.parameterName = parameterName;\n+        this.hP = hP;\n+    }\n+\n+    /** Get parameter name.\n+     * @return parameterName parameter name\n+     */\n+    public String getParameterName() {\n+        return parameterName;\n+    }\n+\n+    /** Get parameter step.\n+     * @return hP parameter step\n+     */\n+    public double getHP() {\n+        return hP;\n+    }\n+\n+    /** Set parameter step.\n+     * @param hP parameter step\n+     */\n+    public void setHP(final double hP) {\n+        this.hP = hP;\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/ode/ParameterJacobianProvider.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.ode;\n+\n+import org.apache.commons.math.exception.MathIllegalArgumentException;\n+\n+/** Interface to compute exactly jacobian matrix for some parameter\n+ *  when computing {@link JacobianMatrices partial derivatives equations}.\n+ * \n+ * @version $Id$\n+ * @since 3.0\n+ */\n+public interface ParameterJacobianProvider extends Parameterizable {\n+\n+    /** Compute the jacobian matrix of ODE with respect to one parameter.\n+     * <p>The parameter must be one given by {@link #getParametersNames()}.</p>\n+     * @param t current value of the independent <I>time</I> variable\n+     * @param y array containing the current value of the main state vector\n+     * @param yDot array containing the current value of the time derivative\n+     * of the main state vector\n+     * @param paramName name of the parameter to consider\n+     * @param dFdP placeholder array where to put the jacobian matrix of the\n+     * ODE with respect to the parameter\n+     * @throws MathIllegalArgumentException if the parameter is not supported\n+     */\n+    void computeParameterJacobian(double t, double[] y, double[] yDot,\n+                                  String paramName, double[] dFdP)\n+        throws MathIllegalArgumentException;\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/ode/ParameterJacobianWrapper.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.ode;\n+\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+/** Wrapper class to compute jacobian matrices by finite differences for ODE\n+ *  which do not compute them by themselves.\n+ *  \n+ * @version $Id$\n+ * @since 3.0\n+ */\n+class ParameterJacobianWrapper implements ParameterJacobianProvider {\n+\n+    /** Main ODE set. */\n+    private final FirstOrderDifferentialEquations fode;\n+\n+    /** Raw ODE without jacobian computation skill to be wrapped into a ParameterJacobianProvider. */\n+    private final ParameterizedODE pode;\n+\n+    /** Steps for finite difference computation of the jacobian df/dp w.r.t. parameters. */\n+    private final Map<String, Double> hParam;\n+\n+    /** Wrap a {@link ParameterizedODE} into a {@link ParameterJacobianProvider}.\n+     * @param fode main first order differential equations set\n+     * @param pode additional problem, without parametre jacobian computation skill\n+     * @param paramsAndSteps parameters and steps to compute the jacobians df/dp\n+     * @see JacobianMatrices#setParameterStep(String, double)\n+     */\n+    public ParameterJacobianWrapper(final FirstOrderDifferentialEquations fode,\n+                                    final ParameterizedODE pode,\n+                                    final Collection<ParameterConfiguration> paramsAndSteps) {\n+        this.fode = fode;\n+        this.pode = pode;\n+        this.hParam = new HashMap<String, Double>();\n+\n+        // set up parameters for jacobian computation\n+        for (final ParameterConfiguration param : paramsAndSteps) {\n+            final String name = param.getParameterName();\n+            if (pode.isSupported(name)) {\n+                hParam.put(name, param.getHP());\n+            }\n+        }\n+    }\n+\n+    /** {@inheritDoc} */\n+    public Collection<String> getParametersNames() {\n+        return pode.getParametersNames();\n+    }\n+\n+    /** {@inheritDoc} */\n+    public boolean isSupported(String name) {\n+        return pode.isSupported(name);\n+    }\n+\n+    /** {@inheritDoc} */\n+    public void computeParameterJacobian(double t, double[] y, double[] yDot,\n+                                         String paramName, double[] dFdP) {\n+\n+        final int n = fode.getDimension();\n+        final double[] tmpDot = new double[n];\n+\n+        // compute the jacobian df/dp w.r.t. parameter\n+        final double p  = pode.getParameter(paramName);\n+        final double hP = hParam.get(paramName);\n+        pode.setParameter(paramName, p + hP);\n+        fode.computeDerivatives(t, y, tmpDot);\n+        for (int i = 0; i < n; ++i) {\n+            dFdP[i] = (tmpDot[i] - yDot[i]) / hP;\n+        }\n+        pode.setParameter(paramName, p);\n+       \n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/ode/Parameterizable.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.ode;\n+\n+import java.util.Collection;\n+\n+/** This interface enables to process any parameterizable object.\n+ *\n+ * @version $Id$\n+ * @since 3.0\n+ */\n+\n+public interface Parameterizable {\n+\n+    /** Get the names of the supported parameters.\n+     * @return parameters names\n+     * @see #isSupported(String)\n+     */\n+    Collection<String> getParametersNames();\n+\n+    /** Check if a parameter is supported.\n+     * <p>Supported parameters are those listed by {@link #getParametersNames()}.</p>\n+     * @param name parameter name to check\n+     * @return true if the parameter is supported\n+     * @see #getParametersNames()\n+     */\n+    boolean isSupported(String name);\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/ode/ParameterizedODE.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.ode;\n+\n+/** Interface to compute by finite difference jacobian matrix for some parameter\n+ *  when computing {@link JacobianMatrices partial derivatives equations}.\n+ * \n+ * @version $Id$\n+ * @since 3.0\n+ */\n+\n+public interface ParameterizedODE extends Parameterizable {\n+\n+    /** Get parameter value from its name.\n+     * @param name parameter name\n+     * @return parameter value\n+     * @exception IllegalArgumentException if parameter is not supported\n+     */\n+    double getParameter(String name) throws IllegalArgumentException;\n+\n+    /** Set the value for a given parameter.\n+     * @param name parameter name\n+     * @param value parameter value\n+     * @exception IllegalArgumentException if parameter is not supported\n+     */\n+    void setParameter(String name, double value) throws IllegalArgumentException;\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/ode/ParameterizedWrapper.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.ode;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+\n+import org.apache.commons.math.exception.MathIllegalArgumentException;\n+import org.apache.commons.math.exception.util.LocalizedFormats;\n+\n+\n+/** Wrapper class enabling {@link FirstOrderDifferentialEquations basic simple}\n+ *  ODE instances to be used when processing {@link JacobianMatrices}.\n+ *  \n+ * @version $Id$\n+ * @since 3.0\n+ */\n+class ParameterizedWrapper implements ParameterizedODE {\n+\n+    /** Basic FODE without parameter. */\n+    private final FirstOrderDifferentialEquations fode;\n+\n+    /** Simple constructor.\n+     * @param ode original first order differential equations\n+     */\n+    public ParameterizedWrapper(final FirstOrderDifferentialEquations ode) {\n+        this.fode = ode;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public int getDimension() {\n+        return fode.getDimension();\n+    }\n+\n+    /** {@inheritDoc} */\n+    public void computeDerivatives(double t, double[] y, double[] yDot) {\n+        fode.computeDerivatives(t, y, yDot);\n+    }\n+\n+    /** {@inheritDoc} */\n+    public Collection<String> getParametersNames() {\n+        return new ArrayList<String>();\n+    }\n+\n+    /** {@inheritDoc} */\n+    public boolean isSupported(String name) {\n+        return false;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public double getParameter(String name)\n+        throws MathIllegalArgumentException {\n+        if (!isSupported(name)) {\n+            throw new MathIllegalArgumentException(LocalizedFormats.UNKNOWN_PARAMETER, name);\n+        }\n+        return Double.NaN;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public void setParameter(String name, double value) {\n+    }\n+\n+}\n--- a/src/main/java/org/apache/commons/math/ode/nonstiff/AdamsBashforthIntegrator.java\n+++ b/src/main/java/org/apache/commons/math/ode/nonstiff/AdamsBashforthIntegrator.java\n import org.apache.commons.math.exception.MathIllegalArgumentException;\n import org.apache.commons.math.exception.MathIllegalStateException;\n import org.apache.commons.math.linear.Array2DRowRealMatrix;\n-import org.apache.commons.math.ode.FirstOrderDifferentialEquations;\n+import org.apache.commons.math.ode.ExpandableFirstOrderDifferentialEquations;\n import org.apache.commons.math.ode.sampling.NordsieckStepInterpolator;\n import org.apache.commons.math.ode.sampling.StepHandler;\n import org.apache.commons.math.util.FastMath;\n \n     /** {@inheritDoc} */\n     @Override\n-    public double integrate(final FirstOrderDifferentialEquations equations,\n-                            final double t0, final double[] y0,\n-                            final double t, final double[] y)\n+    public double integrate(final ExpandableFirstOrderDifferentialEquations equations,\n+                            final double t0, final double[] z0,\n+                            final double t, final double[] z)\n         throws MathIllegalStateException, MathIllegalArgumentException {\n \n-        final int n = y0.length;\n-        sanityChecks(equations, t0, y0, t, y);\n+        sanityChecks(equations, t0, z0, t, z);\n         setEquations(equations);\n         resetEvaluations();\n         final boolean forward = t > t0;\n \n         // initialize working arrays\n+        final int totalDim = equations.getDimension();\n+        final int mainDim  = equations.getMainSetDimension();\n+        final double[] y0  = new double[totalDim];\n+        final double[] y   = new double[totalDim];\n+        System.arraycopy(z0, 0, y0, 0, mainDim);\n+        System.arraycopy(equations.getCurrentAdditionalStates(), 0, y0, mainDim, totalDim - mainDim);\n         if (y != y0) {\n-            System.arraycopy(y0, 0, y, 0, n);\n+            System.arraycopy(y0, 0, y, 0, totalDim);\n         }\n-        final double[] yDot = new double[n];\n+        final double[] yDot = new double[totalDim];\n \n         // set up an interpolator sharing the integrator arrays\n         final NordsieckStepInterpolator interpolator = new NordsieckStepInterpolator();\n \n         } while (!isLastStep);\n \n+        // dispatch result between main and additional states\n+        System.arraycopy(y, 0, z, 0, z.length);\n+        equations.setCurrentAdditionalState(y);\n+\n         final double stopTime = stepStart;\n         resetInternalState();\n         return stopTime;\n--- a/src/main/java/org/apache/commons/math/ode/nonstiff/AdamsIntegrator.java\n+++ b/src/main/java/org/apache/commons/math/ode/nonstiff/AdamsIntegrator.java\n import org.apache.commons.math.exception.MathIllegalArgumentException;\n import org.apache.commons.math.exception.MathIllegalStateException;\n import org.apache.commons.math.linear.Array2DRowRealMatrix;\n-import org.apache.commons.math.ode.FirstOrderDifferentialEquations;\n+import org.apache.commons.math.ode.ExpandableFirstOrderDifferentialEquations;\n import org.apache.commons.math.ode.MultistepIntegrator;\n \n \n \n     /** {@inheritDoc} */\n     @Override\n-    public abstract double integrate(final FirstOrderDifferentialEquations equations,\n+    public abstract double integrate(final ExpandableFirstOrderDifferentialEquations equations,\n                                      final double t0, final double[] y0,\n                                      final double t, final double[] y)\n         throws MathIllegalStateException, MathIllegalArgumentException;\n--- a/src/main/java/org/apache/commons/math/ode/nonstiff/AdamsMoultonIntegrator.java\n+++ b/src/main/java/org/apache/commons/math/ode/nonstiff/AdamsMoultonIntegrator.java\n import org.apache.commons.math.exception.MathIllegalStateException;\n import org.apache.commons.math.linear.Array2DRowRealMatrix;\n import org.apache.commons.math.linear.RealMatrixPreservingVisitor;\n-import org.apache.commons.math.ode.FirstOrderDifferentialEquations;\n+import org.apache.commons.math.ode.ExpandableFirstOrderDifferentialEquations;\n import org.apache.commons.math.ode.sampling.NordsieckStepInterpolator;\n import org.apache.commons.math.ode.sampling.StepHandler;\n import org.apache.commons.math.util.FastMath;\n \n     /** {@inheritDoc} */\n     @Override\n-    public double integrate(final FirstOrderDifferentialEquations equations,\n-                            final double t0, final double[] y0,\n-                            final double t, final double[] y)\n+    public double integrate(final ExpandableFirstOrderDifferentialEquations equations,\n+                            final double t0, final double[] z0,\n+                            final double t, final double[] z)\n         throws MathIllegalStateException, MathIllegalArgumentException {\n \n-        final int n = y0.length;\n-        sanityChecks(equations, t0, y0, t, y);\n+        sanityChecks(equations, t0, z0, t, z);\n         setEquations(equations);\n         resetEvaluations();\n         final boolean forward = t > t0;\n \n         // initialize working arrays\n+        final int totalDim = equations.getDimension();\n+        final int mainDim  = equations.getMainSetDimension();\n+        final double[] y0  = new double[totalDim];\n+        final double[] y   = new double[totalDim];\n+        System.arraycopy(z0, 0, y0, 0, mainDim);\n+        System.arraycopy(equations.getCurrentAdditionalStates(), 0, y0, mainDim, totalDim - mainDim);\n         if (y != y0) {\n-            System.arraycopy(y0, 0, y, 0, n);\n-        }\n-        final double[] yDot = new double[y0.length];\n-        final double[] yTmp = new double[y0.length];\n-        final double[] predictedScaled = new double[y0.length];\n+            System.arraycopy(y0, 0, y, 0, totalDim);\n+        }\n+        final double[] yDot = new double[totalDim];\n+        final double[] yTmp = new double[totalDim];\n+        final double[] predictedScaled = new double[totalDim];\n         Array2DRowRealMatrix nordsieckTmp = null;\n \n         // set up two interpolators sharing the integrator arrays\n             updateHighOrderDerivativesPhase2(predictedScaled, correctedScaled, nordsieckTmp);\n \n             // discrete events handling\n-            System.arraycopy(yTmp, 0, y, 0, n);\n+            System.arraycopy(yTmp, 0, y, 0, totalDim);\n             interpolator.reinitialize(stepEnd, stepSize, correctedScaled, nordsieckTmp);\n             interpolator.storeTime(stepStart);\n             interpolator.shift();\n             }\n \n         } while (!isLastStep);\n+\n+        // dispatch result between main and additional states\n+        System.arraycopy(y, 0, z, 0, z.length);\n+        equations.setCurrentAdditionalState(y);\n \n         final double stopTime  = stepStart;\n         stepStart = Double.NaN;\n--- a/src/main/java/org/apache/commons/math/ode/nonstiff/AdaptiveStepsizeIntegrator.java\n+++ b/src/main/java/org/apache/commons/math/ode/nonstiff/AdaptiveStepsizeIntegrator.java\n import org.apache.commons.math.exception.NumberIsTooSmallException;\n import org.apache.commons.math.exception.util.LocalizedFormats;\n import org.apache.commons.math.ode.AbstractIntegrator;\n-import org.apache.commons.math.ode.ExtendedFirstOrderDifferentialEquations;\n+import org.apache.commons.math.ode.ExpandableFirstOrderDifferentialEquations;\n import org.apache.commons.math.ode.FirstOrderDifferentialEquations;\n import org.apache.commons.math.util.FastMath;\n \n  * component. The user can also use only two scalar values absTol and\n  * relTol which will be used for all components.\n  * </p>\n- *\n- * <p>If the Ordinary Differential Equations is an {@link ExtendedFirstOrderDifferentialEquations\n- * extended ODE} rather than a {@link FirstOrderDifferentialEquations basic ODE},\n- * then <em>only</em> the {@link ExtendedFirstOrderDifferentialEquations#getMainSetDimension()\n- * main set} part of the state vector is used for stepsize control, not the complete\n- * state vector.\n+ * <p>\n+ * If the Ordinary Differential Equations is an {@link ExpandableFirstOrderDifferentialEquations\n+ * extended ODE} rather than a {@link FirstOrderDifferentialEquations basic ODE}, then\n+ * <em>only</em> the {@link ExpandableFirstOrderDifferentialEquations#getMainSet() main part}\n+ * of the state vector is used for stepsize control, not the complete state vector.\n  * </p>\n  *\n  * <p>If the estimated error for ym+1 is such that\n    * @exception NumberIsTooSmallException if integration span is too small\n    */\n   @Override\n-  protected void sanityChecks(final FirstOrderDifferentialEquations equations,\n+  protected void sanityChecks(final ExpandableFirstOrderDifferentialEquations equations,\n                               final double t0, final double[] y0,\n                               final double t, final double[] y)\n       throws DimensionMismatchException, NumberIsTooSmallException {\n \n       super.sanityChecks(equations, t0, y0, t, y);\n \n-      if (equations instanceof ExtendedFirstOrderDifferentialEquations) {\n-          mainSetDimension = ((ExtendedFirstOrderDifferentialEquations) equations).getMainSetDimension();\n-      } else {\n-          mainSetDimension = equations.getDimension();\n-      }\n+      mainSetDimension = equations.getMainSetDimension();\n \n       if ((vecAbsoluteTolerance != null) && (vecAbsoluteTolerance.length != mainSetDimension)) {\n           throw new DimensionMismatchException(mainSetDimension, vecAbsoluteTolerance.length);\n   }\n \n   /** Initialize the integration step.\n-   * @param equations differential equations set\n    * @param forward forward integration indicator\n    * @param order order of the method\n    * @param scale scaling vector for the state vector (can be shorter than state vector)\n    * @param yDot1 work array for the first time derivative of y1\n    * @return first integration step\n    */\n-  public double initializeStep(final FirstOrderDifferentialEquations equations,\n-                               final boolean forward, final int order, final double[] scale,\n+  public double initializeStep(final boolean forward, final int order, final double[] scale,\n                                final double t0, final double[] y0, final double[] yDot0,\n                                final double[] y1, final double[] yDot1) {\n \n   }\n \n   /** {@inheritDoc} */\n-  public abstract double integrate (FirstOrderDifferentialEquations equations,\n+  public abstract double integrate (ExpandableFirstOrderDifferentialEquations equations,\n                                     double t0, double[] y0,\n                                     double t, double[] y)\n     throws MathIllegalStateException, MathIllegalArgumentException;\n--- a/src/main/java/org/apache/commons/math/ode/nonstiff/EmbeddedRungeKuttaIntegrator.java\n+++ b/src/main/java/org/apache/commons/math/ode/nonstiff/EmbeddedRungeKuttaIntegrator.java\n \n import org.apache.commons.math.exception.MathIllegalArgumentException;\n import org.apache.commons.math.exception.MathIllegalStateException;\n-import org.apache.commons.math.ode.FirstOrderDifferentialEquations;\n+import org.apache.commons.math.ode.ExpandableFirstOrderDifferentialEquations;\n import org.apache.commons.math.ode.sampling.StepHandler;\n import org.apache.commons.math.util.FastMath;\n \n \n   /** {@inheritDoc} */\n   @Override\n-  public double integrate(final FirstOrderDifferentialEquations equations,\n-                          final double t0, final double[] y0,\n-                          final double t, final double[] y)\n+  public double integrate(final ExpandableFirstOrderDifferentialEquations equations,\n+                          final double t0, final double[] z0,\n+                          final double t, final double[] z)\n       throws MathIllegalStateException, MathIllegalArgumentException {\n \n-    sanityChecks(equations, t0, y0, t, y);\n+    sanityChecks(equations, t0, z0, t, z);\n     setEquations(equations);\n     resetEvaluations();\n     final boolean forward = t > t0;\n \n     // create some internal working arrays\n+    final int totalDim = equations.getDimension();\n+    final int mainDim  = equations.getMainSetDimension();\n+    final double[] y0  = new double[totalDim];\n+    final double[] y   = new double[totalDim];\n+    System.arraycopy(z0, 0, y0, 0, mainDim);\n+    System.arraycopy(equations.getCurrentAdditionalStates(), 0, y0, mainDim, totalDim - mainDim);\n     final int stages = c.length + 1;\n     if (y != y0) {\n-      System.arraycopy(y0, 0, y, 0, y0.length);\n+      System.arraycopy(y0, 0, y, 0, totalDim);\n     }\n-    final double[][] yDotK = new double[stages][y0.length];\n-    final double[] yTmp    = new double[y0.length];\n-    final double[] yDotTmp = new double[y0.length];\n+    final double[][] yDotK = new double[stages][totalDim];\n+    final double[] yTmp    = new double[totalDim];\n+    final double[] yDotTmp = new double[totalDim];\n \n     // set up an interpolator sharing the integrator arrays\n     final RungeKuttaStepInterpolator interpolator = (RungeKuttaStepInterpolator) prototype.copy();\n                 scale[i] = vecAbsoluteTolerance[i] + vecRelativeTolerance[i] * FastMath.abs(y[i]);\n               }\n           }\n-          hNew = initializeStep(equations, forward, getOrder(), scale,\n+          hNew = initializeStep(forward, getOrder(), scale,\n                                 stepStart, y, yDotK[0], yTmp, yDotK[1]);\n           firstTime = false;\n         }\n \n     } while (!isLastStep);\n \n+    // dispatch result between main and additional states\n+    System.arraycopy(y, 0, z, 0, z.length);\n+    equations.setCurrentAdditionalState(y);\n+\n     final double stopTime = stepStart;\n     resetInternalState();\n     return stopTime;\n--- a/src/main/java/org/apache/commons/math/ode/nonstiff/GraggBulirschStoerIntegrator.java\n+++ b/src/main/java/org/apache/commons/math/ode/nonstiff/GraggBulirschStoerIntegrator.java\n import org.apache.commons.math.analysis.solvers.UnivariateRealSolver;\n import org.apache.commons.math.exception.MathIllegalArgumentException;\n import org.apache.commons.math.exception.MathIllegalStateException;\n-import org.apache.commons.math.ode.FirstOrderDifferentialEquations;\n+import org.apache.commons.math.ode.ExpandableFirstOrderDifferentialEquations;\n import org.apache.commons.math.ode.events.EventHandler;\n import org.apache.commons.math.ode.sampling.AbstractStepInterpolator;\n import org.apache.commons.math.ode.sampling.StepHandler;\n \n   /** {@inheritDoc} */\n   @Override\n-  public double integrate(final FirstOrderDifferentialEquations equations,\n-                          final double t0, final double[] y0, final double t, final double[] y)\n+  public double integrate(final ExpandableFirstOrderDifferentialEquations equations,\n+                          final double t0, final double[] z0, final double t, final double[] z)\n       throws MathIllegalStateException, MathIllegalArgumentException {\n \n-    sanityChecks(equations, t0, y0, t, y);\n+    sanityChecks(equations, t0, z0, t, z);\n     setEquations(equations);\n     resetEvaluations();\n     final boolean forward = t > t0;\n \n     // create some internal working arrays\n-    final double[] yDot0   = new double[y0.length];\n-    final double[] y1      = new double[y0.length];\n-    final double[] yTmp    = new double[y0.length];\n-    final double[] yTmpDot = new double[y0.length];\n+    final int totalDim = equations.getDimension();\n+    final int mainDim  = equations.getMainSetDimension();\n+    final double[] y0 = new double[totalDim];\n+    final double[] y  = new double[totalDim];\n+    System.arraycopy(z0, 0, y0, 0, mainDim);\n+    System.arraycopy(equations.getCurrentAdditionalStates(), 0, y0, mainDim, totalDim - mainDim);\n+    final double[] yDot0   = new double[totalDim];\n+    final double[] y1      = new double[totalDim];\n+    final double[] yTmp    = new double[totalDim];\n+    final double[] yTmpDot = new double[totalDim];\n \n     final double[][] diagonal = new double[sequence.length-1][];\n     final double[][] y1Diag = new double[sequence.length-1][];\n     for (int k = 0; k < sequence.length-1; ++k) {\n-      diagonal[k] = new double[y0.length];\n-      y1Diag[k] = new double[y0.length];\n+      diagonal[k] = new double[totalDim];\n+      y1Diag[k] = new double[totalDim];\n     }\n \n     final double[][][] fk  = new double[sequence.length][][];\n         }\n \n         if (firstTime) {\n-          hNew = initializeStep(equations, forward,\n-                                2 * targetIter + 1, scale,\n+          hNew = initializeStep(forward, 2 * targetIter + 1, scale,\n                                 stepStart, y, yDot0, yTmp, yTmpDot);\n         }\n \n--- a/src/main/java/org/apache/commons/math/ode/nonstiff/RungeKuttaIntegrator.java\n+++ b/src/main/java/org/apache/commons/math/ode/nonstiff/RungeKuttaIntegrator.java\n import org.apache.commons.math.exception.MathIllegalArgumentException;\n import org.apache.commons.math.exception.MathIllegalStateException;\n import org.apache.commons.math.ode.AbstractIntegrator;\n-import org.apache.commons.math.ode.FirstOrderDifferentialEquations;\n+import org.apache.commons.math.ode.ExpandableFirstOrderDifferentialEquations;\n import org.apache.commons.math.ode.sampling.StepHandler;\n import org.apache.commons.math.util.FastMath;\n \n   }\n \n   /** {@inheritDoc} */\n-  public double integrate(final FirstOrderDifferentialEquations equations,\n-                          final double t0, final double[] y0,\n-                          final double t, final double[] y)\n+  public double integrate(final ExpandableFirstOrderDifferentialEquations equations,\n+                          final double t0, final double[] z0,\n+                          final double t, final double[] z)\n       throws MathIllegalStateException, MathIllegalArgumentException {\n \n-    sanityChecks(equations, t0, y0, t, y);\n+    sanityChecks(equations, t0, z0, t, z);\n     setEquations(equations);\n     resetEvaluations();\n     final boolean forward = t > t0;\n \n     // create some internal working arrays\n+    final int totalDim = equations.getDimension();\n+    final int mainDim  = equations.getMainSetDimension();\n+    final double[] y0  = new double[totalDim];\n+    final double[] y   = new double[totalDim];\n+    System.arraycopy(z0, 0, y0, 0, mainDim);\n+    System.arraycopy(equations.getCurrentAdditionalStates(), 0, y0, mainDim, totalDim - mainDim);\n     final int stages = c.length + 1;\n     if (y != y0) {\n       System.arraycopy(y0, 0, y, 0, y0.length);\n \n     } while (!isLastStep);\n \n+    // dispatch result between main and additional states\n+    System.arraycopy(y, 0, z, 0, z.length);\n+    equations.setCurrentAdditionalState(y);\n+\n     final double stopTime = stepStart;\n     stepStart = Double.NaN;\n     stepSize  = Double.NaN;\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/math/ode/JacobianMatricesTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.ode;\n+\n+import org.apache.commons.math.ode.nonstiff.DormandPrince54Integrator;\n+import org.apache.commons.math.stat.descriptive.SummaryStatistics;\n+import org.apache.commons.math.util.FastMath;\n+import org.junit.Assert;\n+import org.junit.Test;\n+\n+public class JacobianMatricesTest {\n+\n+    @Test\n+    public void testLowAccuracyExternalDifferentiation() {\n+        // this test does not really test FirstOrderIntegratorWithJacobians,\n+        // it only shows that WITHOUT this class, attempting to recover\n+        // the jacobians from external differentiation on simple integration\n+        // results with low accuracy gives very poor results. In fact,\n+        // the curves dy/dp = g(b) when b varies from 2.88 to 3.08 are\n+        // essentially noise.\n+        // This test is taken from Hairer, Norsett and Wanner book\n+        // Solving Ordinary Differential Equations I (Nonstiff problems),\n+        // the curves dy/dp = g(b) are in figure 6.5\n+        FirstOrderIntegrator integ =\n+            new DormandPrince54Integrator(1.0e-8, 100.0, new double[] { 1.0e-4, 1.0e-4 }, new double[] { 1.0e-4, 1.0e-4 });\n+        double hP = 1.0e-12;\n+        SummaryStatistics residualsP0 = new SummaryStatistics();\n+        SummaryStatistics residualsP1 = new SummaryStatistics();\n+        for (double b = 2.88; b < 3.08; b += 0.001) {\n+            Brusselator brusselator = new Brusselator(b);\n+            double[] y = { 1.3, b };\n+            integ.integrate(brusselator, 0, y, 20.0, y);\n+            double[] yP = { 1.3, b + hP };\n+            integ.integrate(brusselator, 0, yP, 20.0, yP);\n+            residualsP0.addValue((yP[0] - y[0]) / hP - brusselator.dYdP0());\n+            residualsP1.addValue((yP[1] - y[1]) / hP - brusselator.dYdP1());\n+        }\n+        Assert.assertTrue((residualsP0.getMax() - residualsP0.getMin()) > 500);\n+        Assert.assertTrue(residualsP0.getStandardDeviation() > 30);\n+        Assert.assertTrue((residualsP1.getMax() - residualsP1.getMin()) > 700);\n+        Assert.assertTrue(residualsP1.getStandardDeviation() > 40);\n+    }\n+\n+    @Test\n+    public void testHighAccuracyExternalDifferentiation() {\n+        FirstOrderIntegrator integ =\n+            new DormandPrince54Integrator(1.0e-8, 100.0, new double[] { 1.0e-10, 1.0e-10 }, new double[] { 1.0e-10, 1.0e-10 });\n+        double hP = 1.0e-12;\n+        SummaryStatistics residualsP0 = new SummaryStatistics();\n+        SummaryStatistics residualsP1 = new SummaryStatistics();\n+        for (double b = 2.88; b < 3.08; b += 0.001) {\n+            ParamBrusselator brusselator = new ParamBrusselator(b);\n+            double[] y = { 1.3, b };\n+            integ.integrate(brusselator, 0, y, 20.0, y);\n+            double[] yP = { 1.3, b + hP };\n+            brusselator.setParameter(\"b\", b + hP);\n+            integ.integrate(brusselator, 0, yP, 20.0, yP);\n+            residualsP0.addValue((yP[0] - y[0]) / hP - brusselator.dYdP0());\n+            residualsP1.addValue((yP[1] - y[1]) / hP - brusselator.dYdP1());\n+        }\n+        Assert.assertTrue((residualsP0.getMax() - residualsP0.getMin()) > 0.02);\n+        Assert.assertTrue((residualsP0.getMax() - residualsP0.getMin()) < 0.03);\n+        Assert.assertTrue(residualsP0.getStandardDeviation() > 0.003);\n+        Assert.assertTrue(residualsP0.getStandardDeviation() < 0.004);\n+        Assert.assertTrue((residualsP1.getMax() - residualsP1.getMin()) > 0.04);\n+        Assert.assertTrue((residualsP1.getMax() - residualsP1.getMin()) < 0.05);\n+        Assert.assertTrue(residualsP1.getStandardDeviation() > 0.007);\n+        Assert.assertTrue(residualsP1.getStandardDeviation() < 0.008);\n+    }\n+\n+    @Test\n+    public void testInternalDifferentiation() {\n+        ExpandableFirstOrderIntegrator integ =\n+            new DormandPrince54Integrator(1.0e-8, 100.0, new double[] { 1.0e-4, 1.0e-4 }, new double[] { 1.0e-4, 1.0e-4 });\n+        double hP = 1.0e-12;\n+        double hY = 1.0e-12;\n+        SummaryStatistics residualsP0 = new SummaryStatistics();\n+        SummaryStatistics residualsP1 = new SummaryStatistics();\n+        for (double b = 2.88; b < 3.08; b += 0.001) {\n+            ParamBrusselator brusselator = new ParamBrusselator(b);\n+            brusselator.setParameter(ParamBrusselator.B, b);\n+            double[] z = { 1.3, b };\n+            double[][] dZdZ0 = new double[2][2];\n+            double[]   dZdP  = new double[2];\n+            ExpandableFirstOrderDifferentialEquations efode = new ExpandableFirstOrderDifferentialEquations(brusselator);\n+            JacobianMatrices jacob = new JacobianMatrices(efode, brusselator);\n+            jacob.setParameterizedODE(brusselator);\n+            jacob.selectParameters(ParamBrusselator.B);\n+            jacob.setMainStateSteps(new double[] { hY, hY });\n+            jacob.setParameterStep(ParamBrusselator.B, hP);\n+            jacob.setInitialParameterJacobian(ParamBrusselator.B, new double[] { 0.0, 1.0 });\n+            integ.setMaxEvaluations(5000);\n+            integ.integrate(efode, 0, z, 20.0, z);\n+            jacob.getCurrentMainSetJacobian(dZdZ0);\n+            jacob.getCurrentParameterJacobian(ParamBrusselator.B, dZdP);\n+//            Assert.assertEquals(5000, integ.getMaxEvaluations());\n+//            Assert.assertTrue(integ.getEvaluations() > 1500);\n+//            Assert.assertTrue(integ.getEvaluations() < 2100);\n+//            Assert.assertEquals(4 * integ.getEvaluations(), integ.getEvaluations());\n+            residualsP0.addValue(dZdP[0] - brusselator.dYdP0());\n+            residualsP1.addValue(dZdP[1] - brusselator.dYdP1());\n+        }\n+        Assert.assertTrue((residualsP0.getMax() - residualsP0.getMin()) < 0.02);\n+        Assert.assertTrue(residualsP0.getStandardDeviation() < 0.003);\n+        Assert.assertTrue((residualsP1.getMax() - residualsP1.getMin()) < 0.05);\n+        Assert.assertTrue(residualsP1.getStandardDeviation() < 0.01);\n+    }\n+\n+    @Test\n+    public void testAnalyticalDifferentiation() {\n+        ExpandableFirstOrderIntegrator integ =\n+            new DormandPrince54Integrator(1.0e-8, 100.0, new double[] { 1.0e-4, 1.0e-4 }, new double[] { 1.0e-4, 1.0e-4 });\n+        SummaryStatistics residualsP0 = new SummaryStatistics();\n+        SummaryStatistics residualsP1 = new SummaryStatistics();\n+        for (double b = 2.88; b < 3.08; b += 0.001) {\n+            Brusselator brusselator = new Brusselator(b);\n+            double[] z = { 1.3, b };\n+            double[][] dZdZ0 = new double[2][2];\n+            double[]   dZdP  = new double[2];\n+            ExpandableFirstOrderDifferentialEquations efode = new ExpandableFirstOrderDifferentialEquations(brusselator);\n+            JacobianMatrices jacob = new JacobianMatrices(efode, brusselator);\n+            jacob.setParameterJacobianProvider(brusselator);\n+            jacob.selectParameters(Brusselator.B);\n+            jacob.setInitialParameterJacobian(Brusselator.B, new double[] { 0.0, 1.0 });\n+            integ.setMaxEvaluations(5000);\n+            integ.integrate(efode, 0, z, 20.0, z);\n+            jacob.getCurrentMainSetJacobian(dZdZ0);\n+            jacob.getCurrentParameterJacobian(Brusselator.B, dZdP);\n+//            Assert.assertEquals(5000, integ.getMaxEvaluations());\n+//            Assert.assertTrue(integ.getEvaluations() > 350);\n+//            Assert.assertTrue(integ.getEvaluations() < 510);\n+            residualsP0.addValue(dZdP[0] - brusselator.dYdP0());\n+            residualsP1.addValue(dZdP[1] - brusselator.dYdP1());\n+        }\n+        Assert.assertTrue((residualsP0.getMax() - residualsP0.getMin()) < 0.014);\n+        Assert.assertTrue(residualsP0.getStandardDeviation() < 0.003);\n+        Assert.assertTrue((residualsP1.getMax() - residualsP1.getMin()) < 0.05);\n+        Assert.assertTrue(residualsP1.getStandardDeviation() < 0.01);\n+    }\n+\n+    @Test\n+    public void testFinalResult() {\n+\n+        ExpandableFirstOrderIntegrator integ =\n+            new DormandPrince54Integrator(1.0e-8, 100.0, new double[] { 1.0e-10, 1.0e-10 }, new double[] { 1.0e-10, 1.0e-10 });\n+        double[] y = new double[] { 0.0, 1.0 };\n+        Circle circle = new Circle(y, 1.0, 1.0, 0.1);\n+\n+        ExpandableFirstOrderDifferentialEquations efode = new ExpandableFirstOrderDifferentialEquations(circle);\n+        JacobianMatrices jacob = new JacobianMatrices(efode, circle);\n+        jacob.setParameterJacobianProvider(circle);\n+        jacob.selectParameters(Circle.CX, Circle.CY, Circle.OMEGA);\n+        jacob.setInitialMainStateJacobian(circle.exactDyDy0(0));\n+        jacob.setInitialParameterJacobian(Circle.CX, circle.exactDyDcx(0));\n+        jacob.setInitialParameterJacobian(Circle.CY, circle.exactDyDcy(0));\n+        jacob.setInitialParameterJacobian(Circle.OMEGA, circle.exactDyDom(0));\n+        integ.setMaxEvaluations(5000);\n+\n+        double t = 18 * FastMath.PI;\n+        integ.integrate(efode, 0, y, t, y);\n+        for (int i = 0; i < y.length; ++i) {\n+            Assert.assertEquals(circle.exactY(t)[i], y[i], 1.0e-9);\n+        }\n+\n+        double[][] dydy0 = new double[2][2];\n+        jacob.getCurrentMainSetJacobian(dydy0);\n+        for (int i = 0; i < dydy0.length; ++i) {\n+            for (int j = 0; j < dydy0[i].length; ++j) {\n+                Assert.assertEquals(circle.exactDyDy0(t)[i][j], dydy0[i][j], 1.0e-9);\n+            }\n+        }\n+        double[] dydcx = new double[2];\n+        jacob.getCurrentParameterJacobian(Circle.CX, dydcx);\n+        for (int i = 0; i < dydcx.length; ++i) {\n+            Assert.assertEquals(circle.exactDyDcx(t)[i], dydcx[i], 1.0e-7);\n+        }\n+        double[] dydcy = new double[2];\n+        jacob.getCurrentParameterJacobian(Circle.CY, dydcy);\n+        for (int i = 0; i < dydcy.length; ++i) {\n+            Assert.assertEquals(circle.exactDyDcy(t)[i], dydcy[i], 1.0e-7);\n+        }\n+        double[] dydom = new double[2];\n+        jacob.getCurrentParameterJacobian(Circle.OMEGA, dydom);\n+        for (int i = 0; i < dydom.length; ++i) {\n+            Assert.assertEquals(circle.exactDyDom(t)[i], dydom[i], 1.0e-7);\n+        }\n+    }\n+\n+    @Test\n+    public void testParameterizable() {\n+\n+        ExpandableFirstOrderIntegrator integ =\n+            new DormandPrince54Integrator(1.0e-8, 100.0, new double[] { 1.0e-10, 1.0e-10 }, new double[] { 1.0e-10, 1.0e-10 });\n+        double[] y = new double[] { 0.0, 1.0 };\n+        ParameterizedCircle pcircle = new ParameterizedCircle(y, 1.0, 1.0, 0.1);\n+//        pcircle.setParameter(ParameterizedCircle.CX, 1.0);\n+//        pcircle.setParameter(ParameterizedCircle.CY, 1.0);\n+//        pcircle.setParameter(ParameterizedCircle.OMEGA, 0.1);\n+\n+        ExpandableFirstOrderDifferentialEquations efode = new ExpandableFirstOrderDifferentialEquations(pcircle);\n+\n+        double hP = 1.0e-12;\n+        double hY = 1.0e-12;\n+\n+        JacobianMatrices jacob = new JacobianMatrices(efode, pcircle);\n+        jacob.setParameterJacobianProvider(pcircle);\n+        jacob.setParameterizedODE(pcircle);\n+        jacob.selectParameters(Circle.CX, Circle.OMEGA);\n+        jacob.setMainStateSteps(new double[] { hY, hY });\n+        jacob.setParameterStep(Circle.OMEGA, hP);\n+        jacob.setInitialMainStateJacobian(pcircle.exactDyDy0(0));\n+        jacob.setInitialParameterJacobian(Circle.CX, pcircle.exactDyDcx(0));\n+//        jacob.setInitialParameterJacobian(Circle.CY, circle.exactDyDcy(0));\n+        jacob.setInitialParameterJacobian(Circle.OMEGA, pcircle.exactDyDom(0));\n+        integ.setMaxEvaluations(50000);\n+\n+        double t = 18 * FastMath.PI;\n+        integ.integrate(efode, 0, y, t, y);\n+        for (int i = 0; i < y.length; ++i) {\n+            Assert.assertEquals(pcircle.exactY(t)[i], y[i], 1.0e-9);\n+        }\n+\n+        double[][] dydy0 = new double[2][2];\n+        jacob.getCurrentMainSetJacobian(dydy0);\n+        for (int i = 0; i < dydy0.length; ++i) {\n+            for (int j = 0; j < dydy0[i].length; ++j) {\n+                Assert.assertEquals(pcircle.exactDyDy0(t)[i][j], dydy0[i][j], 5.0e-4);\n+            }\n+        }\n+\n+        double[] dydp0 = new double[2];\n+        jacob.getCurrentParameterJacobian(Circle.CX, dydp0);\n+        for (int i = 0; i < dydp0.length; ++i) {\n+            Assert.assertEquals(pcircle.exactDyDcx(t)[i], dydp0[i], 5.0e-4);\n+        }\n+\n+        double[] dydp1 = new double[2];\n+        jacob.getCurrentParameterJacobian(Circle.OMEGA, dydp1);\n+        for (int i = 0; i < dydp1.length; ++i) {\n+            Assert.assertEquals(pcircle.exactDyDom(t)[i], dydp1[i], 1.0e-2);\n+        }\n+    }\n+\n+    private static class Brusselator extends AbstractParameterizable\n+        implements MainStateJacobianProvider, ParameterJacobianProvider {\n+\n+        public static final String B = \"b\";\n+\n+        private double b;\n+\n+        public Brusselator(double b) {\n+            super(B);\n+            this.b = b;\n+        }\n+\n+        public int getDimension() {\n+            return 2;\n+        }\n+\n+        public void computeDerivatives(double t, double[] y, double[] yDot) {\n+            double prod = y[0] * y[0] * y[1];\n+            yDot[0] = 1 + prod - (b + 1) * y[0];\n+            yDot[1] = b * y[0] - prod;\n+        }\n+\n+        public void computeMainStateJacobian(double t, double[] y, double[] yDot,\n+                                             double[][] dFdY) {\n+            double p = 2 * y[0] * y[1];\n+            double y02 = y[0] * y[0];\n+            dFdY[0][0] = p - (1 + b);\n+            dFdY[0][1] = y02;\n+            dFdY[1][0] = b - p;\n+            dFdY[1][1] = -y02;\n+        }\n+\n+        public void computeParameterJacobian(double t, double[] y, double[] yDot,\n+                                             String paramName, double[] dFdP) {\n+            complainIfNotSupported(paramName);\n+            dFdP[0] = -y[0];\n+            dFdP[1] = y[0];\n+        }\n+\n+        public double dYdP0() {\n+            return -1088.232716447743 + (1050.775747149553 + (-339.012934631828 + 36.52917025056327 * b) * b) * b;\n+        }\n+\n+        public double dYdP1() {\n+            return 1502.824469929139 + (-1438.6974831849952 + (460.959476642384 - 49.43847385647082 * b) * b) * b;\n+        }\n+\n+    }\n+\n+    private static class ParamBrusselator extends AbstractParameterizable\n+        implements FirstOrderDifferentialEquations, ParameterizedODE {\n+\n+        public static final String B = \"b\";\n+\n+        private double b;\n+\n+        public ParamBrusselator(double b) {\n+            super(B);\n+            this.b = b;\n+        }\n+\n+        public int getDimension() {\n+            return 2;\n+        }\n+\n+        /** {@inheritDoc} */\n+        public double getParameter(final String name)\n+            throws IllegalArgumentException {\n+            complainIfNotSupported(name);\n+            return b;\n+        }\n+\n+        /** {@inheritDoc} */\n+        public void setParameter(final String name, final double value)\n+            throws IllegalArgumentException {\n+            complainIfNotSupported(name);\n+            b = value;\n+        }\n+\n+        public void computeDerivatives(double t, double[] y, double[] yDot) {\n+            double prod = y[0] * y[0] * y[1];\n+            yDot[0] = 1 + prod - (b + 1) * y[0];\n+            yDot[1] = b * y[0] - prod;\n+        }\n+\n+        public double dYdP0() {\n+            return -1088.232716447743 + (1050.775747149553 + (-339.012934631828 + 36.52917025056327 * b) * b) * b;\n+        }\n+\n+        public double dYdP1() {\n+            return 1502.824469929139 + (-1438.6974831849952 + (460.959476642384 - 49.43847385647082 * b) * b) * b;\n+        }\n+\n+    }\n+\n+    /** ODE representing a point moving on a circle with provided center and angular rate. */\n+    private static class Circle extends AbstractParameterizable\n+        implements MainStateJacobianProvider, ParameterJacobianProvider {\n+\n+        public static final String CX = \"cx\";\n+        public static final String CY = \"cy\";\n+        public static final String OMEGA = \"omega\";\n+\n+        private final double[] y0;\n+        private double cx;\n+        private double cy;\n+        private double omega;\n+\n+        public Circle(double[] y0, double cx, double cy, double omega) {\n+            super(CX,CY,OMEGA);\n+            this.y0    = y0.clone();\n+            this.cx    = cx;\n+            this.cy    = cy;\n+            this.omega = omega;\n+        }\n+\n+        public int getDimension() {\n+            return 2;\n+        }\n+\n+        public void computeDerivatives(double t, double[] y, double[] yDot) {\n+            yDot[0] = omega * (cy - y[1]);\n+            yDot[1] = omega * (y[0] - cx);\n+        }\n+\n+        public void computeMainStateJacobian(double t, double[] y,\n+                                             double[] yDot, double[][] dFdY) {\n+            dFdY[0][0] = 0;\n+            dFdY[0][1] = -omega;\n+            dFdY[1][0] = omega;\n+            dFdY[1][1] = 0;\n+        }\n+\n+        public void computeParameterJacobian(double t, double[] y, double[] yDot,\n+                                             String paramName, double[] dFdP) {\n+            complainIfNotSupported(paramName);\n+            if (paramName.equals(CX)) {\n+                dFdP[0] = 0;\n+                dFdP[1] = -omega;\n+            } else if (paramName.equals(CY)) {\n+                dFdP[0] = omega;\n+                dFdP[1] = 0;\n+            }  else {\n+                dFdP[0] = cy - y[1];\n+                dFdP[1] = y[0] - cx;\n+            }           \n+        }\n+\n+        public double[] exactY(double t) {\n+            double cos = FastMath.cos(omega * t);\n+            double sin = FastMath.sin(omega * t);\n+            double dx0 = y0[0] - cx;\n+            double dy0 = y0[1] - cy;\n+            return new double[] {\n+                cx + cos * dx0 - sin * dy0,\n+                cy + sin * dx0 + cos * dy0\n+            };\n+        }\n+\n+        public double[][] exactDyDy0(double t) {\n+            double cos = FastMath.cos(omega * t);\n+            double sin = FastMath.sin(omega * t);\n+            return new double[][] {\n+                { cos, -sin },\n+                { sin,  cos }\n+            };\n+        }\n+\n+        public double[] exactDyDcx(double t) {\n+            double cos = FastMath.cos(omega * t);\n+            double sin = FastMath.sin(omega * t);\n+            return new double[] {1 - cos, -sin};\n+        }\n+\n+        public double[] exactDyDcy(double t) {\n+            double cos = FastMath.cos(omega * t);\n+            double sin = FastMath.sin(omega * t);\n+            return new double[] {sin, 1 - cos};\n+        }\n+\n+        public double[] exactDyDom(double t) {\n+            double cos = FastMath.cos(omega * t);\n+            double sin = FastMath.sin(omega * t);\n+            double dx0 = y0[0] - cx;\n+            double dy0 = y0[1] - cy;\n+            return new double[] { -t * (sin * dx0 + cos * dy0) , t * (cos * dx0 - sin * dy0) };\n+        }\n+\n+        public double[][] exactDyDp(double t) {\n+            double cos = FastMath.cos(omega * t);\n+            double sin = FastMath.sin(omega * t);\n+            double dx0 = y0[0] - cx;\n+            double dy0 = y0[1] - cy;\n+            return new double[][] {\n+                { 1 - cos, sin,    -t * (sin * dx0 + cos * dy0) },\n+                { -sin,    1 - cos, t * (cos * dx0 - sin * dy0) }\n+            };\n+        }\n+\n+        public double[] exactYDot(double t) {\n+            double oCos = omega * FastMath.cos(omega * t);\n+            double oSin = omega * FastMath.sin(omega * t);\n+            double dx0 = y0[0] - cx;\n+            double dy0 = y0[1] - cy;\n+            return new double[] {\n+                -oSin * dx0 - oCos * dy0,\n+                 oCos * dx0 - oSin * dy0\n+            };\n+        }\n+\n+        public double[][] exactDyDy0Dot(double t) {\n+            double oCos = omega * FastMath.cos(omega * t);\n+            double oSin = omega * FastMath.sin(omega * t);\n+            return new double[][] {\n+                { -oSin, -oCos },\n+                {  oCos, -oSin }\n+            };\n+        }\n+\n+        public double[][] exactDyDpDot(double t) {\n+            double cos  = FastMath.cos(omega * t);\n+            double sin  = FastMath.sin(omega * t);\n+            double oCos = omega * cos;\n+            double oSin = omega * sin;\n+            double dx0  = y0[0] - cx;\n+            double dy0  = y0[1] - cy;\n+            return new double[][] {\n+                {  oSin, oCos, -sin * dx0 - cos * dy0 - t * ( oCos * dx0 - oSin * dy0) },\n+                { -oCos, oSin,  cos * dx0 - sin * dy0 + t * (-oSin * dx0 - oCos * dy0) }\n+            };\n+        }\n+\n+    }\n+\n+    /** ODE representing a point moving on a circle with provided center and angular rate. */\n+    private static class ParameterizedCircle extends AbstractParameterizable\n+        implements FirstOrderDifferentialEquations, ParameterJacobianProvider, ParameterizedODE {\n+\n+        public static final String CX = \"cx\";\n+        public static final String CY = \"cy\";\n+        public static final String OMEGA = \"omega\";\n+\n+        private final double[] y0;\n+        private double cx;\n+        private double cy;\n+        private double omega;\n+\n+        public ParameterizedCircle(double[] y0, double cx, double cy, double omega) {\n+            super(CX,CY,OMEGA);\n+            this.y0    = y0.clone();\n+            this.cx    = cx;\n+            this.cy    = cy;\n+            this.omega = omega;\n+        }\n+\n+        public int getDimension() {\n+            return 2;\n+        }\n+\n+        public void computeDerivatives(double t, double[] y, double[] yDot) {\n+            yDot[0] = omega * (cy - y[1]);\n+            yDot[1] = omega * (y[0] - cx);\n+        }\n+\n+        public void computeParameterJacobian(double t, double[] y, double[] yDot,\n+                                             String paramName, double[] dFdP)\n+            throws IllegalArgumentException {\n+            if (paramName.equals(CX)) {\n+                dFdP[0] = 0;\n+                dFdP[1] = -omega;\n+            } else {\n+                throw new IllegalArgumentException();\n+            }\n+        }\n+\n+        public double getParameter(final String name)\n+            throws IllegalArgumentException {\n+            if (name.equals(CY)) {\n+                return cy;\n+            } else if (name.equals(OMEGA)) {\n+                return omega;\n+            } else {\n+                throw new IllegalArgumentException();\n+            }\n+        }\n+\n+        public void setParameter(final String name, final double value)\n+            throws IllegalArgumentException {\n+            if (name.equals(CY)) {\n+                cy = value;\n+            } else if (name.equals(OMEGA)) {\n+                omega = value;\n+            } else {\n+                throw new IllegalArgumentException();\n+            }\n+        }\n+\n+        public double[] exactY(double t) {\n+            double cos = FastMath.cos(omega * t);\n+            double sin = FastMath.sin(omega * t);\n+            double dx0 = y0[0] - cx;\n+            double dy0 = y0[1] - cy;\n+            return new double[] {\n+                cx + cos * dx0 - sin * dy0,\n+                cy + sin * dx0 + cos * dy0\n+            };\n+        }\n+\n+        public double[][] exactDyDy0(double t) {\n+            double cos = FastMath.cos(omega * t);\n+            double sin = FastMath.sin(omega * t);\n+            return new double[][] {\n+                { cos, -sin },\n+                { sin,  cos }\n+            };\n+        }\n+\n+        public double[] exactDyDcx(double t) {\n+            double cos = FastMath.cos(omega * t);\n+            double sin = FastMath.sin(omega * t);\n+            return new double[] {1 - cos, -sin};\n+        }\n+\n+        public double[] exactDyDcy(double t) {\n+            double cos = FastMath.cos(omega * t);\n+            double sin = FastMath.sin(omega * t);\n+            return new double[] {sin, 1 - cos};\n+        }\n+\n+        public double[] exactDyDom(double t) {\n+            double cos = FastMath.cos(omega * t);\n+            double sin = FastMath.sin(omega * t);\n+            double dx0 = y0[0] - cx;\n+            double dy0 = y0[1] - cy;\n+            return new double[] { -t * (sin * dx0 + cos * dy0) , t * (cos * dx0 - sin * dy0) };\n+        }\n+\n+    }\n+\n+}\n--- a/src/test/java/org/apache/commons/math/ode/nonstiff/GraggBulirschStoerIntegratorTest.java\n+++ b/src/test/java/org/apache/commons/math/ode/nonstiff/GraggBulirschStoerIntegratorTest.java\n   }\n \n   @Test\n-  public void testUnstableDerivative()\n-    {\n+  public void testUnstableDerivative() {\n     final StepProblem stepProblem = new StepProblem(0.0, 1.0, 2.0);\n     FirstOrderIntegrator integ =\n       new GraggBulirschStoerIntegrator(0.1, 10, 1.0e-12, 0.0);", "timestamp": 1316963079, "metainfo": ""}