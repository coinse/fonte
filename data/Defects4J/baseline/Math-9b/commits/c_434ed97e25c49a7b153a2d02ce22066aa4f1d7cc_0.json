{"sha": "434ed97e25c49a7b153a2d02ce22066aa4f1d7cc", "log": "Added stable random generator based on Chambers-Mallows-Stuck method.  Contributed by Pavel Ryhzov.  JIRA: MATH-462.  ", "commit": "\n--- a/src/main/java/org/apache/commons/math/exception/util/LocalizedFormats.java\n+++ b/src/main/java/org/apache/commons/math/exception/util/LocalizedFormats.java\n     OUT_OF_RANGE_ROOT_OF_UNITY_INDEX(\"out of range root of unity index {0} (must be in [{1};{2}])\"),\n     OUT_OF_RANGE(\"out of range\"), /* keep */\n     OUT_OF_RANGE_SIMPLE(\"{0} out of [{1}, {2}] range\"), /* keep */\n+    OUT_OF_RANGE_LEFT(\"{0} out of ({1}, {2}] range\"),\n+    OUT_OF_RANGE_RIGHT(\"{0} out of [{1}, {2}) range\"),\n     OUTLINE_BOUNDARY_LOOP_OPEN(\"an outline boundary loop is open\"),\n     OVERFLOW(\"overflow\"), /* keep */\n     OVERFLOW_IN_FRACTION(\"overflow in fraction {0}/{1}, cannot negate\"),\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/random/StableRandomGenerator.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.random;\n+\n+import org.apache.commons.math.exception.NullArgumentException;\n+import org.apache.commons.math.exception.OutOfRangeException;\n+import org.apache.commons.math.exception.util.LocalizedFormats;\n+import org.apache.commons.math.util.FastMath;\n+\n+/**\n+ * <p>This class provides a stable normalized random generator. It samples from a stable\n+ * distribution with location parameter 0 and scale 1.</p>\n+ *\n+ * <p>The implementation uses the Chambers-Mallows-Stuck method as described in\n+ * <i>Handbook of computational statistics: concepts and methods</i> by\n+ * James E. Gentle, Wolfgang Hrdle, Yuichi Mori.</p>\n+ *\n+ * @version $Id$\n+ * @since 3.0\n+ */\n+public class StableRandomGenerator implements NormalizedRandomGenerator {\n+    /** Underlying generator. */\n+    private final RandomGenerator generator;\n+\n+    /** stability parameter */\n+    private final double alpha;\n+\n+    /** skewness parameter */\n+    private final double beta;\n+\n+    /** cache of expression value used in generation */\n+    private final double zeta;\n+\n+    /**\n+     * Create a new generator.\n+     *\n+     * @param generator underlying random generator to use\n+     * @param alpha Stability parameter. Must be in range (0, 2]\n+     * @param beta Skewness parameter. Must be in range [-1, 1]\n+     */\n+    public StableRandomGenerator(final RandomGenerator generator, double alpha,\n+            double beta) {\n+        if (generator == null) {\n+            throw new NullArgumentException();\n+        }\n+\n+        if (!(alpha > 0d && alpha <= 2d)) {\n+            throw new OutOfRangeException(LocalizedFormats.OUT_OF_RANGE_LEFT,\n+                    alpha, 0, 2);\n+        }\n+\n+        if (!(beta >= -1d && beta <= 1d)) {\n+            throw new OutOfRangeException(LocalizedFormats.OUT_OF_RANGE_SIMPLE,\n+                    beta, -1, 1);\n+        }\n+\n+        this.generator = generator;\n+        this.alpha = alpha;\n+        this.beta = beta;\n+        if (alpha < 2d && beta != 0d) {\n+            zeta = beta * FastMath.tan(FastMath.PI * alpha / 2);\n+        } else {\n+            zeta = 0d;\n+        }\n+    }\n+\n+    /**\n+     * Generate a random scalar with zero location and unit scale.\n+     *\n+     * @return a random scalar with zero location and unit scale\n+     */\n+    public double nextNormalizedDouble() {\n+        // we need 2 uniform random numbers to calculate omega and phi\n+        double omega = -FastMath.log(generator.nextDouble());\n+        double phi = FastMath.PI * (generator.nextDouble() - 0.5);\n+\n+        // Normal distribution case (Box-Muller algorithm)\n+        if (alpha == 2d) {\n+            return FastMath.sqrt(2d * omega) * FastMath.sin(phi);\n+        }\n+\n+        double x;\n+        // when beta = 0, zeta is zero as well\n+        // Thus we can exclude it from the formula\n+        if (beta == 0d) {\n+            // Cauchy distribution case\n+            if (alpha == 1d) {\n+                x = FastMath.tan(phi);\n+            } else {\n+                x = FastMath.pow(omega * FastMath.cos((1 - alpha) * phi),\n+                    1d / alpha - 1d) *\n+                    FastMath.sin(alpha * phi) /\n+                    FastMath.pow(FastMath.cos(phi), 1d / alpha);\n+            }\n+        } else {\n+            // Generic stable distribution\n+            double cosPhi = FastMath.cos(phi);\n+            // to avoid rounding errors around alpha = 1\n+            if (FastMath.abs(alpha - 1d) > 1e-8) {\n+                double alphaPhi = alpha * phi;\n+                double invAlphaPhi = phi - alphaPhi;\n+                x = (FastMath.sin(alphaPhi) + zeta * FastMath.cos(alphaPhi)) / cosPhi *\n+                    (FastMath.cos(invAlphaPhi) + zeta * FastMath.sin(invAlphaPhi)) /\n+                     FastMath.pow(omega * cosPhi, (1 - alpha) / alpha);\n+            } else {\n+                double betaPhi = FastMath.PI / 2 + beta * phi;\n+                x = 2d / FastMath.PI * (betaPhi * FastMath.tan(phi) - beta *\n+                    FastMath.log(FastMath.PI / 2d * omega * cosPhi / betaPhi));\n+\n+                if (alpha != 1d) {\n+                    x = x + beta * FastMath.tan(FastMath.PI * alpha / 2);\n+                }\n+            }\n+        }\n+        return x;\n+    }\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/math/random/StableRandomGeneratorTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.random;\n+\n+import junit.framework.TestCase;\n+\n+import org.apache.commons.math.exception.OutOfRangeException;\n+import org.apache.commons.math.stat.StatUtils;\n+import org.apache.commons.math.stat.descriptive.DescriptiveStatistics;\n+\n+/**\n+ * The class <code>StableRandomGeneratorTest</code> contains tests for the class\n+ * {@link <code>StableRandomGenerator</code>}\n+ * \n+ * @version $Revision$\n+ */\n+public class StableRandomGeneratorTest extends TestCase {\n+\n+    private RandomGenerator rg = new Well19937c(100);\n+    private final static int sampleSize = 10000;\n+\n+    /**\n+     * Construct new test instance\n+     * \n+     * @param name the test name\n+     */\n+    public StableRandomGeneratorTest(String name) {\n+        super(name);\n+    }\n+\n+    /**\n+     * Run the double nextDouble() method test Due to leptokurtic property the\n+     * acceptance range is widened.\n+     */\n+    public void testNextDouble() {\n+        StableRandomGenerator generator = new StableRandomGenerator(rg, 1.3,\n+                0.1);\n+        double[] sample = new double[2 * sampleSize];\n+        for (int i = 0; i < sample.length; ++i) {\n+            sample[i] = generator.nextNormalizedDouble();\n+        }\n+        assertEquals(0.0, StatUtils.mean(sample), 0.2);\n+    }\n+\n+    /**\n+     * If alpha = 2, than it must be Gaussian distribution\n+     */\n+    public void testGaussianCase() {\n+        StableRandomGenerator generator = new StableRandomGenerator(rg, 2d, 0.0);\n+\n+        double[] sample = new double[sampleSize];\n+        for (int i = 0; i < sample.length; ++i) {\n+            sample[i] = generator.nextNormalizedDouble();\n+        }\n+        assertEquals(0.0, StatUtils.mean(sample), 0.02);\n+        assertEquals(1.0, StatUtils.variance(sample), 0.02);\n+    }\n+\n+    /**\n+     * If alpha = 1, than it must be Cauchy distribution\n+     */\n+    public void testCauchyCase() {\n+        StableRandomGenerator generator = new StableRandomGenerator(rg, 1d, 0.0);\n+        DescriptiveStatistics summary = new DescriptiveStatistics();\n+\n+        for (int i = 0; i < sampleSize; ++i) {\n+            double sample = generator.nextNormalizedDouble();\n+            summary.addValue(sample);\n+        }\n+\n+        // Standard Cauchy distribution should have zero median and mode\n+        double median = summary.getPercentile(50);\n+        assertEquals(0.0, median, 0.2);\n+    }\n+\n+    /**\n+     * Input parameter range tests\n+     */\n+    public void testAlphaRangeBelowZero() {\n+        try {\n+            StableRandomGenerator generator = new StableRandomGenerator(rg,\n+                    -1.0, 0.0);\n+        } catch (OutOfRangeException e) {\n+            assertEquals(-1.0, e.getArgument());\n+        }\n+    }\n+\n+    public void testAlphaRangeAboveTwo() {\n+        try {\n+            StableRandomGenerator generator = new StableRandomGenerator(rg,\n+                    3.0, 0.0);\n+        } catch (OutOfRangeException e) {\n+            assertEquals(3.0, e.getArgument());\n+        }\n+    }\n+\n+    public void testBetaRangeBelowMinusOne() {\n+        try {\n+            StableRandomGenerator generator = new StableRandomGenerator(rg,\n+                    1.0, -2.0);\n+        } catch (OutOfRangeException e) {\n+            assertEquals(-2.0, e.getArgument());\n+        }\n+    }\n+\n+    public void testBetaRangeAboveOne() {\n+        try {\n+            StableRandomGenerator generator = new StableRandomGenerator(rg,\n+                    1.0, 2.0);\n+        } catch (OutOfRangeException e) {\n+            assertEquals(2.0, e.getArgument());\n+        }\n+    }\n+}", "timestamp": 1320563870, "metainfo": ""}