{"sha": "f8b5accabf0f0d90d004e67cb109eb2512d3a471", "log": "replaced arbitrarily small thresholds by 0 where it was sensible with respect to IEEE754 removed unnecessary else clauses removed double indices where possible fixed some comments   ", "commit": "\n--- a/src/java/org/apache/commons/math/geometry/Rotation.java\n+++ b/src/java/org/apache/commons/math/geometry/Rotation.java\n     // There are different ways to compute the quaternions elements\n     // from the matrix. They all involve computing one element from\n     // the diagonal of the matrix, and computing the three other ones\n-    // unsing a formula involving a division by the first element,\n+    // using a formula involving a division by the first element,\n     // which unfortunately can be null. Since the norm of the\n     // quaternion is 1, we know at least one element has an absolute\n     // value greater or equal to 0.5, so it is always possible to\n   double u2u2 = Vector3D.dotProduct(u2, u2);\n   double v1v1 = Vector3D.dotProduct(v1, v1);\n   double v2v2 = Vector3D.dotProduct(v2, v2);\n-  if ((u1u1 < 1.0e-15) || (u2u2 < 1.0e-15)\n-      || (v1v1 < 1.0e-15) || (v2v2 < 1.0e-15))\n+  if ((u1u1 == 0) || (u2u2 == 0) || (v1v1 == 0) || (v2v2 == 0)) {\n     throw new ArithmeticException(\"null norm\");\n+  }\n \n   double u1x = u1.getX();\n   double u1y = u1.getY();\n   double u2y = u2.getY();\n   double u2z = u2.getZ();\n \n-  // renormalize v1 in order to have (v1'|v1') = (u1|u1)\n+  // normalize v1 in order to have (v1'|v1') = (u1|u1)\n   double coeff = Math.sqrt (u1u1 / v1v1);\n   double v1x   = coeff * v1.getX();\n   double v1y   = coeff * v1.getY();\n            + k.getY() * (u1z * u2x - u1x * u2z)\n            + k.getZ() * (u1x * u2y - u1y * u2x);\n \n-  if (c < (1.0e-10 * u1u1 * u2u2)) {\n+  if (c == 0) {\n     // the (q1, q2, q3) vector is in the (u1, u2) plane\n     // we try other vectors\n     Vector3D u3 = Vector3D.crossProduct(u1, u2);\n     double v3x  = v3.getX();\n     double v3y  = v3.getY();\n     double v3z  = v3.getZ();\n-    double u3u3 = u1u1 * u2u2 - u1u2 * u1u2;\n \n     double dx3 = v3x - u3x;\n     double dy3 = v3y - u3y;\n       + k.getY() * (u1z * u3x - u1x * u3z)\n       + k.getZ() * (u1x * u3y - u1y * u3x);\n \n-    if (c < (1.0e-10 * u1u1 * u3u3)) {\n+    if (c == 0) {\n       // the (q1, q2, q3) vector is aligned with u1:\n       // we try (u2, u3) and (v2, v3)\n       k = new Vector3D(dy2 * dz3 - dz2 * dy3,\n         + k.getY() * (u2z * u3x - u2x * u3z)\n         + k.getZ() * (u2x * u3y - u2y * u3x);\n \n-      if (c < (1.0e-10 * u2u2 * u3u3)) {\n+      if (c == 0) {\n         // the (q1, q2, q3) vector is aligned with everything\n         // this is really the identity rotation\n         q0 = 1.0;\n   public Rotation(Vector3D u, Vector3D v) {\n \n     double normProduct = u.getNorm() * v.getNorm();\n-    if (normProduct < 1.0e-15) {\n+    if (normProduct == 0) {\n       throw new ArithmeticException(\"null norm\");\n     }\n \n    */\n   public Vector3D getAxis() {\n     double squaredSine = q1 * q1 + q2 * q2 + q3 * q3;\n-    if (squaredSine < 1.0e-12) {\n+    if (squaredSine == 0) {\n       return new Vector3D(1, 0, 0);\n     } else if (q0 < 0) {\n       double inverse = 1 / Math.sqrt(squaredSine);\n       return new Vector3D(q1 * inverse, q2 * inverse, q3 * inverse);\n-    } else {\n-      double inverse = -1 / Math.sqrt(squaredSine);\n-      return new Vector3D(q1 * inverse, q2 * inverse, q3 * inverse);\n-    }\n+    }\n+    double inverse = -1 / Math.sqrt(squaredSine);\n+    return new Vector3D(q1 * inverse, q2 * inverse, q3 * inverse);\n   }\n \n   /** Get the angle of the rotation.\n       return 2 * Math.asin(Math.sqrt(q1 * q1 + q2 * q2 + q3 * q3));\n     } else if (q0 < 0) {\n       return 2 * Math.acos(-q0);\n-    } else {\n-      return 2 * Math.acos(q0);\n-    }\n+    }\n+    return 2 * Math.acos(q0);\n   }\n \n   /** Get the Cardan or Euler angles corresponding to the instance.\n    */\n   private double[][] orthogonalizeMatrix(double[][] m, double threshold)\n     throws NotARotationMatrixException {\n-    double x00 = m[0][0];\n-    double x01 = m[0][1];\n-    double x02 = m[0][2];\n-    double x10 = m[1][0];\n-    double x11 = m[1][1];\n-    double x12 = m[1][2];\n-    double x20 = m[2][0];\n-    double x21 = m[2][1];\n-    double x22 = m[2][2];\n+    double[] m0 = m[0];\n+    double[] m1 = m[1];\n+    double[] m2 = m[2];\n+    double x00 = m0[0];\n+    double x01 = m0[1];\n+    double x02 = m0[2];\n+    double x10 = m1[0];\n+    double x11 = m1[1];\n+    double x12 = m1[2];\n+    double x20 = m2[0];\n+    double x21 = m2[1];\n+    double x22 = m2[2];\n     double fn = 0;\n     double fn1;\n \n-    double[][] o = new double[3][];\n-    o[0] = new double[3];\n-    o[1] = new double[3];\n-    o[2] = new double[3];\n+    double[][] o = new double[3][3];\n+    double[] o0 = o[0];\n+    double[] o1 = o[1];\n+    double[] o2 = o[2];\n \n     // iterative correction: Xn+1 = Xn - 0.5 * (Xn.Mt.Xn - M)\n     int i = 0;\n     while (++i < 11) {\n \n       // Mt.Xn\n-      double mx00 = m[0][0] * x00 + m[1][0] * x10 + m[2][0] * x20;\n-      double mx10 = m[0][1] * x00 + m[1][1] * x10 + m[2][1] * x20;\n-      double mx20 = m[0][2] * x00 + m[1][2] * x10 + m[2][2] * x20;\n-      double mx01 = m[0][0] * x01 + m[1][0] * x11 + m[2][0] * x21;\n-      double mx11 = m[0][1] * x01 + m[1][1] * x11 + m[2][1] * x21;\n-      double mx21 = m[0][2] * x01 + m[1][2] * x11 + m[2][2] * x21;\n-      double mx02 = m[0][0] * x02 + m[1][0] * x12 + m[2][0] * x22;\n-      double mx12 = m[0][1] * x02 + m[1][1] * x12 + m[2][1] * x22;\n-      double mx22 = m[0][2] * x02 + m[1][2] * x12 + m[2][2] * x22;\n+      double mx00 = m0[0] * x00 + m1[0] * x10 + m2[0] * x20;\n+      double mx10 = m0[1] * x00 + m1[1] * x10 + m2[1] * x20;\n+      double mx20 = m0[2] * x00 + m1[2] * x10 + m2[2] * x20;\n+      double mx01 = m0[0] * x01 + m1[0] * x11 + m2[0] * x21;\n+      double mx11 = m0[1] * x01 + m1[1] * x11 + m2[1] * x21;\n+      double mx21 = m0[2] * x01 + m1[2] * x11 + m2[2] * x21;\n+      double mx02 = m0[0] * x02 + m1[0] * x12 + m2[0] * x22;\n+      double mx12 = m0[1] * x02 + m1[1] * x12 + m2[1] * x22;\n+      double mx22 = m0[2] * x02 + m1[2] * x12 + m2[2] * x22;\n \n       // Xn+1\n-      o[0][0] = x00 - 0.5 * (x00 * mx00 + x01 * mx10 + x02 * mx20 - m[0][0]);\n-      o[0][1] = x01 - 0.5 * (x00 * mx01 + x01 * mx11 + x02 * mx21 - m[0][1]);\n-      o[0][2] = x02 - 0.5 * (x00 * mx02 + x01 * mx12 + x02 * mx22 - m[0][2]);\n-      o[1][0] = x10 - 0.5 * (x10 * mx00 + x11 * mx10 + x12 * mx20 - m[1][0]);\n-      o[1][1] = x11 - 0.5 * (x10 * mx01 + x11 * mx11 + x12 * mx21 - m[1][1]);\n-      o[1][2] = x12 - 0.5 * (x10 * mx02 + x11 * mx12 + x12 * mx22 - m[1][2]);\n-      o[2][0] = x20 - 0.5 * (x20 * mx00 + x21 * mx10 + x22 * mx20 - m[2][0]);\n-      o[2][1] = x21 - 0.5 * (x20 * mx01 + x21 * mx11 + x22 * mx21 - m[2][1]);\n-      o[2][2] = x22 - 0.5 * (x20 * mx02 + x21 * mx12 + x22 * mx22 - m[2][2]);\n+      o0[0] = x00 - 0.5 * (x00 * mx00 + x01 * mx10 + x02 * mx20 - m0[0]);\n+      o0[1] = x01 - 0.5 * (x00 * mx01 + x01 * mx11 + x02 * mx21 - m0[1]);\n+      o0[2] = x02 - 0.5 * (x00 * mx02 + x01 * mx12 + x02 * mx22 - m0[2]);\n+      o1[0] = x10 - 0.5 * (x10 * mx00 + x11 * mx10 + x12 * mx20 - m1[0]);\n+      o1[1] = x11 - 0.5 * (x10 * mx01 + x11 * mx11 + x12 * mx21 - m1[1]);\n+      o1[2] = x12 - 0.5 * (x10 * mx02 + x11 * mx12 + x12 * mx22 - m1[2]);\n+      o2[0] = x20 - 0.5 * (x20 * mx00 + x21 * mx10 + x22 * mx20 - m2[0]);\n+      o2[1] = x21 - 0.5 * (x20 * mx01 + x21 * mx11 + x22 * mx21 - m2[1]);\n+      o2[2] = x22 - 0.5 * (x20 * mx02 + x21 * mx12 + x22 * mx22 - m2[2]);\n \n       // correction on each elements\n-      double corr00 = o[0][0] - m[0][0];\n-      double corr01 = o[0][1] - m[0][1];\n-      double corr02 = o[0][2] - m[0][2];\n-      double corr10 = o[1][0] - m[1][0];\n-      double corr11 = o[1][1] - m[1][1];\n-      double corr12 = o[1][2] - m[1][2];\n-      double corr20 = o[2][0] - m[2][0];\n-      double corr21 = o[2][1] - m[2][1];\n-      double corr22 = o[2][2] - m[2][2];\n+      double corr00 = o0[0] - m0[0];\n+      double corr01 = o0[1] - m0[1];\n+      double corr02 = o0[2] - m0[2];\n+      double corr10 = o1[0] - m1[0];\n+      double corr11 = o1[1] - m1[1];\n+      double corr12 = o1[2] - m1[2];\n+      double corr20 = o2[0] - m2[0];\n+      double corr21 = o2[1] - m2[1];\n+      double corr22 = o2[2] - m2[2];\n \n       // Frobenius norm of the correction\n       fn1 = corr00 * corr00 + corr01 * corr01 + corr02 * corr02\n-        + corr10 * corr10 + corr11 * corr11 + corr12 * corr12\n-        + corr20 * corr20 + corr21 * corr21 + corr22 * corr22;\n+          + corr10 * corr10 + corr11 * corr11 + corr12 * corr12\n+          + corr20 * corr20 + corr21 * corr21 + corr22 * corr22;\n \n       // convergence test\n       if (Math.abs(fn1 - fn) <= threshold)\n         return o;\n \n       // prepare next iteration\n-      x00 = o[0][0];\n-      x01 = o[0][1];\n-      x02 = o[0][2];\n-      x10 = o[1][0];\n-      x11 = o[1][1];\n-      x12 = o[1][2];\n-      x20 = o[2][0];\n-      x21 = o[2][1];\n-      x22 = o[2][2];\n+      x00 = o0[0];\n+      x01 = o0[1];\n+      x02 = o0[2];\n+      x10 = o1[0];\n+      x11 = o1[1];\n+      x12 = o1[2];\n+      x20 = o2[0];\n+      x21 = o2[1];\n+      x22 = o2[2];\n       fn  = fn1;\n \n     }", "timestamp": 1189435183, "metainfo": ""}