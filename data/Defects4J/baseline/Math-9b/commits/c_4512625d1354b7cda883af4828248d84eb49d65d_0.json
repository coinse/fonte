{"sha": "4512625d1354b7cda883af4828248d84eb49d65d", "log": "Merged CholeskyDecomposition and CholeskyDecompositionImpl (see MATH-662).  ", "commit": "\n--- a/src/main/java/org/apache/commons/math/filter/KalmanFilter.java\n+++ b/src/main/java/org/apache/commons/math/filter/KalmanFilter.java\n import org.apache.commons.math.exception.DimensionMismatchException;\n import org.apache.commons.math.linear.Array2DRowRealMatrix;\n import org.apache.commons.math.linear.ArrayRealVector;\n-import org.apache.commons.math.linear.CholeskyDecompositionImpl;\n+import org.apache.commons.math.linear.CholeskyDecomposition;\n import org.apache.commons.math.linear.DecompositionSolver;\n import org.apache.commons.math.linear.MatrixDimensionMismatchException;\n import org.apache.commons.math.linear.MatrixUtils;\n         // invert S\n         // as the error covariance matrix is a symmetric positive\n         // semi-definite matrix, we can use the cholesky decomposition\n-        DecompositionSolver solver = new CholeskyDecompositionImpl(s).getSolver();\n+        DecompositionSolver solver = new CholeskyDecomposition(s).getSolver();\n         RealMatrix invertedS = solver.getInverse();\n \n         // Inn = z(k) - H * xHat(k)-\n--- a/src/main/java/org/apache/commons/math/linear/CholeskyDecomposition.java\n+++ b/src/main/java/org/apache/commons/math/linear/CholeskyDecomposition.java\n \n package org.apache.commons.math.linear;\n \n+import org.apache.commons.math.exception.DimensionMismatchException;\n+import org.apache.commons.math.util.FastMath;\n+\n \n /**\n- * An interface to classes that implement an algorithm to calculate the\n- * Cholesky decomposition of a real symmetric positive-definite matrix.\n+ * Calculates the Cholesky decomposition of a matrix.\n  * <p>The Cholesky decomposition of a real symmetric positive-definite\n  * matrix A consists of a lower triangular matrix L with same size such\n  * that: A = LL<sup>T</sup>. In a sense, this is the square root of A.</p>\n- * <p>This interface is based on the class with similar name from the\n+ * <p>This class is based on the class with similar name from the\n  * <a href=\"http://math.nist.gov/javanumerics/jama/\">JAMA</a> library, with the\n  * following changes:</p>\n  * <ul>\n  *   <li>a {@link #getLT() getLT} method has been added,</li>\n- *   <li>the <code>isspd</code> method has been removed, the constructors of\n- *   implementation classes being expected to throw {@link NonPositiveDefiniteMatrixException}\n- *   when a matrix cannot be decomposed,</li>\n+ *   <li>the {@code isspd} method has been removed, since the constructor of\n+ *   this class throws a {@link NonPositiveDefiniteMatrixException} when a\n+ *   matrix cannot be decomposed,</li>\n  *   <li>a {@link #getDeterminant() getDeterminant} method has been added,</li>\n- *   <li>the <code>solve</code> method has been replaced by a {@link\n- *   #getSolver() getSolver} method and the equivalent method provided by\n- *   the returned {@link DecompositionSolver}.</li>\n+ *   <li>the {@code solve} method has been replaced by a {@link #getSolver()\n+ *   getSolver} method and the equivalent method provided by the returned\n+ *   {@link DecompositionSolver}.</li>\n  * </ul>\n  *\n  * @see <a href=\"http://mathworld.wolfram.com/CholeskyDecomposition.html\">MathWorld</a>\n  * @version $Id$\n  * @since 2.0\n  */\n-public interface CholeskyDecomposition {\n+public class CholeskyDecomposition {\n+    /**\n+     * Default threshold above which off-diagonal elements are considered too different\n+     * and matrix not symmetric.\n+     */\n+    public static final double DEFAULT_RELATIVE_SYMMETRY_THRESHOLD = 1.0e-15;\n+    /**\n+     * Default threshold below which diagonal elements are considered null\n+     * and matrix not positive definite.\n+     */\n+    public static final double DEFAULT_ABSOLUTE_POSITIVITY_THRESHOLD = 1.0e-10;\n+    /** Row-oriented storage for L<sup>T</sup> matrix data. */\n+    private double[][] lTData;\n+    /** Cached value of L. */\n+    private RealMatrix cachedL;\n+    /** Cached value of LT. */\n+    private RealMatrix cachedLT;\n+\n+    /**\n+     * Calculates the Cholesky decomposition of the given matrix.\n+     * <p>\n+     * Calling this constructor is equivalent to call {@link\n+     * #CholeskyDecompositionImpl(RealMatrix, double, double)} with the\n+     * thresholds set to the default values {@link\n+     * #DEFAULT_RELATIVE_SYMMETRY_THRESHOLD} and {@link\n+     * #DEFAULT_ABSOLUTE_POSITIVITY_THRESHOLD}\n+     * </p>\n+     * @param matrix the matrix to decompose\n+     * @throws NonSquareMatrixException if the matrix is not square.\n+     * @throws NonSymmetricMatrixException if the matrix is not symmetric.\n+     * @throws NonPositiveDefiniteMatrixException if the matrix is not\n+     * strictly positive definite.\n+     * @see #CholeskyDecompositionImpl(RealMatrix, double, double)\n+     * @see #DEFAULT_RELATIVE_SYMMETRY_THRESHOLD\n+     * @see #DEFAULT_ABSOLUTE_POSITIVITY_THRESHOLD\n+     */\n+    public CholeskyDecomposition(final RealMatrix matrix) {\n+        this(matrix, DEFAULT_RELATIVE_SYMMETRY_THRESHOLD,\n+             DEFAULT_ABSOLUTE_POSITIVITY_THRESHOLD);\n+    }\n+\n+    /**\n+     * Calculates the Cholesky decomposition of the given matrix.\n+     * @param matrix the matrix to decompose\n+     * @param relativeSymmetryThreshold threshold above which off-diagonal\n+     * elements are considered too different and matrix not symmetric\n+     * @param absolutePositivityThreshold threshold below which diagonal\n+     * elements are considered null and matrix not positive definite\n+     * @throws NonSquareMatrixException if the matrix is not square.\n+     * @throws NonSymmetricMatrixException if the matrix is not symmetric.\n+     * @throws NonPositiveDefiniteMatrixException if the matrix is not\n+     * strictly positive definite.\n+     * @see #CholeskyDecompositionImpl(RealMatrix)\n+     * @see #DEFAULT_RELATIVE_SYMMETRY_THRESHOLD\n+     * @see #DEFAULT_ABSOLUTE_POSITIVITY_THRESHOLD\n+     */\n+    public CholeskyDecomposition(final RealMatrix matrix,\n+                                     final double relativeSymmetryThreshold,\n+                                     final double absolutePositivityThreshold) {\n+        if (!matrix.isSquare()) {\n+            throw new NonSquareMatrixException(matrix.getRowDimension(),\n+                                               matrix.getColumnDimension());\n+        }\n+\n+        final int order = matrix.getRowDimension();\n+        lTData   = matrix.getData();\n+        cachedL  = null;\n+        cachedLT = null;\n+\n+        // check the matrix before transformation\n+        for (int i = 0; i < order; ++i) {\n+            final double[] lI = lTData[i];\n+\n+            // check off-diagonal elements (and reset them to 0)\n+            for (int j = i + 1; j < order; ++j) {\n+                final double[] lJ = lTData[j];\n+                final double lIJ = lI[j];\n+                final double lJI = lJ[i];\n+                final double maxDelta =\n+                    relativeSymmetryThreshold * FastMath.max(FastMath.abs(lIJ), FastMath.abs(lJI));\n+                if (FastMath.abs(lIJ - lJI) > maxDelta) {\n+                    throw new NonSymmetricMatrixException(i, j, relativeSymmetryThreshold);\n+                }\n+                lJ[i] = 0;\n+           }\n+        }\n+\n+        // transform the matrix\n+        for (int i = 0; i < order; ++i) {\n+\n+            final double[] ltI = lTData[i];\n+\n+            // check diagonal element\n+            if (ltI[i] <= absolutePositivityThreshold) {\n+                throw new NonPositiveDefiniteMatrixException(ltI[i], i, absolutePositivityThreshold);\n+            }\n+\n+            ltI[i] = FastMath.sqrt(ltI[i]);\n+            final double inverse = 1.0 / ltI[i];\n+\n+            for (int q = order - 1; q > i; --q) {\n+                ltI[q] *= inverse;\n+                final double[] ltQ = lTData[q];\n+                for (int p = q; p < order; ++p) {\n+                    ltQ[p] -= ltI[q] * ltI[p];\n+                }\n+            }\n+        }\n+    }\n+\n     /**\n      * Returns the matrix L of the decomposition.\n      * <p>L is an lower-triangular matrix</p>\n      * @return the L matrix\n      */\n-    RealMatrix getL();\n+    public RealMatrix getL() {\n+        if (cachedL == null) {\n+            cachedL = getLT().transpose();\n+        }\n+        return cachedL;\n+    }\n \n     /**\n      * Returns the transpose of the matrix L of the decomposition.\n      * <p>L<sup>T</sup> is an upper-triangular matrix</p>\n      * @return the transpose of the matrix L of the decomposition\n      */\n-    RealMatrix getLT();\n+    public RealMatrix getLT() {\n+\n+        if (cachedLT == null) {\n+            cachedLT = MatrixUtils.createRealMatrix(lTData);\n+        }\n+\n+        // return the cached matrix\n+        return cachedLT;\n+    }\n \n     /**\n      * Return the determinant of the matrix\n      * @return determinant of the matrix\n      */\n-    double getDeterminant();\n+    public double getDeterminant() {\n+        double determinant = 1.0;\n+        for (int i = 0; i < lTData.length; ++i) {\n+            double lTii = lTData[i][i];\n+            determinant *= lTii * lTii;\n+        }\n+        return determinant;\n+    }\n \n     /**\n      * Get a solver for finding the A &times; X = B solution in least square sense.\n      * @return a solver\n      */\n-    DecompositionSolver getSolver();\n+    public DecompositionSolver getSolver() {\n+        return new Solver(lTData);\n+    }\n+\n+    /** Specialized solver. */\n+    private static class Solver implements DecompositionSolver {\n+        /** Row-oriented storage for L<sup>T</sup> matrix data. */\n+        private final double[][] lTData;\n+\n+        /**\n+         * Build a solver from decomposed matrix.\n+         * @param lTData row-oriented storage for L<sup>T</sup> matrix data\n+         */\n+        private Solver(final double[][] lTData) {\n+            this.lTData = lTData;\n+        }\n+\n+        /** {@inheritDoc} */\n+        public boolean isNonSingular() {\n+            // if we get this far, the matrix was positive definite, hence non-singular\n+            return true;\n+        }\n+\n+        /** {@inheritDoc} */\n+        public RealVector solve(final RealVector b) {\n+            final int m = lTData.length;\n+            if (b.getDimension() != m) {\n+                throw new DimensionMismatchException(b.getDimension(), m);\n+            }\n+\n+            final double[] x = b.toArray();\n+\n+            // Solve LY = b\n+            for (int j = 0; j < m; j++) {\n+                final double[] lJ = lTData[j];\n+                x[j] /= lJ[j];\n+                final double xJ = x[j];\n+                for (int i = j + 1; i < m; i++) {\n+                    x[i] -= xJ * lJ[i];\n+                }\n+            }\n+\n+            // Solve LTX = Y\n+            for (int j = m - 1; j >= 0; j--) {\n+                x[j] /= lTData[j][j];\n+                final double xJ = x[j];\n+                for (int i = 0; i < j; i++) {\n+                    x[i] -= xJ * lTData[i][j];\n+                }\n+            }\n+\n+            return new ArrayRealVector(x, false);\n+        }\n+\n+        /** {@inheritDoc} */\n+        public RealMatrix solve(RealMatrix b) {\n+            final int m = lTData.length;\n+            if (b.getRowDimension() != m) {\n+                throw new DimensionMismatchException(b.getRowDimension(), m);\n+            }\n+\n+            final int nColB = b.getColumnDimension();\n+            final double[][] x = b.getData();\n+\n+            // Solve LY = b\n+            for (int j = 0; j < m; j++) {\n+                final double[] lJ = lTData[j];\n+                final double lJJ = lJ[j];\n+                final double[] xJ = x[j];\n+                for (int k = 0; k < nColB; ++k) {\n+                    xJ[k] /= lJJ;\n+                }\n+                for (int i = j + 1; i < m; i++) {\n+                    final double[] xI = x[i];\n+                    final double lJI = lJ[i];\n+                    for (int k = 0; k < nColB; ++k) {\n+                        xI[k] -= xJ[k] * lJI;\n+                    }\n+                }\n+            }\n+\n+            // Solve LTX = Y\n+            for (int j = m - 1; j >= 0; j--) {\n+                final double lJJ = lTData[j][j];\n+                final double[] xJ = x[j];\n+                for (int k = 0; k < nColB; ++k) {\n+                    xJ[k] /= lJJ;\n+                }\n+                for (int i = 0; i < j; i++) {\n+                    final double[] xI = x[i];\n+                    final double lIJ = lTData[i][j];\n+                    for (int k = 0; k < nColB; ++k) {\n+                        xI[k] -= xJ[k] * lIJ;\n+                    }\n+                }\n+            }\n+\n+            return new Array2DRowRealMatrix(x);\n+        }\n+\n+        /** {@inheritDoc} */\n+        public RealMatrix getInverse() {\n+            return solve(MatrixUtils.createRealIdentityMatrix(lTData.length));\n+        }\n+    }\n }\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/math/linear/CholeskyDecompositionTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.linear;\n+\n+import org.junit.Test;\n+import org.junit.Assert;\n+\n+public class CholeskyDecompositionTest {\n+\n+    private double[][] testData = new double[][] {\n+            {  1,  2,   4,   7,  11 },\n+            {  2, 13,  23,  38,  58 },\n+            {  4, 23,  77, 122, 182 },\n+            {  7, 38, 122, 294, 430 },\n+            { 11, 58, 182, 430, 855 }\n+    };\n+\n+    /** test dimensions */\n+    @Test\n+    public void testDimensions() {\n+        CholeskyDecomposition llt =\n+            new CholeskyDecomposition(MatrixUtils.createRealMatrix(testData));\n+        Assert.assertEquals(testData.length, llt.getL().getRowDimension());\n+        Assert.assertEquals(testData.length, llt.getL().getColumnDimension());\n+        Assert.assertEquals(testData.length, llt.getLT().getRowDimension());\n+        Assert.assertEquals(testData.length, llt.getLT().getColumnDimension());\n+    }\n+\n+    /** test non-square matrix */\n+    @Test(expected = NonSquareMatrixException.class)\n+    public void testNonSquare() {\n+        new CholeskyDecomposition(MatrixUtils.createRealMatrix(new double[3][2]));\n+    }\n+\n+    /** test non-symmetric matrix */\n+    @Test(expected = NonSymmetricMatrixException.class)\n+    public void testNotSymmetricMatrixException() {\n+        double[][] changed = testData.clone();\n+        changed[0][changed[0].length - 1] += 1.0e-5;\n+        new CholeskyDecomposition(MatrixUtils.createRealMatrix(changed));\n+    }\n+\n+    /** test non positive definite matrix */\n+    @Test(expected = NonPositiveDefiniteMatrixException.class)\n+    public void testNotPositiveDefinite() {\n+        new CholeskyDecomposition(MatrixUtils.createRealMatrix(new double[][] {\n+                { 14, 11, 13, 15, 24 },\n+                { 11, 34, 13, 8,  25 },\n+                { 13, 13, 14, 15, 21 },\n+                { 15, 8,  15, 18, 23 },\n+                { 24, 25, 21, 23, 45 }\n+        }));\n+    }\n+\n+    @Test(expected = NonPositiveDefiniteMatrixException.class)\n+    public void testMath274() {\n+        new CholeskyDecomposition(MatrixUtils.createRealMatrix(new double[][] {\n+                { 0.40434286, -0.09376327, 0.30328980, 0.04909388 },\n+                {-0.09376327,  0.10400408, 0.07137959, 0.04762857 },\n+                { 0.30328980,  0.07137959, 0.30458776, 0.04882449 },\n+                { 0.04909388,  0.04762857, 0.04882449, 0.07543265 }\n+\n+        }));\n+    }\n+\n+    /** test A = LLT */\n+    @Test\n+    public void testAEqualLLT() {\n+        RealMatrix matrix = MatrixUtils.createRealMatrix(testData);\n+        CholeskyDecomposition llt = new CholeskyDecomposition(matrix);\n+        RealMatrix l  = llt.getL();\n+        RealMatrix lt = llt.getLT();\n+        double norm = l.multiply(lt).subtract(matrix).getNorm();\n+        Assert.assertEquals(0, norm, 1.0e-15);\n+    }\n+\n+    /** test that L is lower triangular */\n+    @Test\n+    public void testLLowerTriangular() {\n+        RealMatrix matrix = MatrixUtils.createRealMatrix(testData);\n+        RealMatrix l = new CholeskyDecomposition(matrix).getL();\n+        for (int i = 0; i < l.getRowDimension(); i++) {\n+            for (int j = i + 1; j < l.getColumnDimension(); j++) {\n+                Assert.assertEquals(0.0, l.getEntry(i, j), 0.0);\n+            }\n+        }\n+    }\n+\n+    /** test that LT is transpose of L */\n+    @Test\n+    public void testLTTransposed() {\n+        RealMatrix matrix = MatrixUtils.createRealMatrix(testData);\n+        CholeskyDecomposition llt = new CholeskyDecomposition(matrix);\n+        RealMatrix l  = llt.getL();\n+        RealMatrix lt = llt.getLT();\n+        double norm = l.subtract(lt.transpose()).getNorm();\n+        Assert.assertEquals(0, norm, 1.0e-15);\n+    }\n+\n+    /** test matrices values */\n+    @Test\n+    public void testMatricesValues() {\n+        RealMatrix lRef = MatrixUtils.createRealMatrix(new double[][] {\n+                {  1,  0,  0,  0,  0 },\n+                {  2,  3,  0,  0,  0 },\n+                {  4,  5,  6,  0,  0 },\n+                {  7,  8,  9, 10,  0 },\n+                { 11, 12, 13, 14, 15 }\n+        });\n+       CholeskyDecomposition llt =\n+            new CholeskyDecomposition(MatrixUtils.createRealMatrix(testData));\n+\n+        // check values against known references\n+        RealMatrix l = llt.getL();\n+        Assert.assertEquals(0, l.subtract(lRef).getNorm(), 1.0e-13);\n+        RealMatrix lt = llt.getLT();\n+        Assert.assertEquals(0, lt.subtract(lRef.transpose()).getNorm(), 1.0e-13);\n+\n+        // check the same cached instance is returned the second time\n+        Assert.assertTrue(l  == llt.getL());\n+        Assert.assertTrue(lt == llt.getLT());\n+    }\n+}\n--- a/src/test/java/org/apache/commons/math/linear/CholeskySolverTest.java\n+++ b/src/test/java/org/apache/commons/math/linear/CholeskySolverTest.java\n     @Test\n     public void testSolveDimensionErrors() {\n         DecompositionSolver solver =\n-            new CholeskyDecompositionImpl(MatrixUtils.createRealMatrix(testData)).getSolver();\n+            new CholeskyDecomposition(MatrixUtils.createRealMatrix(testData)).getSolver();\n         RealMatrix b = MatrixUtils.createRealMatrix(new double[2][2]);\n         try {\n             solver.solve(b);\n     @Test\n     public void testSolve() {\n         DecompositionSolver solver =\n-            new CholeskyDecompositionImpl(MatrixUtils.createRealMatrix(testData)).getSolver();\n+            new CholeskyDecomposition(MatrixUtils.createRealMatrix(testData)).getSolver();\n         RealMatrix b = MatrixUtils.createRealMatrix(new double[][] {\n                 {   78,  -13,    1 },\n                 {  414,  -62,   -1 },\n     }\n \n     private double getDeterminant(RealMatrix m) {\n-        return new CholeskyDecompositionImpl(m).getDeterminant();\n+        return new CholeskyDecomposition(m).getDeterminant();\n     }\n \n }", "timestamp": 1316576737, "metainfo": ""}