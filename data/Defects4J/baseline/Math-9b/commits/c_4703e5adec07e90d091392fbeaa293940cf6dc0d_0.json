{"sha": "4703e5adec07e90d091392fbeaa293940cf6dc0d", "log": "Added the following methods to ResizableDoubleArray to support MATH-212  changes to stats classes: copy constructor static copy(-,-) instance copy() equals and hashcode  JIRA: MATH-212   ", "commit": "\n--- a/src/java/org/apache/commons/math/util/ResizableDoubleArray.java\n+++ b/src/java/org/apache/commons/math/util/ResizableDoubleArray.java\n package org.apache.commons.math.util;\n \n import java.io.Serializable;\n+import java.util.Arrays;\n \n import org.apache.commons.math.MathRuntimeException;\n \n         setExpansionMode(expansionMode);\n         internalArray = new double[initialCapacity];\n     }\n+    \n+    /**\n+     * Copy constructor.  Creates a new ResizableDoubleArray that is a deep,\n+     * fresh copy of the original. Needs to acquire synchronization lock\n+     * on original.  Original may not be null; otherwise a NullPointerException\n+     * is thrown.\n+     * \n+     * @param original\n+     */\n+    public ResizableDoubleArray(ResizableDoubleArray original) {\n+        copy(original, this);\n+    }\n \n     /**\n      * Adds an element to the end of this expandable array.\n         }\n         return discarded;\n     }\n-\n+       \n     public synchronized double substituteMostRecentElement(double value) {\n         if (numElements < 1) {\n-        \tthrow MathRuntimeException.createArrayIndexOutOfBoundsException(\"cannot substitute an element from an empty array\",\n-        \t                                                                null);\n+            throw MathRuntimeException.createArrayIndexOutOfBoundsException(\n+                    \"cannot substitute an element from an empty array\", null);\n         }\n \n         double discarded = internalArray[startIndex + (numElements - 1)];\n \n-    \tinternalArray[startIndex + (numElements - 1)] = value;\n-\n-    \treturn discarded;\n-    }\n-\n+        internalArray[startIndex + (numElements - 1)] = value;\n+\n+        return discarded;\n+    }\n+\n+    \n     /**\n      * Checks the expansion factor and the contraction criteria and throws an \n      * IllegalArgumentException if the contractionCriteria is less than the \n      * expansionCriteria\n      * \n      * @param expansionFactor factor to be checked\n-     * @param contractionCritera critera to be checked\n+     * @param contractionCritera criteria to be checked\n      * @throws IllegalArgumentException if the contractionCriteria is less than\n      *         the expansionCriteria.\n      */\n      */\n     public synchronized void discardFrontElements(int i) {\n \n-    \tdiscardExtremeElements(i,true);\n-    \t\n+        discardExtremeElements(i,true);\n+        \n     }\n \n     /**\n      */\n     public synchronized void discardMostRecentElements(int i) {\n \n-    \tdiscardExtremeElements(i,false);\n-    \t\n-    }\n-\n+        discardExtremeElements(i,false);\n+        \n+    }\n+    \n     /**\n      * Discards the <code>i<code> first or last elements of the array,\n      * depending on the value of <code>front</code>.\n      */\n     protected synchronized void expand() {\n \n-        // notice the use of Math.ceil(), this gaurantees that we will always \n+        // notice the use of Math.ceil(), this guarantees that we will always \n         // have an array of at least currentSize + 1.   Assume that the \n         // current initial capacity is 1 and the expansion factor\n         // is 1.000000000000000001.  The newly calculated size will be \n     }\n     \n     /**\n-     * The expansion factor controls the size of a new aray when an array \n+     * The expansion factor controls the size of a new array when an array \n      * needs to be expanded.  The <code>expansionMode</code>\n      * determines whether the size of the array is multiplied by the \n      * <code>expansionFactor</code> (MULTIPLICATIVE_MODE) or if \n         }\n \n         // Test the new num elements, check to see if the array needs to be \n-        // expanded to accomodate this new number of elements\n+        // expanded to accommodate this new number of elements\n         if ((startIndex + i) > internalArray.length) {\n             expandTo(startIndex + i);\n         }\n     public synchronized int start() {\n         return startIndex;\n     }\n-\n+    \n+    /**\n+     * <p>Copies source to dest, copying the underlying data, so dest is\n+     * a new, independent copy of source.  Does not contract before\n+     * the copy.</p>\n+     * \n+     * <p>Obtains synchronization locks on both source and dest\n+     * (in that order) before performing the copy.</p>\n+     * \n+     * <p>Neither source nor dest may be null; otherwise a NullPointerException\n+     * is thrown</p>\n+     * \n+     */\n+    public static void copy(ResizableDoubleArray source, ResizableDoubleArray dest) {\n+       synchronized(source) {\n+           synchronized(dest) {\n+               dest.initialCapacity = source.initialCapacity;\n+               dest.contractionCriteria = source.contractionCriteria;\n+               dest.expansionFactor = source.expansionFactor;\n+               dest.expansionMode = source.expansionMode;\n+               dest.internalArray = new double[source.internalArray.length];\n+               System.arraycopy(source.internalArray, 0, dest.internalArray,\n+                       0, dest.internalArray.length);\n+               dest.numElements = source.numElements;\n+               dest.startIndex = source.startIndex;\n+           }\n+       }\n+    }\n+    \n+    /**\n+     * Returns a copy of the ResizableDoubleArray.  Does not contract before\n+     * the copy, so the returned object is an exact copy of this.\n+     * \n+     * @return a new ResizableDoubleArray with the same data and configuration\n+     * properties as this\n+     */\n+    public synchronized ResizableDoubleArray copy() {\n+        ResizableDoubleArray result = new ResizableDoubleArray();\n+        copy(this, result);\n+        return result;\n+    }\n+    \n+    /**\n+     * Returns true iff object is a ResizableDoubleArray with the same properties\n+     * as this and an identical internal storage array.\n+     * \n+     * @param object object to be compared for equality with this\n+     * @return true iff object is a ResizableDoubleArray with the same data and\n+     * properties as this\n+     *\n+     */\n+    public boolean equals(Object object) {\n+        if (object == this ) {\n+            return true;\n+        }\n+       if (object instanceof ResizableDoubleArray == false) {\n+            return false;\n+        }\n+       boolean result = true;\n+       ResizableDoubleArray other = (ResizableDoubleArray) object;\n+       result = result && (other.initialCapacity == initialCapacity);\n+       result = result && (other.contractionCriteria == contractionCriteria);\n+       result = result && (other.expansionFactor == expansionFactor);\n+       result = result && (other.expansionMode == expansionMode);\n+       result = result && (other.numElements == numElements);\n+       result = result && (other.startIndex == startIndex);\n+       if (!result) { \n+           return false;\n+       } else {\n+           return Arrays.equals(internalArray, other.internalArray);\n+       }\n+    }\n+    \n+    /**\n+     * Returns a hash code consistent with equals.\n+     * \n+     * @return hash code representing this ResizableDoubleArray\n+     */\n+    public int hashCode() {\n+        int[] hashData = new int[7];\n+        hashData[0] = Arrays.hashCode(internalArray);\n+        hashData[1] = new Float(expansionFactor).hashCode();\n+        hashData[2] = new Float(contractionCriteria).hashCode();\n+        hashData[3] = initialCapacity;\n+        hashData[4] = expansionMode;\n+        hashData[5] = numElements;\n+        hashData[6] = startIndex;\n+        return Arrays.hashCode(hashData);\n+    }\n+         \n }\n--- a/src/test/org/apache/commons/math/util/ResizableDoubleArrayTest.java\n+++ b/src/test/org/apache/commons/math/util/ResizableDoubleArrayTest.java\n             // expected\n         }\n         \n+        // Copy constructor\n+        testDa = new ResizableDoubleArray(2, 2.0f, 3.0f, \n+                ResizableDoubleArray.ADDITIVE_MODE);\n+        testDa.addElement(2.0);\n+        testDa.addElement(3.2);\n+        ResizableDoubleArray copyDa = new ResizableDoubleArray(testDa);\n+        assertEquals(copyDa, testDa);\n+        assertEquals(testDa, copyDa);   \n     }\n     \n     \n             // expected\n         }\n     }\n+    \n+    public void testEqualsAndHashCode() throws Exception {\n+        \n+        // Wrong type\n+        ResizableDoubleArray first = new ResizableDoubleArray();\n+        Double other = new Double(2);\n+        assertFalse(first.equals(other));\n+        \n+        // Null\n+        other = null;\n+        assertFalse(first.equals(other));\n+        \n+        // Reflexive\n+        assertTrue(first.equals(first));\n+        \n+        // Argumentless constructor\n+        ResizableDoubleArray second = new ResizableDoubleArray();\n+        verifyEquality(first, second);\n+        \n+        // Equals iff same data, same properties\n+        ResizableDoubleArray third = new ResizableDoubleArray(3, 2.0f, 2.0f);\n+        verifyInequality(third, first);\n+        ResizableDoubleArray fourth = new ResizableDoubleArray(3, 2.0f, 2.0f);\n+        ResizableDoubleArray fifth = new ResizableDoubleArray(2, 2.0f, 2.0f);\n+        verifyEquality(third, fourth);\n+        verifyInequality(third, fifth);\n+        third.addElement(4.1);\n+        third.addElement(4.2);\n+        third.addElement(4.3);\n+        fourth.addElement(4.1);\n+        fourth.addElement(4.2);\n+        fourth.addElement(4.3);\n+        verifyEquality(third, fourth);\n+        \n+        // expand\n+        fourth.addElement(4.4);\n+        verifyInequality(third, fourth);\n+        third.addElement(4.4);\n+        verifyEquality(third, fourth);\n+        fourth.addElement(4.4);\n+        verifyInequality(third, fourth);\n+        third.addElement(4.4);\n+        verifyEquality(third, fourth);\n+        fourth.addElementRolling(4.5);\n+        third.addElementRolling(4.5);\n+        verifyEquality(third, fourth);\n+        \n+        // discard\n+        third.discardFrontElements(1);\n+        verifyInequality(third, fourth);\n+        fourth.discardFrontElements(1);\n+        verifyEquality(third, fourth);\n+        \n+        // discard recent\n+        third.discardMostRecentElements(2);\n+        fourth.discardMostRecentElements(2);\n+        verifyEquality(third, fourth);\n+        \n+        // wrong order\n+        third.addElement(18);\n+        fourth.addElement(17);\n+        third.addElement(17);\n+        fourth.addElement(18);\n+        verifyInequality(third, fourth);\n+        \n+        // copy\n+        ResizableDoubleArray.copy(fourth, fifth);\n+        verifyEquality(fourth, fifth);\n+        \n+        // Copy constructor\n+        verifyEquality(fourth, new ResizableDoubleArray(fourth));\n+        \n+        // Instance copy\n+        verifyEquality(fourth, fourth.copy());   \n+             \n+    }\n+    \n+    private void verifyEquality(ResizableDoubleArray a, ResizableDoubleArray b) {\n+        assertTrue(b.equals(a));\n+        assertTrue(a.equals(b));\n+        assertEquals(a.hashCode(), b.hashCode());    \n+    }\n+    \n+    private void verifyInequality(ResizableDoubleArray a, ResizableDoubleArray b) {\n+        assertFalse(b.equals(a));\n+        assertFalse(a.equals(b));\n+        assertFalse(a.hashCode() == b.hashCode());\n+    }\n+    \n }", "timestamp": 1227379300, "metainfo": ""}