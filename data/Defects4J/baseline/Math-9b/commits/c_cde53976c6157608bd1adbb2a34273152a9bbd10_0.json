{"sha": "cde53976c6157608bd1adbb2a34273152a9bbd10", "log": "implemented solver as an internal class for efficiency  ", "commit": "\n--- a/src/java/org/apache/commons/math/linear/SingularValueDecomposition.java\n+++ b/src/java/org/apache/commons/math/linear/SingularValueDecomposition.java\n  *   #getConditionNumber() getConditionNumber},</li>\n  *   <li>the <code>rank</code> method which has been renamed as {@link #getRank()\n  *   getRank}</li>\n+ *   <li>a {@link #getSolver() getSolver} method has been added.</li>\n  * </ul>\n  * @see <a href=\"http://mathworld.wolfram.com/SingularValueDecomposition.html\">MathWorld</a>\n  * @see <a href=\"http://en.wikipedia.org/wiki/Singular_value_decomposition\">Wikipedia</a>\n      */\n     int getRank();\n \n+    /**\n+     * Get a solver for A &times; X = B.\n+     * @return a solver\n+     */\n+    DecompositionSolver getSolver();\n+\n }\n--- a/src/java/org/apache/commons/math/linear/SingularValueDecompositionImpl.java\n+++ b/src/java/org/apache/commons/math/linear/SingularValueDecompositionImpl.java\n public class SingularValueDecompositionImpl implements SingularValueDecomposition {\n \n     /** Serializable version identifier. */\n-    private static final long serialVersionUID = -238768772547767847L;\n+    private static final long serialVersionUID = -3532767302235568872L;\n \n     /** Number of rows of the initial matrix. */\n     private int m;\n \n     }\n \n+    /** {@inheritDoc} */\n+    public DecompositionSolver getSolver() {\n+        return new Solver(singularValues, getUT(), getV(),\n+                          getRank() == singularValues.length);\n+    }\n+\n+    /** Specialized solver. */\n+    private static class Solver implements DecompositionSolver {\n+\n+        /** Serializable version identifier. */\n+        private static final long serialVersionUID = -1959408026708904378L;\n+\n+        /** Singular values. */\n+        private final double[] singularValues;\n+\n+        /** U<sup>T</sup> matrix of the decomposition. */\n+        private final RealMatrix uT;\n+\n+        /** V matrix of the decomposition. */\n+        private final RealMatrix v;\n+\n+        /** Singularity indicator. */\n+        private boolean nonSingular;\n+\n+        /**\n+         * Build a solver from decomposed matrix.\n+         * @param singularValues singularValues\n+         * @param uT U<sup>T</sup> matrix of the decomposition\n+         * @param v V matrix of the decomposition\n+         * @param nonSingular singularity indicator\n+         */\n+        private Solver(final double[] singularValues, final RealMatrix uT, final RealMatrix v,\n+                       final boolean nonSingular) {\n+            this.singularValues = singularValues;\n+            this.uT             = uT;\n+            this.v              = v;\n+            this.nonSingular    = nonSingular;\n+        }\n+\n+        /** Solve the linear equation A &times; X = B in least square sense.\n+         * <p>The m&times;n matrix A may not be square, the solution X is\n+         * such that ||A &times; X - B|| is minimal.</p>\n+         * @param b right-hand side of the equation A &times; X = B\n+         * @return a vector X that minimizes the two norm of A &times; X - B\n+         * @exception IllegalArgumentException if matrices dimensions don't match\n+         * @exception InvalidMatrixException if decomposed matrix is singular\n+         */\n+        public double[] solve(final double[] b)\n+            throws IllegalArgumentException, InvalidMatrixException {\n+\n+            if (b.length != singularValues.length) {\n+                throw new IllegalArgumentException(\"constant vector has wrong length\");\n+            }\n+\n+            final double[] w = uT.operate(b);\n+            for (int i = 0; i < singularValues.length; ++i) {\n+                final double si = singularValues[i];\n+                if (si == 0) {\n+                    throw new SingularMatrixException();\n+                }\n+                w[i] /= si;\n+            }\n+            return v.operate(w);\n+\n+        }\n+\n+        /** Solve the linear equation A &times; X = B in least square sense.\n+         * <p>The m&times;n matrix A may not be square, the solution X is\n+         * such that ||A &times; X - B|| is minimal.</p>\n+         * @param b right-hand side of the equation A &times; X = B\n+         * @return a vector X that minimizes the two norm of A &times; X - B\n+         * @exception IllegalArgumentException if matrices dimensions don't match\n+         * @exception InvalidMatrixException if decomposed matrix is singular\n+         */\n+        public RealVector solve(final RealVector b)\n+            throws IllegalArgumentException, InvalidMatrixException {\n+\n+            if (b.getDimension() != singularValues.length) {\n+                throw new IllegalArgumentException(\"constant vector has wrong length\");\n+            }\n+\n+            final RealVector w = uT.operate(b);\n+            for (int i = 0; i < singularValues.length; ++i) {\n+                final double si = singularValues[i];\n+                if (si == 0) {\n+                    throw new SingularMatrixException();\n+                }\n+                w.set(i, w.getEntry(i) / si);\n+            }\n+            return v.operate(w);\n+\n+        }\n+\n+        /** Solve the linear equation A &times; X = B in least square sense.\n+         * <p>The m&times;n matrix A may not be square, the solution X is\n+         * such that ||A &times; X - B|| is minimal.</p>\n+         * @param b right-hand side of the equation A &times; X = B\n+         * @return a matrix X that minimizes the two norm of A &times; X - B\n+         * @exception IllegalArgumentException if matrices dimensions don't match\n+         * @exception InvalidMatrixException if decomposed matrix is singular\n+         */\n+        public RealMatrix solve(final RealMatrix b)\n+            throws IllegalArgumentException, InvalidMatrixException {\n+\n+            if (b.getRowDimension() != singularValues.length) {\n+                throw new IllegalArgumentException(\"Incorrect row dimension\");\n+            }\n+\n+            final RealMatrix w = uT.multiply(b);\n+            for (int i = 0; i < singularValues.length; ++i) {\n+                final double si  = singularValues[i];\n+                if (si == 0) {\n+                    throw new SingularMatrixException();\n+                }\n+                final double inv = 1.0 / si;\n+                for (int j = 0; j < b.getColumnDimension(); ++j) {\n+                    w.multiplyEntry(i, j, inv);\n+                }\n+            }\n+            return v.multiply(w);\n+\n+        }\n+\n+        /**\n+         * Check if the decomposed matrix is non-singular.\n+         * @return true if the decomposed matrix is non-singular\n+         */\n+        public boolean isNonSingular() {\n+            return nonSingular;\n+        }\n+\n+        /** Get the pseudo-inverse of the decomposed matrix.\n+         * @return inverse matrix\n+         * @throws InvalidMatrixException if decomposed matrix is singular\n+         */\n+        public RealMatrix getInverse()\n+            throws InvalidMatrixException {\n+\n+            if (!isNonSingular()) {\n+                throw new SingularMatrixException();\n+            }\n+\n+            return solve(MatrixUtils.createRealIdentityMatrix(singularValues.length));\n+\n+        }\n+\n+    }\n+\n }\n--- a/src/java/org/apache/commons/math/linear/SingularValueSolver.java\n+++ b/src/java/org/apache/commons/math/linear/SingularValueSolver.java\n public class SingularValueSolver implements DecompositionSolver {\n \n     /** Serializable version identifier. */\n-    private static final long serialVersionUID = -33167987924870528L;\n+    private static final long serialVersionUID = 4388219358640335388L;\n \n-    /** Underlying decomposition. */\n-    private final SingularValueDecomposition decomposition;\n+    /** Underlying solver. */\n+    private final DecompositionSolver solver;\n \n     /**\n      * Simple constructor.\n      * @param decomposition decomposition to use\n      */\n     public SingularValueSolver(final SingularValueDecomposition decomposition) {\n-        this.decomposition = decomposition;\n+        this.solver = decomposition.getSolver();\n     }\n \n     /** Solve the linear equation A &times; X = B in least square sense.\n      */\n     public double[] solve(final double[] b)\n         throws IllegalArgumentException, InvalidMatrixException {\n-\n-        final double[] singularValues = decomposition.getSingularValues();\n-        if (b.length != singularValues.length) {\n-            throw new IllegalArgumentException(\"constant vector has wrong length\");\n-        }\n-\n-        final double[] w = decomposition.getUT().operate(b);\n-        for (int i = 0; i < singularValues.length; ++i) {\n-            final double si = singularValues[i];\n-            if (si == 0) {\n-                throw new SingularMatrixException();\n-            }\n-            w[i] /= si;\n-        }\n-        return decomposition.getV().operate(w);\n-\n+        return solver.solve(b);\n     }\n \n     /** Solve the linear equation A &times; X = B in least square sense.\n      */\n     public RealVector solve(final RealVector b)\n         throws IllegalArgumentException, InvalidMatrixException {\n-\n-        final double[] singularValues = decomposition.getSingularValues();\n-        if (b.getDimension() != singularValues.length) {\n-            throw new IllegalArgumentException(\"constant vector has wrong length\");\n-        }\n-\n-        final RealVector w = decomposition.getUT().operate(b);\n-        for (int i = 0; i < singularValues.length; ++i) {\n-            final double si = singularValues[i];\n-            if (si == 0) {\n-                throw new SingularMatrixException();\n-            }\n-            w.set(i, w.getEntry(i) / si);\n-        }\n-        return decomposition.getV().operate(w);\n-\n+        return solver.solve(b);\n     }\n \n     /** Solve the linear equation A &times; X = B in least square sense.\n      */\n     public RealMatrix solve(final RealMatrix b)\n         throws IllegalArgumentException, InvalidMatrixException {\n-\n-        final double[] singularValues = decomposition.getSingularValues();\n-        if (b.getRowDimension() != singularValues.length) {\n-            throw new IllegalArgumentException(\"Incorrect row dimension\");\n-        }\n-\n-        final RealMatrix w = decomposition.getUT().multiply(b);\n-        for (int i = 0; i < singularValues.length; ++i) {\n-            final double si  = singularValues[i];\n-            if (si == 0) {\n-                throw new SingularMatrixException();\n-            }\n-            final double inv = 1.0 / si;\n-            for (int j = 0; j < b.getColumnDimension(); ++j) {\n-                w.multiplyEntry(i, j, inv);\n-            }\n-        }\n-        return decomposition.getV().multiply(w);\n-\n+        return solver.solve(b);\n     }\n \n     /**\n      * @return true if the decomposed matrix is non-singular\n      */\n     public boolean isNonSingular() {\n-        return decomposition.getRank() == decomposition.getSingularValues().length;\n+        return solver.isNonSingular();\n     }\n \n     /** Get the pseudo-inverse of the decomposed matrix.\n      */\n     public RealMatrix getInverse()\n         throws InvalidMatrixException {\n-\n-        if (!isNonSingular()) {\n-            throw new SingularMatrixException();\n-        }\n-\n-        return solve(MatrixUtils.createRealIdentityMatrix(decomposition.getSingularValues().length));\n-\n+        return solver.getInverse();\n     }\n \n }", "timestamp": 1229961057, "metainfo": ""}