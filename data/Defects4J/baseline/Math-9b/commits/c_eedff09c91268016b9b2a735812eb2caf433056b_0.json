{"sha": "eedff09c91268016b9b2a735812eb2caf433056b", "log": "MATH-933 Throw exception from optimizers that do not support simple bounds. Changing visibility of \"parseOptimizationData\" method to \"protected\" in order to allow the parent class to parse its data before the subclass (and thus providing more flexibility: the subclass is able check input consistency at the options parsing step).   ", "commit": "\n--- a/src/main/java/org/apache/commons/math3/optim/BaseMultivariateOptimizer.java\n+++ b/src/main/java/org/apache/commons/math3/optim/BaseMultivariateOptimizer.java\n     /**\n      * {@inheritDoc}\n      *\n-     * @param optData Optimization data.\n-     * The following data will be looked for:\n+     * @param optData Optimization data. In addition to those documented in\n+     * {@link BaseOptimizer#parseOptimizationData(OptimizationData[]) BaseOptimizer},\n+     * this method will register the following data:\n      * <ul>\n-     *  <li>{@link MaxEval}</li>\n      *  <li>{@link InitialGuess}</li>\n      *  <li>{@link SimpleBounds}</li>\n      * </ul>\n      */\n     @Override\n     public PAIR optimize(OptimizationData... optData) {\n-        // Retrieve settings.\n-        parseOptimizationData(optData);\n-        // Check input consistency.\n-        checkParameters();\n         // Perform optimization.\n         return super.optimize(optData);\n     }\n      *  <li>{@link SimpleBounds}</li>\n      * </ul>\n      */\n-    private void parseOptimizationData(OptimizationData... optData) {\n+    @Override\n+    protected void parseOptimizationData(OptimizationData... optData) {\n+        // Allow base class to register its own data.\n+        super.parseOptimizationData(optData);\n+\n         // The existing values (as set by the previous call) are reused if\n         // not provided in the argument list.\n         for (OptimizationData data : optData) {\n                 continue;\n             }\n         }\n+\n+        // Check input consistency.\n+        checkParameters();\n     }\n \n     /**\n--- a/src/main/java/org/apache/commons/math3/optim/BaseOptimizer.java\n+++ b/src/main/java/org/apache/commons/math3/optim/BaseOptimizer.java\n      * only when actually present in the list of arguments: when not specified,\n      * data set in a previous call is retained (and thus is optional in\n      * subsequent calls).\n-     *\n-     * @param optData Optimization data. The following data will be looked for:\n+     * <br/>\n+     * Important note: Subclasses <em>must</em> override\n+     * {@link #parseOptimizationData(OptimizationData[])} if they need to register\n+     * their own options; but then, they <em>must</em> also call\n+     * {@code super.parseOptimizationData(optData)} within that method.\n+     *\n+     * @param optData Optimization data.\n+     * This method will register the following data:\n      * <ul>\n      *  <li>{@link MaxEval}</li>\n      *  <li>{@link MaxIter}</li>\n     public PAIR optimize(OptimizationData... optData)\n         throws TooManyEvaluationsException,\n                TooManyIterationsException {\n-        // Retrieve settings.\n+        // Parse options.\n         parseOptimizationData(optData);\n+\n         // Reset counters.\n         evaluations.resetCount();\n         iterations.resetCount();\n      *  <li>{@link MaxIter}</li>\n      * </ul>\n      */\n-    private void parseOptimizationData(OptimizationData... optData) {\n+    protected void parseOptimizationData(OptimizationData... optData) {\n         // The existing values (as set by the previous call) are reused if\n         // not provided in the argument list.\n         for (OptimizationData data : optData) {\n--- a/src/main/java/org/apache/commons/math3/optim/linear/LinearOptimizer.java\n+++ b/src/main/java/org/apache/commons/math3/optim/linear/LinearOptimizer.java\n     /**\n      * {@inheritDoc}\n      *\n-     * @param optData Optimization data. The following data will be looked for:\n+     * @param optData Optimization data. In addition to those documented in\n+     * {@link MultivariateOptimizer#parseOptimizationData(OptimizationData[])\n+     * MultivariateOptimizer}, this method will register the following data:\n      * <ul>\n-     *  <li>{@link org.apache.commons.math3.optim.MaxIter}</li>\n      *  <li>{@link LinearObjectiveFunction}</li>\n      *  <li>{@link LinearConstraintSet}</li>\n      *  <li>{@link NonNegativeConstraint}</li>\n     @Override\n     public PointValuePair optimize(OptimizationData... optData)\n         throws TooManyIterationsException {\n-         // Retrieve settings.\n-        parseOptimizationData(optData);\n         // Set up base class and perform computation.\n         return super.optimize(optData);\n     }\n      *  <li>{@link NonNegativeConstraint}</li>\n      * </ul>\n      */\n-    private void parseOptimizationData(OptimizationData... optData) {\n+    @Override\n+    protected void parseOptimizationData(OptimizationData... optData) {\n+        // Allow base class to register its own data.\n+        super.parseOptimizationData(optData);\n+\n         // The existing values (as set by the previous call) are reused if\n         // not provided in the argument list.\n         for (OptimizationData data : optData) {\n--- a/src/main/java/org/apache/commons/math3/optim/nonlinear/scalar/GradientMultivariateOptimizer.java\n+++ b/src/main/java/org/apache/commons/math3/optim/nonlinear/scalar/GradientMultivariateOptimizer.java\n     /**\n      * {@inheritDoc}\n      *\n-     * @param optData Optimization data.\n-     * The following data will be looked for:\n+     * @param optData Optimization data. In addition to those documented in\n+     * {@link MultivariateOptimizer#parseOptimizationData(OptimizationData[])\n+     * MultivariateOptimizer}, this method will register the following data:\n      * <ul>\n-     *  <li>{@link org.apache.commons.math3.optim.MaxEval}</li>\n-     *  <li>{@link org.apache.commons.math3.optim.InitialGuess}</li>\n-     *  <li>{@link org.apache.commons.math3.optim.SimpleBounds}</li>\n-     *  <li>{@link ObjectiveFunction}</li>\n-     *  <li>{@link GoalType}</li>\n      *  <li>{@link ObjectiveFunctionGradient}</li>\n      * </ul>\n      * @return {@inheritDoc}\n     @Override\n     public PointValuePair optimize(OptimizationData... optData)\n         throws TooManyEvaluationsException {\n-         // Retrieve settings.\n-        parseOptimizationData(optData);\n         // Set up base class and perform computation.\n         return super.optimize(optData);\n     }\n      *  <li>{@link ObjectiveFunctionGradient}</li>\n      * </ul>\n      */\n-    private void parseOptimizationData(OptimizationData... optData) {\n+    @Override\n+    protected void parseOptimizationData(OptimizationData... optData) {\n+        // Allow base class to register its own data.\n+        super.parseOptimizationData(optData);\n+\n         // The existing values (as set by the previous call) are reused if\n         // not provided in the argument list.\n         for (OptimizationData data : optData) {\n--- a/src/main/java/org/apache/commons/math3/optim/nonlinear/scalar/MultivariateOptimizer.java\n+++ b/src/main/java/org/apache/commons/math3/optim/nonlinear/scalar/MultivariateOptimizer.java\n     /**\n      * {@inheritDoc}\n      *\n-     * @param optData Optimization data. The following data will be looked for:\n+     * @param optData Optimization data. In addition to those documented in\n+     * {@link BaseMultivariateOptimizer#parseOptimizationData(OptimizationData[])\n+     * BaseMultivariateOptimizer}, this method will register the following data:\n      * <ul>\n-     *  <li>{@link org.apache.commons.math3.optim.MaxEval}</li>\n-     *  <li>{@link org.apache.commons.math3.optim.InitialGuess}</li>\n-     *  <li>{@link org.apache.commons.math3.optim.SimpleBounds}</li>\n      *  <li>{@link ObjectiveFunction}</li>\n      *  <li>{@link GoalType}</li>\n      * </ul>\n     @Override\n     public PointValuePair optimize(OptimizationData... optData)\n         throws TooManyEvaluationsException {\n-         // Retrieve settings.\n-        parseOptimizationData(optData);\n         // Set up base class and perform computation.\n         return super.optimize(optData);\n     }\n      *  <li>{@link GoalType}</li>\n      * </ul>\n      */\n-    private void parseOptimizationData(OptimizationData... optData) {\n+    @Override\n+    protected void parseOptimizationData(OptimizationData... optData) {\n+        // Allow base class to register its own data.\n+        super.parseOptimizationData(optData);\n+\n         // The existing values (as set by the previous call) are reused if\n         // not provided in the argument list.\n         for (OptimizationData data : optData) {\n                 goal = (GoalType) data;\n                 continue;\n             }\n-            if  (data instanceof ObjectiveFunction) {\n+            if (data instanceof ObjectiveFunction) {\n                 function = ((ObjectiveFunction) data).getObjectiveFunction();\n                 continue;\n             }\n--- a/src/main/java/org/apache/commons/math3/optim/nonlinear/scalar/gradient/NonLinearConjugateGradientOptimizer.java\n+++ b/src/main/java/org/apache/commons/math3/optim/nonlinear/scalar/gradient/NonLinearConjugateGradientOptimizer.java\n import org.apache.commons.math3.exception.MathInternalError;\n import org.apache.commons.math3.exception.MathIllegalStateException;\n import org.apache.commons.math3.exception.TooManyEvaluationsException;\n+import org.apache.commons.math3.exception.MathUnsupportedOperationException;\n import org.apache.commons.math3.exception.util.LocalizedFormats;\n import org.apache.commons.math3.optim.OptimizationData;\n-import org.apache.commons.math3.optim.nonlinear.scalar.GoalType;\n import org.apache.commons.math3.optim.PointValuePair;\n import org.apache.commons.math3.optim.ConvergenceChecker;\n+import org.apache.commons.math3.optim.nonlinear.scalar.GoalType;\n import org.apache.commons.math3.optim.nonlinear.scalar.GradientMultivariateOptimizer;\n import org.apache.commons.math3.util.FastMath;\n \n /**\n  * Non-linear conjugate gradient optimizer.\n- * <p>\n+ * <br/>\n  * This class supports both the Fletcher-Reeves and the Polak-Ribi\u00e8re\n  * update formulas for the conjugate search directions.\n  * It also supports optional preconditioning.\n- * </p>\n+ * <br/>\n+ * Constraints are not supported: the call to\n+ * {@link #optimize(OptimizationData[]) optimize} will throw\n+ * {@link MathUnsupportedOperationException} if bounds are passed to it.\n  *\n  * @version $Id$\n  * @since 2.0\n     /**\n      * {@inheritDoc}\n      *\n-     * @param optData Optimization data.\n-     * The following data will be looked for:\n+     * @param optData Optimization data. In addition to those documented in\n+     * {@link GradientMultivariateOptimizer#parseOptimizationData(OptimizationData[])\n+     * GradientMultivariateOptimizer}, this method will register the following data:\n      * <ul>\n-     *  <li>{@link org.apache.commons.math3.optim.MaxEval}</li>\n-     *  <li>{@link org.apache.commons.math3.optim.InitialGuess}</li>\n-     *  <li>{@link org.apache.commons.math3.optim.SimpleBounds}</li>\n-     *  <li>{@link org.apache.commons.math3.optim.nonlinear.scalar.GoalType}</li>\n-     *  <li>{@link org.apache.commons.math3.optim.nonlinear.scalar.ObjectiveFunction}</li>\n-     *  <li>{@link org.apache.commons.math3.optim.nonlinear.scalar.ObjectiveFunctionGradient}</li>\n      *  <li>{@link BracketingStep}</li>\n      * </ul>\n      * @return {@inheritDoc}\n     @Override\n     public PointValuePair optimize(OptimizationData... optData)\n         throws TooManyEvaluationsException {\n-         // Retrieve settings.\n-        parseOptimizationData(optData);\n         // Set up base class and perform computation.\n         return super.optimize(optData);\n     }\n      *  <li>{@link InitialStep}</li>\n      * </ul>\n      */\n-    private void parseOptimizationData(OptimizationData... optData) {\n+    @Override\n+    protected void parseOptimizationData(OptimizationData... optData) {\n+        // Allow base class to register its own data.\n+        super.parseOptimizationData(optData);\n+\n         // The existing values (as set by the previous call) are reused if\n         // not provided in the argument list.\n         for (OptimizationData data : optData) {\n                 break;\n             }\n         }\n+\n+        checkParameters();\n     }\n \n     /**\n             return dotProduct;\n         }\n     }\n+\n+    /**\n+     * @throws MathUnsupportedOperationException if bounds were passed to the\n+     * {@link #optimize(OptimizationData[]) optimize} method.\n+     */\n+    private void checkParameters() {\n+        if (getLowerBound() != null ||\n+            getUpperBound() != null) {\n+            throw new MathUnsupportedOperationException(LocalizedFormats.CONSTRAINT);\n+        }\n+    }\n }\n--- a/src/main/java/org/apache/commons/math3/optim/nonlinear/scalar/noderiv/CMAESOptimizer.java\n+++ b/src/main/java/org/apache/commons/math3/optim/nonlinear/scalar/noderiv/CMAESOptimizer.java\n     /**\n      * {@inheritDoc}\n      *\n-     * @param optData Optimization data. The following data will be looked for:\n+     * @param optData Optimization data. In addition to those documented in\n+     * {@link MultivariateOptimizer#parseOptimizationData(OptimizationData[])\n+     * MultivariateOptimizer}, this method will register the following data:\n      * <ul>\n-     *  <li>{@link org.apache.commons.math3.optim.MaxEval}</li>\n-     *  <li>{@link org.apache.commons.math3.optim.InitialGuess}</li>\n-     *  <li>{@link org.apache.commons.math3.optim.SimpleBounds}</li>\n-     *  <li>{@link org.apache.commons.math3.optim.nonlinear.scalar.ObjectiveFunction}</li>\n      *  <li>{@link Sigma}</li>\n      *  <li>{@link PopulationSize}</li>\n      * </ul>\n     public PointValuePair optimize(OptimizationData... optData)\n         throws TooManyEvaluationsException,\n                DimensionMismatchException {\n-        // Retrieve settings.\n-        parseOptimizationData(optData);\n         // Set up base class and perform computation.\n         return super.optimize(optData);\n     }\n     /** {@inheritDoc} */\n     @Override\n     protected PointValuePair doOptimize() {\n-        checkParameters();\n          // -------------------- Initialization --------------------------------\n         isMinimize = getGoalType().equals(GoalType.MINIMIZE);\n         final FitnessFunction fitfun = new FitnessFunction();\n      *  <li>{@link PopulationSize}</li>\n      * </ul>\n      */\n-    private void parseOptimizationData(OptimizationData... optData) {\n+    @Override\n+    protected void parseOptimizationData(OptimizationData... optData) {\n+        // Allow base class to register its own data.\n+        super.parseOptimizationData(optData);\n+\n         // The existing values (as set by the previous call) are reused if\n         // not provided in the argument list.\n         for (OptimizationData data : optData) {\n                 continue;\n             }\n         }\n+\n+        checkParameters();\n     }\n \n     /**\n--- a/src/main/java/org/apache/commons/math3/optim/nonlinear/scalar/noderiv/PowellOptimizer.java\n+++ b/src/main/java/org/apache/commons/math3/optim/nonlinear/scalar/noderiv/PowellOptimizer.java\n import org.apache.commons.math3.analysis.UnivariateFunction;\n import org.apache.commons.math3.exception.NumberIsTooSmallException;\n import org.apache.commons.math3.exception.NotStrictlyPositiveException;\n+import org.apache.commons.math3.exception.MathUnsupportedOperationException;\n+import org.apache.commons.math3.exception.util.LocalizedFormats;\n+import org.apache.commons.math3.optim.nonlinear.scalar.GoalType;\n import org.apache.commons.math3.optim.MaxEval;\n-import org.apache.commons.math3.optim.nonlinear.scalar.GoalType;\n import org.apache.commons.math3.optim.PointValuePair;\n import org.apache.commons.math3.optim.ConvergenceChecker;\n import org.apache.commons.math3.optim.nonlinear.scalar.MultivariateOptimizer;\n import org.apache.commons.math3.optim.univariate.UnivariateObjectiveFunction;\n \n /**\n- * Powell algorithm.\n+ * Powell's algorithm.\n  * This code is translated and adapted from the Python version of this\n  * algorithm (as implemented in module {@code optimize.py} v0.5 of\n  * <em>SciPy</em>).\n  * <br/>\n  * The internal line search optimizer is a {@link BrentOptimizer} with a\n  * convergence checker set to {@link SimpleUnivariateValueChecker}.\n+ * <br/>\n+ * Constraints are not supported: the call to\n+ * {@link #optimize(OptimizationData[]) optimize} will throw\n+ * {@link MathUnsupportedOperationException} if bounds are passed to it.\n+ * In order to impose simple constraints, the objective function must be\n+ * wrapped in an adapter like\n+ * {@link org.apache.commons.math3.optim.nonlinear.scalar.MultivariateFunctionMappingAdapter\n+ * MultivariateFunctionMappingAdapter} or\n+ * {@link org.apache.commons.math3.optim.nonlinear.scalar.MultivariateFunctionPenaltyAdapter\n+ * MultivariateFunctionPenaltyAdapter}.\n  *\n  * @version $Id$\n  * @since 2.2\n     /** {@inheritDoc} */\n     @Override\n     protected PointValuePair doOptimize() {\n+        checkParameters();\n+\n         final GoalType goal = getGoalType();\n         final double[] guess = getStartPoint();\n         final int n = guess.length;\n                                                bracket.getMid()));\n         }\n     }\n+\n+    /**\n+     * @throws MathUnsupportedOperationException if bounds were passed to the\n+     * {@link #optimize(OptimizationData[]) optimize} method.\n+     */\n+    private void checkParameters() {\n+        if (getLowerBound() != null ||\n+            getUpperBound() != null) {\n+            throw new MathUnsupportedOperationException(LocalizedFormats.CONSTRAINT);\n+        }\n+    }\n }\n--- a/src/main/java/org/apache/commons/math3/optim/nonlinear/scalar/noderiv/SimplexOptimizer.java\n+++ b/src/main/java/org/apache/commons/math3/optim/nonlinear/scalar/noderiv/SimplexOptimizer.java\n import java.util.Comparator;\n import org.apache.commons.math3.analysis.MultivariateFunction;\n import org.apache.commons.math3.exception.NullArgumentException;\n+import org.apache.commons.math3.exception.MathUnsupportedOperationException;\n+import org.apache.commons.math3.exception.util.LocalizedFormats;\n import org.apache.commons.math3.optim.nonlinear.scalar.GoalType;\n import org.apache.commons.math3.optim.ConvergenceChecker;\n import org.apache.commons.math3.optim.PointValuePair;\n  *  MultivariateFunctionMappingAdapter} or\n  *  {@link org.apache.commons.math3.optim.nonlinear.scalar.MultivariateFunctionPenaltyAdapter\n  *  MultivariateFunctionPenaltyAdapter}.\n+ *  <br/>\n+ *  The call to {@link #optimize(OptimizationData[]) optimize} will throw\n+ *  {@link MathUnsupportedOperationException} if bounds are passed to it.\n  * </p>\n  *\n  * @version $Id$\n     /**\n      * {@inheritDoc}\n      *\n-     * @param optData Optimization data.\n-     * The following data will be looked for:\n+     * @param optData Optimization data. In addition to those documented in\n+     * {@link MultivariateOptimizer#parseOptimizationData(OptimizationData[])\n+     * MultivariateOptimizer}, this method will register the following data:\n      * <ul>\n-     *  <li>{@link org.apache.commons.math3.optim.MaxEval}</li>\n-     *  <li>{@link org.apache.commons.math3.optim.InitialGuess}</li>\n-     *  <li>{@link org.apache.commons.math3.optim.SimpleBounds}</li>\n      *  <li>{@link AbstractSimplex}</li>\n      * </ul>\n      * @return {@inheritDoc}\n      */\n     @Override\n     public PointValuePair optimize(OptimizationData... optData) {\n-        // Retrieve settings\n-        parseOptimizationData(optData);\n         // Set up base class and perform computation.\n         return super.optimize(optData);\n     }\n     /** {@inheritDoc} */\n     @Override\n     protected PointValuePair doOptimize() {\n-        if (simplex == null) {\n-            throw new NullArgumentException();\n-        }\n+        checkParameters();\n \n         // Indirect call to \"computeObjectiveValue\" in order to update the\n         // evaluations counter.\n      *  <li>{@link AbstractSimplex}</li>\n      * </ul>\n      */\n-    private void parseOptimizationData(OptimizationData... optData) {\n+    @Override\n+    protected void parseOptimizationData(OptimizationData... optData) {\n+        // Allow base class to register its own data.\n+        super.parseOptimizationData(optData);\n+\n         // The existing values (as set by the previous call) are reused if\n         // not provided in the argument list.\n         for (OptimizationData data : optData) {\n             }\n         }\n     }\n+\n+    /**\n+     * @throws MathUnsupportedOperationException if bounds were passed to the\n+     * {@link #optimize(OptimizationData[]) optimize} method.\n+     * @throws NullArgumentException if no initial simplex was passed to the\n+     * {@link #optimize(OptimizationData[]) optimize} method.\n+     */\n+    private void checkParameters() {\n+        if (simplex == null) {\n+            throw new NullArgumentException();\n+        }\n+        if (getLowerBound() != null ||\n+            getUpperBound() != null) {\n+            throw new MathUnsupportedOperationException(LocalizedFormats.CONSTRAINT);\n+        }\n+    }\n }\n--- a/src/main/java/org/apache/commons/math3/optim/nonlinear/vector/JacobianMultivariateVectorOptimizer.java\n+++ b/src/main/java/org/apache/commons/math3/optim/nonlinear/vector/JacobianMultivariateVectorOptimizer.java\n     /**\n      * {@inheritDoc}\n      *\n-     * @param optData Optimization data. The following data will be looked for:\n+     * @param optData Optimization data. In addition to those documented in\n+     * {@link MultivariateOptimizer#parseOptimizationData(OptimizationData[])\n+     * MultivariateOptimizer}, this method will register the following data:\n      * <ul>\n-     *  <li>{@link org.apache.commons.math3.optim.MaxEval}</li>\n-     *  <li>{@link org.apache.commons.math3.optim.InitialGuess}</li>\n-     *  <li>{@link org.apache.commons.math3.optim.SimpleBounds}</li>\n-     *  <li>{@link Target}</li>\n-     *  <li>{@link Weight}</li>\n-     *  <li>{@link ModelFunction}</li>\n      *  <li>{@link ModelFunctionJacobian}</li>\n      * </ul>\n      * @return {@inheritDoc}\n     public PointVectorValuePair optimize(OptimizationData... optData)\n         throws TooManyEvaluationsException,\n                DimensionMismatchException {\n-        // Retrieve settings.\n-        parseOptimizationData(optData);\n         // Set up base class and perform computation.\n         return super.optimize(optData);\n     }\n      *  <li>{@link ModelFunctionJacobian}</li>\n      * </ul>\n      */\n-    private void parseOptimizationData(OptimizationData... optData) {\n+    @Override\n+    protected void parseOptimizationData(OptimizationData... optData) {\n+        // Allow base class to register its own data.\n+        super.parseOptimizationData(optData);\n+\n         // The existing values (as set by the previous call) are reused if\n         // not provided in the argument list.\n         for (OptimizationData data : optData) {\n--- a/src/main/java/org/apache/commons/math3/optim/nonlinear/vector/MultivariateVectorOptimizer.java\n+++ b/src/main/java/org/apache/commons/math3/optim/nonlinear/vector/MultivariateVectorOptimizer.java\n     /**\n      * {@inheritDoc}\n      *\n-     * @param optData Optimization data. The following data will be looked for:\n+     * @param optData Optimization data. In addition to those documented in\n+     * {@link BaseMultivariateOptimizer#parseOptimizationData(OptimizationData[])\n+     * BaseMultivariateOptimizer}, this method will register the following data:\n      * <ul>\n-     *  <li>{@link org.apache.commons.math3.optim.MaxEval}</li>\n-     *  <li>{@link org.apache.commons.math3.optim.InitialGuess}</li>\n-     *  <li>{@link org.apache.commons.math3.optim.SimpleBounds}</li>\n      *  <li>{@link Target}</li>\n      *  <li>{@link Weight}</li>\n      *  <li>{@link ModelFunction}</li>\n     public PointVectorValuePair optimize(OptimizationData... optData)\n         throws TooManyEvaluationsException,\n                DimensionMismatchException {\n-        // Retrieve settings.\n-        parseOptimizationData(optData);\n-        // Check input consistency.\n-        checkParameters();\n         // Set up base class and perform computation.\n         return super.optimize(optData);\n     }\n      *  <li>{@link ModelFunction}</li>\n      * </ul>\n      */\n-    private void parseOptimizationData(OptimizationData... optData) {\n+    @Override\n+    protected void parseOptimizationData(OptimizationData... optData) {\n+        // Allow base class to register its own data.\n+        super.parseOptimizationData(optData);\n+\n         // The existing values (as set by the previous call) are reused if\n         // not provided in the argument list.\n         for (OptimizationData data : optData) {\n                 continue;\n             }\n         }\n+\n+        // Check input consistency.\n+        checkParameters();\n     }\n \n     /**\n--- a/src/main/java/org/apache/commons/math3/optim/nonlinear/vector/jacobian/AbstractLeastSquaresOptimizer.java\n+++ b/src/main/java/org/apache/commons/math3/optim/nonlinear/vector/jacobian/AbstractLeastSquaresOptimizer.java\n     /**\n      * {@inheritDoc}\n      *\n-     * @param optData Optimization data. The following data will be looked for:\n+     * @param optData Optimization data. In addition to those documented in\n+     * {@link JacobianMultivariateVectorOptimizer#parseOptimizationData(OptimizationData[])\n+     * JacobianMultivariateVectorOptimizer}, this method will register the following data:\n      * <ul>\n-     *  <li>{@link org.apache.commons.math3.optim.MaxEval}</li>\n-     *  <li>{@link org.apache.commons.math3.optim.InitialGuess}</li>\n-     *  <li>{@link org.apache.commons.math3.optim.SimpleBounds}</li>\n-     *  <li>{@link org.apache.commons.math3.optim.nonlinear.vector.Target}</li>\n      *  <li>{@link org.apache.commons.math3.optim.nonlinear.vector.Weight}</li>\n-     *  <li>{@link org.apache.commons.math3.optim.nonlinear.vector.ModelFunction}</li>\n-     *  <li>{@link org.apache.commons.math3.optim.nonlinear.vector.ModelFunctionJacobian}</li>\n      * </ul>\n      * @return {@inheritDoc}\n      * @throws TooManyEvaluationsException if the maximal number of\n     @Override\n     public PointVectorValuePair optimize(OptimizationData... optData)\n         throws TooManyEvaluationsException {\n-        // Retrieve settings.\n-        parseOptimizationData(optData);\n         // Set up base class and perform computation.\n         return super.optimize(optData);\n     }\n      *  <li>{@link Weight}</li>\n      * </ul>\n      */\n-    private void parseOptimizationData(OptimizationData... optData) {\n+    @Override\n+    protected void parseOptimizationData(OptimizationData... optData) {\n+        // Allow base class to register its own data.\n+        super.parseOptimizationData(optData);\n+\n         // The existing values (as set by the previous call) are reused if\n         // not provided in the argument list.\n         for (OptimizationData data : optData) {\n--- a/src/main/java/org/apache/commons/math3/optim/univariate/UnivariateOptimizer.java\n+++ b/src/main/java/org/apache/commons/math3/optim/univariate/UnivariateOptimizer.java\n     /**\n      * {@inheritDoc}\n      *\n-     * @param optData Optimization data.\n-     * The following data will be looked for:\n+     * @param optData Optimization data. In addition to those documented in\n+     * {@link BaseOptimizer#parseOptimizationData(OptimizationData[])\n+     * BaseOptimizer}, this method will register the following data:\n      * <ul>\n      *  <li>{@link GoalType}</li>\n      *  <li>{@link SearchInterval}</li>\n      */\n     public UnivariatePointValuePair optimize(OptimizationData... optData)\n         throws TooManyEvaluationsException {\n-        // Retrieve settings.\n-        parseOptimizationData(optData);\n         // Perform computation.\n         return super.optimize(optData);\n     }\n      *  <li>{@link UnivariateObjectiveFunction}</li>\n      * </ul>\n      */\n-    private void parseOptimizationData(OptimizationData... optData) {\n+    @Override\n+    protected void parseOptimizationData(OptimizationData... optData) {\n+        // Allow base class to register its own data.\n+        super.parseOptimizationData(optData);\n+\n         // The existing values (as set by the previous call) are reused if\n         // not provided in the argument list.\n         for (OptimizationData data : optData) {\n--- a/src/test/java/org/apache/commons/math3/optim/nonlinear/scalar/gradient/NonLinearConjugateGradientOptimizerTest.java\n+++ b/src/test/java/org/apache/commons/math3/optim/nonlinear/scalar/gradient/NonLinearConjugateGradientOptimizerTest.java\n import org.apache.commons.math3.analysis.solvers.BrentSolver;\n import org.apache.commons.math3.exception.DimensionMismatchException;\n import org.apache.commons.math3.exception.MathIllegalArgumentException;\n+import org.apache.commons.math3.exception.MathUnsupportedOperationException;\n import org.apache.commons.math3.geometry.euclidean.twod.Vector2D;\n import org.apache.commons.math3.linear.BlockRealMatrix;\n import org.apache.commons.math3.linear.RealMatrix;\n-import org.apache.commons.math3.optim.nonlinear.scalar.GoalType;\n import org.apache.commons.math3.optim.PointValuePair;\n import org.apache.commons.math3.optim.SimpleValueChecker;\n import org.apache.commons.math3.optim.InitialGuess;\n import org.apache.commons.math3.optim.MaxEval;\n+import org.apache.commons.math3.optim.SimpleBounds;\n import org.apache.commons.math3.optim.nonlinear.scalar.ObjectiveFunction;\n+import org.apache.commons.math3.optim.nonlinear.scalar.GoalType;\n import org.apache.commons.math3.optim.nonlinear.scalar.ObjectiveFunctionGradient;\n import org.junit.Assert;\n import org.junit.Test;\n  * @author Luc Maisonobe (non-minpack tests and minpack tests Java translation)\n  */\n public class NonLinearConjugateGradientOptimizerTest {\n+    @Test(expected=MathUnsupportedOperationException.class)\n+    public void testBoundsUnsupported() {\n+        LinearProblem problem\n+            = new LinearProblem(new double[][] { { 2 } }, new double[] { 3 });\n+        NonLinearConjugateGradientOptimizer optimizer\n+            = new NonLinearConjugateGradientOptimizer(NonLinearConjugateGradientOptimizer.Formula.POLAK_RIBIERE,\n+                                                      new SimpleValueChecker(1e-6, 1e-6));\n+        optimizer.optimize(new MaxEval(100),\n+                           problem.getObjectiveFunction(),\n+                           problem.getObjectiveFunctionGradient(),\n+                           GoalType.MINIMIZE,\n+                           new InitialGuess(new double[] { 0 }),\n+                           new SimpleBounds(new double[] { -1 },\n+                                            new double[] { 1 }));\n+    }\n+\n     @Test\n     public void testTrivial() {\n         LinearProblem problem\n--- a/src/test/java/org/apache/commons/math3/optim/nonlinear/scalar/noderiv/PowellOptimizerTest.java\n+++ b/src/test/java/org/apache/commons/math3/optim/nonlinear/scalar/noderiv/PowellOptimizerTest.java\n \n import org.apache.commons.math3.analysis.MultivariateFunction;\n import org.apache.commons.math3.analysis.SumSincFunction;\n-import org.apache.commons.math3.optim.nonlinear.scalar.GoalType;\n import org.apache.commons.math3.optim.PointValuePair;\n import org.apache.commons.math3.optim.InitialGuess;\n import org.apache.commons.math3.optim.MaxEval;\n+import org.apache.commons.math3.optim.SimpleBounds;\n+import org.apache.commons.math3.optim.nonlinear.scalar.GoalType;\n import org.apache.commons.math3.optim.nonlinear.scalar.ObjectiveFunction;\n+import org.apache.commons.math3.exception.MathUnsupportedOperationException;\n import org.apache.commons.math3.util.FastMath;\n import org.junit.Assert;\n import org.junit.Test;\n  * Test for {@link PowellOptimizer}.\n  */\n public class PowellOptimizerTest {\n+    @Test(expected=MathUnsupportedOperationException.class)\n+    public void testBoundsUnsupported() {\n+        final MultivariateFunction func = new SumSincFunction(-1);\n+        final PowellOptimizer optim = new PowellOptimizer(1e-8, 1e-5,\n+                                                          1e-4, 1e-4);\n+\n+        optim.optimize(new MaxEval(100),\n+                       new ObjectiveFunction(func),\n+                       GoalType.MINIMIZE,\n+                       new InitialGuess(new double[] { -3, 0 }),\n+                       new SimpleBounds(new double[] { -5, -1 },\n+                                        new double[] { 5, 1 }));\n+    }\n \n     @Test\n     public void testSumSinc() {\n--- a/src/test/java/org/apache/commons/math3/optim/nonlinear/scalar/noderiv/SimplexOptimizerMultiDirectionalTest.java\n+++ b/src/test/java/org/apache/commons/math3/optim/nonlinear/scalar/noderiv/SimplexOptimizerMultiDirectionalTest.java\n \n import org.apache.commons.math3.analysis.MultivariateFunction;\n import org.apache.commons.math3.optim.MaxEval;\n-import org.apache.commons.math3.optim.nonlinear.scalar.GoalType;\n import org.apache.commons.math3.optim.InitialGuess;\n import org.apache.commons.math3.optim.PointValuePair;\n import org.apache.commons.math3.optim.SimpleValueChecker;\n+import org.apache.commons.math3.optim.SimpleBounds;\n+import org.apache.commons.math3.optim.nonlinear.scalar.GoalType;\n import org.apache.commons.math3.optim.nonlinear.scalar.ObjectiveFunction;\n+import org.apache.commons.math3.exception.MathUnsupportedOperationException;\n import org.apache.commons.math3.util.FastMath;\n import org.junit.Assert;\n import org.junit.Test;\n \n public class SimplexOptimizerMultiDirectionalTest {\n+    @Test(expected=MathUnsupportedOperationException.class)\n+    public void testBoundsUnsupported() {\n+        SimplexOptimizer optimizer = new SimplexOptimizer(1e-10, 1e-30);\n+        final FourExtrema fourExtrema = new FourExtrema();\n+\n+        optimizer.optimize(new MaxEval(100),\n+                           new ObjectiveFunction(fourExtrema),\n+                           GoalType.MINIMIZE,\n+                           new InitialGuess(new double[] { -3, 0 }),\n+                           new NelderMeadSimplex(new double[] { 0.2, 0.2 }),\n+                           new SimpleBounds(new double[] { -5, -1 },\n+                                            new double[] { 5, 1 }));\n+    }\n+\n     @Test\n     public void testMinimize1() {\n         SimplexOptimizer optimizer = new SimplexOptimizer(1e-11, 1e-30);\n--- a/src/test/java/org/apache/commons/math3/optim/nonlinear/scalar/noderiv/SimplexOptimizerNelderMeadTest.java\n+++ b/src/test/java/org/apache/commons/math3/optim/nonlinear/scalar/noderiv/SimplexOptimizerNelderMeadTest.java\n \n \n import org.apache.commons.math3.exception.TooManyEvaluationsException;\n+import org.apache.commons.math3.exception.MathUnsupportedOperationException;\n import org.apache.commons.math3.analysis.MultivariateFunction;\n import org.apache.commons.math3.analysis.MultivariateVectorFunction;\n import org.apache.commons.math3.linear.Array2DRowRealMatrix;\n import org.apache.commons.math3.linear.RealMatrix;\n-import org.apache.commons.math3.optim.nonlinear.scalar.GoalType;\n import org.apache.commons.math3.optim.InitialGuess;\n import org.apache.commons.math3.optim.MaxEval;\n+import org.apache.commons.math3.optim.SimpleBounds;\n+import org.apache.commons.math3.optim.PointValuePair;\n+import org.apache.commons.math3.optim.nonlinear.scalar.GoalType;\n import org.apache.commons.math3.optim.nonlinear.scalar.ObjectiveFunction;\n-import org.apache.commons.math3.optim.PointValuePair;\n import org.apache.commons.math3.optim.nonlinear.scalar.LeastSquaresConverter;\n import org.apache.commons.math3.util.FastMath;\n import org.junit.Assert;\n import org.junit.Test;\n \n public class SimplexOptimizerNelderMeadTest {\n+    @Test(expected=MathUnsupportedOperationException.class)\n+    public void testBoundsUnsupported() {\n+        SimplexOptimizer optimizer = new SimplexOptimizer(1e-10, 1e-30);\n+        final FourExtrema fourExtrema = new FourExtrema();\n+\n+        optimizer.optimize(new MaxEval(100),\n+                           new ObjectiveFunction(fourExtrema),\n+                           GoalType.MINIMIZE,\n+                           new InitialGuess(new double[] { -3, 0 }),\n+                           new NelderMeadSimplex(new double[] { 0.2, 0.2 }),\n+                           new SimpleBounds(new double[] { -5, -1 },\n+                                            new double[] { 5, 1 }));\n+    }\n+\n     @Test\n     public void testMinimize1() {\n         SimplexOptimizer optimizer = new SimplexOptimizer(1e-10, 1e-30);", "timestamp": 1360240896, "metainfo": ""}