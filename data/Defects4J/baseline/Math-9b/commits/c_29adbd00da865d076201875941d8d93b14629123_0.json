{"sha": "29adbd00da865d076201875941d8d93b14629123", "log": "Added G-test statistics. JIRA: MATH-878.  Thanks to Radoslav Tsvetkov and Ted Dunning.  ", "commit": "\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math3/stat/inference/GTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math3.stat.inference;\n+\n+import org.apache.commons.math3.distribution.ChiSquaredDistribution;\n+import org.apache.commons.math3.exception.DimensionMismatchException;\n+import org.apache.commons.math3.exception.MaxCountExceededException;\n+import org.apache.commons.math3.exception.NotPositiveException;\n+import org.apache.commons.math3.exception.NotStrictlyPositiveException;\n+import org.apache.commons.math3.exception.OutOfRangeException;\n+import org.apache.commons.math3.exception.ZeroException;\n+import org.apache.commons.math3.exception.util.LocalizedFormats;\n+import org.apache.commons.math3.util.FastMath;\n+import org.apache.commons.math3.util.MathArrays;\n+\n+/**\n+ * Implements <a href=\"http://en.wikipedia.org/wiki/G-test\">G Test</a>\n+ * statistics.\n+ *\n+ * <p>This is known in statistical genetics as the McDonald-Kreitman test.\n+ * The implementation handles both known and unknown distributions.</p>\n+ *\n+ * <p>Two samples tests can be used when the distribution is unknown <i>a priori</i>\n+ * but provided by one sample, or when the hypothesis under test is that the two\n+ * samples come from the same underlying distribution.</p>\n+ *\n+ * @version $Id$\n+ * @since 3.1\n+ */\n+public class GTest {\n+\n+    /**\n+     * Computes the <a href=\"http://en.wikipedia.org/wiki/G-test\">G statistic\n+     * for Goodness of Fit</a> comparing {@code observed} and {@code expected}\n+     * frequency counts.\n+     *\n+     * <p>This statistic can be used to perform a G test (Log-Likelihood Ratio\n+     * Test) evaluating the null hypothesis that the observed counts follow the\n+     * expected distribution.</p>\n+     *\n+     * <p><strong>Preconditions</strong>: <ul>\n+     * <li>Expected counts must all be positive. </li>\n+     * <li>Observed counts must all be &ge; 0. </li>\n+     * <li>The observed and expected arrays must have the same length and their\n+     * common length must be at least 2. </li></ul></p>\n+     *\n+     * <p>If any of the preconditions are not met, a\n+     * {@code MathIllegalArgumentException} is thrown.</p>\n+     *\n+     * <p><strong>Note:</strong>This implementation rescales the\n+     * {@code expected} array if necessary to ensure that the sum of the\n+     * expected and observed counts are equal.</p>\n+     *\n+     * @param observed array of observed frequency counts\n+     * @param expected array of expected frequency counts\n+     * @return G-Test statistic\n+     * @throws NotPositiveException if {@code observed} has negative entries\n+     * @throws NotStrictlyPositiveException if {@code expected} has entries that\n+     * are not strictly positive\n+     * @throws DimensionMismatchException if the array lengths do not match or\n+     * are less than 2.\n+     */\n+    public double gValueGoodnessOfFit(final double[] expected, final long[] observed)\n+            throws NotPositiveException, NotStrictlyPositiveException,\n+            DimensionMismatchException {\n+\n+        if (expected.length < 2) {\n+            throw new DimensionMismatchException(expected.length, 2);\n+        }\n+        if (expected.length != observed.length) {\n+            throw new DimensionMismatchException(expected.length, observed.length);\n+        }\n+        MathArrays.checkPositive(expected);\n+        MathArrays.checkNonNegative(observed);\n+\n+        double sumExpected = 0d;\n+        double sumObserved = 0d;\n+        for (int i = 0; i < observed.length; i++) {\n+            sumExpected += expected[i];\n+            sumObserved += observed[i];\n+        }\n+        double ratio = 1d;\n+        boolean rescale = false;\n+        if (Math.abs(sumExpected - sumObserved) > 10E-6) {\n+            ratio = sumObserved / sumExpected;\n+            rescale = true;\n+        }\n+        double sum = 0d;\n+        for (int i = 0; i < observed.length; i++) {\n+            final double dev = rescale ?\n+                    FastMath.log((double) observed[i] / (ratio * expected[i])) :\n+                        FastMath.log((double) observed[i] / expected[i]);\n+            sum += ((double) observed[i]) * dev;\n+        }\n+        return 2d * sum;\n+    }\n+\n+    /**\n+     * Returns the <i>observed significance level</i>, or <a href=\n+     * \"http://www.cas.lancs.ac.uk/glossary_v1.1/hyptest.html#pvalue\"> p-value</a>,\n+     * associated with a G-Test for goodness of fit</a> comparing the\n+     * {@code observed} frequency counts to those in the {@code expected} array.\n+     *\n+     * <p>The number returned is the smallest significance level at which one\n+     * can reject the null hypothesis that the observed counts conform to the\n+     * frequency distribution described by the expected counts.</p>\n+     *\n+     * <p>The probability returned is the tail probability beyond\n+     * {@link #gValueGoodnessOfFit(double[], long[]) gValueGoodnessOfFit(expected, observed)}\n+     * in the ChiSquare distribution with degrees of freedom one less than the\n+     * common length of {@code expected} and {@code observed}.</p>\n+     *\n+     * <p> <strong>Preconditions</strong>: <ul>\n+     * <li>Expected counts must all be positive. </li>\n+     * <li>Observed counts must all be &ge; 0. </li>\n+     * <li>The observed and expected arrays must have the\n+     * same length and their common length must be at least 2.</li>\n+     * </ul></p>\n+     *\n+     * <p>If any of the preconditions are not met, a\n+     * {@code MathIllegalArgumentException} is thrown.</p>\n+     *\n+     * <p><strong>Note:</strong>This implementation rescales the\n+     * {@code expected} array if necessary to ensure that the sum of the\n+     *  expected and observed counts are equal.</p>\n+     *\n+     * @param observed array of observed frequency counts\n+     * @param expected array of expected frequency counts\n+     * @return p-value\n+     * @throws NotPositiveException if {@code observed} has negative entries\n+     * @throws NotStrictlyPositiveException if {@code expected} has entries that\n+     * are not strictly positive\n+     * @throws DimensionMismatchException if the array lengths do not match or\n+     * are less than 2.\n+     * @throws MaxCountExceededException if an error occurs computing the\n+     * p-value.\n+     */\n+    public double gTestGoodnessOfFitPValue(final double[] expected, final long[] observed)\n+            throws NotPositiveException, NotStrictlyPositiveException,\n+            DimensionMismatchException, MaxCountExceededException {\n+\n+        final ChiSquaredDistribution distribution =\n+                new ChiSquaredDistribution(expected.length - 1.0);\n+        return 1.0 - distribution.cumulativeProbability(\n+                gValueGoodnessOfFit(expected, observed));\n+    }\n+\n+    /**\n+     * Returns the intrinsic (Hardy-Weinberg proportions) p-Value, as described\n+     * in p64-69 of McDonald, J.H. 2009. Handbook of Biological Statistics\n+     * (2nd ed.). Sparky House Publishing, Baltimore, Maryland.\n+     *\n+     * <p> The probability returned is the tail probability beyond\n+     * {@link #gValueGoodnessOfFit(double[], long[]) gValueGoodnessOfFit(expected, observed)}\n+     * in the ChiSquare distribution with degrees of freedom two less than the\n+     * common length of {@code expected} and {@code observed}.</p>\n+     *\n+     * @param observed array of observed frequency counts\n+     * @param expected array of expected frequency counts\n+     * @return p-value\n+     * @throws NotPositiveException if {@code observed} has negative entries\n+     * @throws NotStrictlyPositiveException {@code expected} has entries that are\n+     * not strictly positive\n+     * @throws DimensionMismatchException if the array lengths do not match or\n+     * are less than 2.\n+     * @throws MaxCountExceededException if an error occurs computing the\n+     * p-value.\n+     */\n+    public double gTestGoodnessOfFitIntrinsicPValue(final double[] expected, final long[] observed)\n+            throws NotPositiveException, NotStrictlyPositiveException,\n+            DimensionMismatchException, MaxCountExceededException {\n+\n+        final ChiSquaredDistribution distribution =\n+                new ChiSquaredDistribution(expected.length - 2.0);\n+        return 1.0 - distribution.cumulativeProbability(\n+                gValueGoodnessOfFit(expected, observed));\n+    }\n+\n+    /**\n+     * Performs a G-Test (Log-Likelihood Ratio Test) for goodness of fit\n+     * evaluating the null hypothesis that the observed counts conform to the\n+     * frequency distribution described by the expected counts, with\n+     * significance level {@code alpha}. Returns true iff the null\n+     * hypothesis can be rejected with {@code 100 * (1 - alpha)} percent confidence.\n+     *\n+     * <p><strong>Example:</strong><br> To test the hypothesis that\n+     * {@code observed} follows {@code expected} at the 99% level,\n+     * use </p><p>\n+     * {@code gTest(expected, observed, 0.01)}</p>\n+     *\n+     * <p>Returns true iff {@link #gTestGoodnessOfFitPValue(double[], long[])\n+     *  gTestGoodnessOfFitPValue(expected, observed)} < alpha</p>\n+     *\n+     * <p><strong>Preconditions</strong>: <ul>\n+     * <li>Expected counts must all be positive. </li>\n+     * <li>Observed counts must all be &ge; 0. </li>\n+     * <li>The observed and expected arrays must have the same length and their\n+     * common length must be at least 2.\n+     * <li> {@code 0 < alpha < 0.5} </li></ul></p>\n+     *\n+     * <p>If any of the preconditions are not met, a\n+     * {@code MathIllegalArgumentException} is thrown.</p>\n+     *\n+     * <p><strong>Note:</strong>This implementation rescales the\n+     * {@code expected} array if necessary to ensure that the sum of the\n+     * expected and observed counts are equal.</p>\n+     *\n+     * @param observed array of observed frequency counts\n+     * @param expected array of expected frequency counts\n+     * @param alpha significance level of the test\n+     * @return true iff null hypothesis can be rejected with confidence 1 -\n+     * alpha\n+     * @throws NotPositiveException if {@code observed} has negative entries\n+     * @throws NotStrictlyPositiveException if {@code expected} has entries that\n+     * are not strictly positive\n+     * @throws DimensionMismatchException if the array lengths do not match or\n+     * are less than 2.\n+     * @throws MaxCountExceededException if an error occurs computing the\n+     * p-value.\n+     * @throws OutOfRangeException if alpha is not strictly greater than zero\n+     * and less than or equal to 0.5\n+     */\n+    public boolean gTestGoodnessOfFit(final double[] expected, final long[] observed,\n+            final double alpha)\n+            throws NotPositiveException, NotStrictlyPositiveException,\n+            DimensionMismatchException, OutOfRangeException, MaxCountExceededException {\n+\n+        if ((alpha <= 0) || (alpha > 0.5)) {\n+            throw new OutOfRangeException(LocalizedFormats.OUT_OF_BOUND_SIGNIFICANCE_LEVEL,\n+                    alpha, 0, 0.5);\n+        }\n+        return gTestGoodnessOfFitPValue(expected, observed) < alpha;\n+    }\n+\n+    /**\n+     * Calculates the <a href=\n+     * \"http://en.wikipedia.org/wiki/Entropy_%28information_theory%29\">Shannon\n+     * entropy</a> for 2 Dimensional Matrix.  The value returned is the entropy\n+     * of the vector formed by concatenating the rows (or columns) of {@code k}\n+     * to form a vector. See {@link #entropy(long[])}.\n+     *\n+     * @param k 2 Dimensional Matrix of long values (for ex. the counts of a\n+     * trials)\n+     * @return Shannon Entropy of the given Matrix\n+     *\n+     */\n+    private double entropy(final long[][] k) {\n+        double h = 0d;\n+        double sum_k = 0d;\n+        for (int i = 0; i < k.length; i++) {\n+            for (int j = 0; j < k[i].length; j++) {\n+                sum_k += (double) k[i][j];\n+            }\n+        }\n+        for (int i = 0; i < k.length; i++) {\n+            for (int j = 0; j < k[i].length; j++) {\n+                if (k[i][j] != 0) {\n+                    final double p_ij = (double) k[i][j] / sum_k;\n+                    h += p_ij * Math.log(p_ij);\n+                }\n+            }\n+        }\n+        return -h;\n+    }\n+\n+    /**\n+     * Calculates the <a href=\"http://en.wikipedia.org/wiki/Entropy_%28information_theory%29\">\n+     * Shannon entropy</a> for a vector.  The values of {@code k} are taken to be\n+     * incidence counts of the values of a random variable. What is returned is <br/>\n+     * &sum;p<sub>i</sub>log(p<sub>i</sub><br/>\n+     * where p<sub>i</sub> = k[i] / (sum of elements in k)\n+     *\n+     * @param k Vector (for ex. Row Sums of a trials)\n+     * @return Shannon Entropy of the given Vector\n+     *\n+     */\n+    private double entropy(final long[] k) {\n+        double h = 0d;\n+        double sum_k = 0d;\n+        for (int i = 0; i < k.length; i++) {\n+            sum_k += (double) k[i];\n+        }\n+        for (int i = 0; i < k.length; i++) {\n+            if (k[i] != 0) {\n+                final double p_i = (double) k[i] / sum_k;\n+                h += p_i * Math.log(p_i);\n+            }\n+        }\n+        return -h;\n+    }\n+\n+    /**\n+     * <p>Computes a G (Log-Likelihood Ratio) two sample test statistic for\n+     * independence comparing frequency counts in\n+     * {@code observed1} and {@codeobserved2}. The sums of frequency\n+     * counts in the two samples are not required to be the same. The formula\n+     * used to compute the test statistic is </p>\n+     *\n+     * <p>{@code 2 * totalSum * [H(rowSums) + H(colSums) - H(k)]}</p>\n+     *\n+     * <p> where {@code H} is the\n+     * <a href=\"http://en.wikipedia.org/wiki/Entropy_%28information_theory%29\">\n+     * Shannon Entropy</a> of the random variable formed by viewing the elements\n+     * of the argument array as incidence counts; <br/>\n+     * {@code k} is a matrix with rows {@code [observed1, observed2]}; <br/>\n+     * {@code rowSums, colSums} are the row/col sums of {@code k}; <br>\n+     * and {@code totalSum} is the overall sum of all entries in {@code k}.</p>\n+     *\n+     * <p>This statistic can be used to perform a G test evaluating the null\n+     * hypothesis that both observed counts are independent </p>\n+     *\n+     * <p> <strong>Preconditions</strong>: <ul>\n+     * <li>Observed counts must be non-negative. </li>\n+     * <li>Observed counts for a specific bin must not both be zero. </li>\n+     * <li>Observed counts for a specific sample must not all be  0. </li>\n+     * <li>The arrays {@code observed1} and {@code observed2} must have\n+     * the same length and their common length must be at least 2. </li></ul></p>\n+     *\n+     * <p>If any of the preconditions are not met, a\n+     * {@code MathIllegalArgumentException} is thrown.</p>\n+     *\n+     * @param observed1 array of observed frequency counts of the first data set\n+     * @param observed2 array of observed frequency counts of the second data\n+     * set\n+     * @return G-Test statistic\n+     * @throws DimensionMismatchException the the lengths of the arrays do not\n+     * match or their common length is less than 2\n+     * @throws NotPositiveException if any entry in {@code observed1} or\n+     * {@code observed2} is negative\n+     * @throws ZeroException if either all counts of\n+     * {@code observed1} or {@code observed2} are zero, or if the count\n+     * at the same index is zero for both arrays.\n+     */\n+    public double gValueDataSetsComparison(final long[] observed1, final long[] observed2)\n+            throws DimensionMismatchException, NotPositiveException, ZeroException {\n+\n+        // Make sure lengths are same\n+        if (observed1.length < 2) {\n+            throw new DimensionMismatchException(observed1.length, 2);\n+        }\n+        if (observed1.length != observed2.length) {\n+            throw new DimensionMismatchException(observed1.length, observed2.length);\n+        }\n+\n+        // Ensure non-negative counts\n+        MathArrays.checkNonNegative(observed1);\n+        MathArrays.checkNonNegative(observed2);\n+\n+        // Compute and compare count sums\n+        long countSum1 = 0;\n+        long countSum2 = 0;\n+\n+        // Compute and compare count sums\n+        final long[] collSums = new long[observed1.length];\n+        final long[][] k = new long[2][observed1.length];\n+\n+        for (int i = 0; i < observed1.length; i++) {\n+            if (observed1[i] == 0 && observed2[i] == 0) {\n+                throw new ZeroException(LocalizedFormats.OBSERVED_COUNTS_BOTTH_ZERO_FOR_ENTRY, i);\n+            } else {\n+                countSum1 += observed1[i];\n+                countSum2 += observed2[i];\n+                collSums[i] = observed1[i] + observed2[i];\n+                k[0][i] = observed1[i];\n+                k[1][i] = observed2[i];\n+            }\n+        }\n+        // Ensure neither sample is uniformly 0\n+        if (countSum1 == 0 || countSum2 == 0) {\n+            throw new ZeroException();\n+        }\n+        final long[] rowSums = {countSum1, countSum2};\n+        final double sum = (double) countSum1 + (double) countSum2;\n+        return 2 * sum * (entropy(rowSums) + entropy(collSums) - entropy(k));\n+    }\n+\n+    /**\n+     * Calculates the root log-likelihood ratio for 2 state Datasets. See\n+     * {@link #gValueDataSetsComparison(long[], long[] )}.\n+     *\n+     * <p>Given two events A and B, let k11 be the number of times both events\n+     * occur, k12 the incidence of B without A, k21 the count of A without B,\n+     * and k22 the number of times neither A nor B occurs.  What is returned\n+     * by this method is </p>\n+     *\n+     * <p>{@code (sgn) sqrt(gValueDataSetsComparison({k11, k12}, {k21, k22})}</p>\n+     *\n+     * <p>where {@code sgn} is -1 if {@code k11 / (k11 + k12) < k21 / (k21 + k22))};<br/>\n+     * 1 otherwise.</p>\n+     *\n+     * <p>Signed root LLR has two advantages over the basic LLR: a) it is positive\n+     * where k11 is bigger than expected, negative where it is lower b) if there is\n+     * no difference it is asymptotically normally distributed. This allows one\n+     * to talk about \"number of standard deviations\" which is a more common frame\n+     * of reference than the chi^2 distribution.</p>\n+     *\n+     * @param k11 number of times the two events occurred together (AB)\n+     * @param k12 number of times the second event occurred WITHOUT the\n+     * first event (notA,B)\n+     * @param k21 number of times the first event occurred WITHOUT the\n+     * second event (A, notB)\n+     * @param k22 number of times something else occurred (i.e. was neither\n+     * of these events (notA, notB)\n+     * @return root log-likelihood ratio\n+     *\n+     */\n+    public double rootLogLikelihoodRatio(final long k11, long k12,\n+            final long k21, final long k22) {\n+        final double llr = gValueDataSetsComparison(\n+                new long[]{k11, k12}, new long[]{k21, k22});\n+        double sqrt = FastMath.sqrt(llr);\n+        if ((double) k11 / (k11 + k12) < (double) k21 / (k21 + k22)) {\n+            sqrt = -sqrt;\n+        }\n+        return sqrt;\n+    }\n+\n+    /**\n+     * <p>Returns the <i>observed significance level</i>, or <a href=\n+     * \"http://www.cas.lancs.ac.uk/glossary_v1.1/hyptest.html#pvalue\">\n+     * p-value</a>, associated with a G-Value (Log-Likelihood Ratio) for two\n+     * sample test comparing bin frequency counts in {@code observed1} and\n+     * {@code observed2}.</p>\n+     *\n+     * <p>The number returned is the smallest significance level at which one\n+     * can reject the null hypothesis that the observed counts conform to the\n+     * same distribution. </p>\n+     *\n+     * <p>See {@link #gTestGoodnessOfFitPValue(double[], long[])} for details\n+     * on how the p-value is computed.  The degrees of of freedom used to\n+     * perform the test is one less than the common length of the input observed\n+     * count arrays.</p>\n+     *\n+     * <p><strong>Preconditions</strong>:\n+     * <ul> <li>Observed counts must be non-negative. </li>\n+     * <li>Observed counts for a specific bin must not both be zero. </li>\n+     * <li>Observed counts for a specific sample must not all be 0. </li>\n+     * <li>The arrays {@code observed1} and {@ode observed2} must\n+     * have the same length and their common length must be at least 2. </li>\n+     * </ul><p>\n+     * <p> If any of the preconditions are not met, a\n+     * {@code MathIllegalArgumentException} is thrown.</p>\n+     *\n+     * @param observed1 array of observed frequency counts of the first data set\n+     * @param observed2 array of observed frequency counts of the second data\n+     * set\n+     * @return p-value\n+     * @throws DimensionMismatchException the the length of the arrays does not\n+     * match or their common length is less than 2\n+     * @throws NotPositiveException if any of the entries in {@code observed1} or\n+     * {@code observed2} are negative\n+     * @throws ZeroException if either all counts of {@code observed1} or\n+     * {@code observed2} are zero, or if the count at some index is\n+     * zero for both arrays\n+     * @throws MaxCountExceededException if an error occurs computing the\n+     * p-value.\n+     */\n+    public double gTestDataSetsComparisonPValue(final long[] observed1,\n+            final long[] observed2)\n+            throws DimensionMismatchException, NotPositiveException, ZeroException,\n+            MaxCountExceededException {\n+        final ChiSquaredDistribution distribution = new ChiSquaredDistribution(\n+                (double) observed1.length - 1);\n+        return 1 - distribution.cumulativeProbability(\n+                gValueDataSetsComparison(observed1, observed2));\n+    }\n+\n+    /**\n+     * <p>Performs a G-Test (Log-Likelihood Ratio Test) comparing two binned\n+     * data sets. The test evaluates the null hypothesis that the two lists\n+     * of observed counts conform to the same frequency distribution, with\n+     * significance level {@code alpha}. Returns true iff the null\n+     * hypothesis can be rejected  with 100 * (1 - alpha) percent confidence.\n+     * </p>\n+     * <p>See {@link #gValueDataSetsComparison(long[], long[])} for details\n+     * on the formula used to compute the G (LLR) statistic used in the test and\n+     * {@link #gTestGoodnessOfFitPValue(double[], long[])} for information on how\n+     * the observed significance level is computed. The degrees of of freedom used\n+     * to perform the test is one less than the common length of the input observed\n+     * count arrays. </p>\n+     *\n+     * <strong>Preconditions</strong>: <ul>\n+     * <li>Observed counts must be non-negative. </li>\n+     * <li>Observed counts for a specific bin must not both be zero. </li>\n+     * <li>Observed counts for a specific sample must not all be 0. </li>\n+     * <li>The arrays {@code observed1} and {@code observed2} must\n+     * have the same length and their common length must be at least 2. </li>\n+     * <li>{@code 0 < alpha < 0.5} </li></ul></p>\n+     *\n+     * <p>If any of the preconditions are not met, a\n+     * {@code MathIllegalArgumentException} is thrown.</p>\n+     *\n+     * @param observed1 array of observed frequency counts of the first data set\n+     * @param observed2 array of observed frequency counts of the second data\n+     * set\n+     * @param alpha significance level of the test\n+     * @return true iff null hypothesis can be rejected with confidence 1 -\n+     * alpha\n+     * @throws DimensionMismatchException the the length of the arrays does not\n+     * match\n+     * @throws NotPositiveException if any of the entries in {@code observed1} or\n+     * {@code observed2} are negative\n+     * @throws ZeroException if either all counts of {@code observed1} or\n+     * {@code observed2} are zero, or if the count at some index is\n+     * zero for both arrays\n+     * @throws OutOfRangeException if {@code alpha} is not in the range\n+     * (0, 0.5]\n+     * @throws MaxCountExceededException if an error occurs performing the test\n+     */\n+    public boolean gTestDataSetsComparison(\n+            final long[] observed1,\n+            final long[] observed2,\n+            final double alpha)\n+            throws DimensionMismatchException, NotPositiveException,\n+            ZeroException, OutOfRangeException, MaxCountExceededException {\n+\n+        if (alpha <= 0 || alpha > 0.5) {\n+            throw new OutOfRangeException(\n+                    LocalizedFormats.OUT_OF_BOUND_SIGNIFICANCE_LEVEL, alpha, 0, 0.5);\n+        }\n+        return gTestDataSetsComparisonPValue(observed1, observed2) < alpha;\n+    }\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/math3/stat/inference/GTestTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math3.stat.inference;\n+\n+import org.apache.commons.math3.exception.DimensionMismatchException;\n+import org.apache.commons.math3.exception.NotPositiveException;\n+import org.apache.commons.math3.exception.NotStrictlyPositiveException;\n+import org.apache.commons.math3.exception.OutOfRangeException;\n+import org.apache.commons.math3.exception.ZeroException;\n+import org.junit.Assert;\n+import org.junit.Test;\n+\n+/**\n+ * Test cases for the GTest class.\n+ *\n+ * Data for the tests are from p64-69 in: McDonald, J.H. 2009. Handbook of\n+ * Biological Statistics (2nd ed.). Sparky House Publishing, Baltimore,\n+ * Maryland.\n+ *\n+ */\n+public class GTestTest {\n+\n+    protected GTest testStatistic = new GTest();\n+\n+    @Test\n+    public void testGTestGoodnesOfFit1() throws Exception {\n+        final double[] exp = new double[]{\n+            3d, 1d\n+        };\n+\n+        final long[] obs = new long[]{\n+            423, 133\n+        };\n+\n+        Assert.assertEquals(\"G test statistic\",\n+                0.348721, testStatistic.gValueGoodnessOfFit(exp, obs), 1E-6);\n+        final double p_gtgf = testStatistic.gTestGoodnessOfFitPValue(exp, obs);\n+        Assert.assertEquals(\"g-Test p-value\", 0.55483, p_gtgf, 1E-5);\n+\n+        Assert.assertFalse(testStatistic.gTestGoodnessOfFit(exp, obs, 0.05));\n+    }\n+\n+    @Test\n+    public void testGTestGoodnesOfFit2() throws Exception {\n+        final double[] exp = new double[]{\n+            0.54d, 0.40d, 0.05d, 0.01d\n+        };\n+\n+        final long[] obs = new long[]{\n+            70, 79, 3, 4\n+        };\n+        Assert.assertEquals(\"G test statistic\",\n+                13.144799, testStatistic.gValueGoodnessOfFit(exp, obs), 1E-6);\n+        final double p_gtgf = testStatistic.gTestGoodnessOfFitPValue(exp, obs);\n+        Assert.assertEquals(\"g-Test p-value\", 0.004333, p_gtgf, 1E-5);\n+\n+        Assert.assertTrue(testStatistic.gTestGoodnessOfFit(exp, obs, 0.05));\n+    }\n+\n+    @Test\n+    public void testGTestGoodnesOfFit3() throws Exception {\n+        final double[] exp = new double[]{\n+            0.167d, 0.483d, 0.350d\n+        };\n+\n+        final long[] obs = new long[]{\n+            14, 21, 25\n+        };\n+\n+        Assert.assertEquals(\"G test statistic\",\n+                4.5554, testStatistic.gValueGoodnessOfFit(exp, obs), 1E-4);\n+        // Intrinisic (Hardy-Weinberg proportions) P-Value should be 0.033\n+        final double p_gtgf = testStatistic.gTestGoodnessOfFitIntrinsicPValue(exp, obs);\n+        Assert.assertEquals(\"g-Test p-value\", 0.0328, p_gtgf, 1E-4);\n+\n+        Assert.assertFalse(testStatistic.gTestGoodnessOfFit(exp, obs, 0.05));\n+    }\n+\n+    @Test\n+    public void testGTestIndependance1() throws Exception {\n+        final long[] obs1 = new long[]{\n+            268, 199, 42\n+        };\n+\n+        final long[] obs2 = new long[]{\n+            807, 759, 184\n+        };\n+\n+        final double g = testStatistic.gValueDataSetsComparison(obs1, obs2);\n+\n+        Assert.assertEquals(\"G test statistic\",\n+                7.3008170, g, 1E-6);\n+        final double p_gti = testStatistic.gTestDataSetsComparisonPValue(obs1, obs2);\n+\n+        Assert.assertEquals(\"g-Test p-value\", 0.0259805, p_gti, 1E-6);\n+        Assert.assertTrue(testStatistic.gTestDataSetsComparison(obs1, obs2, 0.05));\n+    }\n+\n+    @Test\n+    public void testGTestIndependance2() throws Exception {\n+        final long[] obs1 = new long[]{\n+            127, 99, 264\n+        };\n+\n+        final long[] obs2 = new long[]{\n+            116, 67, 161\n+        };\n+\n+        final double g = testStatistic.gValueDataSetsComparison(obs1, obs2);\n+\n+        Assert.assertEquals(\"G test statistic\",\n+                6.227288, g, 1E-6);\n+        final double p_gti = testStatistic.gTestDataSetsComparisonPValue(obs1, obs2);\n+\n+        Assert.assertEquals(\"g-Test p-value\", 0.04443, p_gti, 1E-5);\n+        Assert.assertTrue(testStatistic.gTestDataSetsComparison(obs1, obs2, 0.05));\n+    }\n+\n+    @Test\n+    public void testGTestIndependance3() throws Exception {\n+        final long[] obs1 = new long[]{\n+            190, 149\n+        };\n+\n+        final long[] obs2 = new long[]{\n+            42, 49\n+        };\n+\n+        final double g = testStatistic.gValueDataSetsComparison(obs1, obs2);\n+        Assert.assertEquals(\"G test statistic\",\n+                2.8187, g, 1E-4);\n+        final double p_gti = testStatistic.gTestDataSetsComparisonPValue(obs1, obs2);\n+        Assert.assertEquals(\"g-Test p-value\", 0.09317325, p_gti, 1E-6);\n+\n+        Assert.assertFalse(testStatistic.gTestDataSetsComparison(obs1, obs2, 0.05));\n+    }\n+\n+    @Test\n+    public void testGTestSetsComparisonBadCounts() {\n+        long[] observed1 = {10, -1, 12, 10, 15};\n+        long[] observed2 = {15, 10, 10, 15, 5};\n+        try {\n+            testStatistic.gTestDataSetsComparisonPValue(\n+                    observed1, observed2);\n+            Assert.fail(\"Expecting NotPositiveException - negative count\");\n+        } catch (NotPositiveException ex) {\n+            // expected\n+        }\n+        long[] observed3 = {10, 0, 12, 10, 15};\n+        long[] observed4 = {15, 0, 10, 15, 5};\n+        try {\n+            testStatistic.gTestDataSetsComparisonPValue(\n+                    observed3, observed4);\n+            Assert.fail(\"Expecting ZeroException - double 0's\");\n+        } catch (ZeroException ex) {\n+            // expected\n+        }\n+        long[] observed5 = {10, 10, 12, 10, 15};\n+        long[] observed6 = {0, 0, 0, 0, 0};\n+        try {\n+            testStatistic.gTestDataSetsComparisonPValue(\n+                    observed5, observed6);\n+            Assert.fail(\"Expecting ZeroException - vanishing counts\");\n+        } catch (ZeroException ex) {\n+            // expected\n+        }\n+    }\n+    \n+    @Test\n+    public void testUnmatchedArrays() {\n+        final long[] observed = { 0, 1, 2, 3 };\n+        final double[] expected = { 1, 1, 2 };\n+        final long[] observed2 = {3, 4};\n+        try {\n+            testStatistic.gTestGoodnessOfFitPValue(expected, observed);\n+            Assert.fail(\"arrays have different lengths, DimensionMismatchException expected\");\n+        } catch (DimensionMismatchException ex) {\n+            // expected\n+        }\n+        try {\n+            testStatistic.gTestDataSetsComparisonPValue(observed, observed2);\n+            Assert.fail(\"arrays have different lengths, DimensionMismatchException expected\");\n+        } catch (DimensionMismatchException ex) {\n+            // expected\n+        }\n+    }\n+    \n+    @Test\n+    public void testNegativeObservedCounts() {\n+        final long[] observed = { 0, 1, 2, -3 };\n+        final double[] expected = { 1, 1, 2, 3};\n+        final long[] observed2 = {3, 4, 5, 0};\n+        try {\n+            testStatistic.gTestGoodnessOfFitPValue(expected, observed);\n+            Assert.fail(\"negative observed count, NotPositiveException expected\");\n+        } catch (NotPositiveException ex) {\n+            // expected\n+        }\n+        try {\n+            testStatistic.gTestDataSetsComparisonPValue(observed, observed2);\n+            Assert.fail(\"negative observed count, NotPositiveException expected\");\n+        } catch (NotPositiveException ex) {\n+            // expected\n+        } \n+    }\n+    \n+    @Test\n+    public void testZeroExpectedCounts() {\n+        final long[] observed = { 0, 1, 2, -3 };\n+        final double[] expected = { 1, 0, 2, 3};\n+        try {\n+            testStatistic.gTestGoodnessOfFitPValue(expected, observed);\n+            Assert.fail(\"zero expected count, NotStrictlyPositiveException expected\");\n+        } catch (NotStrictlyPositiveException ex) {\n+            // expected\n+        }\n+    }\n+    \n+    @Test\n+    public void testBadAlpha() {\n+        final long[] observed = { 0, 1, 2, 3 };\n+        final double[] expected = { 1, 2, 2, 3};\n+        final long[] observed2 = { 0, 2, 2, 3 };\n+        try {\n+            testStatistic.gTestGoodnessOfFit(expected, observed, 0.8);\n+            Assert.fail(\"zero expected count, NotStrictlyPositiveException expected\");\n+        } catch (OutOfRangeException ex) {\n+            // expected\n+        }\n+        try {\n+            testStatistic.gTestDataSetsComparison(observed, observed2, -0.5);\n+            Assert.fail(\"zero expected count, NotStrictlyPositiveException expected\");\n+        } catch (OutOfRangeException ex) {\n+            // expected\n+        }  \n+    }\n+    \n+    @Test\n+    public void testScaling() {\n+      final long[] observed = {9, 11, 10, 8, 12};\n+      final double[] expected1 = {10, 10, 10, 10, 10};\n+      final double[] expected2 = {1000, 1000, 1000, 1000, 1000};\n+      final double[] expected3 = {1, 1, 1, 1, 1};\n+      final double tol = 1E-15;\n+      Assert.assertEquals(\n+              testStatistic.gTestGoodnessOfFitPValue(expected1, observed),\n+              testStatistic.gTestGoodnessOfFitPValue(expected2, observed),\n+              tol);\n+      Assert.assertEquals(\n+              testStatistic.gTestGoodnessOfFitPValue(expected1, observed),\n+              testStatistic.gTestGoodnessOfFitPValue(expected3, observed),\n+              tol);\n+    }\n+\n+    @Test\n+    public void testRootLogLikelihood() {\n+        // positive where k11 is bigger than expected.\n+        Assert.assertTrue(testStatistic.rootLogLikelihoodRatio(904, 21060, 1144, 283012) > 0.0);\n+\n+        // negative because k11 is lower than expected\n+        Assert.assertTrue(testStatistic.rootLogLikelihoodRatio(36, 21928, 60280, 623876) < 0.0);\n+\n+        Assert.assertEquals(Math.sqrt(2.772589), testStatistic.rootLogLikelihoodRatio(1, 0, 0, 1), 0.000001);\n+        Assert.assertEquals(-Math.sqrt(2.772589), testStatistic.rootLogLikelihoodRatio(0, 1, 1, 0), 0.000001);\n+        Assert.assertEquals(Math.sqrt(27.72589), testStatistic.rootLogLikelihoodRatio(10, 0, 0, 10), 0.00001);\n+\n+        Assert.assertEquals(Math.sqrt(39.33052), testStatistic.rootLogLikelihoodRatio(5, 1995, 0, 100000), 0.00001);\n+        Assert.assertEquals(-Math.sqrt(39.33052), testStatistic.rootLogLikelihoodRatio(0, 100000, 5, 1995), 0.00001);\n+\n+        Assert.assertEquals(Math.sqrt(4730.737), testStatistic.rootLogLikelihoodRatio(1000, 1995, 1000, 100000), 0.001);\n+        Assert.assertEquals(-Math.sqrt(4730.737), testStatistic.rootLogLikelihoodRatio(1000, 100000, 1000, 1995), 0.001);\n+\n+        Assert.assertEquals(Math.sqrt(5734.343), testStatistic.rootLogLikelihoodRatio(1000, 1000, 1000, 100000), 0.001);\n+        Assert.assertEquals(Math.sqrt(5714.932), testStatistic.rootLogLikelihoodRatio(1000, 1000, 1000, 99000), 0.001);\n+    }\n+}", "timestamp": 1352057555, "metainfo": ""}