{"sha": "fa71f3b87a0661b5d2ab920fb9e931d113909a57", "log": "Preliminary checkin of SoC code. Contributed by: Xiaogang Zhang   ", "commit": "\n--- /dev/null\n+++ b/src/java/org/apache/commons/math/analysis/DividedDifferenceInterpolator.java\n+/*\n+ * Copyright 2003-2005 The Apache Software Foundation.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.analysis;\n+\n+import java.io.Serializable;\n+import org.apache.commons.math.MathException;\n+\n+/**\n+ * Implements the <a href=\"\n+ * \"http://mathworld.wolfram.com/NewtonsDividedDifferenceInterpolationFormula.html\">\n+ * Divided Difference Algorithm</a> for interpolation of real univariate\n+ * functions. For reference, see <b>Introduction to Numerical Analysis</b>,\n+ * ISBN 038795452X, chapter 2.\n+ * <p>\n+ * The actual code of Neville's evalution is in PolynomialFunctionLagrangeForm,\n+ * this class provides an easy-to-use interface to it.\n+ *\n+ * @version $Revision$ $Date$\n+ */\n+public class DividedDifferenceInterpolator implements UnivariateRealInterpolator,\n+    Serializable {\n+\n+    /** serializable version identifier */\n+    static final long serialVersionUID = 107049519551235069L;\n+\n+    /**\n+     * Computes an interpolating function for the data set.\n+     *\n+     * @param x the interpolating points array\n+     * @param y the interpolating values array\n+     * @return a function which interpolates the data set\n+     * @throws MathException if arguments are invalid\n+     */\n+    public UnivariateRealFunction interpolate(double x[], double y[]) throws\n+        MathException {\n+\n+        /**\n+         * a[] and c[] are defined in the general formula of Newton form:\n+         * p(x) = a[0] + a[1](x-c[0]) + a[2](x-c[0])(x-c[1]) + ... +\n+         *        a[n](x-c[0])(x-c[1])...(x-c[n-1])\n+         */\n+        double a[], c[];\n+\n+        PolynomialFunctionLagrangeForm.verifyInterpolationArray(x, y);\n+\n+        /**\n+         * When used for interpolation, the Newton form formula becomes\n+         * p(x) = f[x0] + f[x0,x1](x-x0) + f[x0,x1,x2](x-x0)(x-x1) + ... +\n+         *        f[x0,x1,...,x[n-1]](x-x0)(x-x1)...(x-x[n-2])\n+         * Therefore, a[k] = f[x0,x1,...,xk], c[k] = x[k].\n+         * <p>\n+         * Note x[], y[], a[] have the same length but c[]'s size is one less.\n+         */\n+        c = new double[x.length-1];\n+        for (int i = 0; i < c.length; i++) {\n+            c[i] = x[i];\n+        }\n+        a = computeDividedDifference(x, y);\n+\n+        PolynomialFunctionNewtonForm p;\n+        p = new PolynomialFunctionNewtonForm(a, c);\n+        return p;\n+    }\n+\n+    /**\n+     * Returns a copy of the divided difference array defined recursively by\n+     * f[x0] = f(x0)\n+     * f[x0,x1,...,xk] = (f(x1,...,xk) - f(x0,...,x[k-1])) / (xk - x0)\n+     * <p>\n+     * The computational complexity is O(N^2).\n+     *\n+     * @return a fresh copy of the divided difference array\n+     * @throws MathException if any abscissas coincide\n+     */\n+    protected static double[] computeDividedDifference(double x[], double y[])\n+        throws MathException {\n+\n+        int i, j, n;\n+        double divdiff[], a[], denominator;\n+\n+        PolynomialFunctionLagrangeForm.verifyInterpolationArray(x, y);\n+\n+        n = x.length;\n+        divdiff = new double[n];\n+        for (i = 0; i < n; i++) {\n+            divdiff[i] = y[i];      // initialization\n+        }\n+\n+        a = new double [n];\n+        a[0] = divdiff[0];\n+        for (i = 1; i < n; i++) {\n+            for (j = 0; j < n-i; j++) {\n+                denominator = x[j+i] - x[j];\n+                if (denominator == 0.0) {\n+                    // This happens only when two abscissas are identical.\n+                    throw new MathException\n+                        (\"Identical abscissas cause division by zero.\");\n+                }\n+                divdiff[j] = (divdiff[j+1] - divdiff[j]) / denominator;\n+            }\n+            a[i] = divdiff[0];\n+        }\n+\n+        return a;\n+    }\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/math/analysis/LaguerreSolver.java\n+/*\n+ * Copyright 2005 The Apache Software Foundation.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.analysis;\n+\n+import org.apache.commons.math.ConvergenceException;\n+import org.apache.commons.math.FunctionEvaluationException;\n+import org.apache.commons.math.complex.*;\n+\n+/**\n+ * Implements the <a href=\"http://mathworld.wolfram.com/LaguerresMethod.html\">\n+ * Laguerre's Method</a> for root finding of real coefficient polynomials.\n+ * For reference, see <b>A First Course in Numerical Analysis</b>,\n+ * ISBN 048641454X, chapter 8.\n+ * <p>\n+ * Laguerre's method is global in the sense that it can start with any initial\n+ * approximation and be able to solve all roots from that point.\n+ *\n+ * @version $Revision$ $Date$\n+ */\n+public class LaguerreSolver extends UnivariateRealSolverImpl {\n+\n+    /** serializable version identifier */\n+    static final long serialVersionUID = 5287689975005870178L;\n+\n+    /** polynomial function to solve */\n+    private PolynomialFunction p;\n+\n+    /**\n+     * Construct a solver for the given function.\n+     *\n+     * @param f function to solve\n+     * @throws IllegalArgumentException if function is not polynomial\n+     */\n+    public LaguerreSolver(UnivariateRealFunction f) throws\n+        IllegalArgumentException {\n+\n+        super(f, 100, 1E-6);\n+        if (f instanceof PolynomialFunction) {\n+            p = (PolynomialFunction)f;\n+        } else {\n+            throw new IllegalArgumentException(\"Function is not polynomial.\");\n+        }\n+    }\n+\n+    /**\n+     * Returns a copy of the polynomial function.\n+     * \n+     * @return a fresh copy of the polynomial function\n+     */\n+    public PolynomialFunction getPolynomialFunction() {\n+        return new PolynomialFunction(p.getCoefficients());\n+    }\n+\n+    /**\n+     * Find a real root in the given interval with initial value.\n+     * <p>\n+     * Requires bracketing condition.\n+     * \n+     * @param min the lower bound for the interval\n+     * @param max the upper bound for the interval\n+     * @param initial the start value to use\n+     * @return the point at which the function value is zero\n+     * @throws ConvergenceException if the maximum iteration count is exceeded\n+     * or the solver detects convergence problems otherwise\n+     * @throws FunctionEvaluationException if an error occurs evaluating the\n+     * function\n+     * @throws IllegalArgumentException if any parameters are invalid\n+     */\n+    public double solve(double min, double max, double initial) throws\n+        ConvergenceException, FunctionEvaluationException {\n+\n+        // check for zeros before verifying bracketing\n+        if (p.value(min) == 0.0) { return min; }\n+        if (p.value(max) == 0.0) { return max; }\n+        if (p.value(initial) == 0.0) { return initial; }\n+\n+        verifyBracketing(min, max, p);\n+        verifySequence(min, initial, max);\n+        if (isBracketing(min, initial, p)) {\n+            return solve(min, initial);\n+        } else {\n+            return solve(initial, max);\n+        }\n+    }\n+\n+    /**\n+     * Find a real root in the given interval.\n+     * <p>\n+     * Despite the bracketing condition, the root returned by solve(Complex[],\n+     * Complex) may not be a real zero inside [min, max]. For example,\n+     * p(x) = x^3 + 1, min = -2, max = 2, initial = 0. We can either try\n+     * another initial value, or, as we did here, call solveAll() to obtain\n+     * all roots and pick up the one that we're looking for.\n+     *\n+     * @param min the lower bound for the interval\n+     * @param max the upper bound for the interval\n+     * @return the point at which the function value is zero\n+     * @throws ConvergenceException if the maximum iteration count is exceeded\n+     * or the solver detects convergence problems otherwise\n+     * @throws FunctionEvaluationException if an error occurs evaluating the\n+     * function \n+     * @throws IllegalArgumentException if any parameters are invalid\n+     */\n+    public double solve(double min, double max) throws ConvergenceException, \n+        FunctionEvaluationException {\n+\n+        Complex c[], root[], initial, z;\n+\n+        // check for zeros before verifying bracketing\n+        if (p.value(min) == 0.0) { return min; }\n+        if (p.value(max) == 0.0) { return max; }\n+        verifyBracketing(min, max, p);\n+\n+        double coefficients[] = p.getCoefficients();\n+        c = new Complex[coefficients.length];\n+        for (int i = 0; i < coefficients.length; i++) {\n+            c[i] = new Complex(coefficients[i], 0.0);\n+        }\n+        initial = new Complex(0.5 * (min + max), 0.0);\n+        z = solve(c, initial);\n+        if (isRootOK(min, max, z)) {\n+            setResult(z.getReal(), iterationCount);\n+            return result;\n+        }\n+\n+        // solve all roots and select the one we're seeking\n+        root = solveAll(c, initial);\n+        for (int i = 0; i < root.length; i++) {\n+            if (isRootOK(min, max, root[i])) {\n+                setResult(root[i].getReal(), iterationCount);\n+                return result;\n+            }\n+        }\n+\n+        // should never happen\n+        throw new ConvergenceException(\"Convergence failed.\");\n+    }\n+\n+    /**\n+     * Returns true iff the given complex root is actually a real zero\n+     * in the given interval, within the solver tolerance level.\n+     * \n+     * @param min the lower bound for the interval\n+     * @param max the upper bound for the interval\n+     * @param z the complex root\n+     * @return true iff z is the sought-after real zero\n+     */\n+    protected boolean isRootOK(double min, double max, Complex z) {\n+        double tolerance = Math.max(relativeAccuracy * z.abs(), absoluteAccuracy);\n+        return (isSequence(min, z.getReal(), max)) &&\n+               (Math.abs(z.getImaginary()) <= tolerance ||\n+                z.abs() <= functionValueAccuracy);\n+    }\n+\n+    /**\n+     * Find all complex roots for the polynomial with the given coefficients,\n+     * starting from the given initial value.\n+     * \n+     * @param coefficients the polynomial coefficients array\n+     * @param initial the start value to use\n+     * @return the point at which the function value is zero\n+     * @throws ConvergenceException if the maximum iteration count is exceeded\n+     * or the solver detects convergence problems otherwise\n+     * @throws FunctionEvaluationException if an error occurs evaluating the\n+     * function \n+     * @throws IllegalArgumentException if any parameters are invalid\n+     */\n+    public Complex[] solveAll(double coefficients[], double initial) throws\n+        ConvergenceException, FunctionEvaluationException {\n+\n+        Complex c[] = new Complex[coefficients.length];\n+        Complex z = new Complex(initial, 0.0);\n+        for (int i = 0; i < c.length; i++) {\n+            c[i] = new Complex(coefficients[i], 0.0);\n+        }\n+        return solveAll(c, z);\n+    }\n+\n+    /**\n+     * Find all complex roots for the polynomial with the given coefficients,\n+     * starting from the given initial value.\n+     * \n+     * @param coefficients the polynomial coefficients array\n+     * @param initial the start value to use\n+     * @return the point at which the function value is zero\n+     * @throws ConvergenceException if the maximum iteration count is exceeded\n+     * or the solver detects convergence problems otherwise\n+     * @throws FunctionEvaluationException if an error occurs evaluating the\n+     * function \n+     * @throws IllegalArgumentException if any parameters are invalid\n+     */\n+    public Complex[] solveAll(Complex coefficients[], Complex initial) throws\n+        ConvergenceException, FunctionEvaluationException {\n+\n+        int i, j, n, iterationCount = 0;\n+        Complex root[], c[], subarray[], oldc, newc;\n+\n+        n = coefficients.length - 1;\n+        if (n < 1) {\n+            throw new IllegalArgumentException\n+                (\"Polynomial degree must be positive: degree=\" + n);\n+        }\n+        c = new Complex[n+1];    // coefficients for deflated polynomial\n+        for (i = 0; i <= n; i++) {\n+            c[i] = coefficients[i];\n+        }\n+\n+        // solve individual root successively\n+        root = new Complex[n];\n+        for (i = 0; i < n; i++) {\n+            subarray = new Complex[n-i+1];\n+            System.arraycopy(c, 0, subarray, 0, subarray.length);\n+            root[i] = solve(subarray, initial);\n+            // polynomial deflation using synthetic division\n+            newc = c[n-i];\n+            for (j = n-i-1; j >= 0; j--) {\n+                oldc = c[j];\n+                c[j] = newc;\n+                newc = oldc.add(newc.multiply(root[i]));\n+            }\n+            iterationCount += this.iterationCount;\n+        }\n+\n+        resultComputed = true;\n+        this.iterationCount = iterationCount;\n+        return root;\n+    }\n+\n+    /**\n+     * Find a complex root for the polynomial with the given coefficients,\n+     * starting from the given initial value.\n+     * \n+     * @param coefficients the polynomial coefficients array\n+     * @param initial the start value to use\n+     * @return the point at which the function value is zero\n+     * @throws ConvergenceException if the maximum iteration count is exceeded\n+     * or the solver detects convergence problems otherwise\n+     * @throws FunctionEvaluationException if an error occurs evaluating the\n+     * function \n+     * @throws IllegalArgumentException if any parameters are invalid\n+     */\n+    public Complex solve(Complex coefficients[], Complex initial) throws\n+        ConvergenceException, FunctionEvaluationException {\n+\n+        Complex z = initial, oldz, pv, dv, d2v, G, G2, H, delta, denominator;\n+\n+        int n = coefficients.length - 1;\n+        if (n < 1) {\n+            throw new IllegalArgumentException\n+                (\"Polynomial degree must be positive: degree=\" + n);\n+        }\n+        Complex N = new Complex((double)n, 0.0);\n+        Complex N1 = new Complex((double)(n-1), 0.0);\n+\n+        int i = 1;\n+        oldz = new Complex(Double.POSITIVE_INFINITY, Double.POSITIVE_INFINITY);\n+        while (i <= maximalIterationCount) {\n+            // Compute pv (polynomial value), dv (derivative value), and\n+            // d2v (second derivative value) simultaneously.\n+            pv = coefficients[n];\n+            dv = d2v = new Complex(0.0, 0.0);\n+            for (int j = n-1; j >= 0; j--) {\n+                d2v = dv.add(z.multiply(d2v));\n+                dv = pv.add(z.multiply(dv));\n+                pv = coefficients[j].add(z.multiply(pv));\n+            }\n+            d2v = d2v.multiply(new Complex(2.0, 0.0));\n+\n+            // check for convergence\n+            double tolerance = Math.max(relativeAccuracy * z.abs(),\n+                                        absoluteAccuracy);\n+            if ((z.subtract(oldz)).abs() <= tolerance) {\n+                resultComputed = true;\n+                iterationCount = i;\n+                return z;\n+            }\n+            if (pv.abs() <= functionValueAccuracy) {\n+                resultComputed = true;\n+                iterationCount = i;\n+                return z;\n+            }\n+\n+            // now pv != 0, calculate the new approximation\n+            G = dv.divide(pv);\n+            G2 = G.multiply(G);\n+            H = G2.subtract(d2v.divide(pv));\n+            delta = N1.multiply((N.multiply(H)).subtract(G2));\n+            // choose a denominator larger in magnitude\n+            Complex dplus = G.add(ComplexUtils.sqrt(delta));\n+            Complex dminus = G.subtract(ComplexUtils.sqrt(delta));\n+            denominator = dplus.abs() > dminus.abs() ? dplus : dminus;\n+            // Perturb z if denominator is zero, for instance,\n+            // p(x) = x^3 + 1, z = 0.\n+            if (denominator.equals(new Complex(0.0, 0.0))) {\n+                z = z.add(new Complex(absoluteAccuracy, absoluteAccuracy));\n+                oldz = new Complex(Double.POSITIVE_INFINITY,\n+                                   Double.POSITIVE_INFINITY);\n+            } else {\n+                oldz = z;\n+                z = z.subtract(N.divide(denominator));\n+            }\n+            i++;\n+        }\n+        throw new ConvergenceException(\"Maximum number of iterations exceeded.\");\n+    }\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/math/analysis/MullerSolver.java\n+/*\n+ * Copyright 2005 The Apache Software Foundation.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.analysis;\n+\n+import org.apache.commons.math.ConvergenceException;\n+import org.apache.commons.math.FunctionEvaluationException;\n+import org.apache.commons.math.util.MathUtils;\n+\n+/**\n+ * Implements the <a href=\"http://mathworld.wolfram.com/MullersMethod.html\">\n+ * Muller's Method</a> for root finding of real univariate functions. For\n+ * reference, see <b>Elementary Numerical Analysis</b>, ISBN 0070124477,\n+ * chapter 3.\n+ * <p>\n+ * Muller's method applies to both real and complex functions, but here we\n+ * restrict ourselves to real functions. Methods solve() and solve2() find\n+ * real zeros, using different ways to bypass complex arithmetics.\n+ *\n+ * @version $Revision$ $Date$\n+ */\n+public class MullerSolver extends UnivariateRealSolverImpl {\n+\n+    /** serializable version identifier */\n+    static final long serialVersionUID = 2619993603551148137L;\n+\n+    /**\n+     * Construct a solver for the given function.\n+     * \n+     * @param f function to solve\n+     */\n+    public MullerSolver(UnivariateRealFunction f) {\n+        super(f, 100, 1E-6);\n+    }\n+\n+    /**\n+     * Find a real root in the given interval with initial value.\n+     * <p>\n+     * Requires bracketing condition.\n+     * \n+     * @param min the lower bound for the interval\n+     * @param max the upper bound for the interval\n+     * @param initial the start value to use\n+     * @return the point at which the function value is zero\n+     * @throws ConvergenceException if the maximum iteration count is exceeded\n+     * or the solver detects convergence problems otherwise\n+     * @throws FunctionEvaluationException if an error occurs evaluating the\n+     * function\n+     * @throws IllegalArgumentException if any parameters are invalid\n+     */\n+    public double solve(double min, double max, double initial) throws\n+        ConvergenceException, FunctionEvaluationException {\n+\n+        // check for zeros before verifying bracketing\n+        if (f.value(min) == 0.0) { return min; }\n+        if (f.value(max) == 0.0) { return max; }\n+        if (f.value(initial) == 0.0) { return initial; }\n+\n+        verifyBracketing(min, max, f);\n+        verifySequence(min, initial, max);\n+        if (isBracketing(min, initial, f)) {\n+            return solve(min, initial);\n+        } else {\n+            return solve(initial, max);\n+        }\n+    }\n+\n+    /**\n+     * Find a real root in the given interval.\n+     * <p>\n+     * Original Muller's method would have function evaluation at complex point.\n+     * Since our f(x) is real, we have to find ways to avoid that. Bracketing\n+     * condition is one way to go: by requiring bracketing in every iteration,\n+     * the newly computed approximation is guaranteed to be real.\n+     * <p>\n+     * Normally Muller's method converges quadratically in the vicinity of a\n+     * zero, however it may be very slow in regions far away from zeros. For\n+     * example, f(x) = exp(x) - 1, min = -50, max = 100. In such case we use\n+     * bisection as a safety backup if it performs very poorly.\n+     * <p>\n+     * The formulas here use divided differences directly.\n+     * \n+     * @param min the lower bound for the interval\n+     * @param max the upper bound for the interval\n+     * @return the point at which the function value is zero\n+     * @throws ConvergenceException if the maximum iteration count is exceeded\n+     * or the solver detects convergence problems otherwise\n+     * @throws FunctionEvaluationException if an error occurs evaluating the\n+     * function \n+     * @throws IllegalArgumentException if any parameters are invalid\n+     */\n+    public double solve(double min, double max) throws ConvergenceException, \n+        FunctionEvaluationException {\n+\n+        // [x0, x2] is the bracketing interval in each iteration\n+        // x1 is the last approximation and an interpolation point in (x0, x2)\n+        // x is the new root approximation and new x1 for next round\n+        // d01, d12, d012 are divided differences\n+        double x0, x1, x2, x, oldx, y0, y1, y2, y;\n+        double d01, d12, d012, c1, delta, xplus, xminus, tolerance;\n+\n+        x0 = min; y0 = f.value(x0);\n+        x2 = max; y2 = f.value(x2);\n+        x1 = 0.5 * (x0 + x2); y1 = f.value(x1);\n+\n+        // check for zeros before verifying bracketing\n+        if (y0 == 0.0) { return min; }\n+        if (y2 == 0.0) { return max; }\n+        verifyBracketing(min, max, f);\n+\n+        int i = 1;\n+        oldx = Double.POSITIVE_INFINITY;\n+        while (i <= maximalIterationCount) {\n+            // Muller's method employs quadratic interpolation through\n+            // x0, x1, x2 and x is the zero of the interpolating parabola.\n+            // Due to bracketing condition, this parabola must have two\n+            // real roots and we choose one in [x0, x2] to be x.\n+            d01 = (y1 - y0) / (x1 - x0);\n+            d12 = (y2 - y1) / (x2 - x1);\n+            d012 = (d12 - d01) / (x2 - x0);\n+            c1 = d01 + (x1 - x0) * d012;\n+            delta = c1 * c1 - 4 * y1 * d012;\n+            xplus = x1 + (-2.0 * y1) / (c1 + Math.sqrt(delta));\n+            xminus = x1 + (-2.0 * y1) / (c1 - Math.sqrt(delta));\n+            // xplus and xminus are two roots of parabola and at least\n+            // one of them should lie in (x0, x2)\n+            x = isSequence(x0, xplus, x2) ? xplus : xminus;\n+            y = f.value(x);\n+\n+            // check for convergence\n+            tolerance = Math.max(relativeAccuracy * Math.abs(x), absoluteAccuracy);\n+            if (Math.abs(x - oldx) <= tolerance) {\n+                setResult(x, i);\n+                return result;\n+            }\n+            if (Math.abs(y) <= functionValueAccuracy) {\n+                setResult(x, i);\n+                return result;\n+            }\n+\n+            // Bisect if convergence is too slow. Bisection would waste\n+            // our calculation of x, hopefully it won't happen often.\n+            boolean bisect = (x < x1 && (x1 - x0) > 0.95 * (x2 - x0)) ||\n+                             (x > x1 && (x2 - x1) > 0.95 * (x2 - x0)) ||\n+                             (x == x1);\n+            // prepare the new bracketing interval for next iteration\n+            if (!bisect) {\n+                x0 = x < x1 ? x0 : x1;\n+                y0 = x < x1 ? y0 : y1;\n+                x2 = x > x1 ? x2 : x1;\n+                y2 = x > x1 ? y2 : y1;\n+                x1 = x; y1 = y;\n+                oldx = x;\n+            } else {\n+                double xm = 0.5 * (x0 + x2);\n+                double ym = f.value(xm);\n+                if (MathUtils.sign(y0) + MathUtils.sign(ym) == 0.0) {\n+                    x2 = xm; y2 = ym;\n+                } else {\n+                    x0 = xm; y0 = ym;\n+                }\n+                x1 = 0.5 * (x0 + x2);\n+                y1 = f.value(x1);\n+                oldx = Double.POSITIVE_INFINITY;\n+            }\n+            i++;\n+        }\n+        throw new ConvergenceException(\"Maximum number of iterations exceeded.\");\n+    }\n+\n+    /**\n+     * Find a real root in the given interval.\n+     * <p>\n+     * solve2() differs from solve() in the way it avoids complex operations.\n+     * Except for the initial [min, max], solve2() does not require bracketing\n+     * condition, e.g. f(x0), f(x1), f(x2) can have the same sign. If complex\n+     * number arises in the computation, we simply use its modulus as real\n+     * approximation.\n+     * <p>\n+     * Because the interval may not be bracketing, bisection alternative is\n+     * not applicable here. However in practice our treatment usually works\n+     * well, especially near real zeros where the imaginary part of complex\n+     * approximation is often negligible.\n+     * <p>\n+     * The formulas here do not use divided differences directly.\n+     * \n+     * @param min the lower bound for the interval\n+     * @param max the upper bound for the interval\n+     * @return the point at which the function value is zero\n+     * @throws ConvergenceException if the maximum iteration count is exceeded\n+     * or the solver detects convergence problems otherwise\n+     * @throws FunctionEvaluationException if an error occurs evaluating the\n+     * function \n+     * @throws IllegalArgumentException if any parameters are invalid\n+     */\n+    public double solve2(double min, double max) throws ConvergenceException, \n+        FunctionEvaluationException {\n+\n+        // x2 is the last root approximation\n+        // x is the new approximation and new x2 for next round\n+        // x0 < x1 < x2 does not hold here\n+        double x0, x1, x2, x, oldx, y0, y1, y2, y;\n+        double q, A, B, C, delta, denominator, tolerance;\n+\n+        x0 = min; y0 = f.value(x0);\n+        x1 = max; y1 = f.value(x1);\n+        x2 = 0.5 * (x0 + x1); y2 = f.value(x2);\n+\n+        // check for zeros before verifying bracketing\n+        if (y0 == 0.0) { return min; }\n+        if (y1 == 0.0) { return max; }\n+        verifyBracketing(min, max, f);\n+\n+        int i = 1;\n+        oldx = Double.POSITIVE_INFINITY;\n+        while (i <= maximalIterationCount) {\n+            // quadratic interpolation through x0, x1, x2\n+            q = (x2 - x1) / (x1 - x0);\n+            A = q * (y2 - (1 + q) * y1 + q * y0);\n+            B = (2*q + 1) * y2 - (1 + q) * (1 + q) * y1 + q * q * y0;\n+            C = (1 + q) * y2;\n+            delta = B * B - 4 * A * C;\n+            if (delta >= 0.0) {\n+                // choose a denominator larger in magnitude\n+                double dplus = B + Math.sqrt(delta);\n+                double dminus = B - Math.sqrt(delta);\n+                denominator = Math.abs(dplus) > Math.abs(dminus) ? dplus : dminus;\n+            } else {\n+                // take the modulus of (B +/- Math.sqrt(delta))\n+                denominator = Math.sqrt(B * B - delta);\n+            }\n+            if (denominator != 0) {\n+                x = x2 - 2.0 * C * (x2 - x1) / denominator;\n+                // perturb x if it coincides with x1 or x2\n+                while (x == x1 || x == x2) {\n+                    x += absoluteAccuracy;\n+                }\n+            } else {\n+                // extremely rare case, get a random number to skip it\n+                x = min + Math.random() * (max - min);\n+                oldx = Double.POSITIVE_INFINITY;\n+            }\n+            y = f.value(x);\n+\n+            // check for convergence\n+            tolerance = Math.max(relativeAccuracy * Math.abs(x), absoluteAccuracy);\n+            if (Math.abs(x - oldx) <= tolerance) {\n+                setResult(x, i);\n+                return result;\n+            }\n+            if (Math.abs(y) <= functionValueAccuracy) {\n+                setResult(x, i);\n+                return result;\n+            }\n+\n+            // prepare the next iteration\n+            x0 = x1; y0 = y1;\n+            x1 = x2; y1 = y2;\n+            x2 = x; y2 = y;\n+            oldx = x;\n+            i++;\n+        }\n+        throw new ConvergenceException(\"Maximum number of iterations exceeded.\");\n+    }\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/math/analysis/NevilleInterpolator.java\n+/*\n+ * Copyright 2003-2005 The Apache Software Foundation.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.analysis;\n+\n+import java.io.Serializable;\n+import org.apache.commons.math.MathException;\n+\n+/**\n+ * Implements the <a href=\"http://mathworld.wolfram.com/NevillesAlgorithm.html\">\n+ * Neville's Algorithm</a> for interpolation of real univariate functions. For\n+ * reference, see <b>Introduction to Numerical Analysis</b>, ISBN 038795452X,\n+ * chapter 2.\n+ * <p>\n+ * The actual code of Neville's evalution is in PolynomialFunctionLagrangeForm,\n+ * this class provides an easy-to-use interface to it.\n+ *\n+ * @version $Revision$ $Date$\n+ */\n+public class NevilleInterpolator implements UnivariateRealInterpolator,\n+    Serializable {\n+\n+    /** serializable version identifier */\n+    static final long serialVersionUID = 3003707660147873733L;\n+\n+    /**\n+     * Computes an interpolating function for the data set.\n+     *\n+     * @param x the interpolating points array\n+     * @param y the interpolating values array\n+     * @return a function which interpolates the data set\n+     * @throws MathException if arguments are invalid\n+     */\n+    public UnivariateRealFunction interpolate(double x[], double y[]) throws\n+        MathException {\n+\n+        PolynomialFunctionLagrangeForm p;\n+        p = new PolynomialFunctionLagrangeForm(x, y);\n+        return p;\n+    }\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/math/analysis/PolynomialFunctionLagrangeForm.java\n+/*\n+ * Copyright 2003-2005 The Apache Software Foundation.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.analysis;\n+\n+import java.io.Serializable;\n+import org.apache.commons.math.FunctionEvaluationException;\n+\n+/**\n+ * Implements the representation of a real polynomial function in\n+ * <a href=\"http://mathworld.wolfram.com/LagrangeInterpolatingPolynomial.html\">\n+ * Lagrange Form</a>. For reference, see <b>Introduction to Numerical\n+ * Analysis</b>, ISBN 038795452X, chapter 2.\n+ * <p>\n+ * The approximated function should be smooth enough for Lagrange polynomial\n+ * to work well. Otherwise, consider using splines instead.\n+ *\n+ * @version $Revision$ $Date$\n+ */\n+public class PolynomialFunctionLagrangeForm implements UnivariateRealFunction,\n+    Serializable {\n+\n+    /** serializable version identifier */\n+    static final long serialVersionUID = -3965199246151093920L;\n+\n+    /**\n+     * The coefficients of the polynomial, ordered by degree -- i.e.\n+     * coefficients[0] is the constant term and coefficients[n] is the \n+     * coefficient of x^n where n is the degree of the polynomial.\n+     */\n+    private double coefficients[];\n+\n+    /**\n+     * Interpolating points (abscissas) and the function values at these points.\n+     */\n+    private double x[], y[];\n+\n+    /**\n+     * Whether the polynomial coefficients are available.\n+     */\n+    private boolean coefficientsComputed;\n+\n+    /**\n+     * Construct a Lagrange polynomial with the given abscissas and function\n+     * values. The order of interpolating points are not important.\n+     * <p>\n+     * The constructor makes copy of the input arrays and assigns them.\n+     * \n+     * @param x interpolating points\n+     * @param y function values at interpolating points\n+     * @throws IllegalArgumentException if input arrays are not valid\n+     */\n+    PolynomialFunctionLagrangeForm(double x[], double y[]) throws\n+        IllegalArgumentException {\n+\n+        verifyInterpolationArray(x, y);\n+        this.x = new double[x.length];\n+        this.y = new double[y.length];\n+        System.arraycopy(x, 0, this.x, 0, x.length);\n+        System.arraycopy(y, 0, this.y, 0, y.length);\n+        coefficientsComputed = false;\n+    }\n+\n+    /**\n+     * Calculate the function value at the given point.\n+     *\n+     * @param z the point at which the function value is to be computed\n+     * @return the function value\n+     * @throws FunctionEvaluationException if a runtime error occurs\n+     * @see UnivariateRealFunction#value(double)\n+     */\n+    public double value(double z) throws FunctionEvaluationException {\n+       return evaluate(x, y, z);\n+    }\n+\n+    /**\n+     * Returns the degree of the polynomial.\n+     * \n+     * @return the degree of the polynomial\n+     */\n+    public int degree() {\n+        return x.length - 1;\n+    }\n+\n+    /**\n+     * Returns a copy of the interpolating points array.\n+     * <p>\n+     * Changes made to the returned copy will not affect the polynomial.\n+     * \n+     * @return a fresh copy of the interpolating points array\n+     */\n+    public double[] getInterpolatingPoints() {\n+        double[] out = new double[x.length];\n+        System.arraycopy(x, 0, out, 0, x.length);\n+        return out;\n+    }\n+\n+    /**\n+     * Returns a copy of the interpolating values array.\n+     * <p>\n+     * Changes made to the returned copy will not affect the polynomial.\n+     * \n+     * @return a fresh copy of the interpolating values array\n+     */\n+    public double[] getInterpolatingValues() {\n+        double[] out = new double[y.length];\n+        System.arraycopy(y, 0, out, 0, y.length);\n+        return out;\n+    }\n+\n+    /**\n+     * Returns a copy of the coefficients array.\n+     * <p>\n+     * Changes made to the returned copy will not affect the polynomial.\n+     * \n+     * @return a fresh copy of the coefficients array\n+     */\n+    public double[] getCoefficients() {\n+        if (!coefficientsComputed) {\n+            computeCoefficients();\n+        }\n+        double[] out = new double[coefficients.length];\n+        System.arraycopy(coefficients, 0, out, 0, coefficients.length);\n+        return out;\n+    }\n+\n+    /**\n+     * Evaluate the Lagrange polynomial using \n+     * <a href=\"http://mathworld.wolfram.com/NevillesAlgorithm.html\">\n+     * Neville's Algorithm</a>. It takes O(N^2) time.\n+     * <p>\n+     * This function is made public static so that users can call it directly\n+     * without instantiating PolynomialFunctionLagrangeForm object.\n+     *\n+     * @param x the interpolating points array\n+     * @param y the interpolating values array\n+     * @param z the point at which the function value is to be computed\n+     * @return the function value\n+     * @throws FunctionEvaluationException if a runtime error occurs\n+     * @throws IllegalArgumentException if inputs are not valid\n+     */\n+    public static double evaluate(double x[], double y[], double z) throws\n+        FunctionEvaluationException, IllegalArgumentException {\n+\n+        int i, j, n, nearest = 0;\n+        double value, c[], d[], tc, td, divider, w, dist, min_dist;\n+\n+        verifyInterpolationArray(x, y);\n+\n+        n = x.length;\n+        c = new double[n];\n+        d = new double[n];\n+        min_dist = Double.POSITIVE_INFINITY;\n+        for (i = 0; i < n; i++) {\n+            // initialize the difference arrays\n+            c[i] = y[i];\n+            d[i] = y[i];\n+            // find out the abscissa closest to z\n+            dist = Math.abs(z - x[i]);\n+            if (dist < min_dist) {\n+                nearest = i;\n+                min_dist = dist;\n+            }\n+        }\n+\n+        // initial approximation to the function value at z\n+        value = y[nearest];\n+\n+        for (i = 1; i < n; i++) {\n+            for (j = 0; j < n-i; j++) {\n+                tc = x[j] - z;\n+                td = x[i+j] - z;\n+                divider = x[j] - x[i+j];\n+                if (divider == 0.0) {\n+                    // This happens only when two abscissas are identical.\n+                    throw new FunctionEvaluationException(z, \n+                        \"Identical abscissas cause division by zero: x[\" +\n+                        i + \"] = x[\" + (i+j) + \"] = \" + x[i]);\n+                }\n+                // update the difference arrays\n+                w = (c[j+1] - d[j]) / divider;\n+                c[j] = tc * w;\n+                d[j] = td * w;\n+            }\n+            // sum up the difference terms to get the final value\n+            if (nearest < 0.5*(n-i+1)) {\n+                value += c[nearest];    // fork down\n+            } else {\n+                nearest--;\n+                value += d[nearest];    // fork up\n+            }\n+        }\n+\n+        return value;\n+    }\n+\n+    /**\n+     * Calculate the coefficients of Lagrange polynomial from the\n+     * interpolation data. It takes O(N^2) time.\n+     * <p>\n+     * Note this computation can be ill-conditioned. Use with caution\n+     * and only when it is necessary.\n+     *\n+     * @throws ArithmeticException if any abscissas coincide\n+     */\n+    protected void computeCoefficients() throws ArithmeticException {\n+        int i, j, n;\n+        double c[], tc[], d, t;\n+\n+        n = degree() + 1;\n+        coefficients = new double[n];\n+        for (i = 0; i < n; i++) {\n+            coefficients[i] = 0.0;\n+        }\n+\n+        // c[] are the coefficients of P(x) = (x-x[0])(x-x[1])...(x-x[n-1])\n+        c = new double[n+1];\n+        c[0] = 1.0;\n+        for (i = 0; i < n; i++) {\n+            for (j = i; j > 0; j--) {\n+                c[j] = c[j-1] - c[j] * x[i];\n+            }\n+            c[0] *= (-x[i]);\n+            c[i+1] = 1;\n+        }\n+\n+        tc = new double[n];\n+        for (i = 0; i < n; i++) {\n+            // d = (x[i]-x[0])...(x[i]-x[i-1])(x[i]-x[i+1])...(x[i]-x[n-1])\n+            d = 1;\n+            for (j = 0; j < n; j++) {\n+                if (i != j) {\n+                    d *= (x[i] - x[j]);\n+                }\n+            }\n+            if (d == 0.0) {\n+                // This happens only when two abscissas are identical.\n+                throw new ArithmeticException\n+                    (\"Identical abscissas cause division by zero.\");\n+            }\n+            t = y[i] / d;\n+            // Lagrange polynomial is the sum of n terms, each of which is a\n+            // polynomial of degree n-1. tc[] are the coefficients of the i-th\n+            // numerator Pi(x) = (x-x[0])...(x-x[i-1])(x-x[i+1])...(x-x[n-1]).\n+            tc[n-1] = c[n];     // actually c[n] = 1\n+            coefficients[n-1] += t * tc[n-1];\n+            for (j = n-2; j >= 0; j--) {\n+                tc[j] = c[j+1] + tc[j+1] * x[i];\n+                coefficients[j] += t * tc[j];\n+            }\n+        }\n+\n+        coefficientsComputed = true;\n+    }\n+\n+    /**\n+     * Verifies that the interpolation arrays are valid.\n+     * <p>\n+     * The interpolating points must be distinct. However it is not\n+     * verified here, it is checked in evaluate() and computeCoefficients().\n+     * \n+     * @throws IllegalArgumentException if not valid\n+     * @see #evaluate(double[], double[], double)\n+     * @see #computeCoefficients()\n+     */\n+    protected static void verifyInterpolationArray(double x[], double y[]) throws\n+        IllegalArgumentException {\n+\n+        if (x.length < 2 || y.length < 2) {\n+            throw new IllegalArgumentException\n+                (\"Interpolation requires at least two points.\");\n+        }\n+        if (x.length != y.length) {\n+            throw new IllegalArgumentException\n+                (\"Abscissa and value arrays must have the same length.\");\n+        }\n+    }\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/math/analysis/PolynomialFunctionNewtonForm.java\n+/*\n+ * Copyright 2003-2005 The Apache Software Foundation.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.analysis;\n+\n+import java.io.Serializable;\n+import org.apache.commons.math.FunctionEvaluationException;\n+\n+/**\n+ * Implements the representation of a real polynomial function in\n+ * Newton Form. For reference, see <b>Elementary Numerical Analysis</b>,\n+ * ISBN 0070124477, chapter 2.\n+ * <p>\n+ * The formula of polynomial in Newton form is\n+ *     p(x) = a[0] + a[1](x-c[0]) + a[2](x-c[0])(x-c[1]) + ... +\n+ *            a[n](x-c[0])(x-c[1])...(x-c[n-1])\n+ * Note that the length of a[] is one more than the length of c[]\n+ *\n+ * @version $Revision$ $Date$\n+ */\n+public class PolynomialFunctionNewtonForm implements UnivariateRealFunction,\n+    Serializable {\n+\n+    /** serializable version identifier */\n+    static final long serialVersionUID = -3353896576191389897L;\n+\n+    /**\n+     * The coefficients of the polynomial, ordered by degree -- i.e.\n+     * coefficients[0] is the constant term and coefficients[n] is the \n+     * coefficient of x^n where n is the degree of the polynomial.\n+     */\n+    private double coefficients[];\n+\n+    /**\n+     * Members of c[] are called centers of the Newton polynomial.\n+     * When all c[i] = 0, a[] becomes normal polynomial coefficients,\n+     * i.e. a[i] = coefficients[i].\n+     */\n+    private double a[], c[];\n+\n+    /**\n+     * Whether the polynomial coefficients are available.\n+     */\n+    private boolean coefficientsComputed;\n+\n+    /**\n+     * Construct a Newton polynomial with the given a[] and c[]. The order of\n+     * centers are important in that if c[] shuffle, then values of a[] would\n+     * completely change, not just a permutation of old a[].\n+     * <p>\n+     * The constructor makes copy of the input arrays and assigns them.\n+     * \n+     * @param a the coefficients in Newton form formula\n+     * @param c the centers\n+     * @throws IllegalArgumentException if input arrays are not valid\n+     */\n+    PolynomialFunctionNewtonForm(double a[], double c[]) throws\n+        IllegalArgumentException {\n+\n+        verifyInputArray(a, c);\n+        this.a = new double[a.length];\n+        this.c = new double[c.length];\n+        System.arraycopy(a, 0, this.a, 0, a.length);\n+        System.arraycopy(c, 0, this.c, 0, c.length);\n+        coefficientsComputed = false;\n+    }\n+\n+    /**\n+     * Calculate the function value at the given point.\n+     *\n+     * @param z the point at which the function value is to be computed\n+     * @return the function value\n+     * @throws FunctionEvaluationException if a runtime error occurs\n+     * @see UnivariateRealFunction#value(double)\n+     */\n+    public double value(double z) throws FunctionEvaluationException {\n+       return evaluate(a, c, z);\n+    }\n+\n+    /**\n+     * Returns the degree of the polynomial.\n+     * \n+     * @return the degree of the polynomial\n+     */\n+    public int degree() {\n+        return c.length;\n+    }\n+\n+    /**\n+     * Returns a copy of coefficients in Newton form formula.\n+     * <p>\n+     * Changes made to the returned copy will not affect the polynomial.\n+     * \n+     * @return a fresh copy of coefficients in Newton form formula\n+     */\n+    public double[] getNewtonCoefficients() {\n+        double[] out = new double[a.length];\n+        System.arraycopy(a, 0, out, 0, a.length);\n+        return out;\n+    }\n+\n+    /**\n+     * Returns a copy of the centers array.\n+     * <p>\n+     * Changes made to the returned copy will not affect the polynomial.\n+     * \n+     * @return a fresh copy of the centers array\n+     */\n+    public double[] getCenters() {\n+        double[] out = new double[c.length];\n+        System.arraycopy(c, 0, out, 0, c.length);\n+        return out;\n+    }\n+\n+    /**\n+     * Returns a copy of the coefficients array.\n+     * <p>\n+     * Changes made to the returned copy will not affect the polynomial.\n+     * \n+     * @return a fresh copy of the coefficients array\n+     */\n+    public double[] getCoefficients() {\n+        if (!coefficientsComputed) {\n+            computeCoefficients();\n+        }\n+        double[] out = new double[coefficients.length];\n+        System.arraycopy(coefficients, 0, out, 0, coefficients.length);\n+        return out;\n+    }\n+\n+    /**\n+     * Evaluate the Newton polynomial using nested multiplication. It is\n+     * also called <a href=\"http://mathworld.wolfram.com/HornersRule.html\">\n+     * Horner's Rule</a> and takes O(N) time.\n+     *\n+     * @param a the coefficients in Newton form formula\n+     * @param c the centers\n+     * @param z the point at which the function value is to be computed\n+     * @return the function value\n+     * @throws FunctionEvaluationException if a runtime error occurs\n+     * @throws IllegalArgumentException if inputs are not valid\n+     */\n+    public static double evaluate(double a[], double c[], double z) throws\n+        FunctionEvaluationException, IllegalArgumentException {\n+\n+        verifyInputArray(a, c);\n+\n+        int n = c.length;\n+        double value = a[n];\n+        for (int i = n-1; i >= 0; i--) {\n+            value = a[i] + (z - c[i]) * value;\n+        }\n+\n+        return value;\n+    }\n+\n+    /**\n+     * Calculate the normal polynomial coefficients given the Newton form.\n+     * It also uses nested multiplication but takes O(N^2) time.\n+     */\n+    protected void computeCoefficients() {\n+        int i, j, n = degree();\n+\n+        coefficients = new double[n+1];\n+        for (i = 0; i <= n; i++) {\n+            coefficients[i] = 0.0;\n+        }\n+\n+        coefficients[0] = a[n];\n+        for (i = n-1; i >= 0; i--) {\n+            for (j = n-i; j > 0; j--) {\n+                coefficients[j] = coefficients[j-1] - c[i] * coefficients[j];\n+            }\n+            coefficients[0] = a[i] - c[i] * coefficients[0];\n+        }\n+\n+        coefficientsComputed = true;\n+    }\n+\n+    /**\n+     * Verifies that the input arrays are valid.\n+     * <p>\n+     * The centers must be distinct for interpolation purposes, but not\n+     * for general use. Thus it is not verified here.\n+     * \n+     * @throws IllegalArgumentException if not valid\n+     * @see DividedDifferenceInterpolator#computeDividedDifference(double[],\n+     * double[])\n+     */\n+    protected static void verifyInputArray(double a[], double c[]) throws\n+        IllegalArgumentException {\n+\n+        if (a.length < 1 || c.length < 1) {\n+            throw new IllegalArgumentException\n+                (\"Input arrays must not be empty.\");\n+        }\n+        if (a.length != c.length + 1) {\n+            throw new IllegalArgumentException\n+                (\"Bad input array sizes, should have difference 1.\");\n+        }\n+    }\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/math/analysis/RiddersSolver.java\n+/*\n+ * Copyright 2005 The Apache Software Foundation.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.analysis;\n+\n+import org.apache.commons.math.ConvergenceException;\n+import org.apache.commons.math.FunctionEvaluationException;\n+import org.apache.commons.math.util.MathUtils;\n+\n+/**\n+ * Implements the <a href=\"http://mathworld.wolfram.com/RiddersMethod.html\">\n+ * Ridders' Method</a> for root finding of real univariate functions. For\n+ * reference, see C. Ridders, <i>A new algorithm for computing a single root\n+ * of a real continuous function </i>, IEEE Transactions on Circuits and\n+ * Systems, 26 (1979), 979 - 980.\n+ * <p>\n+ * The function should be continuous but not necessarily smooth.\n+ *  \n+ * @version $Revision$ $Date$\n+ */\n+public class RiddersSolver extends UnivariateRealSolverImpl {\n+\n+    /** serializable version identifier */\n+    static final long serialVersionUID = -4703139035737911735L;\n+\n+    /**\n+     * Construct a solver for the given function.\n+     * \n+     * @param f function to solve\n+     */\n+    public RiddersSolver(UnivariateRealFunction f) {\n+        super(f, 100, 1E-6);\n+    }\n+\n+    /**\n+     * Find a root in the given interval with initial value.\n+     * <p>\n+     * Requires bracketing condition.\n+     * \n+     * @param min the lower bound for the interval\n+     * @param max the upper bound for the interval\n+     * @param initial the start value to use\n+     * @return the point at which the function value is zero\n+     * @throws ConvergenceException if the maximum iteration count is exceeded\n+     * or the solver detects convergence problems otherwise\n+     * @throws FunctionEvaluationException if an error occurs evaluating the\n+     * function\n+     * @throws IllegalArgumentException if any parameters are invalid\n+     */\n+    public double solve(double min, double max, double initial) throws\n+        ConvergenceException, FunctionEvaluationException {\n+\n+        // check for zeros before verifying bracketing\n+        if (f.value(min) == 0.0) { return min; }\n+        if (f.value(max) == 0.0) { return max; }\n+        if (f.value(initial) == 0.0) { return initial; }\n+\n+        verifyBracketing(min, max, f);\n+        verifySequence(min, initial, max);\n+        if (isBracketing(min, initial, f)) {\n+            return solve(min, initial);\n+        } else {\n+            return solve(initial, max);\n+        }\n+    }\n+\n+    /**\n+     * Find a root in the given interval.\n+     * <p>\n+     * Requires bracketing condition.\n+     * \n+     * @param min the lower bound for the interval\n+     * @param max the upper bound for the interval\n+     * @return the point at which the function value is zero\n+     * @throws ConvergenceException if the maximum iteration count is exceeded\n+     * or the solver detects convergence problems otherwise\n+     * @throws FunctionEvaluationException if an error occurs evaluating the\n+     * function \n+     * @throws IllegalArgumentException if any parameters are invalid\n+     */\n+    public double solve(double min, double max) throws ConvergenceException, \n+        FunctionEvaluationException {\n+\n+        // [x1, x2] is the bracketing interval in each iteration\n+        // x3 is the midpoint of [x1, x2]\n+        // x is the new root approximation and an endpoint of the new interval\n+        double x1, x2, x3, x, oldx, y1, y2, y3, y, delta, correction, tolerance;\n+\n+        x1 = min; y1 = f.value(x1);\n+        x2 = max; y2 = f.value(x2);\n+\n+        // check for zeros before verifying bracketing\n+        if (y1 == 0.0) { return min; }\n+        if (y2 == 0.0) { return max; }\n+        verifyBracketing(min, max, f);\n+\n+        int i = 1;\n+        oldx = Double.POSITIVE_INFINITY;\n+        while (i <= maximalIterationCount) {\n+            // calculate the new root approximation\n+            x3 = 0.5 * (x1 + x2);\n+            y3 = f.value(x3);\n+            if (Math.abs(y3) <= functionValueAccuracy) {\n+                setResult(x3, i);\n+                return result;\n+            }\n+            delta = 1 - (y1 * y2) / (y3 * y3);  // delta > 1 due to bracketing\n+            correction = (MathUtils.sign(y2) * MathUtils.sign(y3)) *\n+                         (x3 - x1) / Math.sqrt(delta);\n+            x = x3 - correction;                // correction != 0\n+            y = f.value(x);\n+\n+            // check for convergence\n+            tolerance = Math.max(relativeAccuracy * Math.abs(x), absoluteAccuracy);\n+            if (Math.abs(x - oldx) <= tolerance) {\n+                setResult(x, i);\n+                return result;\n+            }\n+            if (Math.abs(y) <= functionValueAccuracy) {\n+                setResult(x, i);\n+                return result;\n+            }\n+\n+            // prepare the new interval for next iteration\n+            // Ridders' method guarantees x1 < x < x2\n+            if (correction > 0.0) {             // x1 < x < x3\n+                if (MathUtils.sign(y1) + MathUtils.sign(y) == 0.0) {\n+                    x2 = x; y2 = y;\n+                } else {\n+                    x1 = x; x2 = x3;\n+                    y1 = y; y2 = y3;\n+                }\n+            } else {                            // x3 < x < x2\n+                if (MathUtils.sign(y2) + MathUtils.sign(y) == 0.0) {\n+                    x1 = x; y1 = y;\n+                } else {\n+                    x1 = x3; x2 = x;\n+                    y1 = y3; y2 = y;\n+                }\n+            }\n+            oldx = x;\n+            i++;\n+        }\n+        throw new ConvergenceException(\"Maximum number of iterations exceeded.\");\n+    }\n+}", "timestamp": 1124919835, "metainfo": ""}