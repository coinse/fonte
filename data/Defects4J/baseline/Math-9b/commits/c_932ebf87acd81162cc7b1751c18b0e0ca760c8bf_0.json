{"sha": "932ebf87acd81162cc7b1751c18b0e0ca760c8bf", "log": "Javadoc only. Added missing </p>'s  ", "commit": "\n--- a/src/java/org/apache/commons/math/MathException.java\n+++ b/src/java/org/apache/commons/math/MathException.java\n /**\n * Base class for commons-math checked exceptions.\n * <p>\n-* Supports nesting, emulating JDK 1.4 behavior if necessary.  \n+* Supports nesting, emulating JDK 1.4 behavior if necessary.</p>\n * <p>\n-* Adapted from {@link org.apache.commons.collections.FunctorException}.\n+* Adapted from {@link org.apache.commons.collections.FunctorException}.</p>\n * \n * @version $Revision$ $Date$\n */\n--- a/src/java/org/apache/commons/math/analysis/BisectionSolver.java\n+++ b/src/java/org/apache/commons/math/analysis/BisectionSolver.java\n  * Implements the <a href=\"http://mathworld.wolfram.com/Bisection.html\">\n  * bisection algorithm</a> for finding zeros of univariate real functions. \n  * <p>\n- * The function should be continuous but not necessarily smooth.\n+ * The function should be continuous but not necessarily smooth.</p>\n  * \n  * @version $Revision$ $Date$\n  */\n--- a/src/java/org/apache/commons/math/analysis/BrentSolver.java\n+++ b/src/java/org/apache/commons/math/analysis/BrentSolver.java\n  * Implements the <a href=\"http://mathworld.wolfram.com/BrentsMethod.html\">\n  * Brent algorithm</a> for  finding zeros of real univariate functions.\n  * <p>\n- * The function should be continuous but not necessarily smooth.\n+ * The function should be continuous but not necessarily smooth.</p>\n  *  \n  * @version $Revision$ $Date$\n  */\n      * <p>\n      * Requires that the values of the function at the endpoints have opposite\n      * signs. An <code>IllegalArgumentException</code> is thrown if this is not\n-     * the case.\n+     * the case.</p>\n      * \n      * @param min the lower bound for the interval.\n      * @param max the upper bound for the interval.\n--- a/src/java/org/apache/commons/math/analysis/DividedDifferenceInterpolator.java\n+++ b/src/java/org/apache/commons/math/analysis/DividedDifferenceInterpolator.java\n  * ISBN 038795452X, chapter 2.\n  * <p>\n  * The actual code of Neville's evalution is in PolynomialFunctionLagrangeForm,\n- * this class provides an easy-to-use interface to it.\n+ * this class provides an easy-to-use interface to it.</p>\n  *\n  * @version $Revision$ $Date$\n  */\n          *        f[x0,x1,...,x[n-1]](x-x0)(x-x1)...(x-x[n-2])\n          * Therefore, a[k] = f[x0,x1,...,xk], c[k] = x[k].\n          * <p>\n-         * Note x[], y[], a[] have the same length but c[]'s size is one less.\n+         * Note x[], y[], a[] have the same length but c[]'s size is one less.</p>\n          */\n         c = new double[x.length-1];\n         for (int i = 0; i < c.length; i++) {\n      * The divided difference array is defined recursively by <pre>\n      * f[x0] = f(x0)\n      * f[x0,x1,...,xk] = (f(x1,...,xk) - f(x0,...,x[k-1])) / (xk - x0)\n-     * </pre><p>\n-     * The computational complexity is O(N^2).\n+     * </pre></p>\n+     * <p>\n+     * The computational complexity is O(N^2).</p>\n      *\n      * @param x the interpolating points array\n      * @param y the interpolating values array\n--- a/src/java/org/apache/commons/math/analysis/LaguerreSolver.java\n+++ b/src/java/org/apache/commons/math/analysis/LaguerreSolver.java\n  * ISBN 048641454X, chapter 8.\n  * <p>\n  * Laguerre's method is global in the sense that it can start with any initial\n- * approximation and be able to solve all roots from that point.\n+ * approximation and be able to solve all roots from that point.</p>\n  *\n  * @version $Revision$ $Date$\n  */\n     /**\n      * Find a real root in the given interval with initial value.\n      * <p>\n-     * Requires bracketing condition.\n+     * Requires bracketing condition.</p>\n      * \n      * @param min the lower bound for the interval\n      * @param max the upper bound for the interval\n      * Complex) may not be a real zero inside [min, max]. For example,\n      * p(x) = x^3 + 1, min = -2, max = 2, initial = 0. We can either try\n      * another initial value, or, as we did here, call solveAll() to obtain\n-     * all roots and pick up the one that we're looking for.\n+     * all roots and pick up the one that we're looking for.</p>\n      *\n      * @param min the lower bound for the interval\n      * @param max the upper bound for the interval\n--- a/src/java/org/apache/commons/math/analysis/MullerSolver.java\n+++ b/src/java/org/apache/commons/math/analysis/MullerSolver.java\n  * <p>\n  * Muller's method applies to both real and complex functions, but here we\n  * restrict ourselves to real functions. Methods solve() and solve2() find\n- * real zeros, using different ways to bypass complex arithmetics.\n+ * real zeros, using different ways to bypass complex arithmetics.</p>\n  *\n  * @version $Revision$ $Date$\n  */\n     /**\n      * Find a real root in the given interval with initial value.\n      * <p>\n-     * Requires bracketing condition.\n+     * Requires bracketing condition.</p>\n      * \n      * @param min the lower bound for the interval\n      * @param max the upper bound for the interval\n      * Original Muller's method would have function evaluation at complex point.\n      * Since our f(x) is real, we have to find ways to avoid that. Bracketing\n      * condition is one way to go: by requiring bracketing in every iteration,\n-     * the newly computed approximation is guaranteed to be real.\n+     * the newly computed approximation is guaranteed to be real.</p>\n      * <p>\n      * Normally Muller's method converges quadratically in the vicinity of a\n      * zero, however it may be very slow in regions far away from zeros. For\n      * example, f(x) = exp(x) - 1, min = -50, max = 100. In such case we use\n-     * bisection as a safety backup if it performs very poorly.\n-     * <p>\n-     * The formulas here use divided differences directly.\n+     * bisection as a safety backup if it performs very poorly.</p>\n+     * <p>\n+     * The formulas here use divided differences directly.</p>\n      * \n      * @param min the lower bound for the interval\n      * @param max the upper bound for the interval\n      * Except for the initial [min, max], solve2() does not require bracketing\n      * condition, e.g. f(x0), f(x1), f(x2) can have the same sign. If complex\n      * number arises in the computation, we simply use its modulus as real\n-     * approximation.\n+     * approximation.</p>\n      * <p>\n      * Because the interval may not be bracketing, bisection alternative is\n      * not applicable here. However in practice our treatment usually works\n      * well, especially near real zeros where the imaginary part of complex\n-     * approximation is often negligible.\n-     * <p>\n-     * The formulas here do not use divided differences directly.\n+     * approximation is often negligible.</p>\n+     * <p>\n+     * The formulas here do not use divided differences directly.</p>\n      * \n      * @param min the lower bound for the interval\n      * @param max the upper bound for the interval\n--- a/src/java/org/apache/commons/math/analysis/NevilleInterpolator.java\n+++ b/src/java/org/apache/commons/math/analysis/NevilleInterpolator.java\n  * chapter 2.\n  * <p>\n  * The actual code of Neville's evalution is in PolynomialFunctionLagrangeForm,\n- * this class provides an easy-to-use interface to it.\n+ * this class provides an easy-to-use interface to it.</p>\n  *\n  * @version $Revision$ $Date$\n  */\n--- a/src/java/org/apache/commons/math/analysis/NewtonSolver.java\n+++ b/src/java/org/apache/commons/math/analysis/NewtonSolver.java\n  * Implements <a href=\"http://mathworld.wolfram.com/NewtonsMethod.html\">\n  * Newton's Method</a> for finding zeros of real univariate functions. \n  * <p> \n- * The function should be continuous but not necessarily smooth.\n+ * The function should be continuous but not necessarily smooth.</p>\n  *\n  * @version $Revision$ $Date$\n  */\n--- a/src/java/org/apache/commons/math/analysis/PolynomialFunction.java\n+++ b/src/java/org/apache/commons/math/analysis/PolynomialFunction.java\n  * Immutable representation of a real polynomial function with real coefficients.\n  * <p>\n  * <a href=\"http://mathworld.wolfram.com/HornersMethod.html\">Horner's Method</a>\n- *  is used to evaluate the function.   \n+ *  is used to evaluate the function.</p>\n  *\n  * @version $Revision$ $Date$\n  */\n      * is the length of the array minus 1. \n      * <p>\n      * The constructor makes a copy of the input array and assigns the copy to\n-     *  the coefficients property.\n+     * the coefficients property.</p>\n      * \n      * @param c polynominal coefficients\n      * @throws NullPointerException if c is null\n      * <p>\n      *  The value returned is <br>\n      *   <code>coefficients[n] * x^n + ... + coefficients[1] * x  + coefficients[0]</code>\n-     *\n+     * </p>\n+     * \n      * @param x the argument for which the function value should be computed\n      * @return the value of the polynomial at the given point\n      * @see UnivariateRealFunction#value(double)\n      * Returns a copy of the coefficients array.\n      * <p>\n      * Changes made to the returned copy will not affect the coefficients of\n-     * the polynomial.\n+     * the polynomial.</p>\n      * \n      * @return  a fresh copy of the coefficients array\n      */\n--- a/src/java/org/apache/commons/math/analysis/PolynomialFunctionLagrangeForm.java\n+++ b/src/java/org/apache/commons/math/analysis/PolynomialFunctionLagrangeForm.java\n  * Analysis</b>, ISBN 038795452X, chapter 2.\n  * <p>\n  * The approximated function should be smooth enough for Lagrange polynomial\n- * to work well. Otherwise, consider using splines instead.\n+ * to work well. Otherwise, consider using splines instead.</p>\n  *\n  * @version $Revision$ $Date$\n  */\n      * Construct a Lagrange polynomial with the given abscissas and function\n      * values. The order of interpolating points are not important.\n      * <p>\n-     * The constructor makes copy of the input arrays and assigns them.\n+     * The constructor makes copy of the input arrays and assigns them.</p>\n      * \n      * @param x interpolating points\n      * @param y function values at interpolating points\n     /**\n      * Returns a copy of the interpolating points array.\n      * <p>\n-     * Changes made to the returned copy will not affect the polynomial.\n+     * Changes made to the returned copy will not affect the polynomial.</p>\n      * \n      * @return a fresh copy of the interpolating points array\n      */\n     /**\n      * Returns a copy of the interpolating values array.\n      * <p>\n-     * Changes made to the returned copy will not affect the polynomial.\n+     * Changes made to the returned copy will not affect the polynomial.</p>\n      * \n      * @return a fresh copy of the interpolating values array\n      */\n     /**\n      * Returns a copy of the coefficients array.\n      * <p>\n-     * Changes made to the returned copy will not affect the polynomial.\n+     * Changes made to the returned copy will not affect the polynomial.</p>\n      * \n      * @return a fresh copy of the coefficients array\n      */\n      * Neville's Algorithm</a>. It takes O(N^2) time.\n      * <p>\n      * This function is made public static so that users can call it directly\n-     * without instantiating PolynomialFunctionLagrangeForm object.\n+     * without instantiating PolynomialFunctionLagrangeForm object.</p>\n      *\n      * @param x the interpolating points array\n      * @param y the interpolating values array\n      * interpolation data. It takes O(N^2) time.\n      * <p>\n      * Note this computation can be ill-conditioned. Use with caution\n-     * and only when it is necessary.\n+     * and only when it is necessary.</p>\n      *\n      * @throws ArithmeticException if any abscissas coincide\n      */\n      * Verifies that the interpolation arrays are valid.\n      * <p>\n      * The interpolating points must be distinct. However it is not\n-     * verified here, it is checked in evaluate() and computeCoefficients().\n+     * verified here, it is checked in evaluate() and computeCoefficients().</p>\n      * \n      * @param x the interpolating points array\n      * @param y the interpolating values array\n--- a/src/java/org/apache/commons/math/analysis/PolynomialFunctionNewtonForm.java\n+++ b/src/java/org/apache/commons/math/analysis/PolynomialFunctionNewtonForm.java\n  * The formula of polynomial in Newton form is\n  *     p(x) = a[0] + a[1](x-c[0]) + a[2](x-c[0])(x-c[1]) + ... +\n  *            a[n](x-c[0])(x-c[1])...(x-c[n-1])\n- * Note that the length of a[] is one more than the length of c[]\n+ * Note that the length of a[] is one more than the length of c[]</p>\n  *\n  * @version $Revision$ $Date$\n  */\n      * centers are important in that if c[] shuffle, then values of a[] would\n      * completely change, not just a permutation of old a[].\n      * <p>\n-     * The constructor makes copy of the input arrays and assigns them.\n+     * The constructor makes copy of the input arrays and assigns them.</p>\n      * \n      * @param a the coefficients in Newton form formula\n      * @param c the centers\n     /**\n      * Returns a copy of coefficients in Newton form formula.\n      * <p>\n-     * Changes made to the returned copy will not affect the polynomial.\n+     * Changes made to the returned copy will not affect the polynomial.</p>\n      * \n      * @return a fresh copy of coefficients in Newton form formula\n      */\n     /**\n      * Returns a copy of the centers array.\n      * <p>\n-     * Changes made to the returned copy will not affect the polynomial.\n+     * Changes made to the returned copy will not affect the polynomial.</p>\n      * \n      * @return a fresh copy of the centers array\n      */\n     /**\n      * Returns a copy of the coefficients array.\n      * <p>\n-     * Changes made to the returned copy will not affect the polynomial.\n+     * Changes made to the returned copy will not affect the polynomial.</p>\n      * \n      * @return a fresh copy of the coefficients array\n      */\n      * Verifies that the input arrays are valid.\n      * <p>\n      * The centers must be distinct for interpolation purposes, but not\n-     * for general use. Thus it is not verified here.\n+     * for general use. Thus it is not verified here.</p>\n      * \n      * @param a the coefficients in Newton form formula\n      * @param c the centers\n--- a/src/java/org/apache/commons/math/analysis/PolynomialSplineFunction.java\n+++ b/src/java/org/apache/commons/math/analysis/PolynomialSplineFunction.java\n  * have been computed to match the values of another function at the knot\n  * points.  The value consistency constraints are not currently enforced by \n  * <code>PolynomialSplineFunction</code> itself, but are assumed to hold among\n- * the polynomials and knot points passed to the constructor.\n+ * the polynomials and knot points passed to the constructor.</p>\n  * <p>\n  * N.B.:  The polynomials in the <code>polynomials</code> property must be\n- * centered on the knot points to compute the spline function values.  See below.\n+ * centered on the knot points to compute the spline function values.  \n+ * See below.</p>\n  * <p>\n  * The domain of the polynomial spline function is \n  * <code>[smallest knot, largest knot]</code>.  Attempts to evaluate the\n  * function at values outside of this range generate IllegalArgumentExceptions.\n+ * </p>\n  * <p>\n  * The value of the polynomial spline function for an argument <code>x</code>\n  * is computed as follows:\n  * is thrown.</li>\n  * <li> Let <code>j</code> be the index of the largest knot point that is less\n  * than or equal to <code>x</code>.  The value returned is <br>\n- * <code>polynomials[j](x - knot[j])</code></li></ol>\n+ * <code>polynomials[j](x - knot[j])</code></li></ol></p>\n  *\n  * @version $Revision$ $Date$\n  */\n      * and interpolating polynomials.\n      * <p>\n      * The constructor copies both arrays and assigns the copies to the knots\n-     * and polynomials properties, respectively.\n+     * and polynomials properties, respectively.</p>\n      * \n      * @param knots spline segment interval delimiters\n      * @param polynomials polynomial functions that make up the spline\n      * Compute the value for the function.\n      * <p>\n      * Throws FunctionEvaluationException if v is outside of the domain of the\n-     * function.  The domain is [smallest knot, largest knot].\n+     * function.  The domain is [smallest knot, largest knot].</p>\n      * <p>\n      * See {@link PolynomialSplineFunction} for details on the algorithm for\n-     * computing the value of the function.\n+     * computing the value of the function.</p>\n      * \n      * @param v the point for which the function value should be computed\n      * @return the value\n      * Returns a copy of the interpolating polynomials array.\n      * <p>\n      * Returns a fresh copy of the array. Changes made to the copy will\n-     * not affect the polynomials property.\n+     * not affect the polynomials property.</p>\n      * \n      * @return the interpolating polynomials\n      */\n      * Returns an array copy of the knot points.\n      * <p>\n      * Returns a fresh copy of the array. Changes made to the copy\n-     * will not affect the knots property.\n+     * will not affect the knots property.</p>\n      * \n      * @return the knot points\n      */\n--- a/src/java/org/apache/commons/math/analysis/RiddersSolver.java\n+++ b/src/java/org/apache/commons/math/analysis/RiddersSolver.java\n  * of a real continuous function </i>, IEEE Transactions on Circuits and\n  * Systems, 26 (1979), 979 - 980.\n  * <p>\n- * The function should be continuous but not necessarily smooth.\n+ * The function should be continuous but not necessarily smooth.</p>\n  *  \n  * @version $Revision$ $Date$\n  */\n     /**\n      * Find a root in the given interval with initial value.\n      * <p>\n-     * Requires bracketing condition.\n+     * Requires bracketing condition.</p>\n      * \n      * @param min the lower bound for the interval\n      * @param max the upper bound for the interval\n     /**\n      * Find a root in the given interval.\n      * <p>\n-     * Requires bracketing condition.\n+     * Requires bracketing condition.</p>\n      * \n      * @param min the lower bound for the interval\n      * @param max the upper bound for the interval\n--- a/src/java/org/apache/commons/math/analysis/RombergIntegrator.java\n+++ b/src/java/org/apache/commons/math/analysis/RombergIntegrator.java\n  * <p>\n  * Romberg integration employs k successvie refinements of the trapezoid\n  * rule to remove error terms less than order O(N^(-2k)). Simpson's rule\n- * is a special case of k = 2.\n+ * is a special case of k = 2.</p>\n  *  \n  * @version $Revision$ $Date$\n  */\n--- a/src/java/org/apache/commons/math/analysis/SecantSolver.java\n+++ b/src/java/org/apache/commons/math/analysis/SecantSolver.java\n  * the unrestricted secant algorithm. However, this implementation should in\n  * general outperform the \n  * <a href=\"http://mathworld.wolfram.com/MethodofFalsePosition.html\">\n- * regula falsi method.</a>\n+ * regula falsi method.</a></p>\n  * <p>\n- * The function is assumed to be continuous but not necessarily smooth.\n+ * The function is assumed to be continuous but not necessarily smooth.</p>\n  *  \n  * @version $Revision$ $Date$\n  */\n--- a/src/java/org/apache/commons/math/analysis/SimpsonIntegrator.java\n+++ b/src/java/org/apache/commons/math/analysis/SimpsonIntegrator.java\n  * chapter 3.\n  * <p>\n  * This implementation employs basic trapezoid rule as building blocks to\n- * calculate the Simpson's rule of alternating 2/3 and 4/3.\n+ * calculate the Simpson's rule of alternating 2/3 and 4/3.</p>\n  *  \n  * @version $Revision$ $Date$\n  */\n--- a/src/java/org/apache/commons/math/analysis/SplineInterpolator.java\n+++ b/src/java/org/apache/commons/math/analysis/SplineInterpolator.java\n  * <p>\n  * The {@link #interpolate(double[], double[])} method returns a {@link PolynomialSplineFunction}\n  * consisting of n cubic polynomials, defined over the subintervals determined by the x values,  \n- * x[0] < x[i] ... < x[n].  The x values are referred to as \"knot points.\"\n+ * x[0] < x[i] ... < x[n].  The x values are referred to as \"knot points.\"</p>\n  * <p>\n  * The value of the PolynomialSplineFunction at a point x that is greater than or equal to the smallest\n  * knot point and strictly less than the largest knot point is computed by finding the subinterval to which\n  * x belongs and computing the value of the corresponding polynomial at <code>x - x[i] </code> where\n  * <code>i</code> is the index of the subinterval.  See {@link PolynomialSplineFunction} for more details.\n+ * </p>\n  * <p>\n  * The interpolating polynomials satisfy: <ol>\n  * <li>The value of the PolynomialSplineFunction at each of the input x values equals the \n  *  corresponding y value.</li>\n  * <li>Adjacent polynomials are equal through two derivatives at the knot points (i.e., adjacent polynomials \n  *  \"match up\" at the knot points, as do their first and second derivatives).</li>\n- * </ol>\n+ * </ol></p>\n  * <p>\n  * The cubic spline interpolation algorithm implemented is as described in R.L. Burden, J.D. Faires, \n  * <u>Numerical Analysis</u>, 4th Ed., 1989, PWS-Kent, ISBN 0-53491-585-X, pp 126-131.\n+ * </p>\n  *\n  * @version $Revision$ $Date$\n  *\n--- a/src/java/org/apache/commons/math/analysis/TrapezoidIntegrator.java\n+++ b/src/java/org/apache/commons/math/analysis/TrapezoidIntegrator.java\n  * reference, see <b>Introduction to Numerical Analysis</b>, ISBN 038795452X,\n  * chapter 3.\n  * <p>\n- * The function should be integrable.\n+ * The function should be integrable.</p>\n  *  \n  * @version $Revision$ $Date$\n  */\n      * <p>\n      * The interval is divided equally into 2^n sections rather than an\n      * arbitrary m sections because this configuration can best utilize the\n-     * alrealy computed values.\n+     * alrealy computed values.</p>\n      *\n      * @param min the lower bound for the interval\n      * @param max the upper bound for the interval\n--- a/src/java/org/apache/commons/math/analysis/UnivariateRealIntegrator.java\n+++ b/src/java/org/apache/commons/math/analysis/UnivariateRealIntegrator.java\n      * <p>\n      * Usually a high iteration count indicates convergence problem. However,\n      * the \"reasonable value\" varies widely for different cases.  Users are\n-     * advised to use the default value.\n+     * advised to use the default value.</p>\n      * <p>\n      * A <code>ConvergenceException</code> will be thrown if this number\n-     * is exceeded.\n+     * is exceeded.</p>\n      *  \n      * @param count maximum number of iterations\n      */\n     /**\n      * Reset the upper limit for the number of iterations to the default.\n      * <p>\n-     * The default value is supplied by the implementation.\n+     * The default value is supplied by the implementation.</p>\n      * \n      * @see #setMaximalIterationCount(int)\n      */\n      * <p>\n      * Minimal iteration is needed to avoid false early convergence, e.g.\n      * the sample points happen to be zeroes of the function. Users can\n-     * use the default value or choose one that they see as appropriate.\n+     * use the default value or choose one that they see as appropriate.</p>\n      * <p>\n      * A <code>ConvergenceException</code> will be thrown if this number\n-     * is not met.\n+     * is not met.</p>\n      *\n      * @param count minimum number of iterations\n      */\n     /**\n      * Reset the lower limit for the number of iterations to the default.\n      * <p>\n-     * The default value is supplied by the implementation.\n+     * The default value is supplied by the implementation.</p>\n      * \n      * @see #setMinimalIterationCount(int)\n      */\n     /**\n      * Set the relative accuracy.\n      * <p>\n-     * This is used to stop iterations.\n+     * This is used to stop iterations.</p>\n      * \n      * @param accuracy the relative accuracy\n      * @throws IllegalArgumentException if the accuracy can't be achieved\n     /**\n      * Reset the relative accuracy to the default.\n      * <p>\n-     * The default value is provided by the implementation.\n+     * The default value is provided by the implementation.</p>\n      *\n      * @see #setRelativeAccuracy(double)\n      */\n      * help track down performance problems: if the iteration count\n      * is notoriously high, check whether the function is evaluated\n      * properly, and whether another integrator is more amenable to the\n-     * problem.\n+     * problem.</p>\n      * \n      * @return the last iteration count\n      * @throws IllegalStateException if there is no result available, either\n--- a/src/java/org/apache/commons/math/analysis/UnivariateRealSolver.java\n+++ b/src/java/org/apache/commons/math/analysis/UnivariateRealSolver.java\n /**\n  * Interface for (univariate real) rootfinding algorithms.\n  * <p>\n- * Implementations will search for only one zero in the given interval.\n+ * Implementations will search for only one zero in the given interval.</p>\n  *  \n  * @version $Revision$ $Date$\n  */\n      * <p>\n      * Usually a high iteration count indicates convergence problems. However,\n      * the \"reasonable value\" varies widely for different solvers.  Users are\n-     * advised to use the default value supplied by the solver.\n+     * advised to use the default value supplied by the solver.</p>\n      * <p>\n      * A <code>ConvergenceException</code> will be thrown if this number\n-     * is exceeded.\n+     * is exceeded.</p>\n      *  \n      * @param count maximum number of iterations\n      */\n     /**\n      * Reset the upper limit for the number of iterations to the default.\n      * <p>\n-     * The default value is supplied by the solver implementation.\n+     * The default value is supplied by the solver implementation.</p>\n      * \n      * @see #setMaximalIterationCount(int)\n      */\n      * The default is usually choosen so that roots in the interval\n      * -10..-0.1 and +0.1..+10 can be found with a reasonable accuracy. If the\n      * expected absolute value of your roots is of much smaller magnitude, set\n-     * this to a smaller value.\n+     * this to a smaller value.</p>\n      * <p>\n      * Solvers are advised to do a plausibility check with the relative\n-     * accuracy, but clients should not rely on this.\n+     * accuracy, but clients should not rely on this.</p>\n      *  \n      * @param accuracy the accuracy.\n      * @throws IllegalArgumentException if the accuracy can't be achieved by\n     /**\n      * Reset the absolute accuracy to the default.\n      * <p>\n-     * The default value is provided by the solver implementation.\n+     * The default value is provided by the solver implementation.</p>\n      */\n     void resetAbsoluteAccuracy();\n \n      * Set the relative accuracy.\n      * <p>\n      * This is used to stop iterations if the absolute accuracy can't be\n-     * achieved due to large values or short mantissa length.\n+     * achieved due to large values or short mantissa length.</p>\n      * <p>\n      * If this should be the primary criterion for convergence rather then a\n      * safety measure, set the absolute accuracy to a ridiculously small value,\n-     * like 1E-1000.\n+     * like 1E-1000.</p>\n      * \n      * @param accuracy the relative accuracy.\n      * @throws IllegalArgumentException if the accuracy can't be achieved by\n      * Set the function value accuracy.\n      * <p>\n      * This is used to determine when an evaluated function value or some other\n-     * value which is used as divisor is zero.\n+     * value which is used as divisor is zero.</p>\n      * <p>\n      * This is a safety guard and it shouldn't be necessary to change this in\n-     * general.\n+     * general.</p>\n      * \n      * @param accuracy the accuracy.\n      * @throws IllegalArgumentException if the accuracy can't be achieved by\n      * help track down performance problems: if the iteration count\n      * is notoriously high, check whether the function is evaluated\n      * properly, and whether another solver is more amenable to the\n-     * problem.\n+     * problem.</p>\n      * \n      * @return the last iteration count.\n      * @throws IllegalStateException if there is no result available, either\n--- a/src/java/org/apache/commons/math/analysis/UnivariateRealSolverFactory.java\n+++ b/src/java/org/apache/commons/math/analysis/UnivariateRealSolverFactory.java\n  * <li>Secant method</li>\n  * </ul>\n  * Concrete factories extending this class also specify a default solver, instances of which\n- * are returned by <code>newDefaultSolver()</code>.\n+ * are returned by <code>newDefaultSolver()</code>.</p>\n  * <p>\n  * Common usage:<pre>\n- * SolverFactory factory = UnivariateRealSolverFactory.newInstance();\n+ * SolverFactory factory = UnivariateRealSolverFactory.newInstance();</p>\n  *\n  * // create a Brent solver to use with a UnivariateRealFunction f\n  * BrentSolver solver = factory.newBrentSolver(f);\n--- a/src/java/org/apache/commons/math/analysis/UnivariateRealSolverFactoryImpl.java\n+++ b/src/java/org/apache/commons/math/analysis/UnivariateRealSolverFactoryImpl.java\n  * A concrete {@link  UnivariateRealSolverFactory}.  This is the default solver factory\n  * used by commons-math.\n  * <p>\n- * The default solver returned by this factory is a {@link BrentSolver}.\n+ * The default solver returned by this factory is a {@link BrentSolver}.</p>\n  *\n  * @version $Revision$ $Date$\n  */\n--- a/src/java/org/apache/commons/math/analysis/UnivariateRealSolverUtils.java\n+++ b/src/java/org/apache/commons/math/analysis/UnivariateRealSolverUtils.java\n      * -- ConvergenceException </li>\n      * <li> <code> Integer.MAX_VALUE</code> iterations elapse \n      * -- ConvergenceException </li>\n-     * </ul>\n+     * </ul></p>\n      * <p>\n      * <strong>Note: </strong> this method can take \n      * <code>Integer.MAX_VALUE</code> iterations to throw a \n      * is a root between <code>lowerBound</code> and <code>upperBound</code>\n      * near <code>initial,</code> it is better to use \n      * {@link #bracket(UnivariateRealFunction, double, double, double, int)}, \n-     * explicitly specifying the maximum number of iterations.\n+     * explicitly specifying the maximum number of iterations.</p>\n      *\n      * @param function the function\n      * @param initial initial midpoint of interval being expanded to\n      * <li> <code> a = lower </code> and <code> b = upper</code> \n      * -- ConvergenceException </li>\n      * <li> <code> maximumIterations</code> iterations elapse \n-     * -- ConvergenceException </li></ul>\n+     * -- ConvergenceException </li></ul></p>\n      * \n      * @param function the function\n      * @param initial initial midpoint of interval being expanded to\n--- a/src/java/org/apache/commons/math/complex/Complex.java\n+++ b/src/java/org/apache/commons/math/complex/Complex.java\n  * infinite values according to the rules for {@link java.lang.Double}\n  * arithmetic, applying definitional formulas and returning <code>NaN</code> or\n  * infinite values in real or imaginary parts as these arise in computation. \n- * See individual method javadocs for details.\n+ * See individual method javadocs for details.</p>\n  * <p>\n  * {@link #equals} identifies all values with <code>NaN</code> in either real \n  * or imaginary part - e.g., <pre>\n- * <code>1 + NaNi  == NaN + i == NaN + NaNi.</code></pre>\n+ * <code>1 + NaNi  == NaN + i == NaN + NaNi.</code></pre></p>\n  *\n  * @author Apache Software Foundation\n  * @version $Revision$ $Date$\n      * Returns <code>NaN</code> if either real or imaginary part is\n      * <code>NaN</code> and <code>Double.POSITIVE_INFINITY</code> if\n      * neither part is <code>NaN</code>, but at least one part takes an infinite\n-     * value.\n+     * value.</p>\n      *\n      * @return the absolute value\n      */\n      * Uses the definitional formula \n      * <pre>\n      * (a + bi) + (c + di) = (a+c) + (b+d)i\n-     * </pre>\n+     * </pre></p>\n      * <p>\n      * If either this or <code>rhs</code> has a NaN value in either part,\n      * {@link #NaN} is returned; otherwise Inifinite and NaN values are\n      * returned in the parts of the result according to the rules for\n-     * {@link java.lang.Double} arithmetic. \n+     * {@link java.lang.Double} arithmetic.</p> \n      *\n      * @param rhs the other complex number\n      * @return the complex number sum\n      * \"A + Bi\" is \"A - Bi\". \n      * <p>\n      * {@link #NaN} is returned if either the real or imaginary\n-     * part of this Complex number equals <code>Double.NaN</code>.\n+     * part of this Complex number equals <code>Double.NaN</code>.</p>\n      * <p>\n      * If the imaginary part is infinite, and the real part is not NaN, \n      * the returned value has infinite imaginary part of the opposite\n      * sign - e.g. the conjugate of <code>1 + POSITIVE_INFINITY i</code>\n-     * is <code>1 - NEGATIVE_INFINITY i</code>\n+     * is <code>1 - NEGATIVE_INFINITY i</code></p>\n      *\n      * @return the conjugate of this Complex object\n      */\n      * but uses \n      * <a href=\"http://doi.acm.org/10.1145/1039813.1039814\">\n      * prescaling of operands</a> to limit the effects of overflows and\n-     * underflows in the computation.\n+     * underflows in the computation.</p>\n      * <p>\n      * Infinite and NaN values are handled / returned according to the\n      * following rules, applied in the order presented:\n      * <li>If this is infinite and <code>rhs</code> is finite, NaN values are\n      * returned in the parts of the result if the {@link java.lang.Double}\n      * rules applied to the definitional formula force NaN results.</li>\n-     * </ul>\n+     * </ul></p>\n      * \n      * @param rhs the other complex number\n      * @return the complex number quotient\n      * <p>\n      * If both the real and imaginary parts of two Complex numbers\n      * are exactly the same, and neither is <code>Double.NaN</code>, the two\n-     * Complex objects are considered to be equal. \n+     * Complex objects are considered to be equal.</p>\n      * <p>\n      * All <code>NaN</code> values are considered to be equal - i.e, if either\n      * (or both) real and imaginary parts of the complex number are equal\n      * to <code>Double.NaN</code>, the complex number is equal to \n-     * <code>Complex.NaN</code>.\n+     * <code>Complex.NaN</code>.</p>\n      *\n      * @param other Object to test for equality to this\n      * @return true if two Complex objects are equal, false if\n     /**\n      * Get a hashCode for the complex number.\n      * <p>\n-     * All NaN values have the same hash code.\n+     * All NaN values have the same hash code.</p>\n      * \n      * @return a hash code value for this object\n      */\n      * Return the additive inverse of this complex number.\n      * <p>\n      * Returns <code>Complex.NaN</code> if either real or imaginary\n-     * part of this Complex number equals <code>Double.NaN</code>.\n+     * part of this Complex number equals <code>Double.NaN</code>.</p>\n      *\n      * @return the negation of this complex number\n      */\n      * Uses the definitional formula \n      * <pre>\n      * (a + bi) - (c + di) = (a-c) + (b-d)i\n-     * </pre>\n+     * </pre></p>\n      * <p>\n      * If either this or <code>rhs</code> has a NaN value in either part,\n      * {@link #NaN} is returned; otherwise inifinite and NaN values are\n      * returned in the parts of the result according to the rules for\n-     * {@link java.lang.Double} arithmetic. \n+     * {@link java.lang.Double} arithmetic. </p>\n      * \n      * @param rhs the other complex number\n      * @return the complex number difference\n      * inverse cosine</a> of this complex number.\n      * <p>\n      * Implements the formula: <pre>\n-     * <code> acos(z) = -i (log(z + i (sqrt(1 - z<sup>2</sup>))))</code></pre>\n-     * <p>\n-     * Returns {@link Complex#NaN} if either real or imaginary part of the \n-     * input argument is <code>NaN</code> or infinite.\n+     * <code> acos(z) = -i (log(z + i (sqrt(1 - z<sup>2</sup>))))</code></pre></p>\n+     * <p>\n+     * Returns {@link Complex#NaN} if either real or imaginary part of the \n+     * input argument is <code>NaN</code> or infinite.</p>\n      * \n      * @return the inverse cosine of this complex number\n      * @since 1.2\n      * inverse sine</a> of this complex number.\n      * <p>\n      * Implements the formula: <pre>\n-     * <code> asin(z) = -i (log(sqrt(1 - z<sup>2</sup>) + iz)) </code></pre>\n-     * <p>\n-     * Returns {@link Complex#NaN} if either real or imaginary part of the \n-     * input argument is <code>NaN</code> or infinite.\n+     * <code> asin(z) = -i (log(sqrt(1 - z<sup>2</sup>) + iz)) </code></pre></p>\n+     * <p>\n+     * Returns {@link Complex#NaN} if either real or imaginary part of the \n+     * input argument is <code>NaN</code> or infinite.</p>\n      * \n      * @return the inverse sine of this complex number.\n      * @since 1.2\n      * inverse tangent</a> of this complex number.\n      * <p>\n      * Implements the formula: <pre>\n-     * <code> atan(z) = (i/2) log((i + z)/(i - z)) </code></pre>\n-     * <p>\n-     * Returns {@link Complex#NaN} if either real or imaginary part of the \n-     * input argument is <code>NaN</code> or infinite. \n+     * <code> atan(z) = (i/2) log((i + z)/(i - z)) </code></pre></p>\n+     * <p>\n+     * Returns {@link Complex#NaN} if either real or imaginary part of the \n+     * input argument is <code>NaN</code> or infinite.</p>\n      * \n      * @return the inverse tangent of this complex number\n      * @since 1.2\n      * <code> cos(a + bi) = cos(a)cosh(b) - sin(a)sinh(b)i</code></pre>\n      * where the (real) functions on the right-hand side are\n      * {@link java.lang.Math#sin}, {@link java.lang.Math#cos}, \n-     * {@link MathUtils#cosh} and {@link MathUtils#sinh}.\n-     * <p>\n-     * Returns {@link Complex#NaN} if either real or imaginary part of the \n-     * input argument is <code>NaN</code>.\n+     * {@link MathUtils#cosh} and {@link MathUtils#sinh}.</p>\n+     * <p>\n+     * Returns {@link Complex#NaN} if either real or imaginary part of the \n+     * input argument is <code>NaN</code>.</p>\n      * <p>\n      * Infinite values in real or imaginary parts of the input may result in\n      * infinite or NaN values returned in parts of the result.<pre>\n      * <code>\n      * cos(1 &plusmn; INFINITY i) = 1 &#x2213; INFINITY i\n      * cos(&plusmn;INFINITY + i) = NaN + NaN i\n-     * cos(&plusmn;INFINITY &plusmn; INFINITY i) = NaN + NaN i</code></pre>\n+     * cos(&plusmn;INFINITY &plusmn; INFINITY i) = NaN + NaN i</code></pre></p>\n      * \n      * @return the cosine of this complex number\n      * @since 1.2\n      * <code> cosh(a + bi) = cosh(a)cos(b) + sinh(a)sin(b)i</code></pre>\n      * where the (real) functions on the right-hand side are\n      * {@link java.lang.Math#sin}, {@link java.lang.Math#cos}, \n-     * {@link MathUtils#cosh} and {@link MathUtils#sinh}.\n-     * <p>\n-     * Returns {@link Complex#NaN} if either real or imaginary part of the \n-     * input argument is <code>NaN</code>.\n+     * {@link MathUtils#cosh} and {@link MathUtils#sinh}.</p>\n+     * <p>\n+     * Returns {@link Complex#NaN} if either real or imaginary part of the \n+     * input argument is <code>NaN</code>.</p>\n      * <p>\n      * Infinite values in real or imaginary parts of the input may result in\n      * infinite or NaN values returned in parts of the result.<pre>\n      * <code>\n      * cosh(1 &plusmn; INFINITY i) = NaN + NaN i\n      * cosh(&plusmn;INFINITY + i) = INFINITY &plusmn; INFINITY i\n-     * cosh(&plusmn;INFINITY &plusmn; INFINITY i) = NaN + NaN i</code></pre>\n+     * cosh(&plusmn;INFINITY &plusmn; INFINITY i) = NaN + NaN i</code></pre></p>\n      * \n      * @return the hyperbolic cosine of this complex number.\n      * @since 1.2\n      * <code> exp(a + bi) = exp(a)cos(b) + exp(a)sin(b)i</code></pre>\n      * where the (real) functions on the right-hand side are\n      * {@link java.lang.Math#exp}, {@link java.lang.Math#cos}, and\n-     * {@link java.lang.Math#sin}.\n-     * <p>\n-     * Returns {@link Complex#NaN} if either real or imaginary part of the \n-     * input argument is <code>NaN</code>.\n+     * {@link java.lang.Math#sin}.</p>\n+     * <p>\n+     * Returns {@link Complex#NaN} if either real or imaginary part of the \n+     * input argument is <code>NaN</code>.</p>\n      * <p>\n      * Infinite values in real or imaginary parts of the input may result in\n      * infinite or NaN values returned in parts of the result.<pre>\n      * exp(1 &plusmn; INFINITY i) = NaN + NaN i\n      * exp(INFINITY + i) = INFINITY + INFINITY i\n      * exp(-INFINITY + i) = 0 + 0i\n-     * exp(&plusmn;INFINITY &plusmn; INFINITY i) = NaN + NaN i</code></pre>\n+     * exp(&plusmn;INFINITY &plusmn; INFINITY i) = NaN + NaN i</code></pre></p>\n      * \n      * @return <i>e</i><sup><code>this</code></sup>\n      * @since 1.2\n      * <code> log(a + bi) = ln(|a + bi|) + arg(a + bi)i</code></pre>\n      * where ln on the right hand side is {@link java.lang.Math#log},\n      * <code>|a + bi|</code> is the modulus, {@link Complex#abs},  and\n-     * <code>arg(a + bi) = {@link java.lang.Math#atan2}(b, a)</code>\n-     * <p>\n-     * Returns {@link Complex#NaN} if either real or imaginary part of the \n-     * input argument is <code>NaN</code>.\n+     * <code>arg(a + bi) = {@link java.lang.Math#atan2}(b, a)</code></p>\n+     * <p>\n+     * Returns {@link Complex#NaN} if either real or imaginary part of the \n+     * input argument is <code>NaN</code>.</p>\n      * <p>\n      * Infinite (or critical) values in real or imaginary parts of the input may\n      * result in infinite or NaN values returned in parts of the result.<pre>\n      * log(INFINITY &plusmn; INFINITY i) = INFINITY &plusmn; (&pi;/4)i\n      * log(-INFINITY &plusmn; INFINITY i) = INFINITY &plusmn; (3&pi;/4)i\n      * log(0 + 0i) = -INFINITY + 0i\n-     * </code></pre>\n+     * </code></pre></p>\n      * \n      * @return ln of this complex number.\n      * @since 1.2\n      * Implements the formula: <pre>\n      * <code> y<sup>x</sup> = exp(x&middot;log(y))</code></pre> \n      * where <code>exp</code> and <code>log</code> are {@link #exp} and\n-     * {@link #log}, respectively.\n+     * {@link #log}, respectively.</p>\n      * <p>\n      * Returns {@link Complex#NaN} if either real or imaginary part of the \n      * input argument is <code>NaN</code> or infinite, or if <code>y</code>\n-     * equals {@link Complex#ZERO}.\n+     * equals {@link Complex#ZERO}.</p>\n      * \n      * @param x the exponent.\n      * @return <code>this</code><sup><code>x</code></sup>\n      * <code> sin(a + bi) = sin(a)cosh(b) - cos(a)sinh(b)i</code></pre>\n      * where the (real) functions on the right-hand side are\n      * {@link java.lang.Math#sin}, {@link java.lang.Math#cos}, \n-     * {@link MathUtils#cosh} and {@link MathUtils#sinh}.\n-     * <p>\n-     * Returns {@link Complex#NaN} if either real or imaginary part of the \n-     * input argument is <code>NaN</code>.\n+     * {@link MathUtils#cosh} and {@link MathUtils#sinh}.</p>\n+     * <p>\n+     * Returns {@link Complex#NaN} if either real or imaginary part of the \n+     * input argument is <code>NaN</code>.</p>\n      * <p>\n      * Infinite values in real or imaginary parts of the input may result in\n      * infinite or NaN values returned in parts of the result.<pre>\n      * <code>\n      * sin(1 &plusmn; INFINITY i) = 1 &plusmn; INFINITY i\n      * sin(&plusmn;INFINITY + i) = NaN + NaN i\n-     * sin(&plusmn;INFINITY &plusmn; INFINITY i) = NaN + NaN i</code></pre>\n+     * sin(&plusmn;INFINITY &plusmn; INFINITY i) = NaN + NaN i</code></pre></p>\n      * \n      * @return the sine of this complex number.\n      * @since 1.2\n      * <code> sinh(a + bi) = sinh(a)cos(b)) + cosh(a)sin(b)i</code></pre>\n      * where the (real) functions on the right-hand side are\n      * {@link java.lang.Math#sin}, {@link java.lang.Math#cos}, \n-     * {@link MathUtils#cosh} and {@link MathUtils#sinh}.\n-     * <p>\n-     * Returns {@link Complex#NaN} if either real or imaginary part of the \n-     * input argument is <code>NaN</code>.\n+     * {@link MathUtils#cosh} and {@link MathUtils#sinh}.</p>\n+     * <p>\n+     * Returns {@link Complex#NaN} if either real or imaginary part of the \n+     * input argument is <code>NaN</code>.</p>\n      * <p>\n      * Infinite values in real or imaginary parts of the input may result in\n      * infinite or NaN values returned in parts of the result.<pre>\n      * <code>\n      * sinh(1 &plusmn; INFINITY i) = NaN + NaN i\n      * sinh(&plusmn;INFINITY + i) = &plusmn; INFINITY + INFINITY i\n-     * sinh(&plusmn;INFINITY &plusmn; INFINITY i) = NaN + NaN i</code></pre\n+     * sinh(&plusmn;INFINITY &plusmn; INFINITY i) = NaN + NaN i</code></pre></p>\n      * \n      * @return the hyperbolic sine of this complex number\n      * @since 1.2\n      * <li><code>|a| = {@link Math#abs}(a)</code></li>\n      * <li><code>|a + bi| = {@link Complex#abs}(a + bi) </code></li>\n      * <li><code>sign(b) =  {@link MathUtils#indicator}(b) </code>\n-     * </ul>\n-     * <p>\n-     * Returns {@link Complex#NaN} if either real or imaginary part of the \n-     * input argument is <code>NaN</code>.\n+     * </ul></p>\n+     * <p>\n+     * Returns {@link Complex#NaN} if either real or imaginary part of the \n+     * input argument is <code>NaN</code>.</p>\n      * <p>\n      * Infinite values in real or imaginary parts of the input may result in\n      * infinite or NaN values returned in parts of the result.<pre>\n      * sqrt(-INFINITY + i) = 0 + INFINITY i\n      * sqrt(INFINITY &plusmn; INFINITY i) = INFINITY + NaN i\n      * sqrt(-INFINITY &plusmn; INFINITY i) = NaN &plusmn; INFINITY i\n-     * </code></pre>\n+     * </code></pre></p>\n      * \n      * @return the square root of this complex number\n      * @since 1.2\n      * number.\n      * <p>\n      * Computes the result directly as \n-     * <code>sqrt(Complex.ONE.subtract(z.multiply(z)))</code>.\n-     * <p>\n-     * Returns {@link Complex#NaN} if either real or imaginary part of the \n-     * input argument is <code>NaN</code>.\n+     * <code>sqrt(Complex.ONE.subtract(z.multiply(z)))</code>.</p>\n+     * <p>\n+     * Returns {@link Complex#NaN} if either real or imaginary part of the \n+     * input argument is <code>NaN</code>.</p>\n      * <p>\n      * Infinite values in real or imaginary parts of the input may result in\n-     * infinite or NaN values returned in parts of the result. \n+     * infinite or NaN values returned in parts of the result.</p>\n      * \n      * @return the square root of 1 - <code>this</code><sup>2</sup>\n      * @since 1.2\n      * <code>tan(a + bi) = sin(2a)/(cos(2a)+cosh(2b)) + [sinh(2b)/(cos(2a)+cosh(2b))]i</code></pre>\n      * where the (real) functions on the right-hand side are\n      * {@link java.lang.Math#sin}, {@link java.lang.Math#cos}, \n-     * {@link MathUtils#cosh} and {@link MathUtils#sinh}.\n-     * <p>\n-     * Returns {@link Complex#NaN} if either real or imaginary part of the \n-     * input argument is <code>NaN</code>.\n+     * {@link MathUtils#cosh} and {@link MathUtils#sinh}.</p>\n+     * <p>\n+     * Returns {@link Complex#NaN} if either real or imaginary part of the \n+     * input argument is <code>NaN</code>.</p>\n      * <p>\n      * Infinite (or critical) values in real or imaginary parts of the input may\n      * result in infinite or NaN values returned in parts of the result.<pre>\n      * tan(1 &plusmn; INFINITY i) = 0 + NaN i\n      * tan(&plusmn;INFINITY + i) = NaN + NaN i\n      * tan(&plusmn;INFINITY &plusmn; INFINITY i) = NaN + NaN i\n-     * tan(&plusmn;&pi;/2 + 0 i) = &plusmn;INFINITY + NaN i</code></pre>\n+     * tan(&plusmn;&pi;/2 + 0 i) = &plusmn;INFINITY + NaN i</code></pre></p>\n      * \n      * @return the tangent of this complex number\n      * @since 1.2\n      * <code>tan(a + bi) = sinh(2a)/(cosh(2a)+cos(2b)) + [sin(2b)/(cosh(2a)+cos(2b))]i</code></pre>\n      * where the (real) functions on the right-hand side are\n      * {@link java.lang.Math#sin}, {@link java.lang.Math#cos}, \n-     * {@link MathUtils#cosh} and {@link MathUtils#sinh}.\n-     * <p>\n-     * Returns {@link Complex#NaN} if either real or imaginary part of the \n-     * input argument is <code>NaN</code>.\n+     * {@link MathUtils#cosh} and {@link MathUtils#sinh}.</p>\n+     * <p>\n+     * Returns {@link Complex#NaN} if either real or imaginary part of the \n+     * input argument is <code>NaN</code>.</p>\n      * <p>\n      * Infinite values in real or imaginary parts of the input may result in\n      * infinite or NaN values returned in parts of the result.<pre>\n      * tanh(1 &plusmn; INFINITY i) = NaN + NaN i\n      * tanh(&plusmn;INFINITY + i) = NaN + 0 i\n      * tanh(&plusmn;INFINITY &plusmn; INFINITY i) = NaN + NaN i\n-     * tanh(0 + (&pi;/2)i) = NaN + INFINITY i</code></pre>\n+     * tanh(0 + (&pi;/2)i) = NaN + INFINITY i</code></pre></p>\n      *\n      * @return the hyperbolic tangent of this complex number\n      * @since 1.2\n--- a/src/java/org/apache/commons/math/complex/ComplexUtils.java\n+++ b/src/java/org/apache/commons/math/complex/ComplexUtils.java\n      * Creates a complex number from the given polar representation.\n      * <p>\n      * The value returned is <code>r&middot;e<sup>i&middot;theta</sup></code>,\n-     * computed as <code>r&middot;cos(theta) + r&middot;sin(theta)i</code>\n+     * computed as <code>r&middot;cos(theta) + r&middot;sin(theta)i</code></p>\n      * <p>\n      * If either <code>r</code> or <code>theta</code> is NaN, or \n-     * <code>theta</code> is infinite, {@link Complex#NaN} is returned.\n+     * <code>theta</code> is infinite, {@link Complex#NaN} is returned.</p>\n      * <p>\n      * If <code>r</code> is infinite and <code>theta</code> is finite, \n      * infinite or NaN values may be returned in parts of the result, following\n      * polar2Complex(INFINITY, &pi;/4) = INFINITY + INFINITY i\n      * polar2Complex(INFINITY, 0) = INFINITY + NaN i\n      * polar2Complex(INFINITY, -&pi;/4) = INFINITY - INFINITY i\n-     * polar2Complex(INFINITY, 5&pi;/4) = -INFINITY - INFINITY i </code></pre>\n+     * polar2Complex(INFINITY, 5&pi;/4) = -INFINITY - INFINITY i </code></pre></p>\n      * \n      * @param r the modulus of the complex number to create\n      * @param theta  the argument of the complex number to create\n--- a/src/java/org/apache/commons/math/random/AbstractRandomGenerator.java\n+++ b/src/java/org/apache/commons/math/random/AbstractRandomGenerator.java\n  * Concrete implementations <strong>must</strong> override\n  * this method and <strong>should</strong> provide better / more\n  * performant implementations of the other methods if the underlying PRNG\n- * supplies them.\n+ * supplies them.</p>\n  *\n  * @since 1.1\n  * @version $Revision$ $Date$\n      * <p>\n      * Implementations that do not override the default implementation of \n      * <code>nextGaussian</code> should include a call to {@link #clear} in the\n-     * implementation of this method.\n+     * implementation of this method.</p>\n      *\n      * @param seed the seed value\n      */\n      * the length of the byte array.\n      * <p>\n      * The default implementation fills the array with bytes extracted from\n-     * random integers generated using {@link #nextInt}.\n+     * random integers generated using {@link #nextInt}.</p>\n      * \n      * @param bytes the non-null byte array in which to put the \n      * random bytes\n      * The default implementation provided here returns \n      * <pre>\n      * <code>(int) (nextDouble() * Integer.MAX_VALUE)</code>\n-     * </pre>\n+     * </pre></p>\n      *\n      * @return the next pseudorandom, uniformly distributed <code>int</code>\n      *  value from this random number generator's sequence\n      * The default implementation returns \n      * <pre>\n      * <code>(int) (nextDouble() * n</code>\n-     * </pre>\n+     * </pre></p>\n      *\n      * @param n the bound on the random number to be returned.  Must be\n      * positive.\n      * The default implementation returns \n      * <pre>\n      * <code>(long) (nextDouble() * Long.MAX_VALUE)</code>\n-     * </pre>\n+     * </pre></p>\n      *\n      * @return  the next pseudorandom, uniformly distributed <code>long</code>\n      *value from this random number generator's sequence\n      * The default implementation returns \n      * <pre>\n      * <code>nextDouble() <= 0.5</code>\n-     * </pre>\n+     * </pre></p>\n      * \n      * @return  the next pseudorandom, uniformly distributed\n      * <code>boolean</code> value from this random number generator's\n      * The default implementation returns \n      * <pre>\n      * <code>(float) nextDouble() </code>\n-     * </pre>\n+     * </pre></p>\n      *\n      * @return  the next pseudorandom, uniformly distributed <code>float</code>\n      * value between <code>0.0</code> and <code>1.0</code> from this\n      * <code>1.0</code> from this random number generator's sequence.  \n      * <p>\n      * This method provides the underlying source of random data used by the\n-     * other methods.   \n+     * other methods.</p>   \n      *\n      * @return  the next pseudorandom, uniformly distributed \n      *  <code>double</code> value between <code>0.0</code> and\n      * <p>\n      * The default implementation uses the <em>Polar Method</em>\n      * due to G.E.P. Box, M.E. Muller and G. Marsaglia, as described in \n-     * D. Knuth, <u>The Art of Computer Programming</u>, 3.4.1C.\n+     * D. Knuth, <u>The Art of Computer Programming</u>, 3.4.1C.</p>\n      * <p>\n      * The algorithm generates a pair of independent random values.  One of\n      * these is cached for reuse, so the full algorithm is not executed on each\n      * activation.  Implementations that do not override this method should\n      * make sure to call {@link #clear} to clear the cached value in the \n-     * implementation of {@link #setSeed(long)}.\n+     * implementation of {@link #setSeed(long)}.</p>\n      * \n      * @return  the next pseudorandom, Gaussian (\"normally\") distributed\n      * <code>double</code> value with mean <code>0.0</code> and\n--- a/src/java/org/apache/commons/math/random/EmpiricalDistribution.java\n+++ b/src/java/org/apache/commons/math/random/EmpiricalDistribution.java\n  * <li>generating random values from the distribution</li>\n  * </ul>\n  * Applications can use <code>EmpiricalDistribution</code> implementations to\n- * build grouped frequnecy histograms representing the input data or to\n+ * build grouped frequency histograms representing the input data or to\n  * generate random values \"like\" those in the input file -- i.e., the values\n- * generated will follow the distribution of the values in the file.\n+ * generated will follow the distribution of the values in the file.</p>\n  * \n  * @version $Revision$ $Date$\n  */\n--- a/src/java/org/apache/commons/math/random/NotPositiveDefiniteMatrixException.java\n+++ b/src/java/org/apache/commons/math/random/NotPositiveDefiniteMatrixException.java\n \n import org.apache.commons.math.MathException;\n \n-/** This class represents exceptions thrown by the correlated random\n+/** \n+ * This class represents exceptions thrown by the correlated random\n  * vector generator.\n- * @version $Revision:$ $Date$\n+ * \n+ * @since 1.2\n+ * @version $Revision$ $Date$\n  */\n \n public class NotPositiveDefiniteMatrixException extends MathException {\n--- a/src/java/org/apache/commons/math/random/RandomData.java\n+++ b/src/java/org/apache/commons/math/random/RandomData.java\n      * <p>\n      * The generated string will be random, but not cryptographically\n      * secure. To generate cryptographically secure strings, use\n-     * <code>nextSecureHexString</code>\n+     * <code>nextSecureHexString</code></p>\n      * <p>\n      * <strong>Preconditions</strong>:<ul>\n      * <li><code>len > 0</code> (otherwise an IllegalArgumentException\n      *     is thrown.)</li>\n-     * </ul>\n+     * </ul></p>\n      *\n      * @param len the length of the string to be generated\n      * @return random string of hex characters of length <code>len</code>\n      * <p>\n      * The generated integer will be random, but not cryptographically secure.\n      * To generate cryptographically secure integer sequences, use\n-     * <code>nextSecureInt</code>.\n-     * <p>\n-     * <strong>Preconditions</strong>:<ul>\n-     * <li><code>lower < upper</code> (otherwise an IllegalArgumentException\n-     *     is thrown.)</li>\n-     * </ul>\n+     * <code>nextSecureInt</code>.</p>\n+     * <p>\n+     * <strong>Preconditions</strong>:<ul>\n+     * <li><code>lower < upper</code> (otherwise an IllegalArgumentException\n+     *     is thrown.)</li>\n+     * </ul></p>\n      *\n      * @param lower lower bound for generated integer\n      * @param upper upper bound for generated integer\n      * The generated long integer values will be random, but not\n      * cryptographically secure.\n      * To generate cryptographically secure sequences of longs, use\n-     * <code>nextSecureLong</code>\n-     * <p>\n-     * <strong>Preconditions</strong>:<ul>\n-     * <li><code>lower < upper</code> (otherwise an IllegalArgumentException\n-     *     is thrown.)</li>\n-     * </ul>\n+     * <code>nextSecureLong</code></p>\n+     * <p>\n+     * <strong>Preconditions</strong>:<ul>\n+     * <li><code>lower < upper</code> (otherwise an IllegalArgumentException\n+     *     is thrown.)</li>\n+     * </ul></p>\n      *\n      * @param lower lower bound for generated integer\n      * @param upper upper bound for generated integer\n      * sequence.\n      * <p>\n      * If cryptographic security is not required,\n-     * use <code>nextHexString()</code>.\n+     * use <code>nextHexString()</code>.</p>\n      * <p>\n      * <strong>Preconditions</strong>:<ul>\n      * <li><code>len > 0</code> (otherwise an IllegalArgumentException\n      *     is thrown.)</li>\n-     * </ul>\n+     * </ul></p>\n      * @param len length of return string\n      * @return the random hex string\n      */\n      * <p>\n      * Sequences of integers generated using this method will be\n      * cryptographically secure. If cryptographic security is not required,\n-     * <code>nextInt</code> should be used instead of this method.\n+     * <code>nextInt</code> should be used instead of this method.</p>\n      * <p>\n      * <strong>Definition</strong>:\n      * <a href=\"http://en.wikipedia.org/wiki/Cryptographically_secure_pseudo-random_number_generator\">\n-     * Secure Random Sequence</a>\n-     * <p>\n-     * <strong>Preconditions</strong>:<ul>\n-     * <li><code>lower < upper</code> (otherwise an IllegalArgumentException\n-     *     is thrown.)</li>\n-     * </ul>\n+     * Secure Random Sequence</a></p>\n+     * <p>\n+     * <strong>Preconditions</strong>:<ul>\n+     * <li><code>lower < upper</code> (otherwise an IllegalArgumentException\n+     *     is thrown.)</li>\n+     * </ul></p>\n      *\n      * @param lower lower bound for generated integer\n      * @param upper upper bound for generated integer\n \n     /**\n      * Generates a random long integer between <code>lower</code>\n-     * and <code>upper</code> (endpoints included).<p>\n+     * and <code>upper</code> (endpoints included).\n+     * <p>\n      * Sequences of long values generated using this method will be\n      * cryptographically secure. If cryptographic security is not required,\n-     * <code>nextLong</code> should be used instead of this method.\n+     * <code>nextLong</code> should be used instead of this method.</p>\n      * <p>\n      * <strong>Definition</strong>:\n      * <a href=\"http://en.wikipedia.org/wiki/Cryptographically_secure_pseudo-random_number_generator\">\n-     * Secure Random Sequence</a>\n-     * <p>\n-     * <strong>Preconditions</strong>:<ul>\n-     * <li><code>lower < upper</code> (otherwise an IllegalArgumentException\n-     *     is thrown.)</li>\n-     * </ul>\n+     * Secure Random Sequence</a></p>\n+     * <p>\n+     * <strong>Preconditions</strong>:<ul>\n+     * <li><code>lower < upper</code> (otherwise an IllegalArgumentException\n+     *     is thrown.)</li>\n+     * </ul></p>\n      *\n      * @param lower lower bound for generated integer\n      * @param upper upper bound for generated integer\n      * <p>\n      * <strong>Definition</strong>:\n      * <a href=\"http://www.itl.nist.gov/div898/handbook/eda/section3/eda366j.htm\">\n-     * Poisson Distribution</a>\n+     * Poisson Distribution</a></p>\n      * <p>\n      * <strong>Preconditions</strong>: <ul>\n      * <li>The specified mean <i>must</i> be positive (otherwise an\n      *     IllegalArgumentException is thrown.)</li>\n-     * </ul>\n+     * </ul></p>\n      * @param mean Mean of the distribution\n      * @return poisson deviate with the specified mean\n      */\n      * <p>\n      * <strong>Definition</strong>:\n      * <a href=\"http://www.itl.nist.gov/div898/handbook/eda/section3/eda3661.htm\">\n-     * Normal Distribution</a>\n+     * Normal Distribution</a></p>\n      * <p>\n      * <strong>Preconditions</strong>: <ul>\n      * <li><code>sigma > 0</code> (otherwise an IllegalArgumentException\n      *     is thrown.)</li>\n-     * </ul>\n+     * </ul></p>\n      * @param mu Mean of the distribution\n      * @param sigma Standard deviation of the distribution\n      * @return random value from Gaussian distribution with mean = mu,\n      * <p>\n      * <strong>Definition</strong>:\n      * <a href=\"http://www.itl.nist.gov/div898/handbook/eda/section3/eda3667.htm\">\n-     * Exponential Distribution</a>\n+     * Exponential Distribution</a></p>\n      * <p>\n      * <strong>Preconditions</strong>: <ul>\n      * <li><code>mu >= 0</code> (otherwise an IllegalArgumentException\n      *     is thrown.)</li>\n-     * </ul>\n+     * </ul></p>\n      * @param mean Mean of the distribution\n      * @return random value from exponential distribution\n      */\n      * Uniform Distribution</a> <code>lower</code> and\n      * <code>upper - lower</code> are the\n      * <a href = \"http://www.itl.nist.gov/div898/handbook/eda/section3/eda364.htm\">\n-     * location and scale parameters</a>, respectively.\n-     * <p>\n-     * <strong>Preconditions</strong>:<ul>\n-     * <li><code>lower < upper</code> (otherwise an IllegalArgumentException\n-     *     is thrown.)</li>\n-     * </ul>\n+     * location and scale parameters</a>, respectively.</p>\n+     * <p>\n+     * <strong>Preconditions</strong>:<ul>\n+     * <li><code>lower < upper</code> (otherwise an IllegalArgumentException\n+     *     is thrown.)</li>\n+     * </ul></p>\n      *\n      * @param lower lower endpoint of the interval of support\n      * @param upper upper endpoint of the interval of support\n      * 0 through n-1</code> (inclusive).\n      * <p>\n      * Generated arrays represent permutations\n-     * of <code>n</code> taken <code>k</code> at a time.\n+     * of <code>n</code> taken <code>k</code> at a time.</p>\n      * <p>\n      * <strong>Preconditions:</strong><ul>\n      * <li> <code>k <= n</code></li>\n      * <li> <code>n > 0</code> </li>\n      * </ul>\n      * If the preconditions are not met, an IllegalArgumentException is\n-     * thrown.\n+     * thrown.</p>\n      *\n      * @param n domain of the permutation\n      * @param k size of the permutation\n      * c</code> are distinct, the resulting object array represents a\n      * <a href=\"http://rkb.home.cern.ch/rkb/AN16pp/node250.html#SECTION0002500000000000000000\">\n      * Simple Random Sample</a> of size\n-     * <code>k</code> from the elements of <code>c</code>.\n+     * <code>k</code> from the elements of <code>c</code>.</p>\n      * <p>\n      * <strong>Preconditions:</strong><ul>\n      * <li> k must be less than or equal to the size of c </li>\n      * <li> c must not be empty </li>\n      * </ul>\n      * If the preconditions are not met, an IllegalArgumentException is\n-     * thrown.\n+     * thrown.</p>\n      *\n      * @param c collection to be sampled\n      * @param k size of the sample\n--- a/src/java/org/apache/commons/math/random/RandomDataImpl.java\n+++ b/src/java/org/apache/commons/math/random/RandomDataImpl.java\n  * <p>\n  * Supports reseeding the underlying pseudo-random number generator (PRNG). \n  * The <code>SecurityProvider</code> and <code>Algorithm</code>\n- * used by the <code>SecureRandom</code> instance can also be reset.\n+ * used by the <code>SecureRandom</code> instance can also be reset.</p>\n  * <p>\n  * For details on the default PRNGs, see {@link java.util.Random} and\n- * {@link java.security.SecureRandom}. \n+ * {@link java.security.SecureRandom}.</p>\n  * <p>\n  * <strong>Usage Notes</strong>: <ul>\n  * <li>\n  * identical).</li>\n  * <li>\n  * This implementation is not synchronized.\n- * </ul>\n+ * </ul></p>\n  *\n  * @version $Revision$ $Date$\n  */\n     }\n \n     /**\n+     * {@inheritDoc}<p>\n      * <strong>Algorithm Description:</strong> hex strings are generated\n      * using a 2-step process. <ol>\n      * <li>\n      * len/2+1 binary bytes are generated using the underlying Random</li>\n      * <li>\n-     * Each binary byte is translated into 2 hex digits</li></ol>\n+     * Each binary byte is translated into 2 hex digits</li></ol></p>\n+     * \n      * @param len the desired string length.\n      * @return the random string.\n      */\n     }\n \n      /**\n+     * {@inheritDoc}<p>\n      * <strong>Algorithm Description:</strong> hex strings are generated in\n      * 40-byte segments using a 3-step process. <ol>\n      * <li>\n      * SHA-1 hash is applied to yield a 20-byte binary digest.</li>\n      * <li>\n      * Each byte of the binary digest is converted to 2 hex digits.</li></ol>\n+     * </p>\n      *\n      * @param len the length of the generated string\n      * @return the random string\n     }\n \n     /**\n-     * Generates a random long value from the Poisson distribution with the\n-     * given mean.\n+     * {@inheritDoc}\n      * <p>\n      * <strong>Algorithm Description</strong>:\n      * Uses simulation of a Poisson process using Uniform deviates, as\n      * described\n      * <a href=\"http://irmi.epfl.ch/cmos/Pmmi/interactive/rng7.htm\">\n-     * here.</a>\n+     * here.</a></p>\n      * <p>\n      * The Poisson process (and hence value returned) is bounded by \n-     * 1000 * mean.\n+     * 1000 * mean.</p>\n      * \n      * @param mean mean of the Poisson distribution.\n      * @return the random Poisson value.\n      * <strong>Algorithm Description</strong>:  Uses the\n      * <a href=\"http://www.jesus.ox.ac.uk/~clifford/a5/chap1/node5.html\">\n      * Inversion Method</a> to generate exponentially distributed random values\n-     * from uniform deviates.\n+     * from uniform deviates.</p>\n      * \n      * @param mean the mean of the distribution\n      * @return the random Exponential value\n     }\n \n     /**\n+     * {@inheritDoc}<p>\n      * <strong>Algorithm Description</strong>: scales the output of\n      * Random.nextDouble(), but rejects 0 values (i.e., will generate another\n      * random double if Random.nextDouble() returns 0).\n      * This is necessary to provide a symmetric output interval\n-     * (both endpoints excluded).\n+     * (both endpoints excluded).</p>\n      * \n      * @param lower the lower bound.\n      * @param upper the upper bound.\n      * Returns the RandomGenerator used to generate non-secure\n      * random data.\n      * <p>\n-     * Creates and initializes a default generator if null.\n+     * Creates and initializes a default generator if null.</p>\n      *\n      * @return the Random used to generate random data\n      * @since 1.1\n     /**\n      * Returns the SecureRandom used to generate secure random data.\n      * <p>\n-     * Creates and initializes if null.\n+     * Creates and initializes if null.</p>\n      *\n      * @return the SecureRandom used to generate secure random data\n      */\n     /**\n      * Reseeds the random number generator with the supplied seed.\n      * <p>\n-     * Will create and initialize if null.\n+     * Will create and initialize if null.</p>\n      *\n      * @param seed the seed value to use\n      */\n      * Reseeds the secure random number generator with the current time\n      * in milliseconds.\n      * <p>\n-     * Will create and initialize if null.\n+     * Will create and initialize if null.</p>\n      */\n     public void reSeedSecure() {\n         if (secRand == null) {\n     /**\n      * Reseeds the secure random number generator with the supplied seed.\n      * <p>\n-     * Will create and initialize if null.\n+     * Will create and initialize if null.</p>\n      *\n      * @param seed the seed value to use\n      */\n--- a/src/java/org/apache/commons/math/random/RandomVectorGenerator.java\n+++ b/src/java/org/apache/commons/math/random/RandomVectorGenerator.java\n package org.apache.commons.math.random;\n \n /** This interface represents a random generator for whole vectors.\n-\n+ * \n+ * @since 1.2\n  * @version $Revision$ $Date$\n-\n+ *\n  */\n \n public interface RandomVectorGenerator {\n--- a/src/java/org/apache/commons/math/random/UniformRandomGenerator.java\n+++ b/src/java/org/apache/commons/math/random/UniformRandomGenerator.java\n  * from a uniform distribution with mean equal to 0 and standard \n  * deviation equal to 1. Generated values fall in the range\n  * [-&#x0221A;3, +&#x0221A;3].</p>\n+ * \n+ * @since 1.2\n  * \n  * @version $Revision$ $Date$\n  */\n--- a/src/java/org/apache/commons/math/random/ValueServer.java\n+++ b/src/java/org/apache/commons/math/random/ValueServer.java\n  * Generates values for use in simulation applications.\n  * <p>\n  * How values are generated is determined by the <code>mode</code>\n- * property.\n+ * property.</p>\n  * <p>\n  * Supported <code>mode</code> values are: <ul>\n  * <li> DIGEST_MODE -- uses an empirical distribution </li>\n  * <li> GAUSSIAN_MODE -- generates Gaussian distributed random values with\n  *                       mean = <code>mu</code> and\n  *                       standard deviation = <code>sigma</code></li>\n- * <li> CONSTANT_MODE -- returns <code>mu</code> every time.</li></ul>\n+ * <li> CONSTANT_MODE -- returns <code>mu</code> every time.</li></ul></p>\n  *\n  * @version $Revision$ $Date$\n  *\n      * in <code>valuesFileURL</code>, using the default number of bins.\n      * <p>\n      * <code>valuesFileURL</code> must exist and be\n-     * readable by *this at runtime.\n+     * readable by *this at runtime.</p>\n      * <p>\n      * This method must be called before using <code>getNext()</code>\n-     * with <code>mode = DIGEST_MODE</code>\n+     * with <code>mode = DIGEST_MODE</code></p>\n      *\n      * @throws IOException if an I/O error occurs reading the input file\n      */\n      * Computes the empirical distribution using values from the file\n      * in <code>valuesFileURL</code> and <code>binCount</code> bins.\n      * <p>\n-     * <code>valuesFileURL</code> must exist and be\n-     * readable by *this at runtime.\n+     * <code>valuesFileURL</code> must exist and be readable by this process\n+     * at runtime.</p>\n      * <p>\n      * This method must be called before using <code>getNext()</code>\n-     * with <code>mode = DIGEST_MODE</code>\n+     * with <code>mode = DIGEST_MODE</code></p>\n      *\n      * @param binCount the number of bins used in computing the empirical\n      * distribution\n      * <strong>Preconditions</strong>: <ul>\n      * <li>Before this method is called, <code>computeDistribution()</code>\n      * must have completed successfully; otherwise an\n-     * <code>IllegalStateException</code> will be thrown</li></ul>\n+     * <code>IllegalStateException</code> will be thrown</li></ul></p>\n      *\n      * @return next random value from the empirical distribution digest\n      */", "timestamp": 1201500603, "metainfo": ""}