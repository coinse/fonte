{"sha": "b7c6f9c6616bf63d910b00796169b288c0af1b42", "log": "Patch contributed by Christian Winter (MATH-703).  ", "commit": "\n--- a/src/main/java/org/apache/commons/math/distribution/AbstractIntegerDistribution.java\n+++ b/src/main/java/org/apache/commons/math/distribution/AbstractIntegerDistribution.java\n import org.apache.commons.math.exception.OutOfRangeException;\n import org.apache.commons.math.exception.util.LocalizedFormats;\n import org.apache.commons.math.random.RandomDataImpl;\n-import org.apache.commons.math.util.FastMath;\n-\n \n /**\n  * Base class for integer-valued discrete distributions.  Default\n  *\n  * @version $Id$\n  */\n-public abstract class AbstractIntegerDistribution extends AbstractDistribution\n-    implements IntegerDistribution, Serializable {\n-   /** Serializable version identifier */\n+public abstract class AbstractIntegerDistribution\n+implements IntegerDistribution, Serializable {\n+    /** Serializable version identifier */\n     private static final long serialVersionUID = -1146319659338487221L;\n+\n     /**\n      * RandomData instance used to generate samples from the distribution.\n-     * @since 2.2\n      */\n     protected final RandomDataImpl randomData = new RandomDataImpl();\n \n-    /**\n-     * Default constructor.\n-     */\n+    /** Default constructor. */\n     protected AbstractIntegerDistribution() {}\n \n     /**\n-     * For a random variable {@code X} whose values are distributed according\n-     * to this distribution, this method returns {@code P(X <= x)}.  In other\n-     * words, this method represents the (cumulative) distribution function,\n-     * or CDF, for this distribution.\n-     * If {@code x} does not represent an integer value, the CDF is\n-     * evaluated at the greatest integer less than {@code x}.\n-     *\n-     * @param x Value at which the distribution function is evaluated.\n-     * @return the cumulative probability that a random variable with this\n-     * distribution takes a value less than or equal to {@code x}.\n-     */\n-    public double cumulativeProbability(double x) {\n-        return cumulativeProbability((int) FastMath.floor(x));\n-    }\n-\n-    /**\n-     * For a random variable {@code X} whose values are distributed\n-     * according to this distribution, this method returns\n-     * {@code P(x0 <= X <= x1)}.\n-     *\n-     * @param x0 Inclusive lower bound.\n-     * @param x1 Inclusive upper bound.\n-     * @return the probability that a random variable with this distribution\n-     * will take a value between {@code x0} and {@code x1},\n-     * including the endpoints.\n-     * @throws NumberIsTooSmallException if {@code x1 > x0}.\n-     */\n-    @Override\n-    public double cumulativeProbability(double x0, double x1) {\n-        if (x1 < x0) {\n-            throw new NumberIsTooSmallException(LocalizedFormats.LOWER_ENDPOINT_ABOVE_UPPER_ENDPOINT,\n-                                                x1, x0, true);\n-        }\n-        if (FastMath.floor(x0) < x0) {\n-            return cumulativeProbability(((int) FastMath.floor(x0)) + 1,\n-               (int) FastMath.floor(x1)); // don't want to count mass below x0\n-        } else { // x0 is mathematical integer, so use as is\n-            return cumulativeProbability((int) FastMath.floor(x0),\n-                (int) FastMath.floor(x1));\n-        }\n-    }\n-\n-    /**\n-     * For a random variable {@code X} whose values are distributed according\n-     * to this distribution, this method returns {@code P(X <= x)}. In other\n-     * words, this method represents the probability distribution function,\n-     * or PDF, for this distribution.\n-     *\n-     * @param x Value at which the PDF is evaluated.\n-     * @return PDF for this distribution.\n-     */\n-    public abstract double cumulativeProbability(int x);\n-\n-    /**\n-     * For a random variable {@code X} whose values are distributed according\n-     * to this distribution, this method returns {@code P(X = x)}. In other\n-     * words, this method represents the probability mass function, or PMF,\n-     * for the distribution.\n-     * If {@code x} does not represent an integer value, 0 is returned.\n-     *\n-     * @param x Value at which the probability density function is evaluated.\n-     * @return the value of the probability density function at {@code x}.\n-     */\n-    public double probability(double x) {\n-        double fl = FastMath.floor(x);\n-        if (fl == x) {\n-            return this.probability((int) x);\n-        } else {\n-            return 0;\n-        }\n-    }\n-\n-    /**\n-     * For a random variable {@code X} whose values are distributed according\n-     * to this distribution, this method returns {@code P(x0 < X < x1)}.\n-     *\n-     * @param x0 Inclusive lower bound.\n-     * @param x1 Inclusive upper bound.\n-     * @return the cumulative probability.\n-     * @throws NumberIsTooSmallException {@code if x0 > x1}.\n+     * {@inheritDoc}\n+     * \n+     * The default implementation uses the identity\n+     * <p>{@code P(x0 <= X <= x1) = P(X <= x1) - P(X <= x0 - 1)}</p>\n      */\n     public double cumulativeProbability(int x0, int x1) {\n         if (x1 < x0) {\n-            throw new NumberIsTooSmallException(LocalizedFormats.LOWER_ENDPOINT_ABOVE_UPPER_ENDPOINT,\n-                                                x1, x0, true);\n+            throw new NumberIsTooSmallException(\n+                    LocalizedFormats.LOWER_ENDPOINT_ABOVE_UPPER_ENDPOINT,\n+                    x1, x0, true);\n         }\n         return cumulativeProbability(x1) - cumulativeProbability(x0 - 1);\n     }\n \n-    /**\n-     * For a random variable {@code X} whose values are distributed according\n-     * to this distribution, this method returns the largest {@code x}, such\n-     * that {@code P(X <= x) <= p}.\n-     *\n-     * @param p Desired probability.\n-     * @return the largest {@code x} such that {@code P(X < x) <= p}.\n-     * @throws OutOfRangeException if {@code p < 0} or {@code p > 1}.\n-     */\n+    /** {@inheritDoc} */\n     public int inverseCumulativeProbability(final double p) {\n         if (p < 0 || p > 1) {\n             throw new OutOfRangeException(p, 0, 1);\n     }\n \n     /**\n-     * {@inheritDoc}\n+     * Access the domain value lower bound, based on {@code p}, used to\n+     * bracket a CDF root. This method is used by\n+     * {@link #inverseCumulativeProbability(double)} to find critical values.\n+     *\n+     * @param p the desired probability for the critical value ({@code 0 < p < 1})\n+     * @return a domain value lower bound, i.e. a value {@code x} such that\n+     * {@code P(X <= x) < p}\n      */\n+    protected abstract int getDomainLowerBound(double p);\n+\n+    /**\n+     * Access the domain value upper bound, based on {@code p}, used to\n+     * bracket a CDF root. This method is used by\n+     * {@link #inverseCumulativeProbability(double)} to find critical values.\n+     *\n+     * @param p the desired probability for the critical value ({@code 0 < p < 1})\n+     * @return a domain value upper bound, i.e. a value {@code x} such that\n+     * {@code P(X <= x) >= p}\n+     */\n+    protected abstract int getDomainUpperBound(double p);\n+\n+    /** {@inheritDoc} */\n     public void reseedRandomGenerator(long seed) {\n         randomData.reSeed(seed);\n     }\n \n     /**\n-     * Generates a random value sampled from this distribution. The default\n-     * implementation uses the\n+     * {@inheritDoc}\n+     * \n+     * The default implementation uses the\n      * <a href=\"http://en.wikipedia.org/wiki/Inverse_transform_sampling\">\n-     *  inversion method.\n-     * </a>\n-     *\n-     * @return a random value.\n-     * @since 2.2\n+     * inversion method</a>.\n      */\n     public int sample() {\n         return randomData.nextInversionDeviate(this);\n     }\n \n     /**\n-     * Generates a random sample from the distribution.  The default\n-     * implementation generates the sample by calling {@link #sample()}\n-     * in a loop.\n-     *\n-     * @param sampleSize number of random values to generate.\n-     * @since 2.2\n-     * @return an array representing the random sample.\n-     * @throws NotStrictlyPositiveException if {@code sampleSize <= 0}.\n+     * {@inheritDoc}\n+     * \n+     * The default implementation generates the sample by calling\n+     * {@link #sample()} in a loop.\n      */\n     public int[] sample(int sampleSize) {\n         if (sampleSize <= 0) {\n-            throw new NotStrictlyPositiveException(LocalizedFormats.NUMBER_OF_SAMPLES,\n-                                                   sampleSize);\n+            throw new NotStrictlyPositiveException(\n+                    LocalizedFormats.NUMBER_OF_SAMPLES, sampleSize);\n         }\n         int[] out = new int[sampleSize];\n         for (int i = 0; i < sampleSize; i++) {\n     }\n \n     /**\n-     * Computes the cumulative probability function and checks for NaN\n-     * values returned.\n-     * Throws MathInternalError if the value is NaN. Rethrows any Exception encountered\n-     * evaluating the cumulative probability function. Throws\n-     * MathInternalError if the cumulative probability function returns NaN.\n+     * Computes the cumulative probability function and checks for {@code NaN}\n+     * values returned. Throws {@code MathInternalError} if the value is\n+     * {@code NaN}. Rethrows any exception encountered evaluating the cumulative\n+     * probability function. Throws {@code MathInternalError} if the cumulative\n+     * probability function returns {@code NaN}.\n      *\n-     * @param argument Input value.\n-     * @return the cumulative probability.\n-     * @throws MathInternalError if the cumulative probability is NaN\n+     * @param argument input value\n+     * @return the cumulative probability\n+     * @throws MathInternalError if the cumulative probability is {@code NaN}\n      */\n     private double checkedCumulativeProbability(int argument)\n         throws MathInternalError {\n         double result = Double.NaN;\n-            result = cumulativeProbability(argument);\n+        result = cumulativeProbability(argument);\n         if (Double.isNaN(result)) {\n-            throw new MathInternalError(\n-                    LocalizedFormats.DISCRETE_CUMULATIVE_PROBABILITY_RETURNED_NAN, argument);\n+            throw new MathInternalError(LocalizedFormats\n+                    .DISCRETE_CUMULATIVE_PROBABILITY_RETURNED_NAN, argument);\n         }\n         return result;\n     }\n-\n-    /**\n-     * Access the domain value lower bound, based on {@code p}, used to\n-     * bracket a PDF root.  This method is used by\n-     * {@link #inverseCumulativeProbability(double)} to find critical values.\n-     *\n-     * @param p Desired probability for the critical value\n-     * @return the domain value lower bound, i.e. {@code P(X < 'lower bound') < p}.\n-     */\n-    protected abstract int getDomainLowerBound(double p);\n-\n-    /**\n-     * Access the domain value upper bound, based on {@code p}, used to\n-     * bracket a PDF root.  This method is used by\n-     * {@link #inverseCumulativeProbability(double)} to find critical values.\n-     *\n-     * @param p Desired probability for the critical value.\n-     * @return the domain value upper bound, i.e. {@code P(X < 'upper bound') > p}.\n-     */\n-    protected abstract int getDomainUpperBound(double p);\n-\n-    /**\n-     * Access the lower bound of the support.\n-     *\n-     * @return lower bound of the support (Integer.MIN_VALUE for negative infinity)\n-     */\n-    public abstract int getSupportLowerBound();\n-\n-    /**\n-     * Access the upper bound of the support.\n-     *\n-     * @return upper bound of the support (Integer.MAX_VALUE for positive infinity)\n-     */\n-    public abstract int getSupportUpperBound();\n-\n-    /**\n-     * Use this method to get information about whether the lower bound\n-     * of the support is inclusive or not. For discrete support,\n-     * only true here is meaningful.\n-     *\n-     * @return true (always but at Integer.MIN_VALUE because of the nature of discrete support)\n-     */\n-    @Override\n-    public boolean isSupportLowerBoundInclusive() {\n-        return true;\n-    }\n-\n-    /**\n-     * Use this method to get information about whether the upper bound\n-     * of the support is inclusive or not. For discrete support,\n-     * only true here is meaningful.\n-     *\n-     * @return true (always but at Integer.MAX_VALUE because of the nature of discrete support)\n-     */\n-    @Override\n-    public boolean isSupportUpperBoundInclusive() {\n-        return true;\n-    }\n }\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/distribution/AbstractRealDistribution.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.distribution;\n+\n+import java.io.Serializable;\n+\n+import org.apache.commons.math.analysis.UnivariateFunction;\n+import org.apache.commons.math.analysis.solvers.UnivariateRealSolverUtils;\n+import org.apache.commons.math.exception.MathInternalError;\n+import org.apache.commons.math.exception.NotStrictlyPositiveException;\n+import org.apache.commons.math.exception.NumberIsTooLargeException;\n+import org.apache.commons.math.exception.OutOfRangeException;\n+import org.apache.commons.math.exception.util.LocalizedFormats;\n+import org.apache.commons.math.random.RandomDataImpl;\n+import org.apache.commons.math.util.FastMath;\n+\n+/**\n+ * Base class for probability distributions on the reals.\n+ * Default implementations are provided for some of the methods\n+ * that do not vary from distribution to distribution.\n+ *\n+ * @version $Id$\n+ * @since 3.0\n+ */\n+public abstract class AbstractRealDistribution\n+implements RealDistribution, Serializable {\n+    /** Serializable version identifier */\n+    private static final long serialVersionUID = -38038050983108802L;\n+\n+    /** Default accuracy. */\n+    public static final double SOLVER_DEFAULT_ABSOLUTE_ACCURACY = 1e-6;\n+\n+    /** Solver absolute accuracy for inverse cumulative computation */\n+    private double solverAbsoluteAccuracy = SOLVER_DEFAULT_ABSOLUTE_ACCURACY;\n+\n+    /** RandomData instance used to generate samples from the distribution. */\n+    protected final RandomDataImpl randomData = new RandomDataImpl();\n+\n+    /** Default constructor. */\n+    protected AbstractRealDistribution() {}\n+\n+    /**\n+     * {@inheritDoc}\n+     *\n+     * The default implementation uses the identity\n+     * <p>{@code P(x0 < X <= x1) = P(X <= x1) - P(X <= x0)}</p>\n+     */\n+    public double cumulativeProbability(double x0, double x1) throws NumberIsTooLargeException {\n+        if (x0 > x1) {\n+            throw new NumberIsTooLargeException(LocalizedFormats.LOWER_ENDPOINT_ABOVE_UPPER_ENDPOINT,\n+                    x0, x1, true);\n+        }\n+        return cumulativeProbability(x1) - cumulativeProbability(x0);\n+    }\n+\n+    /** {@inheritDoc} */\n+    public double inverseCumulativeProbability(final double p) throws OutOfRangeException {\n+\n+        if (p < 0.0 || p > 1.0) {\n+            throw new OutOfRangeException(p, 0, 1);\n+        }\n+\n+        // by default, do simple root finding using bracketing and default solver.\n+        // subclasses can override if there is a better method.\n+        UnivariateFunction rootFindingFunction =\n+            new UnivariateFunction() {\n+            public double value(double x) {\n+                return cumulativeProbability(x) - p;\n+            }\n+        };\n+\n+        // Try to bracket root, test domain endpoints if this fails\n+        double lowerBound = getDomainLowerBound(p);\n+        double upperBound = getDomainUpperBound(p);\n+        double[] bracket = null;\n+        try {\n+            bracket = UnivariateRealSolverUtils.bracket(\n+                    rootFindingFunction, getInitialDomain(p),\n+                    lowerBound, upperBound);\n+        } catch (NumberIsTooLargeException ex) {\n+            /*\n+             * Check domain endpoints to see if one gives value that is within\n+             * the default solver's defaultAbsoluteAccuracy of 0 (will be the\n+             * case if density has bounded support and p is 0 or 1).\n+             */\n+            if (FastMath.abs(rootFindingFunction.value(lowerBound)) < getSolverAbsoluteAccuracy()) {\n+                return lowerBound;\n+            }\n+            if (FastMath.abs(rootFindingFunction.value(upperBound)) < getSolverAbsoluteAccuracy()) {\n+                return upperBound;\n+            }\n+            // Failed bracket convergence was not because of corner solution\n+            throw new MathInternalError(ex);\n+        }\n+\n+        // find root\n+        double root = UnivariateRealSolverUtils.solve(rootFindingFunction,\n+                // override getSolverAbsoluteAccuracy() to use a Brent solver with\n+                // absolute accuracy different from the default.\n+                bracket[0],bracket[1], getSolverAbsoluteAccuracy());\n+        return root;\n+    }\n+\n+    /**\n+     * Access the initial domain value, based on {@code p}, used to\n+     * bracket a CDF root.  This method is used by\n+     * {@link #inverseCumulativeProbability(double)} to find critical values.\n+     *\n+     * @param p Desired probability for the critical value.\n+     * @return the initial domain value.\n+     * TODO to be deleted when applying MATH-699\n+     */\n+    protected abstract double getInitialDomain(double p);\n+\n+    /**\n+     * Access the domain value lower bound, based on {@code p}, used to\n+     * bracket a CDF root.  This method is used by\n+     * {@link #inverseCumulativeProbability(double)} to find critical values.\n+     *\n+     * @param p Desired probability for the critical value.\n+     * @return the domain value lower bound, i.e. {@code P(X < 'lower bound') < p}.\n+     * TODO to be deleted when applying MATH-699\n+     */\n+    protected abstract double getDomainLowerBound(double p);\n+\n+    /**\n+     * Access the domain value upper bound, based on {@code p}, used to\n+     * bracket a CDF root.  This method is used by\n+     * {@link #inverseCumulativeProbability(double)} to find critical values.\n+     *\n+     * @param p Desired probability for the critical value.\n+     * @return the domain value upper bound, i.e. {@code P(X < 'upper bound') > p}.\n+     * TODO to be deleted when applying MATH-699\n+     */\n+    protected abstract double getDomainUpperBound(double p);\n+\n+    /**\n+     * Returns the solver absolute accuracy for inverse cumulative computation.\n+     * You can override this method in order to use a Brent solver with an\n+     * absolute accuracy different from the default.\n+     *\n+     * @return the maximum absolute error in inverse cumulative probability estimates\n+     */\n+    protected double getSolverAbsoluteAccuracy() {\n+        return solverAbsoluteAccuracy;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public void reseedRandomGenerator(long seed) {\n+        randomData.reSeed(seed);\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     * \n+     * The default implementation uses the\n+     * <a href=\"http://en.wikipedia.org/wiki/Inverse_transform_sampling\">\n+     * inversion method.\n+     * </a>\n+     */\n+    public double sample() {\n+        return randomData.nextInversionDeviate(this);\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     * \n+     * The default implementation generates the sample by calling\n+     * {@link #sample()} in a loop.\n+     */\n+    public double[] sample(int sampleSize) {\n+        if (sampleSize <= 0) {\n+            throw new NotStrictlyPositiveException(LocalizedFormats.NUMBER_OF_SAMPLES,\n+                    sampleSize);\n+        }\n+        double[] out = new double[sampleSize];\n+        for (int i = 0; i < sampleSize; i++) {\n+            out[i] = sample();\n+        }\n+        return out;\n+    }\n+}\n--- a/src/main/java/org/apache/commons/math/distribution/BetaDistribution.java\n+++ b/src/main/java/org/apache/commons/math/distribution/BetaDistribution.java\n  * @version $Id$\n  * @since 2.0 (changed to concrete class in 3.0)\n  */\n-public class BetaDistribution extends AbstractContinuousDistribution {\n+public class BetaDistribution extends AbstractRealDistribution {\n     /**\n      * Default inverse cumulative probability accuracy.\n      * @since 2.1\n         }\n     }\n \n+    /**\n+     * {@inheritDoc}\n+     *\n+     * For this distribution {@code P(X = x)} always evaluates to 0.\n+     *\n+     * @return 0\n+     */\n+    public double probability(double x) {\n+        return 0.0;\n+    }\n+\n     /** {@inheritDoc} */\n     public double density(double x) {\n         recomputeZ();\n     /**\n      * {@inheritDoc}\n      *\n-     * The lower bound of the support is always 0 no matter the parameters.\n-     *\n-     * @return lower bound of the support (always 0)\n-     */\n-    @Override\n-    public double getSupportLowerBound() {\n-        return 0;\n-    }\n-\n-    /**\n-     * {@inheritDoc}\n-     *\n-     * The upper bound of the support is always 1 no matter the parameters.\n-     *\n-     * @return upper bound of the support (always 1)\n-     */\n-    @Override\n-    public double getSupportUpperBound() {\n-        return 1;\n-    }\n-\n-    /**\n-     * {@inheritDoc}\n-     *\n-     * For first shape parameter {@code alpha} and second shape parameter {@code beta}, the\n-     * mean is {@code alpha / (alpha + beta)}.\n-     */\n-    @Override\n-    protected double calculateNumericalMean() {\n+     * For first shape parameter {@code alpha} and second shape parameter\n+     * {@code beta}, the mean is {@code alpha / (alpha + beta)}.\n+     */\n+    public double getNumericalMean() {\n         final double a = getAlpha();\n         return a / (a + getBeta());\n     }\n      * {@code beta}, the variance is\n      * {@code (alpha * beta) / [(alpha + beta)^2 * (alpha + beta + 1)]}.\n      */\n-    @Override\n-    protected double calculateNumericalVariance() {\n+    public double getNumericalVariance() {\n         final double a = getAlpha();\n         final double b = getBeta();\n         final double alphabetasum = a + b;\n         return (a * b) / ((alphabetasum * alphabetasum) * (alphabetasum + 1));\n     }\n \n-    /** {@inheritDoc} */\n-    @Override\n+    /**\n+     * {@inheritDoc}\n+     *\n+     * The lower bound of the support is always 0 no matter the parameters.\n+     *\n+     * @return lower bound of the support (always 0)\n+     */\n+    public double getSupportLowerBound() {\n+        return 0;\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     *\n+     * The upper bound of the support is always 1 no matter the parameters.\n+     *\n+     * @return upper bound of the support (always 1)\n+     */\n+    public double getSupportUpperBound() {\n+        return 1;\n+    }\n+\n+    /** {@inheritDoc} */\n     public boolean isSupportLowerBoundInclusive() {\n         return false;\n     }\n \n     /** {@inheritDoc} */\n-    @Override\n     public boolean isSupportUpperBoundInclusive() {\n         return false;\n     }\n+\n+    /**\n+     * {@inheritDoc}\n+     * \n+     * The support of this distribution is connected.\n+     * \n+     * @return {@code true}\n+     */\n+    public boolean isSupportConnected() {\n+        return true;\n+    }\n }\n--- a/src/main/java/org/apache/commons/math/distribution/BinomialDistribution.java\n+++ b/src/main/java/org/apache/commons/math/distribution/BinomialDistribution.java\n  */\n package org.apache.commons.math.distribution;\n \n-import java.io.Serializable;\n-\n import org.apache.commons.math.exception.OutOfRangeException;\n import org.apache.commons.math.exception.NotPositiveException;\n import org.apache.commons.math.exception.util.LocalizedFormats;\n  * @see <a href=\"http://mathworld.wolfram.com/BinomialDistribution.html\">Binomial Distribution (MathWorld)</a>\n  * @version $Id$\n  */\n-public class BinomialDistribution extends AbstractIntegerDistribution\n-        implements Serializable {\n+public class BinomialDistribution extends AbstractIntegerDistribution {\n     /** Serializable version identifier. */\n     private static final long serialVersionUID = 6751309484392813623L;\n     /** The number of trials. */\n     }\n \n     /** {@inheritDoc} */\n-    @Override\n-    protected int getDomainLowerBound(double p) {\n-        return -1;\n+    public double probability(int x) {\n+        double ret;\n+        if (x < 0 || x > numberOfTrials) {\n+            ret = 0.0;\n+        } else {\n+            ret = FastMath.exp(SaddlePointExpansion.logBinomialProbability(x,\n+                    numberOfTrials, probabilityOfSuccess,\n+                    1.0 - probabilityOfSuccess));\n+        }\n+        return ret;\n     }\n \n     /** {@inheritDoc} */\n-    @Override\n-    protected int getDomainUpperBound(double p) {\n-        return numberOfTrials;\n-    }\n-\n-    /** {@inheritDoc} */\n-    @Override\n     public double cumulativeProbability(int x) {\n         double ret;\n         if (x < 0) {\n         } else {\n             ret = 1.0 - Beta.regularizedBeta(getProbabilityOfSuccess(),\n                     x + 1.0, numberOfTrials - x);\n-        }\n-        return ret;\n-    }\n-\n-    /** {@inheritDoc} */\n-    public double probability(int x) {\n-        double ret;\n-        if (x < 0 || x > numberOfTrials) {\n-            ret = 0.0;\n-        } else {\n-            ret = FastMath.exp(SaddlePointExpansion.logBinomialProbability(x,\n-                    numberOfTrials, probabilityOfSuccess,\n-                    1.0 - probabilityOfSuccess));\n         }\n         return ret;\n     }\n         return super.inverseCumulativeProbability(p);\n     }\n \n+    /** {@inheritDoc} */\n+    @Override\n+    protected int getDomainLowerBound(double p) {\n+        return -1;\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    protected int getDomainUpperBound(double p) {\n+        return numberOfTrials;\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     *\n+     * For {@code n} trials and probability parameter {@code p}, the mean is\n+     * {@code n * p}.\n+     */\n+    public double getNumericalMean() {\n+        return getNumberOfTrials() * getProbabilityOfSuccess();\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     *\n+     * For {@code n} trials and probability parameter {@code p}, the variance is\n+     * {@code n * p * (1 - p)}.\n+     */\n+    public double getNumericalVariance() {\n+        final double p = getProbabilityOfSuccess();\n+        return getNumberOfTrials() * p * (1 - p);\n+    }\n+\n     /**\n      * {@inheritDoc}\n      *\n      *\n      * @return lower bound of the support (always 0)\n      */\n-    @Override\n     public int getSupportLowerBound() {\n         return 0;\n     }\n      *\n      * @return upper bound of the support (equal to number of trials)\n      */\n-    @Override\n     public int getSupportUpperBound() {\n         return getNumberOfTrials();\n     }\n \n     /**\n      * {@inheritDoc}\n-     *\n-     * For {@code n} trials and probability parameter {@code p}, the mean is\n-     * {@code n * p}.\n+     * \n+     * The support of this distribution is connected.\n+     * \n+     * @return {@code true}\n      */\n-    @Override\n-    protected double calculateNumericalMean() {\n-        return getNumberOfTrials() * getProbabilityOfSuccess();\n-    }\n-\n-    /**\n-     * {@inheritDoc}\n-     *\n-     * For {@code n} trials and probability parameter {@code p}, the variance is\n-     * {@code n * p * (1 - p)}.\n-     */\n-    @Override\n-    protected double calculateNumericalVariance() {\n-        final double p = getProbabilityOfSuccess();\n-        return getNumberOfTrials() * p * (1 - p);\n+    public boolean isSupportConnected() {\n+        return true;\n     }\n }\n--- a/src/main/java/org/apache/commons/math/distribution/CauchyDistribution.java\n+++ b/src/main/java/org/apache/commons/math/distribution/CauchyDistribution.java\n  * See the License for the specific language governing permissions and\n  * limitations under the License.\n  */\n-\n package org.apache.commons.math.distribution;\n-\n-import java.io.Serializable;\n \n import org.apache.commons.math.exception.NotStrictlyPositiveException;\n import org.apache.commons.math.exception.OutOfRangeException;\n  * @since 1.1 (changed to concrete class in 3.0)\n  * @version $Id$\n  */\n-public class CauchyDistribution extends AbstractContinuousDistribution\n-    implements Serializable {\n+public class CauchyDistribution extends AbstractRealDistribution {\n     /**\n      * Default inverse cumulative probability accuracy.\n      * @since 2.1\n         return scale;\n     }\n \n+    /**\n+     * {@inheritDoc}\n+     *\n+     * For this distribution {@code P(X = x)} always evaluates to 0.\n+     *\n+     * @return 0\n+     */\n+    public double probability(double x) {\n+        return 0.0;\n+    }\n+\n     /** {@inheritDoc} */\n     public double density(double x) {\n         final double dev = x - median;\n     /**\n      * {@inheritDoc}\n      *\n+     * The mean is always undefined no matter the parameters.\n+     *\n+     * @return mean (always Double.NaN)\n+     */\n+    public double getNumericalMean() {\n+        return Double.NaN;\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     *\n+     * The variance is always undefined no matter the parameters.\n+     *\n+     * @return variance (always Double.NaN)\n+     */\n+    public double getNumericalVariance() {\n+        return Double.NaN;\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     *\n      * The lower bound of the support is always negative infinity no matter\n      * the parameters.\n      *\n      * @return lower bound of the support (always Double.NEGATIVE_INFINITY)\n      */\n-    @Override\n     public double getSupportLowerBound() {\n         return Double.NEGATIVE_INFINITY;\n     }\n      *\n      * @return upper bound of the support (always Double.POSITIVE_INFINITY)\n      */\n-    @Override\n     public double getSupportUpperBound() {\n         return Double.POSITIVE_INFINITY;\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     *\n-     * The mean is always undefined no matter the parameters.\n-     *\n-     * @return mean (always Double.NaN)\n-     */\n-    @Override\n-    protected double calculateNumericalMean() {\n-        return Double.NaN;\n-    }\n-\n-    /**\n-     * {@inheritDoc}\n-     *\n-     * The variance is always undefined no matter the parameters.\n-     *\n-     * @return variance (always Double.NaN)\n-     */\n-    @Override\n-    protected double calculateNumericalVariance() {\n-        return Double.NaN;\n-    }\n-\n-    /** {@inheritDoc} */\n-    @Override\n+    /** {@inheritDoc} */\n     public boolean isSupportLowerBoundInclusive() {\n         return false;\n     }\n \n     /** {@inheritDoc} */\n-    @Override\n     public boolean isSupportUpperBoundInclusive() {\n         return false;\n     }\n+\n+    /**\n+     * {@inheritDoc}\n+     * \n+     * The support of this distribution is connected.\n+     * \n+     * @return {@code true}\n+     */\n+    public boolean isSupportConnected() {\n+        return true;\n+    }\n }\n--- a/src/main/java/org/apache/commons/math/distribution/ChiSquaredDistribution.java\n+++ b/src/main/java/org/apache/commons/math/distribution/ChiSquaredDistribution.java\n-/*\n- * Licensed to the Apache Software Foundation (ASF) under one or more\n- * contributor license agreements.  See the NOTICE file distributed with\n- * this work for additional information regarding copyright ownership.\n- * The ASF licenses this file to You under the Apache License, Version 2.0\n- * (the \"License\"); you may not use this file except in compliance with\n- * the License.  You may obtain a copy of the License at\n- *\n- *      http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-package org.apache.commons.math.distribution;\n-\n-import java.io.Serializable;\n-\n-\n-/**\n- * Implementation of the chi-squared distribution.\n- *\n- * @see <a href=\"http://en.wikipedia.org/wiki/Chi-squared_distribution\">Chi-squared distribution (Wikipedia)</a>\n- * @see <a href=\"http://mathworld.wolfram.com/Chi-SquaredDistribution.html\">Chi-squared Distribution (MathWorld)</a>\n- * @version $Id: ChiSquaredDistribution.java 1206060 2011-11-25 05:16:56Z celestin $\n- */\n-public class ChiSquaredDistribution\n-    extends AbstractContinuousDistribution\n-    implements Serializable {\n-    /**\n-     * Default inverse cumulative probability accuracy\n-     * @since 2.1\n-     */\n-    public static final double DEFAULT_INVERSE_ABSOLUTE_ACCURACY = 1e-9;\n-    /** Serializable version identifier */\n-    private static final long serialVersionUID = -8352658048349159782L;\n-    /** Internal Gamma distribution. */\n-    private final GammaDistribution gamma;\n-    /** Inverse cumulative probability accuracy */\n-    private final double solverAbsoluteAccuracy;\n-\n-    /**\n-     * Create a Chi-Squared distribution with the given degrees of freedom.\n-     *\n-     * @param degreesOfFreedom Degrees of freedom.\n-     */\n-    public ChiSquaredDistribution(double degreesOfFreedom) {\n-        this(degreesOfFreedom, DEFAULT_INVERSE_ABSOLUTE_ACCURACY);\n-    }\n-\n-    /**\n-     * Create a Chi-Squared distribution with the given degrees of freedom and\n-     * inverse cumulative probability accuracy.\n-     *\n-     * @param degreesOfFreedom Degrees of freedom.\n-     * @param inverseCumAccuracy the maximum absolute error in inverse\n-     * cumulative probability estimates (defaults to\n-     * {@link #DEFAULT_INVERSE_ABSOLUTE_ACCURACY}).\n-     * @since 2.1\n-     */\n-    public ChiSquaredDistribution(double degreesOfFreedom,\n-                                      double inverseCumAccuracy) {\n-        gamma = new GammaDistribution(degreesOfFreedom / 2, 2);\n-        solverAbsoluteAccuracy = inverseCumAccuracy;\n-    }\n-\n-    /**\n-     * Access the number of degrees of freedom.\n-     *\n-     * @return the degrees of freedom.\n-     */\n-    public double getDegreesOfFreedom() {\n-        return gamma.getAlpha() * 2.0;\n-    }\n-\n-    /** {@inheritDoc} */\n-    public double density(double x) {\n-        return gamma.density(x);\n-    }\n-\n-    /** {@inheritDoc} */\n-    public double cumulativeProbability(double x)  {\n-        return gamma.cumulativeProbability(x);\n-    }\n-\n-    /**\n-     * {@inheritDoc}\n-     *\n-     * Returns {@code 0} when {@code p == 0} and\n-     * {@code Double.POSITIVE_INFINITY} when {@code p == 1}.\n-     */\n-    @Override\n-    public double inverseCumulativeProbability(final double p) {\n-        if (p == 0) {\n-            return 0d;\n-        }\n-        if (p == 1) {\n-            return Double.POSITIVE_INFINITY;\n-        }\n-        return super.inverseCumulativeProbability(p);\n-    }\n-\n-    /** {@inheritDoc} */\n-    @Override\n-    protected double getDomainLowerBound(double p) {\n-        return Double.MIN_VALUE * gamma.getBeta();\n-    }\n-\n-    /** {@inheritDoc} */\n-    @Override\n-    protected double getDomainUpperBound(double p) {\n-        // NOTE: chi squared is skewed to the left\n-        // NOTE: therefore, P(X < &mu;) > .5\n-\n-        double ret;\n-\n-        if (p < .5) {\n-            // use mean\n-            ret = getDegreesOfFreedom();\n-        } else {\n-            // use max\n-            ret = Double.MAX_VALUE;\n-        }\n-\n-        return ret;\n-    }\n-\n-    /** {@inheritDoc} */\n-    @Override\n-    protected double getInitialDomain(double p) {\n-        // NOTE: chi squared is skewed to the left\n-        // NOTE: therefore, P(X < &mu;) > 0.5\n-\n-        double ret;\n-\n-        if (p < 0.5) {\n-            // use 1/2 mean\n-            ret = getDegreesOfFreedom() * 0.5;\n-        } else {\n-            // use mean\n-            ret = getDegreesOfFreedom();\n-        }\n-\n-        return ret;\n-    }\n-\n-    /** {@inheritDoc} */\n-    @Override\n-    protected double getSolverAbsoluteAccuracy() {\n-        return solverAbsoluteAccuracy;\n-    }\n-\n-    /**\n-     * {@inheritDoc}\n-     *\n-     * The lower bound of the support is always 0 no matter the\n-     * degrees of freedom.\n-     *\n-     * @return lower bound of the support (always 0)\n-     */\n-    @Override\n-    public double getSupportLowerBound() {\n-        return 0;\n-    }\n-\n-    /**\n-     * {@inheritDoc}\n-     *\n-     * The upper bound of the support is always positive infinity no matter the\n-     * degrees of freedom.\n-     *\n-     * @return upper bound of the support (always Double.POSITIVE_INFINITY)\n-     */\n-    @Override\n-    public double getSupportUpperBound() {\n-        return Double.POSITIVE_INFINITY;\n-    }\n-\n-    /**\n-     * {@inheritDoc}\n-     *\n-     * For {@code k} degrees of freedom, the mean is {@code k}.\n-     */\n-    @Override\n-    protected double calculateNumericalMean() {\n-        return getDegreesOfFreedom();\n-    }\n-\n-    /**\n-     * {@inheritDoc}\n-     *\n-     * For {@code k} degrees of freedom, the variance is {@code 2 * k}.\n-     *\n-     * @return {@inheritDoc}\n-     */\n-    @Override\n-    protected double calculateNumericalVariance() {\n-        return 2*getDegreesOfFreedom();\n-    }\n-\n-    /** {@inheritDoc} */\n-    @Override\n-    public boolean isSupportLowerBoundInclusive() {\n-        return true;\n-    }\n-\n-    /** {@inheritDoc} */\n-    @Override\n-    public boolean isSupportUpperBoundInclusive() {\n-        return false;\n-    }\n-}\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.distribution;\n+\n+/**\n+ * Implementation of the chi-squared distribution.\n+ *\n+ * @see <a href=\"http://en.wikipedia.org/wiki/Chi-squared_distribution\">Chi-squared distribution (Wikipedia)</a>\n+ * @see <a href=\"http://mathworld.wolfram.com/Chi-SquaredDistribution.html\">Chi-squared Distribution (MathWorld)</a>\n+ * @version $Id$\n+ */\n+public class ChiSquaredDistribution extends AbstractRealDistribution {\n+    /**\n+     * Default inverse cumulative probability accuracy\n+     * @since 2.1\n+     */\n+    public static final double DEFAULT_INVERSE_ABSOLUTE_ACCURACY = 1e-9;\n+    /** Serializable version identifier */\n+    private static final long serialVersionUID = -8352658048349159782L;\n+    /** Internal Gamma distribution. */\n+    private final GammaDistribution gamma;\n+    /** Inverse cumulative probability accuracy */\n+    private final double solverAbsoluteAccuracy;\n+\n+    /**\n+     * Create a Chi-Squared distribution with the given degrees of freedom.\n+     *\n+     * @param degreesOfFreedom Degrees of freedom.\n+     */\n+    public ChiSquaredDistribution(double degreesOfFreedom) {\n+        this(degreesOfFreedom, DEFAULT_INVERSE_ABSOLUTE_ACCURACY);\n+    }\n+\n+    /**\n+     * Create a Chi-Squared distribution with the given degrees of freedom and\n+     * inverse cumulative probability accuracy.\n+     *\n+     * @param degreesOfFreedom Degrees of freedom.\n+     * @param inverseCumAccuracy the maximum absolute error in inverse\n+     * cumulative probability estimates (defaults to\n+     * {@link #DEFAULT_INVERSE_ABSOLUTE_ACCURACY}).\n+     * @since 2.1\n+     */\n+    public ChiSquaredDistribution(double degreesOfFreedom,\n+                                      double inverseCumAccuracy) {\n+        gamma = new GammaDistribution(degreesOfFreedom / 2, 2);\n+        solverAbsoluteAccuracy = inverseCumAccuracy;\n+    }\n+\n+    /**\n+     * Access the number of degrees of freedom.\n+     *\n+     * @return the degrees of freedom.\n+     */\n+    public double getDegreesOfFreedom() {\n+        return gamma.getAlpha() * 2.0;\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     *\n+     * For this distribution {@code P(X = x)} always evaluates to 0.\n+     *\n+     * @return 0\n+     */\n+    public double probability(double x) {\n+        return 0.0;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public double density(double x) {\n+        return gamma.density(x);\n+    }\n+\n+    /** {@inheritDoc} */\n+    public double cumulativeProbability(double x)  {\n+        return gamma.cumulativeProbability(x);\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     *\n+     * Returns {@code 0} when {@code p == 0} and\n+     * {@code Double.POSITIVE_INFINITY} when {@code p == 1}.\n+     */\n+    @Override\n+    public double inverseCumulativeProbability(final double p) {\n+        if (p == 0) {\n+            return 0d;\n+        }\n+        if (p == 1) {\n+            return Double.POSITIVE_INFINITY;\n+        }\n+        return super.inverseCumulativeProbability(p);\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    protected double getDomainLowerBound(double p) {\n+        return Double.MIN_VALUE * gamma.getBeta();\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    protected double getDomainUpperBound(double p) {\n+        // NOTE: chi squared is skewed to the left\n+        // NOTE: therefore, P(X < &mu;) > .5\n+\n+        double ret;\n+\n+        if (p < .5) {\n+            // use mean\n+            ret = getDegreesOfFreedom();\n+        } else {\n+            // use max\n+            ret = Double.MAX_VALUE;\n+        }\n+\n+        return ret;\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    protected double getInitialDomain(double p) {\n+        // NOTE: chi squared is skewed to the left\n+        // NOTE: therefore, P(X < &mu;) > 0.5\n+\n+        double ret;\n+\n+        if (p < 0.5) {\n+            // use 1/2 mean\n+            ret = getDegreesOfFreedom() * 0.5;\n+        } else {\n+            // use mean\n+            ret = getDegreesOfFreedom();\n+        }\n+\n+        return ret;\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    protected double getSolverAbsoluteAccuracy() {\n+        return solverAbsoluteAccuracy;\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     *\n+     * For {@code k} degrees of freedom, the mean is {@code k}.\n+     */\n+    public double getNumericalMean() {\n+        return getDegreesOfFreedom();\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     *\n+     * For {@code k} degrees of freedom, the variance is {@code 2 * k}.\n+     *\n+     * @return {@inheritDoc}\n+     */\n+    public double getNumericalVariance() {\n+        return 2*getDegreesOfFreedom();\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     *\n+     * The lower bound of the support is always 0 no matter the\n+     * degrees of freedom.\n+     *\n+     * @return lower bound of the support (always 0)\n+     */\n+    public double getSupportLowerBound() {\n+        return 0;\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     *\n+     * The upper bound of the support is always positive infinity no matter the\n+     * degrees of freedom.\n+     *\n+     * @return upper bound of the support (always Double.POSITIVE_INFINITY)\n+     */\n+    public double getSupportUpperBound() {\n+        return Double.POSITIVE_INFINITY;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public boolean isSupportLowerBoundInclusive() {\n+        return true;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public boolean isSupportUpperBoundInclusive() {\n+        return false;\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     * \n+     * The support of this distribution is connected.\n+     * \n+     * @return {@code true}\n+     */\n+    public boolean isSupportConnected() {\n+        return true;\n+    }\n+}\n--- a/src/main/java/org/apache/commons/math/distribution/ExponentialDistribution.java\n+++ b/src/main/java/org/apache/commons/math/distribution/ExponentialDistribution.java\n  */\n package org.apache.commons.math.distribution;\n \n-import java.io.Serializable;\n-\n import org.apache.commons.math.exception.NotStrictlyPositiveException;\n import org.apache.commons.math.exception.OutOfRangeException;\n import org.apache.commons.math.exception.util.LocalizedFormats;\n  * @see <a href=\"http://mathworld.wolfram.com/ExponentialDistribution.html\">Exponential distribution (MathWorld)</a>\n  * @version $Id$\n  */\n-public class ExponentialDistribution extends AbstractContinuousDistribution\n-    implements Serializable {\n+public class ExponentialDistribution extends AbstractRealDistribution {\n     /**\n      * Default inverse cumulative probability accuracy.\n      * @since 2.1\n      */\n     public double getMean() {\n         return mean;\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     *\n+     * For this distribution {@code P(X = x)} always evaluates to 0.\n+     *\n+     * @return 0\n+     */\n+    public double probability(double x) {\n+        return 0.0;\n     }\n \n     /** {@inheritDoc} */\n     /**\n      * {@inheritDoc}\n      *\n+     * For mean parameter {@code k}, the mean is {@code k}.\n+     */\n+    public double getNumericalMean() {\n+        return getMean();\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     *\n+     * For mean parameter {@code k}, the variance is {@code k^2}.\n+     */\n+    public double getNumericalVariance() {\n+        final double m = getMean();\n+        return m * m;\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     *\n      * The lower bound of the support is always 0 no matter the mean parameter.\n      *\n      * @return lower bound of the support (always 0)\n      */\n-    @Override\n     public double getSupportLowerBound() {\n         return 0;\n     }\n      *\n      * @return upper bound of the support (always Double.POSITIVE_INFINITY)\n      */\n-    @Override\n     public double getSupportUpperBound() {\n         return Double.POSITIVE_INFINITY;\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     *\n-     * For mean parameter {@code k}, the mean is {@code k}.\n-     */\n-    @Override\n-    protected double calculateNumericalMean() {\n-        return getMean();\n-    }\n-\n-    /**\n-     * {@inheritDoc}\n-     *\n-     * For mean parameter {@code k}, the variance is {@code k^2}.\n-     */\n-    @Override\n-    protected double calculateNumericalVariance() {\n-        final double m = getMean();\n-        return m * m;\n-    }\n-\n-    /** {@inheritDoc} */\n-    @Override\n+    /** {@inheritDoc} */\n     public boolean isSupportLowerBoundInclusive() {\n         return true;\n     }\n \n     /** {@inheritDoc} */\n-    @Override\n     public boolean isSupportUpperBoundInclusive() {\n         return false;\n     }\n+\n+    /**\n+     * {@inheritDoc}\n+     * \n+     * The support of this distribution is connected.\n+     * \n+     * @return {@code true}\n+     */\n+    public boolean isSupportConnected() {\n+        return true;\n+    }\n }\n--- a/src/main/java/org/apache/commons/math/distribution/FDistribution.java\n+++ b/src/main/java/org/apache/commons/math/distribution/FDistribution.java\n \n package org.apache.commons.math.distribution;\n \n-import java.io.Serializable;\n-\n import org.apache.commons.math.exception.NotStrictlyPositiveException;\n import org.apache.commons.math.exception.OutOfRangeException;\n import org.apache.commons.math.exception.util.LocalizedFormats;\n  * @see <a href=\"http://mathworld.wolfram.com/F-Distribution.html\">F-distribution (MathWorld)</a>\n  * @version $Id$\n  */\n-public class FDistribution\n-    extends AbstractContinuousDistribution\n-    implements Serializable  {\n+public class FDistribution extends AbstractRealDistribution {\n+    /** Serializable version identifier. */\n+    private static final long serialVersionUID = -8516354193418641566L;\n+\n     /**\n      * Default inverse cumulative probability accuracy.\n      * @since 2.1\n      */\n     public static final double DEFAULT_INVERSE_ABSOLUTE_ACCURACY = 1e-9;\n-    /** Serializable version identifier. */\n-    private static final long serialVersionUID = -8516354193418641566L;\n+\n     /** The numerator degrees of freedom. */\n     private final double numeratorDegreesOfFreedom;\n+\n     /** The numerator degrees of freedom. */\n     private final double denominatorDegreesOfFreedom;\n+\n     /** Inverse cumulative probability accuracy. */\n     private final double solverAbsoluteAccuracy;\n+\n+    /** Cached numerical variance */\n+    private double numericalVariance = Double.NaN;\n+\n+    /** Whether or not the numerical variance has been calculated */\n+    private boolean numericalVarianceIsCalculated = false;\n \n     /**\n      * Create a F distribution using the given degrees of freedom.\n     /**\n      * {@inheritDoc}\n      *\n+     * For this distribution {@code P(X = x)} always evaluates to 0.\n+     *\n+     * @return 0\n+     */\n+    public double probability(double x) {\n+        return 0.0;\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     *\n      * @since 2.1\n      */\n     public double density(double x) {\n     /**\n      * {@inheritDoc}\n      *\n-     * The lower bound of the support is always 0 no matter the parameters.\n-     *\n-     * @return lower bound of the support (always 0)\n-     */\n-    @Override\n-    public double getSupportLowerBound() {\n-        return 0;\n-    }\n-\n-    /**\n-     * {@inheritDoc}\n-     *\n-     * The upper bound of the support is always positive infinity\n-     * no matter the parameters.\n-     *\n-     * @return upper bound of the support (always Double.POSITIVE_INFINITY)\n-     */\n-    @Override\n-    public double getSupportUpperBound() {\n-        return Double.POSITIVE_INFINITY;\n-    }\n-\n-    /**\n-     * {@inheritDoc}\n-     *\n      * For denominator degrees of freedom parameter {@code b}, the mean is\n      * <ul>\n      *  <li>if {@code b > 2} then {@code b / (b - 2)},</li>\n      *  <li>else undefined ({@code Double.NaN}).\n      * </ul>\n      */\n-    @Override\n-    protected double calculateNumericalMean() {\n+    public double getNumericalMean() {\n         final double denominatorDF = getDenominatorDegreesOfFreedom();\n \n         if (denominatorDF > 2) {\n      *  <li>else undefined ({@code Double.NaN}).\n      * </ul>\n      */\n-    @Override\n+    public double getNumericalVariance() {\n+        if (!numericalVarianceIsCalculated) {\n+            numericalVariance = calculateNumericalVariance();\n+            numericalVarianceIsCalculated = true;\n+        }\n+        return numericalVariance;\n+    }\n+\n+    /**\n+     * used by {@link #getNumericalVariance()}\n+     * \n+     * @return the variance of this distribution\n+     */\n     protected double calculateNumericalVariance() {\n         final double denominatorDF = getDenominatorDegreesOfFreedom();\n \n         return Double.NaN;\n     }\n \n-    /** {@inheritDoc} */\n-    @Override\n+    /**\n+     * {@inheritDoc}\n+     *\n+     * The lower bound of the support is always 0 no matter the parameters.\n+     *\n+     * @return lower bound of the support (always 0)\n+     */\n+    public double getSupportLowerBound() {\n+        return 0;\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     *\n+     * The upper bound of the support is always positive infinity\n+     * no matter the parameters.\n+     *\n+     * @return upper bound of the support (always Double.POSITIVE_INFINITY)\n+     */\n+    public double getSupportUpperBound() {\n+        return Double.POSITIVE_INFINITY;\n+    }\n+\n+    /** {@inheritDoc} */\n     public boolean isSupportLowerBoundInclusive() {\n         return true;\n     }\n \n     /** {@inheritDoc} */\n-    @Override\n     public boolean isSupportUpperBoundInclusive() {\n         return false;\n     }\n+\n+    /**\n+     * {@inheritDoc}\n+     * \n+     * The support of this distribution is connected.\n+     * \n+     * @return {@code true}\n+     */\n+    public boolean isSupportConnected() {\n+        return true;\n+    }\n }\n--- a/src/main/java/org/apache/commons/math/distribution/GammaDistribution.java\n+++ b/src/main/java/org/apache/commons/math/distribution/GammaDistribution.java\n  */\n package org.apache.commons.math.distribution;\n \n-import java.io.Serializable;\n-\n import org.apache.commons.math.exception.NotStrictlyPositiveException;\n import org.apache.commons.math.exception.util.LocalizedFormats;\n import org.apache.commons.math.special.Gamma;\n  * @see <a href=\"http://mathworld.wolfram.com/GammaDistribution.html\">Gamma distribution (MathWorld)</a>\n  * @version $Id$\n  */\n-public class GammaDistribution extends AbstractContinuousDistribution\n-    implements Serializable  {\n+public class GammaDistribution extends AbstractRealDistribution {\n     /**\n      * Default inverse cumulative probability accuracy.\n      * @since 2.1\n         this.alpha = alpha;\n         this.beta = beta;\n         solverAbsoluteAccuracy = inverseCumAccuracy;\n+    }\n+\n+    /**\n+     * Access the {@code alpha} shape parameter.\n+     *\n+     * @return {@code alpha}.\n+     */\n+    public double getAlpha() {\n+        return alpha;\n+    }\n+\n+    /**\n+     * Access the {@code beta} scale parameter.\n+     *\n+     * @return {@code beta}.\n+     */\n+    public double getBeta() {\n+        return beta;\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     *\n+     * For this distribution {@code P(X = x)} always evaluates to 0.\n+     *\n+     * @return 0\n+     */\n+    public double probability(double x) {\n+        return 0.0;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public double density(double x) {\n+        if (x < 0) {\n+            return 0;\n+        }\n+        return FastMath.pow(x / beta, alpha - 1) / beta *\n+               FastMath.exp(-x / beta) / FastMath.exp(Gamma.logGamma(alpha));\n     }\n \n     /**\n         return super.inverseCumulativeProbability(p);\n     }\n \n-    /**\n-     * Access the {@code alpha} shape parameter.\n-     *\n-     * @return {@code alpha}.\n-     */\n-    public double getAlpha() {\n-        return alpha;\n-    }\n-\n-    /**\n-     * Access the {@code beta} scale parameter.\n-     *\n-     * @return {@code beta}.\n-     */\n-    public double getBeta() {\n-        return beta;\n-    }\n-\n-    /** {@inheritDoc} */\n-    public double density(double x) {\n-        if (x < 0) {\n-            return 0;\n-        }\n-        return FastMath.pow(x / beta, alpha - 1) / beta *\n-               FastMath.exp(-x / beta) / FastMath.exp(Gamma.logGamma(alpha));\n-    }\n-\n     /** {@inheritDoc} */\n     @Override\n     protected double getDomainLowerBound(double p) {\n     /**\n      * {@inheritDoc}\n      *\n+     * For shape parameter {@code alpha} and scale parameter {@code beta}, the\n+     * mean is {@code alpha * beta}.\n+     */\n+    public double getNumericalMean() {\n+        return getAlpha() * getBeta();\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     *\n+     * For shape parameter {@code alpha} and scale parameter {@code beta}, the\n+     * variance is {@code alpha * beta^2}.\n+     *\n+     * @return {@inheritDoc}\n+     */\n+    public double getNumericalVariance() {\n+        final double b = getBeta();\n+        return getAlpha() * b * b;\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     *\n      * The lower bound of the support is always 0 no matter the parameters.\n      *\n      * @return lower bound of the support (always 0)\n      */\n-    @Override\n     public double getSupportLowerBound() {\n         return 0;\n     }\n      *\n      * @return upper bound of the support (always Double.POSITIVE_INFINITY)\n      */\n-    @Override\n     public double getSupportUpperBound() {\n         return Double.POSITIVE_INFINITY;\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     *\n-     * For shape parameter {@code alpha} and scale parameter {@code beta}, the\n-     * mean is {@code alpha * beta}.\n-     */\n-    @Override\n-    protected double calculateNumericalMean() {\n-        return getAlpha() * getBeta();\n-    }\n-\n-    /**\n-     * {@inheritDoc}\n-     *\n-     * For shape parameter {@code alpha} and scale parameter {@code beta}, the\n-     * variance is {@code alpha * beta^2}.\n-     *\n-     * @return {@inheritDoc}\n-     */\n-    @Override\n-    protected double calculateNumericalVariance() {\n-        final double b = getBeta();\n-        return getAlpha() * b * b;\n-    }\n-\n-    /** {@inheritDoc} */\n-    @Override\n+    /** {@inheritDoc} */\n     public boolean isSupportLowerBoundInclusive() {\n         return true;\n     }\n \n     /** {@inheritDoc} */\n-    @Override\n     public boolean isSupportUpperBoundInclusive() {\n         return false;\n     }\n+\n+    /**\n+     * {@inheritDoc}\n+     * \n+     * The support of this distribution is connected.\n+     * \n+     * @return {@code true}\n+     */\n+    public boolean isSupportConnected() {\n+        return true;\n+    }\n }\n--- a/src/main/java/org/apache/commons/math/distribution/HypergeometricDistribution.java\n+++ b/src/main/java/org/apache/commons/math/distribution/HypergeometricDistribution.java\n \n package org.apache.commons.math.distribution;\n \n-import java.io.Serializable;\n-\n import org.apache.commons.math.exception.NotPositiveException;\n import org.apache.commons.math.exception.NotStrictlyPositiveException;\n import org.apache.commons.math.exception.NumberIsTooLargeException;\n  * @see <a href=\"http://mathworld.wolfram.com/HypergeometricDistribution.html\">Hypergeometric distribution (MathWorld)</a>\n  * @version $Id$\n  */\n-public class HypergeometricDistribution extends AbstractIntegerDistribution\n-    implements Serializable {\n+public class HypergeometricDistribution extends AbstractIntegerDistribution {\n     /** Serializable version identifier. */\n     private static final long serialVersionUID = -436928820673516179L;\n+\n     /** The number of successes in the population. */\n     private final int numberOfSuccesses;\n+\n     /** The population size. */\n     private final int populationSize;\n+\n     /** The sample size. */\n     private final int sampleSize;\n+\n+    /** Cached numerical variance */\n+    private double numericalVariance = Double.NaN;\n+\n+    /** Whether or not the numerical variance has been calculated */\n+    private boolean numericalVarianceIsCalculated = false;\n \n     /**\n      * Construct a new hypergeometric distribution with the specified population\n      * @param populationSize Population size.\n      * @param numberOfSuccesses Number of successes in the population.\n      * @param sampleSize Sample size.\n-     * @throws NotPositiveException if {@code numberOfSuccesses < 0},\n-     * or {@code populationSize < 0}.\n+     * @throws NotPositiveException if {@code numberOfSuccesses < 0}.\n      * @throws NotStrictlyPositiveException if {@code populationSize <= 0}.\n      * @throws NumberIsTooLargeException if {@code numberOfSuccesses > populationSize},\n      * or {@code sampleSize > populationSize}.\n      */\n-    public HypergeometricDistribution(int populationSize,\n-                                          int numberOfSuccesses,\n-                                          int sampleSize)\n-        throws NotPositiveException,\n-        NotStrictlyPositiveException,\n-        NumberIsTooLargeException {\n+    public HypergeometricDistribution(int populationSize, int numberOfSuccesses, int sampleSize)\n+    throws NotPositiveException, NotStrictlyPositiveException, NumberIsTooLargeException {\n         if (populationSize <= 0) {\n             throw new NotStrictlyPositiveException(LocalizedFormats.POPULATION_SIZE,\n                                                    populationSize);\n     }\n \n     /** {@inheritDoc} */\n-    @Override\n     public double cumulativeProbability(int x) {\n         double ret;\n \n      * {@inheritDoc}\n      *\n      * For population size {@code N}, number of successes {@code m}, and sample\n-     * size {@code n}, the lower bound of the support is\n-     * {@code max(0, n + m - N)}.\n-     *\n-     * @return lower bound of the support\n-     */\n-    @Override\n-    public int getSupportLowerBound() {\n-        return FastMath.max(0,\n-                getSampleSize() + getNumberOfSuccesses() - getPopulationSize());\n-    }\n-\n-    /**\n-     * {@inheritDoc}\n-     *\n-     * For number of successes {@code m} and sample size {@code n}, the upper\n-     * bound of the support is {@code min(m, n)}.\n-     *\n-     * @return upper bound of the support\n-     */\n-    @Override\n-    public int getSupportUpperBound() {\n-        return FastMath.min(getNumberOfSuccesses(), getSampleSize());\n-    }\n-\n-    /**\n-     * {@inheritDoc}\n-     *\n-     * For population size {@code N}, number of successes {@code m}, and sample\n      * size {@code n}, the mean is {@code n * m / N}.\n      */\n-    @Override\n-    protected double calculateNumericalMean() {\n+    public double getNumericalMean() {\n         return (double)(getSampleSize() * getNumberOfSuccesses()) / (double)getPopulationSize();\n     }\n \n      * size {@code n}, the variance is\n      * {@code [n * m * (N - n) * (N - m)] / [N^2 * (N - 1)]}.\n      */\n-    @Override\n+    public double getNumericalVariance() {\n+        if (!numericalVarianceIsCalculated) {\n+            numericalVariance = calculateNumericalVariance();\n+            numericalVarianceIsCalculated = true;\n+        }\n+        return numericalVariance;\n+    }\n+\n+    /**\n+     * Used by {@link #getNumericalVariance()}.\n+     * \n+     * @return the variance of this distribution\n+     */\n     protected double calculateNumericalVariance() {\n         final double N = getPopulationSize();\n         final double m = getNumberOfSuccesses();\n         final double n = getSampleSize();\n         return ( n * m * (N - n) * (N - m) ) / ( (N*N * (N - 1)) );\n     }\n+\n+    /**\n+     * {@inheritDoc}\n+     *\n+     * For population size {@code N}, number of successes {@code m}, and sample\n+     * size {@code n}, the lower bound of the support is\n+     * {@code max(0, n + m - N)}.\n+     *\n+     * @return lower bound of the support\n+     */\n+    public int getSupportLowerBound() {\n+        return FastMath.max(0,\n+                getSampleSize() + getNumberOfSuccesses() - getPopulationSize());\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     *\n+     * For number of successes {@code m} and sample size {@code n}, the upper\n+     * bound of the support is {@code min(m, n)}.\n+     *\n+     * @return upper bound of the support\n+     */\n+    public int getSupportUpperBound() {\n+        return FastMath.min(getNumberOfSuccesses(), getSampleSize());\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     * \n+     * The support of this distribution is connected.\n+     * \n+     * @return {@code true}\n+     */\n+    public boolean isSupportConnected() {\n+        return true;\n+    }\n }\n--- a/src/main/java/org/apache/commons/math/distribution/IntegerDistribution.java\n+++ b/src/main/java/org/apache/commons/math/distribution/IntegerDistribution.java\n package org.apache.commons.math.distribution;\n \n /**\n- * Interface for discrete distributions of integer-valued random variables.\n+ * Interface for distributions on the integers.\n  *\n  * @version $Id$\n  */\n-public interface IntegerDistribution extends DiscreteDistribution {\n+public interface IntegerDistribution {\n     /**\n      * For a random variable {@code X} whose values are distributed according\n      * to this distribution, this method returns {@code P(X = x)}. In other\n      * words, this method represents the probability mass function for the\n      * distribution.\n      *\n-     * @param x Value at which the probability density function is evaluated.\n-     * @return the value of the probability density function at {@code x}.\n+     * @param x the point at which the probability density function is evaluated.\n+     * @return the value of the probability density function at {@code x}\n      */\n     double probability(int x);\n \n      * words, this method represents the probability distribution function, or\n      * PDF for the distribution.\n      *\n-     * @param x Value at which the PDF is evaluated.\n+     * @param x the point at which the PDF is evaluated\n      * @return PDF for this distribution.\n      */\n     double cumulativeProbability(int x);\n \n     /**\n-     * For this distribution, {@code X}, this method returns\n-     * {@code P(x0 <= X <= x1)}.\n+     * For a random variable {@code X} whose values are distributed according\n+     * to this distribution, this method returns {@code P(x0 <= X <= x1)}.\n      *\n-     * @param x0 the inclusive, lower bound\n-     * @param x1 the inclusive, upper bound\n-     * @return the cumulative probability.\n-     * @throws IllegalArgumentException if {@code x0 > x1}.\n+     * @param x0 the inclusive lower bound\n+     * @param x1 the inclusive upper bound\n+     * @return the cumulative probability\n+     * @throws IllegalArgumentException if {@code x0 > x1}\n      */\n     double cumulativeProbability(int x0, int x1);\n \n      *  </li>\n      * </ul>\n      *\n-     * @param p Cumulative probability.\n-     * @return the largest {@code x} such that {@code P(X < x) <= p}.\n+     * @param p the cumulative probability\n+     * @return the largest {@code x} such that {@code P(X < x) <= p}\n      * @throws IllegalArgumentException if {@code p} is not between 0 and 1\n-     * (inclusive).\n+     * (inclusive)\n      */\n     int inverseCumulativeProbability(double p);\n \n     /**\n+     * Use this method to get the numerical value of the mean of this\n+     * distribution.\n+     *\n+     * @return the mean or {@code Double.NaN} if it is not defined\n+     */\n+    double getNumericalMean();\n+\n+    /**\n+     * Use this method to get the numerical value of the variance of this\n+     * distribution.\n+     *\n+     * @return the variance (possibly {@code Double.POSITIVE_INFINITY} as\n+     * for certain cases in {@link TDistributionImpl}) or\n+     * {@code Double.NaN} if it is not defined\n+     */\n+    double getNumericalVariance();\n+\n+    /**\n+     * Access the lower bound of the support.\n+     *\n+     * @return lower bound of the support ({@code Integer.MIN_VALUE}\n+     * for negative infinity)\n+     */\n+    int getSupportLowerBound();\n+\n+    /**\n+     * Access the upper bound of the support.\n+     *\n+     * @return upper bound of the support ({@code Integer.MAX_VALUE}\n+     * for positive infinity)\n+     */\n+    int getSupportUpperBound();\n+\n+    /**\n+     * Use this method to get information about whether the support is\n+     * connected, i.e. whether all integers between the lower and upper bound of\n+     * the support are included in the support.\n+     *\n+     * @return whether the support is connected or not\n+     */\n+    boolean isSupportConnected();\n+\n+    /**\n      * Reseed the random generator used to generate samples.\n      *\n-     * @param seed New seed.\n+     * @param seed the new seed\n      * @since 3.0\n      */\n     void reseedRandomGenerator(long seed);\n     /**\n      * Generate a random value sampled from this distribution.\n      *\n-     * @return a random value.\n+     * @return a random value\n      * @since 3.0\n      */\n     int sample();\n     /**\n      * Generate a random sample from the distribution.\n      *\n-     * @param sampleSize number of random values to generate.\n-     * @return an array representing the random sample.\n+     * @param sampleSize the number of random values to generate\n+     * @return an array representing the random sample\n      * @throws org.apache.commons.math.exception.NotStrictlyPositiveException\n-     * if {@code sampleSize} is not positive.\n+     * if {@code sampleSize} is not positive\n      * @since 3.0\n      */\n     int[] sample(int sampleSize);\n--- a/src/main/java/org/apache/commons/math/distribution/NormalDistribution.java\n+++ b/src/main/java/org/apache/commons/math/distribution/NormalDistribution.java\n \n package org.apache.commons.math.distribution;\n \n-import java.io.Serializable;\n-\n import org.apache.commons.math.exception.NotStrictlyPositiveException;\n import org.apache.commons.math.exception.NumberIsTooLargeException;\n import org.apache.commons.math.exception.util.LocalizedFormats;\n  * @see <a href=\"http://mathworld.wolfram.com/NormalDistribution.html\">Normal distribution (MathWorld)</a>\n  * @version $Id$\n  */\n-public class NormalDistribution extends AbstractContinuousDistribution\n-        implements Serializable {\n+public class NormalDistribution extends AbstractRealDistribution {\n     /**\n      * Default inverse cumulative probability accuracy.\n      * @since 2.1\n      * @throws NotStrictlyPositiveException if {@code sd <= 0}.\n      * @since 2.1\n      */\n-    public NormalDistribution(double mean, double sd, double inverseCumAccuracy) {\n+    public NormalDistribution(double mean, double sd, double inverseCumAccuracy)\n+        throws NotStrictlyPositiveException {\n         if (sd <= 0) {\n             throw new NotStrictlyPositiveException(LocalizedFormats.STANDARD_DEVIATION, sd);\n         }\n      * Create a normal distribution with mean equal to zero and standard\n      * deviation equal to one.\n      */\n-    public NormalDistribution(){\n+    public NormalDistribution() {\n         this(0, 1);\n     }\n \n      */\n     public double getStandardDeviation() {\n         return standardDeviation;\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     *\n+     * For this distribution {@code P(X = x)} always evaluates to 0.\n+     *\n+     * @return 0\n+     */\n+    public double probability(double x) {\n+        return 0.0;\n     }\n \n     /** {@inheritDoc} */\n         return 0.5 * Erf.erf(v0, v1);\n     }\n \n-    /** {@inheritDoc} */\n-    @Override\n-    protected double getSolverAbsoluteAccuracy() {\n-        return solverAbsoluteAccuracy;\n-    }\n-\n     /**\n      * {@inheritDoc}\n      *\n             return Double.POSITIVE_INFINITY;\n         }\n         return super.inverseCumulativeProbability(p);\n-    }\n-\n-    /** {@inheritDoc} */\n-    @Override\n-    public double sample()  {\n-        return randomData.nextGaussian(mean, standardDeviation);\n     }\n \n     /** {@inheritDoc} */\n         return ret;\n     }\n \n+    /** {@inheritDoc} */\n+    @Override\n+    protected double getSolverAbsoluteAccuracy() {\n+        return solverAbsoluteAccuracy;\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     *\n+     * For mean parameter {@code mu}, the mean is {@code mu}.\n+     */\n+    public double getNumericalMean() {\n+        return getMean();\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     *\n+     * For standard deviation parameter {@code s}, the variance is {@code s^2}.\n+     */\n+    public double getNumericalVariance() {\n+        final double s = getStandardDeviation();\n+        return s * s;\n+    }\n+\n     /**\n      * {@inheritDoc}\n      *\n      * @return lower bound of the support (always\n      * {@code Double.NEGATIVE_INFINITY})\n      */\n-    @Override\n     public double getSupportLowerBound() {\n         return Double.NEGATIVE_INFINITY;\n     }\n      * @return upper bound of the support (always\n      * {@code Double.POSITIVE_INFINITY})\n      */\n-    @Override\n     public double getSupportUpperBound() {\n         return Double.POSITIVE_INFINITY;\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     *\n-     * For mean parameter {@code mu}, the mean is {@code mu}.\n-     */\n-    @Override\n-    protected double calculateNumericalMean() {\n-        return getMean();\n-    }\n-\n-    /**\n-     * {@inheritDoc}\n-     *\n-     * For standard deviation parameter {@code s}, the variance is {@code s^2}.\n-     */\n-    @Override\n-    protected double calculateNumericalVariance() {\n-        final double s = getStandardDeviation();\n-        return s * s;\n-    }\n-\n-    /** {@inheritDoc} */\n-    @Override\n+    /** {@inheritDoc} */\n     public boolean isSupportLowerBoundInclusive() {\n         return false;\n     }\n \n     /** {@inheritDoc} */\n-    @Override\n     public boolean isSupportUpperBoundInclusive() {\n         return false;\n     }\n+\n+    /**\n+     * {@inheritDoc}\n+     * \n+     * The support of this distribution is connected.\n+     * \n+     * @return {@code true}\n+     */\n+    public boolean isSupportConnected() {\n+        return true;\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public double sample()  {\n+        return randomData.nextGaussian(mean, standardDeviation);\n+    }\n }\n--- a/src/main/java/org/apache/commons/math/distribution/PascalDistribution.java\n+++ b/src/main/java/org/apache/commons/math/distribution/PascalDistribution.java\n  * limitations under the License.\n  */\n package org.apache.commons.math.distribution;\n-\n-import java.io.Serializable;\n \n import org.apache.commons.math.exception.OutOfRangeException;\n import org.apache.commons.math.exception.NotPositiveException;\n  * @version $Id$\n  * @since 1.2 (changed to concrete class in 3.0)\n  */\n-public class PascalDistribution extends AbstractIntegerDistribution\n-    implements Serializable {\n+public class PascalDistribution extends AbstractIntegerDistribution {\n     /** Serializable version identifier. */\n     private static final long serialVersionUID = 6751309484392813623L;\n     /** The number of successes. */\n      */\n     public double getProbabilityOfSuccess() {\n         return probabilityOfSuccess;\n-    }\n-\n-    /** {@inheritDoc} */\n-    @Override\n-    protected int getDomainLowerBound(double p) {\n-        return -1;\n-    }\n-\n-    /** {@inheritDoc} */\n-    @Override\n-    protected int getDomainUpperBound(double p) {\n-        // use MAX - 1 because MAX causes loop\n-        return Integer.MAX_VALUE - 1;\n-    }\n-\n-    /** {@inheritDoc} */\n-    @Override\n-    public double cumulativeProbability(int x) {\n-        double ret;\n-        if (x < 0) {\n-            ret = 0.0;\n-        } else {\n-            ret = Beta.regularizedBeta(probabilityOfSuccess,\n-                numberOfSuccesses, x + 1);\n-        }\n-        return ret;\n     }\n \n     /** {@inheritDoc} */\n         return ret;\n     }\n \n+    /** {@inheritDoc} */\n+    public double cumulativeProbability(int x) {\n+        double ret;\n+        if (x < 0) {\n+            ret = 0.0;\n+        } else {\n+            ret = Beta.regularizedBeta(probabilityOfSuccess,\n+                    numberOfSuccesses, x + 1);\n+        }\n+        return ret;\n+    }\n+\n     /**\n      * {@inheritDoc}\n      *\n         return ret;\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     *\n-     * The lower bound of the support is always 0 no matter the parameters.\n-     *\n-     * @return lower bound of the support (always 0)\n-     */\n+    /** {@inheritDoc} */\n     @Override\n-    public int getSupportLowerBound() {\n-        return 0;\n-    }\n-\n-    /**\n-     * {@inheritDoc}\n-     *\n-     * The upper bound of the support is always positive infinity no matter the\n-     * parameters. Positive infinity is symbolised by {@code Integer.MAX_VALUE}\n-     * together with {@link #isSupportUpperBoundInclusive()} being\n-     * {@code false}.\n-     *\n-     * @return upper bound of the support (always {@code Integer.MAX_VALUE}\n-     * for positive infinity)\n-     */\n+    protected int getDomainLowerBound(double p) {\n+        return -1;\n+    }\n+\n+    /** {@inheritDoc} */\n     @Override\n-    public int getSupportUpperBound() {\n-        return Integer.MAX_VALUE;\n+    protected int getDomainUpperBound(double p) {\n+        // use MAX - 1 because MAX causes loop\n+        return Integer.MAX_VALUE - 1;\n     }\n \n     /**\n      * For number of successes {@code r} and probability of success {@code p},\n      * the mean is {@code (r * p) / (1 - p)}.\n      */\n-    @Override\n-    protected double calculateNumericalMean() {\n+    public double getNumericalMean() {\n         final double p = getProbabilityOfSuccess();\n         final double r = getNumberOfSuccesses();\n         return (r * p) / (1 - p);\n      * {@inheritDoc}\n      *\n      * For number of successes {@code r} and probability of success {@code p},\n-     * the mean is {@code (r * p) / (1 - p)^2}.\n-     */\n-    @Override\n-    protected double calculateNumericalVariance() {\n+     * the variance is {@code (r * p) / (1 - p)^2}.\n+     */\n+    public double getNumericalVariance() {\n         final double p = getProbabilityOfSuccess();\n         final double r = getNumberOfSuccesses();\n         final double pInv = 1 - p;\n     /**\n      * {@inheritDoc}\n      *\n-     * Always returns {@code false}.\n-     *\n-     * @see PascalDistribution#getSupportUpperBound() getSupportUpperBound()\n-     */\n-    @Override\n-    public boolean isSupportUpperBoundInclusive() {\n-        return false;\n+     * The lower bound of the support is always 0 no matter the parameters.\n+     *\n+     * @return lower bound of the support (always 0)\n+     */\n+    public int getSupportLowerBound() {\n+        return 0;\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     *\n+     * The upper bound of the support is always positive infinity no matter the\n+     * parameters. Positive infinity is symbolised by {@code Integer.MAX_VALUE}.\n+     *\n+     * @return upper bound of the support (always {@code Integer.MAX_VALUE}\n+     * for positive infinity)\n+     */\n+    public int getSupportUpperBound() {\n+        return Integer.MAX_VALUE;\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     * \n+     * The support of this distribution is connected.\n+     * \n+     * @return {@code true}\n+     */\n+    public boolean isSupportConnected() {\n+        return true;\n     }\n }\n--- a/src/main/java/org/apache/commons/math/distribution/PoissonDistribution.java\n+++ b/src/main/java/org/apache/commons/math/distribution/PoissonDistribution.java\n  */\n package org.apache.commons.math.distribution;\n \n-import java.io.Serializable;\n-\n import org.apache.commons.math.exception.NotStrictlyPositiveException;\n import org.apache.commons.math.exception.util.LocalizedFormats;\n import org.apache.commons.math.special.Gamma;\n  * @see <a href=\"http://mathworld.wolfram.com/PoissonDistribution.html\">Poisson distribution (MathWorld)</a>\n  * @version $Id$\n  */\n-public class PoissonDistribution extends AbstractIntegerDistribution\n-    implements Serializable {\n+public class PoissonDistribution extends AbstractIntegerDistribution {\n     /**\n      * Default maximum number of iterations for cumulative probability calculations.\n      * @since 2.1\n      * @param p the Poisson mean\n      * @throws NotStrictlyPositiveException if {@code p <= 0}.\n      */\n-    public PoissonDistribution(double p) {\n+    public PoissonDistribution(double p) throws NotStrictlyPositiveException {\n         this(p, DEFAULT_EPSILON, DEFAULT_MAX_ITERATIONS);\n     }\n \n      * @param epsilon Convergence criterion for cumulative probabilities.\n      * @param maxIterations the maximum number of iterations for cumulative\n      * probabilities.\n-     * @since 2.1\n-     */\n-    public PoissonDistribution(double p, double epsilon, int maxIterations) {\n+     * @throws NotStrictlyPositiveException if {@code p <= 0}.\n+     * @since 2.1\n+     */\n+    public PoissonDistribution(double p, double epsilon, int maxIterations)\n+    throws NotStrictlyPositiveException {\n         if (p <= 0) {\n             throw new NotStrictlyPositiveException(LocalizedFormats.MEAN, p);\n         }\n      *\n      * @param p Poisson mean.\n      * @param epsilon Convergence criterion for cumulative probabilities.\n-     * @since 2.1\n-     */\n-    public PoissonDistribution(double p, double epsilon) {\n+     * @throws NotStrictlyPositiveException if {@code p <= 0}.\n+     * @since 2.1\n+     */\n+    public PoissonDistribution(double p, double epsilon)\n+    throws NotStrictlyPositiveException {\n         this(p, epsilon, DEFAULT_MAX_ITERATIONS);\n     }\n \n     }\n \n     /** {@inheritDoc} */\n-    @Override\n     public double cumulativeProbability(int x) {\n         if (x < 0) {\n             return 0;\n     public double normalApproximateProbability(int x)  {\n         // calculate the probability using half-correction\n         return normal.cumulativeProbability(x + 0.5);\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    protected int getDomainLowerBound(double p) {\n+        return 0;\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    protected int getDomainUpperBound(double p) {\n+        return Integer.MAX_VALUE;\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     *\n+     * For mean parameter {@code p}, the mean is {@code p}.\n+     */\n+    public double getNumericalMean() {\n+        return getMean();\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     *\n+     * For mean parameter {@code p}, the variance is {@code p}.\n+     */\n+    public double getNumericalVariance() {\n+        return getMean();\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     *\n+     * The lower bound of the support is always 0 no matter the mean parameter.\n+     *\n+     * @return lower bound of the support (always 0)\n+     */\n+    public int getSupportLowerBound() {\n+        return 0;\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     *\n+     * The upper bound of the support is positive infinity,\n+     * regardless of the parameter values. There is no integer infinity,\n+     * so this method returns {@code Integer.MAX_VALUE} and\n+     * {@link #isSupportUpperBoundInclusive()} returns {@code true}.\n+     *\n+     * @return upper bound of the support (always {@code Integer.MAX_VALUE} for\n+     * positive infinity)\n+     */\n+    public int getSupportUpperBound() {\n+        return Integer.MAX_VALUE;\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     *\n+     * The support of this distribution is connected.\n+     *\n+     * @return {@code true}\n+     */\n+    public boolean isSupportConnected() {\n+        return true;\n     }\n \n     /**\n      * @since 2.2\n      */\n     @Override\n-    public int sample()  {\n+    public int sample() {\n         return (int) FastMath.min(randomData.nextPoisson(mean), Integer.MAX_VALUE);\n     }\n-\n-    /** {@inheritDoc} */\n-    @Override\n-    protected int getDomainLowerBound(double p) {\n-        return 0;\n-    }\n-\n-    /** {@inheritDoc} */    @Override\n-    protected int getDomainUpperBound(double p) {\n-        return Integer.MAX_VALUE;\n-    }\n-\n-    /**\n-     * {@inheritDoc}\n-     *\n-     * The lower bound of the support is always 0 no matter the mean parameter.\n-     *\n-     * @return lower bound of the support (always 0)\n-     */\n-    @Override\n-    public int getSupportLowerBound() {\n-        return 0;\n-    }\n-\n-    /**\n-     * {@inheritDoc}\n-     *\n-     * The upper bound of the support is positive infinity,\n-     * regardless of the parameter values. There is no integer infinity,\n-     * so this method returns {@code Integer.MAX_VALUE} and\n-     * {@link #isSupportUpperBoundInclusive()} returns {@code true}.\n-     *\n-     * @return upper bound of the support (always {@code Integer.MAX_VALUE} for\n-     * positive infinity)\n-     */\n-    @Override\n-    public int getSupportUpperBound() {\n-        return Integer.MAX_VALUE;\n-    }\n-\n-    /**\n-     * {@inheritDoc}\n-     *\n-     * For mean parameter {@code p}, the mean is {@code p}.\n-     */\n-    @Override\n-    protected double calculateNumericalMean() {\n-        return getMean();\n-    }\n-\n-    /**\n-     * {@inheritDoc}\n-     *\n-     * For mean parameter {@code p}, the variance is {@code p}.\n-     */\n-    @Override\n-    protected double calculateNumericalVariance() {\n-        return getMean();\n-    }\n-\n-    /** {@inheritDoc} */\n-    @Override\n-    public boolean isSupportUpperBoundInclusive() {\n-        return true;\n-    }\n }\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/distribution/RealDistribution.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.distribution;\n+\n+import org.apache.commons.math.exception.NumberIsTooLargeException;\n+import org.apache.commons.math.exception.OutOfRangeException;\n+\n+/**\n+ * Base interface for distributions on the reals.\n+ *\n+ * @version $Id$\n+ * @since 3.0\n+ */\n+public interface RealDistribution {\n+    /**\n+     * For a random variable {@code X} whose values are distributed according\n+     * to this distribution, this method returns {@code P(X = x)}. In other\n+     * words, this method represents the probability mass function (PMF)\n+     * for the distribution.\n+     *\n+     * @param x the point at which the PMF is evaluated\n+     * @return the value of the probability mass function at point {@code x}\n+     */\n+    double probability(double x);\n+\n+    /**\n+     * Returns the probability density function (PDF) of this distribution\n+     * evaluated at the specified point {@code x}. In general, the PDF is\n+     * the derivative of the {@link #cumulativeProbability(double) CDF}.\n+     * If the derivative does not exist at {@code x}, then an appropriate\n+     * replacement should be returned, e.g. {@code Double.POSITIVE_INFINITY},\n+     * {@code Double.NaN}, or  the limit inferior or limit superior of the\n+     * difference quotient.\n+     *\n+     * @param x the point at which the PDF is evaluated\n+     * @return the value of the probability density function at point {@code x}\n+     */\n+    double density(double x);\n+\n+    /**\n+     * For a random variable {@code X} whose values are distributed according\n+     * to this distribution, this method returns {@code P(X <= x)}. In other\n+     * words, this method represents the (cumulative) distribution function\n+     * (CDF) for this distribution.\n+     *\n+     * @param x the point at which the CDF is evaluated\n+     * @return the probability that a random variable with this\n+     * distribution takes a value less than or equal to {@code x}\n+     */\n+    double cumulativeProbability(double x);\n+\n+    /**\n+     * For a random variable {@code X} whose values are distributed according\n+     * to this distribution, this method returns {@code P(x0 < X <= x1)}.\n+     *\n+     * @param x0 the exclusive lower bound\n+     * @param x1 the inclusive upper bound\n+     * @return the probability that a random variable with this distribution\n+     * takes a value between {@code x0} and {@code x1},\n+     * excluding the lower and including the upper endpoint\n+     * @throws NumberIsTooLargeException if {@code x0 > x1}\n+     */\n+    double cumulativeProbability(double x0, double x1) throws NumberIsTooLargeException;\n+\n+    /**\n+     * Computes the quantile function of this distribution. For a random\n+     * variable {@code X} distributed according to this distribution, the\n+     * returned value is\n+     * <ul>\n+     * <li><code>inf{x in R | P(X<=x) >= p}</code> for {@code 0 < p <= 1},</li>\n+     * <li><code>inf{x in R | P(X<=x) > 0}</code> for {@code p = 0}.</li>\n+     * </ul>\n+     *\n+     * @param p the cumulative probability\n+     * @return the smallest {@code p}-quantile of this distribution\n+     * (largest 0-quantile for {@code p = 0})\n+     * @throws OutOfRangeException if {@code p < 0} or {@code p > 1}\n+     */\n+    double inverseCumulativeProbability(double p) throws OutOfRangeException;\n+\n+    /**\n+     * Use this method to get the numerical value of the mean of this\n+     * distribution.\n+     *\n+     * @return the mean or {@code Double.NaN} if it is not defined\n+     */\n+    double getNumericalMean();\n+\n+    /**\n+     * Use this method to get the numerical value of the variance of this\n+     * distribution.\n+     *\n+     * @return the variance (possibly {@code Double.POSITIVE_INFINITY} as\n+     * for certain cases in {@link TDistributionImpl}) or\n+     * {@code Double.NaN} if it is not defined\n+     */\n+    double getNumericalVariance();\n+\n+    /**\n+     * Access the lower bound of the support.\n+     *\n+     * @return lower bound of the support (might be\n+     * {@code Double.NEGATIVE_INFINITY})\n+     */\n+    double getSupportLowerBound();\n+\n+    /**\n+     * Access the upper bound of the support.\n+     *\n+     * @return upper bound of the support (might be\n+     * {@code Double.POSITIVE_INFINITY})\n+     */\n+    double getSupportUpperBound();\n+\n+    /**\n+     * Use this method to get information about whether the lower bound\n+     * of the support is inclusive or not.\n+     *\n+     * @return whether the lower bound of the support is inclusive or not\n+     */\n+    boolean isSupportLowerBoundInclusive();\n+\n+    /**\n+     * Use this method to get information about whether the upper bound\n+     * of the support is inclusive or not.\n+     *\n+     * @return whether the upper bound of the support is inclusive or not\n+     */\n+    boolean isSupportUpperBoundInclusive();\n+\n+    /**\n+     * Use this method to get information about whether the support is connected,\n+     * i.e. whether all values between the lower and upper bound of the support\n+     * are included in the support.\n+     *\n+     * @return whether the support is connected or not\n+     */\n+    boolean isSupportConnected();\n+\n+    /**\n+     * Reseed the random generator used to generate samples.\n+     *\n+     * @param seed the new seed\n+     */\n+    void reseedRandomGenerator(long seed);\n+\n+    /**\n+     * Generate a random value sampled from this distribution.\n+     *\n+     * @return a random value.\n+     */\n+    double sample();\n+\n+    /**\n+     * Generate a random sample from the distribution.\n+     *\n+     * @param sampleSize the number of random values to generate\n+     * @return an array representing the random sample\n+     * @throws org.apache.commons.math.exception.NotStrictlyPositiveException\n+     * if {@code sampleSize} is not positive\n+     */\n+    double[] sample(int sampleSize);\n+}\n--- a/src/main/java/org/apache/commons/math/distribution/SaddlePointExpansion.java\n+++ b/src/main/java/org/apache/commons/math/distribution/SaddlePointExpansion.java\n     }\n \n     /**\n-     * Compute the PMF for a binomial distribution using the saddle point\n-     * expansion.\n+     * Compute the logarithm of the PMF for a binomial distribution\n+     * using the saddle point expansion.\n      *\n      * @param x the value at which the probability is evaluated.\n      * @param n the number of trials.\n--- a/src/main/java/org/apache/commons/math/distribution/TDistribution.java\n+++ b/src/main/java/org/apache/commons/math/distribution/TDistribution.java\n  */\n package org.apache.commons.math.distribution;\n \n-import java.io.Serializable;\n-\n import org.apache.commons.math.exception.NotStrictlyPositiveException;\n import org.apache.commons.math.exception.util.LocalizedFormats;\n import org.apache.commons.math.special.Beta;\n  * @see \"<a href='http://mathworld.wolfram.com/Studentst-Distribution.html'>Student's t-distribution (MathWorld)</a>\"\n  * @version $Id$\n  */\n-public class TDistribution extends AbstractContinuousDistribution\n-    implements Serializable  {\n+public class TDistribution extends AbstractRealDistribution {\n     /**\n      * Default inverse cumulative probability accuracy.\n      * @since 2.1\n      */\n     public double getDegreesOfFreedom() {\n         return degreesOfFreedom;\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     *\n+     * For this distribution {@code P(X = x)} always evaluates to 0.\n+     *\n+     * @return 0\n+     */\n+    public double probability(double x) {\n+        return 0.0;\n     }\n \n     /** {@inheritDoc} */\n     /**\n      * {@inheritDoc}\n      *\n-     * The lower bound of the support is always negative infinity no matter the\n-     * parameters.\n-     *\n-     * @return lower bound of the support (always\n-     * {@code Double.NEGATIVE_INFINITY})\n-     */\n-    @Override\n-    public double getSupportLowerBound() {\n-        return Double.NEGATIVE_INFINITY;\n-    }\n-\n-    /**\n-     * {@inheritDoc}\n-     *\n-     * The upper bound of the support is always positive infinity no matter the\n-     * parameters.\n-     *\n-     * @return upper bound of the support (always\n-     * {@code Double.POSITIVE_INFINITY})\n-     */\n-    @Override\n-    public double getSupportUpperBound() {\n-        return Double.POSITIVE_INFINITY;\n-    }\n-\n-    /**\n-     * {@inheritDoc}\n-     *\n      * For degrees of freedom parameter {@code df}, the mean is\n      * <ul>\n      *  <li>if {@code df > 1} then {@code 0},</li>\n      * <li>else undefined ({@code Double.NaN}).</li>\n      * </ul>\n      */\n-    @Override\n-    protected double calculateNumericalMean() {\n+    public double getNumericalMean() {\n         final double df = getDegreesOfFreedom();\n \n         if (df > 1) {\n      *  <li>else undefined ({@code Double.NaN}).</li>\n      * </ul>\n      */\n-    @Override\n-    protected double calculateNumericalVariance() {\n+    public double getNumericalVariance() {\n         final double df = getDegreesOfFreedom();\n \n         if (df > 2) {\n         return Double.NaN;\n     }\n \n-    /** {@inheritDoc} */\n-    @Override\n+    /**\n+     * {@inheritDoc}\n+     *\n+     * The lower bound of the support is always negative infinity no matter the\n+     * parameters.\n+     *\n+     * @return lower bound of the support (always\n+     * {@code Double.NEGATIVE_INFINITY})\n+     */\n+    public double getSupportLowerBound() {\n+        return Double.NEGATIVE_INFINITY;\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     *\n+     * The upper bound of the support is always positive infinity no matter the\n+     * parameters.\n+     *\n+     * @return upper bound of the support (always\n+     * {@code Double.POSITIVE_INFINITY})\n+     */\n+    public double getSupportUpperBound() {\n+        return Double.POSITIVE_INFINITY;\n+    }\n+\n+    /** {@inheritDoc} */\n     public boolean isSupportLowerBoundInclusive() {\n         return false;\n     }\n \n     /** {@inheritDoc} */\n-    @Override\n     public boolean isSupportUpperBoundInclusive() {\n         return false;\n     }\n+\n+    /**\n+     * {@inheritDoc}\n+     * \n+     * The support of this distribution is connected.\n+     * \n+     * @return {@code true}\n+     */\n+    public boolean isSupportConnected() {\n+        return true;\n+    }\n }\n--- a/src/main/java/org/apache/commons/math/distribution/WeibullDistribution.java\n+++ b/src/main/java/org/apache/commons/math/distribution/WeibullDistribution.java\n \n package org.apache.commons.math.distribution;\n \n-import java.io.Serializable;\n-\n import org.apache.commons.math.exception.OutOfRangeException;\n import org.apache.commons.math.exception.NotStrictlyPositiveException;\n import org.apache.commons.math.exception.util.LocalizedFormats;\n  * @since 1.1 (changed to concrete class in 3.0)\n  * @version $Id$\n  */\n-public class WeibullDistribution extends AbstractContinuousDistribution\n-    implements Serializable {\n+public class WeibullDistribution extends AbstractRealDistribution {\n+    /** Serializable version identifier. */\n+    private static final long serialVersionUID = 8589540077390120676L;\n+    \n     /**\n      * Default inverse cumulative probability accuracy.\n      * @since 2.1\n      */\n     public static final double DEFAULT_INVERSE_ABSOLUTE_ACCURACY = 1e-9;\n-    /** Serializable version identifier. */\n-    private static final long serialVersionUID = 8589540077390120676L;\n+    \n     /** The shape parameter. */\n     private final double shape;\n+    \n     /** The scale parameter. */\n     private final double scale;\n+    \n     /** Inverse cumulative probability accuracy. */\n     private final double solverAbsoluteAccuracy;\n+\n+    /** Cached numerical mean */\n+    private double numericalMean = Double.NaN;\n+\n+    /** Whether or not the numerical mean has been calculated */\n+    private boolean numericalMeanIsCalculated = false;\n+\n+    /** Cached numerical variance */\n+    private double numericalVariance = Double.NaN;\n+\n+    /** Whether or not the numerical variance has been calculated */\n+    private boolean numericalVarianceIsCalculated = false;\n \n     /**\n      * Create a Weibull distribution with the given shape and scale and a\n         solverAbsoluteAccuracy = inverseCumAccuracy;\n     }\n \n+    /**\n+     * Access the shape parameter, {@code alpha}.\n+     *\n+     * @return the shape parameter, {@code alpha}.\n+     */\n+    public double getShape() {\n+        return shape;\n+    }\n+\n+    /**\n+     * Access the scale parameter, {@code beta}.\n+     *\n+     * @return the scale parameter, {@code beta}.\n+     */\n+    public double getScale() {\n+        return scale;\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     *\n+     * For this distribution {@code P(X = x)} always evaluates to 0.\n+     *\n+     * @return 0\n+     */\n+    public double probability(double x) {\n+        return 0.0;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public double density(double x) {\n+        if (x < 0) {\n+            return 0;\n+        }\n+\n+        final double xscale = x / scale;\n+        final double xscalepow = FastMath.pow(xscale, shape - 1);\n+\n+        /*\n+         * FastMath.pow(x / scale, shape) =\n+         * FastMath.pow(xscale, shape) =\n+         * FastMath.pow(xscale, shape - 1) * xscale\n+         */\n+        final double xscalepowshape = xscalepow * xscale;\n+\n+        return (shape / scale) * xscalepow * FastMath.exp(-xscalepowshape);\n+    }\n+\n     /** {@inheritDoc} */\n     public double cumulativeProbability(double x) {\n         double ret;\n             ret = 1.0 - FastMath.exp(-FastMath.pow(x / scale, shape));\n         }\n         return ret;\n-    }\n-\n-    /**\n-     * Access the shape parameter, {@code alpha}.\n-     *\n-     * @return the shape parameter, {@code alpha}.\n-     */\n-    public double getShape() {\n-        return shape;\n-    }\n-\n-    /**\n-     * Access the scale parameter, {@code beta}.\n-     *\n-     * @return the scale parameter, {@code beta}.\n-     */\n-    public double getScale() {\n-        return scale;\n-    }\n-\n-    /** {@inheritDoc} */\n-    public double density(double x) {\n-        if (x < 0) {\n-            return 0;\n-        }\n-\n-        final double xscale = x / scale;\n-        final double xscalepow = FastMath.pow(xscale, shape - 1);\n-\n-        /*\n-         * FastMath.pow(x / scale, shape) =\n-         * FastMath.pow(xscale, shape) =\n-         * FastMath.pow(xscale, shape - 1) * xscale\n-         */\n-        final double xscalepowshape = xscalepow * xscale;\n-\n-        return (shape / scale) * xscalepow * FastMath.exp(-xscalepowshape);\n     }\n \n     /**\n         return 0;\n     }\n \n-    /** {@inheritDoc} */    @Override\n+    /** {@inheritDoc} */\n+    @Override\n     protected double getDomainUpperBound(double p) {\n         return Double.MAX_VALUE;\n     }\n \n-    /** {@inheritDoc} */    @Override\n+    /** {@inheritDoc} */\n+    @Override\n     protected double getInitialDomain(double p) {\n         // use median\n         return FastMath.pow(scale * FastMath.log(2.0), 1.0 / shape);\n     /**\n      * {@inheritDoc}\n      *\n-     * The lower bound of the support is always 0 no matter the parameters.\n-     *\n-     * @return lower bound of the support (always 0)\n-     */\n-    @Override\n-    public double getSupportLowerBound() {\n-        return 0;\n-    }\n-\n-    /**\n-     * {@inheritDoc}\n-     *\n-     * The upper bound of the support is always positive infinity\n-     * no matter the parameters.\n-     *\n-     * @return upper bound of the support (always\n-     * {@code Double.POSITIVE_INFINITY})\n-     */\n-    @Override\n-    public double getSupportUpperBound() {\n-        return Double.POSITIVE_INFINITY;\n-    }\n-\n-    /**\n-     * {@inheritDoc}\n-     *\n      * The mean is {@code scale * Gamma(1 + (1 / shape))}, where {@code Gamma()}\n      * is the Gamma-function.\n      */\n-    @Override\n+    public double getNumericalMean() {\n+        if (!numericalMeanIsCalculated) {\n+            numericalMean = calculateNumericalMean();\n+            numericalMeanIsCalculated = true;\n+        }\n+        return numericalMean;\n+    }\n+\n+    /**\n+     * used by {@link #getNumericalMean()}\n+     * \n+     * @return the mean of this distribution\n+     */\n     protected double calculateNumericalMean() {\n         final double sh = getShape();\n         final double sc = getScale();\n      * The variance is {@code scale^2 * Gamma(1 + (2 / shape)) - mean^2}\n      * where {@code Gamma()} is the Gamma-function.\n      */\n-    @Override\n+    public double getNumericalVariance() {\n+        if (!numericalVarianceIsCalculated) {\n+            numericalVariance = calculateNumericalVariance();\n+            numericalVarianceIsCalculated = true;\n+        }\n+        return numericalVariance;\n+    }\n+\n+    /**\n+     * used by {@link #getNumericalVariance()}\n+     * \n+     * @return the variance of this distribution\n+     */\n     protected double calculateNumericalVariance() {\n         final double sh = getShape();\n         final double sc = getScale();\n         final double mn = getNumericalMean();\n \n-        return (sc * sc) *\n-            FastMath.exp(Gamma.logGamma(1 + (2 / sh))) -\n-            (mn * mn);\n-    }\n-\n-    /** {@inheritDoc} */\n-    @Override\n+        return (sc * sc) * FastMath.exp(Gamma.logGamma(1 + (2 / sh)))\n+               - (mn * mn);\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     *\n+     * The lower bound of the support is always 0 no matter the parameters.\n+     *\n+     * @return lower bound of the support (always 0)\n+     */\n+    public double getSupportLowerBound() {\n+        return 0;\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     *\n+     * The upper bound of the support is always positive infinity\n+     * no matter the parameters.\n+     *\n+     * @return upper bound of the support (always\n+     * {@code Double.POSITIVE_INFINITY})\n+     */\n+    public double getSupportUpperBound() {\n+        return Double.POSITIVE_INFINITY;\n+    }\n+\n+    /** {@inheritDoc} */\n     public boolean isSupportLowerBoundInclusive() {\n         return true;\n     }\n \n     /** {@inheritDoc} */\n-    @Override\n     public boolean isSupportUpperBoundInclusive() {\n         return false;\n     }\n+\n+    /**\n+     * {@inheritDoc}\n+     * \n+     * The support of this distribution is connected.\n+     * \n+     * @return {@code true}\n+     */\n+    public boolean isSupportConnected() {\n+        return true;\n+    }\n }\n--- a/src/main/java/org/apache/commons/math/distribution/ZipfDistribution.java\n+++ b/src/main/java/org/apache/commons/math/distribution/ZipfDistribution.java\n \n package org.apache.commons.math.distribution;\n \n-import java.io.Serializable;\n-\n import org.apache.commons.math.exception.NotStrictlyPositiveException;\n import org.apache.commons.math.exception.util.LocalizedFormats;\n import org.apache.commons.math.util.FastMath;\n  * @see <a href=\"http://mathworld.wolfram.com/ZipfDistribution.html\">Zipf distribution (MathWorld)</a>\n  * @version $Id$\n  */\n-public class ZipfDistribution extends AbstractIntegerDistribution\n-    implements Serializable {\n+public class ZipfDistribution extends AbstractIntegerDistribution {\n     /** Serializable version identifier. */\n     private static final long serialVersionUID = -140627372283420404L;\n+\n     /** Number of elements. */\n     private final int numberOfElements;\n+\n     /** Exponent parameter of the distribution. */\n     private final double exponent;\n+\n+    /** Cached numerical mean */\n+    private double numericalMean = Double.NaN;\n+\n+    /** Whether or not the numerical mean has been calculated */\n+    private boolean numericalMeanIsCalculated = false;\n+\n+    /** Cached numerical variance */\n+    private double numericalVariance = Double.NaN;\n+\n+    /** Whether or not the numerical variance has been calculated */\n+    private boolean numericalVarianceIsCalculated = false;\n \n     /**\n      * Create a new Zipf distribution with the given number of elements and\n     }\n \n     /** {@inheritDoc} */\n-    @Override\n     public double cumulativeProbability(final int x) {\n         if (x <= 0) {\n             return 0.0;\n     @Override\n     protected int getDomainUpperBound(final double p) {\n         return numberOfElements;\n-    }\n-\n-    /**\n-     * Calculates the Nth generalized harmonic number. See\n-     * <a href=\"http://mathworld.wolfram.com/HarmonicSeries.html\">Harmonic\n-     * Series</a>.\n-     *\n-     * @param n Term in the series to calculate (must be larger than 1)\n-     * @param m Exponent (special case {@code m = 1} is the harmonic series).\n-     * @return the n<sup>th</sup> generalized harmonic number.\n-     */\n-    private double generalizedHarmonic(final int n, final double m) {\n-        double value = 0;\n-        for (int k = n; k > 0; --k) {\n-            value += 1.0 / FastMath.pow(k, m);\n-        }\n-        return value;\n-    }\n-\n-    /**\n-     * {@inheritDoc}\n-     *\n-     * The lower bound of the support is always 1 no matter the parameters.\n-     *\n-     * @return lower bound of the support (always 1)\n-     */\n-    @Override\n-    public int getSupportLowerBound() {\n-        return 1;\n-    }\n-\n-    /**\n-     * {@inheritDoc}\n-     *\n-     * The upper bound of the support is the number of elements.\n-     *\n-     * @return upper bound of the support\n-     */\n-    @Override\n-    public int getSupportUpperBound() {\n-        return getNumberOfElements();\n     }\n \n     /**\n      *  <li>{@code Hs = generalizedHarmonic(N, s)}.</li>\n      * </ul>\n      */\n-    @Override\n+    public double getNumericalMean() {\n+        if (!numericalMeanIsCalculated) {\n+            numericalMean = calculateNumericalMean();\n+            numericalMeanIsCalculated = true;\n+        }\n+        return numericalMean;\n+    }\n+\n+    /**\n+     * Used by {@link #getNumericalMean()}.\n+     * \n+     * @return the mean of this distribution\n+     */\n     protected double calculateNumericalMean() {\n         final int N = getNumberOfElements();\n         final double s = getExponent();\n      *  <li>{@code Hs = generalizedHarmonic(N, s)}.</li>\n      * </ul>\n      */\n-    @Override\n+    public double getNumericalVariance() {\n+        if (!numericalVarianceIsCalculated) {\n+            numericalVariance = calculateNumericalVariance();\n+            numericalVarianceIsCalculated = true;\n+        }\n+        return numericalVariance;\n+    }\n+\n+    /**\n+     * used by {@link #getNumericalVariance()}\n+     * \n+     * @return the variance of this distribution\n+     */\n     protected double calculateNumericalVariance() {\n         final int N = getNumberOfElements();\n         final double s = getExponent();\n \n         return (Hs2 / Hs) - ((Hs1 * Hs1) / (Hs * Hs));\n     }\n+\n+    /**\n+     * Calculates the Nth generalized harmonic number. See\n+     * <a href=\"http://mathworld.wolfram.com/HarmonicSeries.html\">Harmonic\n+     * Series</a>.\n+     *\n+     * @param n Term in the series to calculate (must be larger than 1)\n+     * @param m Exponent (special case {@code m = 1} is the harmonic series).\n+     * @return the n<sup>th</sup> generalized harmonic number.\n+     */\n+    private double generalizedHarmonic(final int n, final double m) {\n+        double value = 0;\n+        for (int k = n; k > 0; --k) {\n+            value += 1.0 / FastMath.pow(k, m);\n+        }\n+        return value;\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     *\n+     * The lower bound of the support is always 1 no matter the parameters.\n+     *\n+     * @return lower bound of the support (always 1)\n+     */\n+    public int getSupportLowerBound() {\n+        return 1;\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     *\n+     * The upper bound of the support is the number of elements.\n+     *\n+     * @return upper bound of the support\n+     */\n+    public int getSupportUpperBound() {\n+        return getNumberOfElements();\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     * \n+     * The support of this distribution is connected.\n+     * \n+     * @return {@code true}\n+     */\n+    public boolean isSupportConnected() {\n+        return true;\n+    }\n }\n--- a/src/main/java/org/apache/commons/math/random/RandomDataImpl.java\n+++ b/src/main/java/org/apache/commons/math/random/RandomDataImpl.java\n import org.apache.commons.math.distribution.BinomialDistribution;\n import org.apache.commons.math.distribution.CauchyDistribution;\n import org.apache.commons.math.distribution.ChiSquaredDistribution;\n-import org.apache.commons.math.distribution.ContinuousDistribution;\n+import org.apache.commons.math.distribution.RealDistribution;\n import org.apache.commons.math.distribution.FDistribution;\n import org.apache.commons.math.distribution.HypergeometricDistribution;\n import org.apache.commons.math.distribution.IntegerDistribution;\n \n     /**\n      * Generates a random value from the {@link BetaDistribution Beta Distribution}.\n-     * This implementation uses {@link #nextInversionDeviate(ContinuousDistribution) inversion}\n+     * This implementation uses {@link #nextInversionDeviate(RealDistribution) inversion}\n      * to generate random values.\n      *\n      * @param alpha first distribution shape parameter\n \n     /**\n      * Generates a random value from the {@link BinomialDistribution Binomial Distribution}.\n-     * This implementation uses {@link #nextInversionDeviate(ContinuousDistribution) inversion}\n+     * This implementation uses {@link #nextInversionDeviate(RealDistribution) inversion}\n      * to generate random values.\n      *\n      * @param numberOfTrials number of trials of the Binomial distribution\n \n     /**\n      * Generates a random value from the {@link CauchyDistribution Cauchy Distribution}.\n-     * This implementation uses {@link #nextInversionDeviate(ContinuousDistribution) inversion}\n+     * This implementation uses {@link #nextInversionDeviate(RealDistribution) inversion}\n      * to generate random values.\n      *\n      * @param median the median of the Cauchy distribution\n \n     /**\n      * Generates a random value from the {@link ChiSquaredDistribution ChiSquare Distribution}.\n-     * This implementation uses {@link #nextInversionDeviate(ContinuousDistribution) inversion}\n+     * This implementation uses {@link #nextInversionDeviate(RealDistribution) inversion}\n      * to generate random values.\n      *\n      * @param df the degrees of freedom of the ChiSquare distribution\n \n     /**\n      * Generates a random value from the {@link FDistribution F Distribution}.\n-     * This implementation uses {@link #nextInversionDeviate(ContinuousDistribution) inversion}\n+     * This implementation uses {@link #nextInversionDeviate(RealDistribution) inversion}\n      * to generate random values.\n      *\n      * @param numeratorDf the numerator degrees of freedom of the F distribution\n \n     /**\n      * Generates a random value from the {@link TDistribution T Distribution}.\n-     * This implementation uses {@link #nextInversionDeviate(ContinuousDistribution) inversion}\n+     * This implementation uses {@link #nextInversionDeviate(RealDistribution) inversion}\n      * to generate random values.\n      *\n      * @param df the degrees of freedom of the T distribution\n \n     /**\n      * Generates a random value from the {@link WeibullDistribution Weibull Distribution}.\n-     * This implementation uses {@link #nextInversionDeviate(ContinuousDistribution) inversion}\n+     * This implementation uses {@link #nextInversionDeviate(RealDistribution) inversion}\n      * to generate random values.\n      *\n      * @param shape the shape parameter of the Weibull distribution\n      * @return a random value sampled from the given distribution\n      * @since 2.2\n      */\n-    public double nextInversionDeviate(ContinuousDistribution distribution) {\n+    public double nextInversionDeviate(RealDistribution distribution) {\n         return distribution.inverseCumulativeProbability(nextUniform(0, 1));\n \n     }\n--- a/src/test/java/org/apache/commons/math/TestUtils.java\n+++ b/src/test/java/org/apache/commons/math/TestUtils.java\n \n import org.apache.commons.math.complex.Complex;\n import org.apache.commons.math.complex.ComplexFormat;\n-import org.apache.commons.math.distribution.ContinuousDistribution;\n+import org.apache.commons.math.distribution.RealDistribution;\n import org.apache.commons.math.linear.FieldMatrix;\n import org.apache.commons.math.linear.RealMatrix;\n import org.apache.commons.math.stat.inference.ChiSquareTest;\n      * Computes the 25th, 50th and 75th percentiles of the given distribution and returns\n      * these values in an array.\n      */\n-    public static double[] getDistributionQuartiles(ContinuousDistribution distribution) throws Exception {\n+    public static double[] getDistributionQuartiles(RealDistribution distribution) throws Exception {\n         double[] quantiles = new double[3];\n         quantiles[0] = distribution.inverseCumulativeProbability(0.25d);\n         quantiles[1] = distribution.inverseCumulativeProbability(0.5d);\n--- a/src/test/java/org/apache/commons/math/distribution/AbtractIntegerDistributionTest.java\n+++ b/src/test/java/org/apache/commons/math/distribution/AbtractIntegerDistributionTest.java\n  * See the License for the specific language governing permissions and\n  * limitations under the License.\n  */\n-\n package org.apache.commons.math.distribution;\n \n import org.junit.Assert;\n     }\n     \n     @Test\n-    public void testCumulativeProbabilitiesSingleDoubleArguments() throws Exception {\n-        int lower = 1;\n-        double arg = 0;\n-        for (int i = 1; i < 7; i++) {\n-            // Exact integer\n-            arg = lower;\n-            Assert.assertEquals(p * i,\n-                    diceDistribution.cumulativeProbability(arg), Double.MIN_VALUE);\n-            \n-            // Add a fraction\n-            arg = lower + Math.random();\n-            Assert.assertEquals(p * i,\n-                    diceDistribution.cumulativeProbability(arg), Double.MIN_VALUE);\n-            lower++;\n-        }\n-    }\n-    \n-    @Test\n-    public void testCumulativeProbabilitiesRangeIntegerArguments() throws Exception {\n+    public void testCumulativeProbabilitiesRangeArguments() throws Exception {\n         int lower = 1;\n         int upper = 6;\n         for (int i = 0; i < 2; i++) {\n         }\n     }\n     \n-    @Test\n-    public void testCumulativeProbabilitiesRangeDoubleArguments() throws Exception {\n-        int lower = 1;\n-        int upper = 6;\n-        double dlower = lower;\n-        double dupper = upper;\n-        for (int i = 0; i < 2; i++) {\n-            // cum(1,6) = p(1 <= X <= 6) = 1, cum(2,5) = 4/6, cum(3,4) = 2/6 \n-            // Exact integers\n-            Assert.assertEquals(1 - p * 2 * i, \n-                    diceDistribution.cumulativeProbability(dlower, dupper), 1E-12);\n-            // Subtract a fraction from lower, add to upper.  Should be no change.\n-            dlower -= Math.random();\n-            dupper += Math.random();\n-            Assert.assertEquals(1 - p * 2 * i, \n-                    diceDistribution.cumulativeProbability(dlower, dupper), 1E-12);\n-            lower++;\n-            upper--;\n-            dlower = lower;\n-            dupper = upper;\n-        }\n-        for (int i = 1; i < 7; i++) {\n-            lower = i;\n-            Assert.assertEquals(p, diceDistribution.cumulativeProbability(\n-                    lower, lower), 1E-12);\n-            Assert.assertEquals(p, diceDistribution.cumulativeProbability(\n-                    lower, lower + Math.random()), 1E-12);\n-            Assert.assertEquals(p, diceDistribution.cumulativeProbability(\n-                    lower - Math.random(), lower), 1E-12);\n-            Assert.assertEquals(p, diceDistribution.cumulativeProbability(\n-                    lower - Math.random(), lower + Math.random()), 1E-12);\n-        }\n-    }\n-\n     /**\n      * Simple distribution modeling a 6-sided die\n      */\n     class DiceDistribution extends AbstractIntegerDistribution {\n         public static final long serialVersionUID = 23734213;\n+\n         private final double p = 1d/6d;\n+\n         public double probability(int x) {\n             if (x < 1 || x > 6) {\n                 return 0;\n             }\n         }\n \n-        @Override\n         public double cumulativeProbability(int x) {\n             if (x < 1) {\n                 return 0;\n             return 6;\n         }\n \n-        @Override\n+        public double getNumericalMean() {\n+            return 3.5;\n+        }\n+\n+        public double getNumericalVariance() {\n+            return 12.5 - 3.5 * 3.5;  // E(X^2) - E(X)^2\n+        }\n+\n         public int getSupportLowerBound() {\n             return 1;\n         }\n \n-        @Override\n         public int getSupportUpperBound() {\n             return 6;\n         }\n \n-        @Override\n-        protected double calculateNumericalMean() {\n-            return 3.5;\n-        }\n-\n-        @Override\n-        protected double calculateNumericalVariance() {\n-            return 12.5 - 3.5 * 3.5;  // E(X^2) - E(X)^2\n+        public final boolean isSupportConnected() {\n+            return true;\n         }\n     }\n }\n--- a/src/test/java/org/apache/commons/math/distribution/CauchyDistributionTest.java\n+++ b/src/test/java/org/apache/commons/math/distribution/CauchyDistributionTest.java\n  *\n  * @version $Id$\n  */\n-public class CauchyDistributionTest extends ContinuousDistributionAbstractTest  {\n+public class CauchyDistributionTest extends RealDistributionAbstractTest {\n \n     // --------------------- Override tolerance  --------------\n     protected double defaultTolerance = NormalDistribution.DEFAULT_INVERSE_ABSOLUTE_ACCURACY;\n--- a/src/test/java/org/apache/commons/math/distribution/ChiSquaredDistributionTest.java\n+++ b/src/test/java/org/apache/commons/math/distribution/ChiSquaredDistributionTest.java\n /**\n  * Test cases for {@link ChiSquaredDistribution}.\n  *\n- * @see ContinuousDistributionAbstractTest\n+ * @see RealDistributionAbstractTest\n  * @version $Id$\n  */\n-public class ChiSquaredDistributionTest extends ContinuousDistributionAbstractTest {\n+public class ChiSquaredDistributionTest extends RealDistributionAbstractTest {\n \n     //-------------- Implementations for abstract methods -----------------------\n \n         Assert.assertEquals(dist.getNumericalMean(), 1.12, tol);\n         Assert.assertEquals(dist.getNumericalVariance(), 2.24, tol);\n     }\n-\n }\n--- a/src/test/java/org/apache/commons/math/distribution/ExponentialDistributionTest.java\n+++ b/src/test/java/org/apache/commons/math/distribution/ExponentialDistributionTest.java\n  *\n  * @version $Id$\n  */\n-public class ExponentialDistributionTest extends ContinuousDistributionAbstractTest {\n+public class ExponentialDistributionTest extends RealDistributionAbstractTest {\n \n     // --------------------- Override tolerance  --------------\n     @Override\n--- a/src/test/java/org/apache/commons/math/distribution/FDistributionTest.java\n+++ b/src/test/java/org/apache/commons/math/distribution/FDistributionTest.java\n  *\n  * @version $Id$\n  */\n-public class FDistributionTest extends ContinuousDistributionAbstractTest {\n+public class FDistributionTest extends RealDistributionAbstractTest {\n \n     //-------------- Implementations for abstract methods -----------------------\n \n--- a/src/test/java/org/apache/commons/math/distribution/GammaDistributionTest.java\n+++ b/src/test/java/org/apache/commons/math/distribution/GammaDistributionTest.java\n  *\n  * @version $Id$\n  */\n-public class GammaDistributionTest extends ContinuousDistributionAbstractTest {\n+public class GammaDistributionTest extends RealDistributionAbstractTest {\n \n     //-------------- Implementations for abstract methods -----------------------\n \n--- a/src/test/java/org/apache/commons/math/distribution/IntegerDistributionAbstractTest.java\n+++ b/src/test/java/org/apache/commons/math/distribution/IntegerDistributionAbstractTest.java\n package org.apache.commons.math.distribution;\n \n import org.apache.commons.math.TestUtils;\n-import org.apache.commons.math.util.FastMath;\n import org.apache.commons.math.exception.MathIllegalArgumentException;\n import org.junit.After;\n import org.junit.Assert;\n import org.junit.Before;\n import org.junit.Test;\n-\n \n /**\n  * Abstract base class for {@link IntegerDistribution} tests.\n     }\n \n     /**\n-     * Verifies that floating point arguments are correctly handled by\n-     * cumulativeProbablility(-,-)\n-     * JIRA: MATH-184\n-     */\n-    @Test\n-    public void testFloatingPointArguments() throws Exception {\n-        for (int i = 0; i < cumulativeTestPoints.length; i++) {\n-            double arg = cumulativeTestPoints[i];\n-            Assert.assertEquals(\n-                    \"Incorrect cumulative probability value returned for \" +\n-                    cumulativeTestPoints[i],\n-                    cumulativeTestValues[i],\n-                    distribution.cumulativeProbability(arg), tolerance);\n-            if (i < cumulativeTestPoints.length - 1) {\n-                double arg2 = cumulativeTestPoints[i + 1];\n-                Assert.assertEquals(\"Inconsistent probability for discrete range \" +\n-                        \"[ \" + arg + \",\" + arg2 + \" ]\",\n-                   distribution.cumulativeProbability(\n-                           cumulativeTestPoints[i],\n-                           cumulativeTestPoints[i + 1]),\n-                   distribution.cumulativeProbability(arg, arg2), tolerance);\n-                arg = arg - FastMath.random();\n-                arg2 = arg2 + FastMath.random();\n-                Assert.assertEquals(\"Inconsistent probability for discrete range \" +\n-                        \"[ \" + arg + \",\" + arg2 + \" ]\",\n-                   distribution.cumulativeProbability(\n-                           cumulativeTestPoints[i],\n-                           cumulativeTestPoints[i + 1]),\n-                   distribution.cumulativeProbability(arg, arg2), tolerance);\n-            }\n-        }\n-        int one = 1;\n-        int ten = 10;\n-        int two = 2;\n-        double oned = one;\n-        double twod = two;\n-        double tend = ten;\n-        Assert.assertEquals(distribution.cumulativeProbability(one, two),\n-                distribution.cumulativeProbability(oned, twod), tolerance);\n-        Assert.assertEquals(distribution.cumulativeProbability(one, two),\n-                distribution.cumulativeProbability(oned - tolerance,\n-                        twod + 0.9), tolerance);\n-        Assert.assertEquals(distribution.cumulativeProbability(two, ten),\n-                distribution.cumulativeProbability(twod, tend), tolerance);\n-        Assert.assertEquals(distribution.cumulativeProbability(two, ten),\n-                distribution.cumulativeProbability(twod - tolerance,\n-                        tend + 0.9), tolerance);\n-    }\n-\n-    /**\n      * Verifies that inverse cumulative probability density calculations match expected values\n      * using default test instance data\n      */\n--- a/src/test/java/org/apache/commons/math/distribution/NormalDistributionTest.java\n+++ b/src/test/java/org/apache/commons/math/distribution/NormalDistributionTest.java\n  *\n  * @version $Id$\n  */\n-public class NormalDistributionTest extends ContinuousDistributionAbstractTest  {\n+public class NormalDistributionTest extends RealDistributionAbstractTest {\n \n     //-------------- Implementations for abstract methods -----------------------\n \n--- a/src/test/java/org/apache/commons/math/distribution/PoissonDistributionTest.java\n+++ b/src/test/java/org/apache/commons/math/distribution/PoissonDistributionTest.java\n             double sigma = FastMath.sqrt(mean);\n             while (x >= 0) {\n                 try {\n-                    p = dist.cumulativeProbability(x);\n+                    p = dist.cumulativeProbability((int) x);\n                     Assert.assertFalse(\"NaN cumulative probability returned for mean = \" +\n                             mean + \" x = \" + x,Double.isNaN(p));\n                     if (x > mean - 2 * sigma) {\n         checkProbability(dist, 6950);\n     }\n \n-    private void checkProbability(PoissonDistribution dist, double x) throws Exception {\n+    private void checkProbability(PoissonDistribution dist, int x) throws Exception {\n         double p = dist.cumulativeProbability(x);\n         Assert.assertFalse(\"NaN cumulative probability returned for mean = \" +\n                 dist.getMean() + \" x = \" + x, Double.isNaN(p));\n             double p = 0.1;\n             double dp = p;\n             while (p < .99) {\n-                double ret = Double.NaN;\n                 try {\n-                    ret = dist.inverseCumulativeProbability(p);\n+                    int ret = dist.inverseCumulativeProbability(p);\n                     // Verify that returned value satisties definition\n                     Assert.assertTrue(p >= dist.cumulativeProbability(ret));\n                     Assert.assertTrue(p < dist.cumulativeProbability(ret + 1));\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/math/distribution/RealDistributionAbstractTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.distribution;\n+\n+\n+import org.apache.commons.math.TestUtils;\n+import org.apache.commons.math.util.FastMath;\n+import org.apache.commons.math.exception.MathIllegalArgumentException;\n+import org.apache.commons.math.exception.NumberIsTooLargeException;\n+import org.junit.After;\n+import org.junit.Assert;\n+import org.junit.Before;\n+import org.junit.Test;\n+\n+/**\n+ * Abstract base class for {@link RealDistribution} tests.\n+ * <p>\n+ * To create a concrete test class for a continuous distribution\n+ * implementation, first implement makeDistribution() to return a distribution\n+ * instance to use in tests. Then implement each of the test data generation\n+ * methods below.  In each case, the test points and test values arrays\n+ * returned represent parallel arrays of inputs and expected values for the\n+ * distribution returned by makeDistribution().  Default implementations\n+ * are provided for the makeInverseXxx methods that just invert the mapping\n+ * defined by the arrays returned by the makeCumulativeXxx methods.\n+ * <p>\n+ * makeCumulativeTestPoints() -- arguments used to test cumulative probabilities\n+ * makeCumulativeTestValues() -- expected cumulative probabilites\n+ * makeDensityTestValues() -- expected density values at cumulativeTestPoints\n+ * makeInverseCumulativeTestPoints() -- arguments used to test inverse cdf\n+ * makeInverseCumulativeTestValues() -- expected inverse cdf values\n+ * <p>\n+ * To implement additional test cases with different distribution instances and\n+ * test data, use the setXxx methods for the instance data in test cases and\n+ * call the verifyXxx methods to verify results.\n+ * <p>\n+ * Error tolerance can be overriden by implementing getTolerance().\n+ * <p>\n+ * Test data should be validated against reference tables or other packages\n+ * where possible, and the source of the reference data and/or validation\n+ * should be documented in the test cases.  A framework for validating\n+ * distribution data against R is included in the /src/test/R source tree.\n+ * <p>\n+ * See {@link NormalDistributionTest} and {@link ChiSquaredDistributionTest}\n+ * for examples.\n+ *\n+ * @version $Id$\n+ */\n+public abstract class RealDistributionAbstractTest {\n+\n+//-------------------- Private test instance data -------------------------\n+    /**  Distribution instance used to perform tests */\n+    private RealDistribution distribution;\n+\n+    /** Tolerance used in comparing expected and returned values */\n+    private double tolerance = 1E-4;\n+\n+    /** Arguments used to test cumulative probability density calculations */\n+    private double[] cumulativeTestPoints;\n+\n+    /** Values used to test cumulative probability density calculations */\n+    private double[] cumulativeTestValues;\n+\n+    /** Arguments used to test inverse cumulative probability density calculations */\n+    private double[] inverseCumulativeTestPoints;\n+\n+    /** Values used to test inverse cumulative probability density calculations */\n+    private double[] inverseCumulativeTestValues;\n+\n+    /** Values used to test density calculations */\n+    private double[] densityTestValues;\n+\n+    //-------------------- Abstract methods -----------------------------------\n+\n+    /** Creates the default continuous distribution instance to use in tests. */\n+    public abstract RealDistribution makeDistribution();\n+\n+    /** Creates the default cumulative probability test input values */\n+    public abstract double[] makeCumulativeTestPoints();\n+\n+    /** Creates the default cumulative probability test expected values */\n+    public abstract double[] makeCumulativeTestValues();\n+\n+    /** Creates the default density test expected values */\n+    public abstract double[] makeDensityTestValues();\n+\n+    //---- Default implementations of inverse test data generation methods ----\n+\n+    /** Creates the default inverse cumulative probability test input values */\n+    public double[] makeInverseCumulativeTestPoints() {\n+        return makeCumulativeTestValues();\n+    }\n+\n+    /** Creates the default inverse cumulative probability density test expected values */\n+    public double[] makeInverseCumulativeTestValues() {\n+        return makeCumulativeTestPoints();\n+    }\n+\n+    //-------------------- Setup / tear down ----------------------------------\n+\n+    /**\n+     * Setup sets all test instance data to default values\n+     */\n+    @Before\n+    public void setUp() throws Exception {\n+        distribution = makeDistribution();\n+        cumulativeTestPoints = makeCumulativeTestPoints();\n+        cumulativeTestValues = makeCumulativeTestValues();\n+        inverseCumulativeTestPoints = makeInverseCumulativeTestPoints();\n+        inverseCumulativeTestValues = makeInverseCumulativeTestValues();\n+        densityTestValues = makeDensityTestValues();\n+    }\n+\n+    /**\n+     * Cleans up test instance data\n+     */\n+    @After\n+    public void tearDown() throws Exception {\n+        distribution = null;\n+        cumulativeTestPoints = null;\n+        cumulativeTestValues = null;\n+        inverseCumulativeTestPoints = null;\n+        inverseCumulativeTestValues = null;\n+        densityTestValues = null;\n+    }\n+\n+    //-------------------- Verification methods -------------------------------\n+\n+    /**\n+     * Verifies that cumulative probability density calculations match expected values\n+     * using current test instance data\n+     */\n+    protected void verifyCumulativeProbabilities() throws Exception {\n+        // verify cumulativeProbability(double)\n+        for (int i = 0; i < cumulativeTestPoints.length; i++) {\n+            TestUtils.assertEquals(\"Incorrect cumulative probability value returned for \"\n+                + cumulativeTestPoints[i], cumulativeTestValues[i],\n+                distribution.cumulativeProbability(cumulativeTestPoints[i]),\n+                getTolerance());\n+        }\n+        // verify cumulativeProbability(double, double)\n+        for (int i = 0; i < cumulativeTestPoints.length; i++) {\n+            for (int j = 0; j < cumulativeTestPoints.length; j++) {\n+                if (cumulativeTestPoints[i] <= cumulativeTestPoints[j]) {\n+                    TestUtils.assertEquals(cumulativeTestValues[j] - cumulativeTestValues[i],\n+                        distribution.cumulativeProbability(cumulativeTestPoints[i], cumulativeTestPoints[j]),\n+                        getTolerance());\n+                } else {\n+                    try {\n+                        distribution.cumulativeProbability(cumulativeTestPoints[i], cumulativeTestPoints[j]);\n+                    } catch (NumberIsTooLargeException e) {\n+                        continue;\n+                    }\n+                    Assert.fail(\"distribution.cumulativeProbability(double, double) should have thrown an exception that second argument is too large\");\n+                }\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Verifies that inverse cumulative probability density calculations match expected values\n+     * using current test instance data\n+     */\n+    protected void verifyInverseCumulativeProbabilities() throws Exception {\n+        for (int i = 0; i < inverseCumulativeTestPoints.length; i++) {\n+            TestUtils.assertEquals(\"Incorrect inverse cumulative probability value returned for \"\n+                + inverseCumulativeTestPoints[i], inverseCumulativeTestValues[i],\n+                 distribution.inverseCumulativeProbability(inverseCumulativeTestPoints[i]),\n+                 getTolerance());\n+        }\n+    }\n+\n+    /**\n+     * Verifies that density calculations match expected values\n+     */\n+    protected void verifyDensities() throws Exception {\n+        for (int i = 0; i < cumulativeTestPoints.length; i++) {\n+            TestUtils.assertEquals(\"Incorrect probability density value returned for \"\n+                + cumulativeTestPoints[i], densityTestValues[i],\n+                 distribution.density(cumulativeTestPoints[i]),\n+                 getTolerance());\n+        }\n+    }\n+\n+    //------------------------ Default test cases -----------------------------\n+\n+    /**\n+     * Verifies that cumulative probability density calculations match expected values\n+     * using default test instance data\n+     */\n+    @Test\n+    public void testCumulativeProbabilities() throws Exception {\n+        verifyCumulativeProbabilities();\n+    }\n+\n+    /**\n+     * Verifies that inverse cumulative probability density calculations match expected values\n+     * using default test instance data\n+     */\n+    @Test\n+    public void testInverseCumulativeProbabilities() throws Exception {\n+        verifyInverseCumulativeProbabilities();\n+    }\n+\n+    /**\n+     * Verifies that density calculations return expected values\n+     * for default test instance data\n+     */\n+    @Test\n+    public void testDensities() throws Exception {\n+        verifyDensities();\n+    }\n+\n+    /**\n+     * Verifies that probability computations are consistent\n+     */\n+    @Test\n+    public void testConsistency() throws Exception {\n+        for (int i=1; i < cumulativeTestPoints.length; i++) {\n+\n+            // check that cdf(x, x) = 0\n+            TestUtils.assertEquals(0d,\n+               distribution.cumulativeProbability\n+                 (cumulativeTestPoints[i], cumulativeTestPoints[i]), tolerance);\n+\n+            // check that P(a < X <= b) = P(X <= b) - P(X <= a)\n+            double upper = FastMath.max(cumulativeTestPoints[i], cumulativeTestPoints[i -1]);\n+            double lower = FastMath.min(cumulativeTestPoints[i], cumulativeTestPoints[i -1]);\n+            double diff = distribution.cumulativeProbability(upper) -\n+                distribution.cumulativeProbability(lower);\n+            double direct = distribution.cumulativeProbability(lower, upper);\n+            TestUtils.assertEquals(\"Inconsistent cumulative probabilities for (\"\n+                    + lower + \",\" + upper + \")\", diff, direct, tolerance);\n+        }\n+    }\n+\n+    /**\n+     * Verifies that illegal arguments are correctly handled\n+     */\n+    @Test\n+    public void testIllegalArguments() throws Exception {\n+        try {\n+            distribution.cumulativeProbability(1, 0);\n+            Assert.fail(\"Expecting MathIllegalArgumentException for bad cumulativeProbability interval\");\n+        } catch (MathIllegalArgumentException ex) {\n+            // expected\n+        }\n+        try {\n+            distribution.inverseCumulativeProbability(-1);\n+            Assert.fail(\"Expecting MathIllegalArgumentException for p = -1\");\n+        } catch (MathIllegalArgumentException ex) {\n+            // expected\n+        }\n+        try {\n+            distribution.inverseCumulativeProbability(2);\n+            Assert.fail(\"Expecting MathIllegalArgumentException for p = 2\");\n+        } catch (MathIllegalArgumentException ex) {\n+            // expected\n+        }\n+    }\n+    \n+    /**\n+     * Test sampling\n+     */\n+    @Test\n+    public void testSampling() throws Exception {\n+        final int sampleSize = 1000;\n+        distribution.reseedRandomGenerator(1000); // Use fixed seed\n+        double[] sample = distribution.sample(sampleSize);\n+        double[] quartiles = TestUtils.getDistributionQuartiles(distribution);\n+        double[] expected = {250, 250, 250, 250};\n+        long[] counts = new long[4];\n+        for (int i = 0; i < sampleSize; i++) {\n+            TestUtils.updateCounts(sample[i], counts, quartiles);\n+        }\n+        TestUtils.assertChiSquareAccept(expected, counts, 0.001);\n+    }\n+\n+    //------------------ Getters / Setters for test instance data -----------\n+    /**\n+     * @return Returns the cumulativeTestPoints.\n+     */\n+    protected double[] getCumulativeTestPoints() {\n+        return cumulativeTestPoints;\n+    }\n+\n+    /**\n+     * @param cumulativeTestPoints The cumulativeTestPoints to set.\n+     */\n+    protected void setCumulativeTestPoints(double[] cumulativeTestPoints) {\n+        this.cumulativeTestPoints = cumulativeTestPoints;\n+    }\n+\n+    /**\n+     * @return Returns the cumulativeTestValues.\n+     */\n+    protected double[] getCumulativeTestValues() {\n+        return cumulativeTestValues;\n+    }\n+\n+    /**\n+     * @param cumulativeTestValues The cumulativeTestValues to set.\n+     */\n+    protected void setCumulativeTestValues(double[] cumulativeTestValues) {\n+        this.cumulativeTestValues = cumulativeTestValues;\n+    }\n+\n+    protected double[] getDensityTestValues() {\n+        return densityTestValues;\n+    }\n+\n+    protected void setDensityTestValues(double[] densityTestValues) {\n+        this.densityTestValues = densityTestValues;\n+    }\n+\n+    /**\n+     * @return Returns the distribution.\n+     */\n+    protected RealDistribution getDistribution() {\n+        return distribution;\n+    }\n+\n+    /**\n+     * @param distribution The distribution to set.\n+     */\n+    protected void setDistribution(RealDistribution distribution) {\n+        this.distribution = distribution;\n+    }\n+\n+    /**\n+     * @return Returns the inverseCumulativeTestPoints.\n+     */\n+    protected double[] getInverseCumulativeTestPoints() {\n+        return inverseCumulativeTestPoints;\n+    }\n+\n+    /**\n+     * @param inverseCumulativeTestPoints The inverseCumulativeTestPoints to set.\n+     */\n+    protected void setInverseCumulativeTestPoints(double[] inverseCumulativeTestPoints) {\n+        this.inverseCumulativeTestPoints = inverseCumulativeTestPoints;\n+    }\n+\n+    /**\n+     * @return Returns the inverseCumulativeTestValues.\n+     */\n+    protected double[] getInverseCumulativeTestValues() {\n+        return inverseCumulativeTestValues;\n+    }\n+\n+    /**\n+     * @param inverseCumulativeTestValues The inverseCumulativeTestValues to set.\n+     */\n+    protected void setInverseCumulativeTestValues(double[] inverseCumulativeTestValues) {\n+        this.inverseCumulativeTestValues = inverseCumulativeTestValues;\n+    }\n+\n+    /**\n+     * @return Returns the tolerance.\n+     */\n+    protected double getTolerance() {\n+        return tolerance;\n+    }\n+\n+    /**\n+     * @param tolerance The tolerance to set.\n+     */\n+    protected void setTolerance(double tolerance) {\n+        this.tolerance = tolerance;\n+    }\n+\n+}\n--- a/src/test/java/org/apache/commons/math/distribution/TDistributionTest.java\n+++ b/src/test/java/org/apache/commons/math/distribution/TDistributionTest.java\n  *\n  * @version $Id$\n  */\n-public class TDistributionTest extends ContinuousDistributionAbstractTest {\n+public class TDistributionTest extends RealDistributionAbstractTest {\n \n //-------------- Implementations for abstract methods -----------------------\n \n--- a/src/test/java/org/apache/commons/math/distribution/WeibullDistributionTest.java\n+++ b/src/test/java/org/apache/commons/math/distribution/WeibullDistributionTest.java\n  *\n  * @version $Id$\n  */\n-public class WeibullDistributionTest extends ContinuousDistributionAbstractTest  {\n+public class WeibullDistributionTest extends RealDistributionAbstractTest {\n \n     //-------------- Implementations for abstract methods -----------------------\n ", "timestamp": 1322893039, "metainfo": ""}