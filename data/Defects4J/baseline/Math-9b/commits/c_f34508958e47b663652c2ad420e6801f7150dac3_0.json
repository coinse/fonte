{"sha": "f34508958e47b663652c2ad420e6801f7150dac3", "log": "MATH-577 Replaced function calls by direct reference to the instance variable. Removed redundant prefix for static fields.   ", "commit": "\n--- a/src/main/java/org/apache/commons/math/complex/Complex.java\n+++ b/src/main/java/org/apache/commons/math/complex/Complex.java\n      * @return the absolute value\n      */\n     public double abs() {\n-        if (isNaN()) {\n+        if (isNaN) {\n             return Double.NaN;\n         }\n \n      * @return the conjugate of this Complex object\n      */\n     public Complex conjugate() {\n-        if (isNaN()) {\n+        if (isNaN) {\n             return NaN;\n         }\n         return createComplex(real, -imaginary);\n     public Complex divide(Complex rhs)\n         throws NullArgumentException {\n         MathUtils.checkNotNull(rhs);\n-        if (isNaN() || rhs.isNaN()) {\n+        if (isNaN || rhs.isNaN) {\n             return NaN;\n         }\n \n         }\n         if (other instanceof Complex){\n             Complex rhs = (Complex)other;\n-            if (rhs.isNaN()) {\n-                return this.isNaN();\n+            if (rhs.isNaN) {\n+                return isNaN;\n             } else {\n                 return (real == rhs.real) && (imaginary == rhs.imaginary);\n             }\n      */\n     @Override\n     public int hashCode() {\n-        if (isNaN()) {\n+        if (isNaN) {\n             return 7;\n         }\n         return 37 * (17 * MathUtils.hash(imaginary) +\n     public Complex multiply(Complex rhs)\n         throws NullArgumentException {\n         MathUtils.checkNotNull(rhs);\n-        if (isNaN() || rhs.isNaN()) {\n+        if (isNaN || rhs.isNaN) {\n             return NaN;\n         }\n         if (Double.isInfinite(real) || Double.isInfinite(imaginary) ||\n      * @return the complex number product\n      */\n     public Complex multiply(double rhs) {\n-        if (isNaN() || Double.isNaN(rhs)) {\n+        if (isNaN || Double.isNaN(rhs)) {\n             return NaN;\n         }\n         if (Double.isInfinite(real) || Double.isInfinite(imaginary) ||\n      * @return the negation of this complex number\n      */\n     public Complex negate() {\n-        if (isNaN()) {\n+        if (isNaN) {\n             return NaN;\n         }\n \n     public Complex subtract(Complex rhs)\n         throws NullArgumentException {\n         MathUtils.checkNotNull(rhs);\n-        if (isNaN() || rhs.isNaN()) {\n+        if (isNaN || rhs.isNaN) {\n             return NaN;\n         }\n \n      * @since 1.2\n      */\n     public Complex acos() {\n-        if (isNaN()) {\n-            return Complex.NaN;\n+        if (isNaN) {\n+            return NaN;\n         }\n \n         return this.add(this.sqrt1z().multiply(Complex.I)).log()\n      * @since 1.2\n      */\n     public Complex asin() {\n-        if (isNaN()) {\n-            return Complex.NaN;\n+        if (isNaN) {\n+            return NaN;\n         }\n \n         return sqrt1z().add(this.multiply(Complex.I)).log()\n      * @since 1.2\n      */\n     public Complex atan() {\n-        if (isNaN()) {\n-            return Complex.NaN;\n+        if (isNaN) {\n+            return NaN;\n         }\n \n         return this.add(Complex.I).divide(Complex.I.subtract(this)).log()\n      * @since 1.2\n      */\n     public Complex cos() {\n-        if (isNaN()) {\n-            return Complex.NaN;\n+        if (isNaN) {\n+            return NaN;\n         }\n \n         return createComplex(FastMath.cos(real) * MathUtils.cosh(imaginary),\n      * @since 1.2\n      */\n     public Complex cosh() {\n-        if (isNaN()) {\n-            return Complex.NaN;\n+        if (isNaN) {\n+            return NaN;\n         }\n \n         return createComplex(MathUtils.cosh(real) * FastMath.cos(imaginary),\n      * @since 1.2\n      */\n     public Complex exp() {\n-        if (isNaN()) {\n-            return Complex.NaN;\n+        if (isNaN) {\n+            return NaN;\n         }\n \n         double expReal = FastMath.exp(real);\n      * @since 1.2\n      */\n     public Complex log() {\n-        if (isNaN()) {\n-            return Complex.NaN;\n+        if (isNaN) {\n+            return NaN;\n         }\n \n         return createComplex(FastMath.log(abs()),\n      * @since 1.2\n      */\n     public Complex sin() {\n-        if (isNaN()) {\n-            return Complex.NaN;\n+        if (isNaN) {\n+            return NaN;\n         }\n \n         return createComplex(FastMath.sin(real) * MathUtils.cosh(imaginary),\n      * @since 1.2\n      */\n     public Complex sinh() {\n-        if (isNaN()) {\n-            return Complex.NaN;\n+        if (isNaN) {\n+            return NaN;\n         }\n \n         return createComplex(MathUtils.sinh(real) * FastMath.cos(imaginary),\n      * @since 1.2\n      */\n     public Complex sqrt() {\n-        if (isNaN()) {\n-            return Complex.NaN;\n+        if (isNaN) {\n+            return NaN;\n         }\n \n         if (real == 0.0 && imaginary == 0.0) {\n      * @since 1.2\n      */\n     public Complex tan() {\n-        if (isNaN()) {\n-            return Complex.NaN;\n+        if (isNaN) {\n+            return NaN;\n         }\n \n         double real2 = 2.0 * real;\n      * @since 1.2\n      */\n     public Complex tanh() {\n-        if (isNaN()) {\n-            return Complex.NaN;\n+        if (isNaN) {\n+            return NaN;\n         }\n \n         double real2 = 2.0 * real;\n \n         List<Complex> result = new ArrayList<Complex>();\n \n-        if (isNaN()) {\n-            result.add(Complex.NaN);\n+        if (isNaN) {\n+            result.add(NaN);\n             return result;\n         }\n \n         if (isInfinite()) {\n-            result.add(Complex.INF);\n+            result.add(INF);\n             return result;\n         }\n ", "timestamp": 1310551856, "metainfo": ""}