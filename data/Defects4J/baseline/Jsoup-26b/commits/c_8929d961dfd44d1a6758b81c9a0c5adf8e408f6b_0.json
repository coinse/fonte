{"sha": "8929d961dfd44d1a6758b81c9a0c5adf8e408f6b", "log": "Implemented Jsoup.parse(File), and javadocced.", "commit": "\n--- /dev/null\n+++ b/src/main/java/org/jsoup/DataUtil.java\n+package org.jsoup;\n+\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.InputStreamReader;\n+import java.io.Reader;\n+\n+/**\n+ * Internal static utilities for handling data.\n+ *\n+ */\n+class DataUtil {\n+    \n+    /**\n+     * Loads a file to a String.\n+     * @param in\n+     * @param charsetName\n+     * @return\n+     * @throws IOException\n+     */\n+    static String load(File in, String charsetName) throws IOException {        \n+        char[] buffer = new char[0x20000]; // ~ 130K\n+        StringBuilder data = new StringBuilder(0x20000);\n+        InputStream inStream = new FileInputStream(in);\n+        Reader inReader = new InputStreamReader(inStream, charsetName);\n+        int read;\n+        do {\n+            read = inReader.read(buffer, 0, buffer.length);\n+            if (read > 0) {\n+                data.append(buffer, 0, read);\n+            }\n+            \n+        } while (read >= 0);\n+        \n+        return data.toString();        \n+    }\n+    \n+}\n--- a/src/main/java/org/jsoup/Jsoup.java\n+++ b/src/main/java/org/jsoup/Jsoup.java\n package org.jsoup;\n+\n+import java.io.File;\n+import java.io.IOException;\n \n import org.jsoup.nodes.Document;\n import org.jsoup.parser.Parser;\n import org.jsoup.safety.Whitelist;\n \n /**\n- * Jsoup main entry point.\n+ * Jsoup HTML Parser.\n  *\n  * @author Jonathan Hedley\n  */\n public class Jsoup {\n+    \n+    /**\n+     * Parse HTML into a Document. The parser will make a sensible, balanced document tree out of any HTML.\n+     * @param html HTML to parse\n+     * @param baseUri The URL where the HTML was retrieved from. Used to resolve relative URLs to absolute URLs, until\n+     * the HTML declares a {@code <base href>} tag.\n+     * @return sane HTML\n+     */\n     public static Document parse(String html, String baseUri) {\n         return Parser.parse(html, baseUri);\n     }\n \n+    /**\n+     * Parse HTML into a Document. As no base URI is specified, absolute URL detection relies on the HTML including a \n+     * {@code <base href>} tag.\n+     * @param html HTML to parse\n+     * @return sane HTML\n+     * @see #parse(String, String)\n+     */\n     public static Document parse(String html) {\n         return Parser.parse(html, \"\");\n     }\n     \n+    /**\n+     * Parse the contents of a file as HTML.\n+     * @param in file to load HTML from\n+     * @param charsetName character set of file contents. If you don't know the charset, generally the best guess is\n+     * {@code UTF-8}.\n+     * @param baseUri The URL where the HTML was retrieved from, to generate absolute URLs relative to.\n+     * @return sane HTML\n+     * @throws IOException if the file could not be found, or read, or if the charsetName is invalid.\n+     */\n+    public static Document parse(File in, String charsetName, String baseUri) throws IOException {\n+        String html = DataUtil.load(in, charsetName);\n+        return parse(html, baseUri);\n+    }\n+    \n+    /**\n+     * Parse the contents of a file as HTML. The location of the file is used as the base URI to qualify relative URLs.\n+     * @param in file to load HTML from\n+     * @param charsetName character set of file contents. If you don't know the charset, generally the best guess is\n+     * {@code UTF-8}.\n+     * @return sane HTML\n+     * @throws IOException if the file could not be found, or read, or if the charsetName is invalid.\n+     * @see #parse(File, String, String)\n+     */\n+    public static Document parse(File in, String charsetName) throws IOException {\n+        String html = DataUtil.load(in, charsetName);\n+        return parse(html, in.getAbsolutePath());\n+    }\n+    \n+    /**\n+     * Parse a fragment of HTML, with the assumption that it forms the {@code body} of the HTML.\n+     * @param bodyHtml body HTML fragment\n+     * @param baseUri URL to resolve relative URLs against.\n+     * @return sane HTML document\n+     * @see Document#body()\n+     */\n     public static Document parseBodyFragment(String bodyHtml, String baseUri) {\n         return Parser.parseBodyFragment(bodyHtml, baseUri);\n     }\n     \n+    /**\n+     * Parse a fragment of HTML, with the assumption that it forms the {@code body} of the HTML.\n+     * @param bodyHtml body HTML fragment\n+     * @return sane HTML document\n+     * @see Document#body()\n+     */\n     public static Document parseBodyFragment(String bodyHtml) {\n         return Parser.parseBodyFragment(bodyHtml, \"\");\n     }\n \n+    /**\n+     * Get safe HTML from untrusted input HTML, by parsing input HTML and filtering it through a white-list of \n+     * permitted tags and attributes.\n+     * @param bodyHtml input untrusted HMTL\n+     * @param baseUri URL to resolve relative URLs against\n+     * @param whitelist white-list of permitted HTML elements\n+     * @return safe HTML\n+     * @see Cleaner#clean(Document)\n+     */\n     public static String clean(String bodyHtml, String baseUri, Whitelist whitelist) {\n         Document dirty = parseBodyFragment(bodyHtml, baseUri);\n         Cleaner cleaner = new Cleaner(whitelist);\n         return clean.body().html();\n     }\n     \n+    /**\n+     * Get safe HTML from untrusted input HTML, by parsing input HTML and filtering it through a white-list of \n+     * permitted tags and attributes.\n+     * @param bodyHtml input untrusted HTML\n+     * @param whitelist white-list of permitted HTML elements\n+     * @return safe HTML\n+     * @see Cleaner#clean(Document)\n+     */\n     public static String clean(String bodyHtml, Whitelist whitelist) {\n         return clean(bodyHtml, \"\", whitelist);\n     }", "timestamp": 1309605107, "metainfo": ""}