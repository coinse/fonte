{"sha": "ae7308a2832897f351712e44f656a3e71fac7efc", "log": "Evaluator.match(Element test) -> Evaluator.match(Element root, Element test) change", "commit": "\n--- a/src/main/java/org/jsoup/nodes/Evaluator.java\n+++ b/src/main/java/org/jsoup/nodes/Evaluator.java\n     \n     /**\n      * Test if the element meets the evaluator's requirements.\n+     * \n+     * @param root Root of the matching subtree\n+     * @param element tested element\n      */\n-    public abstract boolean matches(Element element);\n+    public abstract boolean matches(Element root, Element element);\n \n     public static final class Tag extends Evaluator {\n         private String tagName;\n             this.tagName = tagName;\n         }\n \n-        public boolean matches(Element element) {\n+        @Override\n+        public boolean matches(Element root, Element element) {\n             return (element.tagName().equals(tagName));\n         }\n         \n             this.id = id;\n         }\n \n-        public boolean matches(Element element) {\n+        @Override\n+        public boolean matches(Element root, Element element) {\n             return (id.equals(element.id()));\n         }\n         \n             this.className = className;\n         }\n \n-        public boolean matches(Element element) {\n+        @Override\n+        public boolean matches(Element root, Element element) {\n             return (element.hasClass(className));\n         }\n         \n             this.key = key;\n         }\n \n-        public boolean matches(Element element) {\n+        @Override\n+        public boolean matches(Element root, Element element) {\n             return element.hasAttr(key);\n         }\n         \n             this.keyPrefix = keyPrefix;\n         }\n \n-        public boolean matches(Element element) {\n+        @Override\n+        public boolean matches(Element root, Element element) {\n             List<org.jsoup.nodes.Attribute> values = element.attributes.asList();\n             for (org.jsoup.nodes.Attribute attribute : values) {\n                 if (attribute.getKey().startsWith(keyPrefix))\n             super(key, value);\n         }\n \n-        public boolean matches(Element element) {\n+        @Override\n+        public boolean matches(Element root, Element element) {\n             return element.hasAttr(key) && value.equalsIgnoreCase(element.attr(key));\n         }\n         \n             super(key, value);\n         }\n \n-        public boolean matches(Element element) {\n+        @Override\n+        public boolean matches(Element root, Element element) {\n             return !value.equalsIgnoreCase(element.attr(key));\n         }\n         \n             super(key, value);\n         }\n \n-        public boolean matches(Element element) {\n+        @Override\n+        public boolean matches(Element root, Element element) {\n             return element.hasAttr(key) && element.attr(key).toLowerCase().startsWith(value); // value is lower case already\n         }\n         \n             super(key, value);\n         }\n \n-        public boolean matches(Element element) {\n+        @Override\n+        public boolean matches(Element root, Element element) {\n             return element.hasAttr(key) && element.attr(key).toLowerCase().endsWith(value); // value is lower case\n         }\n         \n             super(key, value);\n         }\n \n-        public boolean matches(Element element) {\n+        @Override\n+        public boolean matches(Element root, Element element) {\n             return element.hasAttr(key) && element.attr(key).toLowerCase().contains(value); // value is lower case\n         }\n         \n             this.pattern = pattern;\n         }\n \n-        public boolean matches(Element element) {\n+        @Override\n+        public boolean matches(Element root, Element element) {\n             return element.hasAttr(key) && pattern.matcher(element.attr(key)).find();\n         }\n         \n     }\n \n     public static final class AllElements extends Evaluator {\n-        public boolean matches(Element element) {\n+\n+    \t@Override\n+        public boolean matches(Element root, Element element) {\n             return true;\n         }\n     }\n             super(index);\n         }\n \n-        public boolean matches(Element element) {\n+        @Override\n+        public boolean matches(Element root, Element element) {\n             return element.elementSiblingIndex() < index;\n         }\n         \n             super(index);\n         }\n \n-        public boolean matches(Element element) {\n+        @Override\n+        public boolean matches(Element root, Element element) {\n             return element.elementSiblingIndex() > index;\n         }\n         \n             super(index);\n         }\n \n-        public boolean matches(Element element) {\n+        @Override\n+        public boolean matches(Element root, Element element) {\n             return element.elementSiblingIndex() == index;\n         }\n         \n             this.searchText = searchText.toLowerCase();\n         }\n \n-        public boolean matches(Element element) {\n+        @Override\n+        public boolean matches(Element root, Element element) {\n             return (element.text().toLowerCase().contains(searchText));\n         }\n     }\n             this.searchText = searchText.toLowerCase();\n         }\n \n-        public boolean matches(Element element) {\n+        @Override\n+        public boolean matches(Element root, Element element) {\n             return (element.ownText().toLowerCase().contains(searchText));\n         }\n     }\n             this.pattern = pattern;\n         }\n \n-        public boolean matches(Element element) {\n+        @Override\n+        public boolean matches(Element root, Element element) {\n             Matcher m = pattern.matcher(element.text());\n             return m.find();\n         }\n             this.pattern = pattern;\n         }\n \n-        public boolean matches(Element element) {\n+        @Override\n+        public boolean matches(Element root, Element element) {\n             Matcher m = pattern.matcher(element.ownText());\n             return m.find();\n         }\n--- a/src/main/java/org/jsoup/select/Collector.java\n+++ b/src/main/java/org/jsoup/select/Collector.java\n         public void head(Node node, int depth) {\n             if (node instanceof Element) {\n                 Element el = (Element) node;\n-                if (eval.matches(el))\n+                if (eval.matches(el, el))\n                     elements.add(el);\n             }\n         }\n--- a/src/main/java/org/jsoup/select/ng/AndSelector.java\n+++ b/src/main/java/org/jsoup/select/ng/AndSelector.java\n \n \n \t@Override\n-\tpublic boolean matches(Element node) {\n+\tpublic boolean matches(Element root, Element node) {\n \t\tfor(Evaluator s : selectors) {\n-\t\t\tif(!s.matches(node))\n+\t\t\tif(!s.matches(root, node))\n \t\t\t\treturn false;\n \t\t}\n \t\t\n--- a/src/main/java/org/jsoup/select/ng/ElementContainerSelector.java\n+++ b/src/main/java/org/jsoup/select/ng/ElementContainerSelector.java\n \t}\n \n \t@Override\n-\tpublic boolean matches(Element element) {\n+\tpublic boolean matches(Element root, Element element) {\n \t\tfor(Evaluator e: sels)\n-\t\t\tif(!e.matches(element))\n+\t\t\tif(!e.matches(root, element))\n \t\t\t\treturn false;\n \t\t\n \t\treturn true;\n--- a/src/main/java/org/jsoup/select/ng/ElementSelector.java\n+++ b/src/main/java/org/jsoup/select/ng/ElementSelector.java\n \t}\n \n \t@Override\n-\tpublic boolean matches(Element node) {\n+\tpublic boolean matches(Element root, Element node) {\n \t\t\tElement el = (Element) node;\n \t\t\t\n \t\t\tif(tag != null && !el.tagName().equals(tag))\n--- a/src/main/java/org/jsoup/select/ng/HasSelector.java\n+++ b/src/main/java/org/jsoup/select/ng/HasSelector.java\n \t}\n \n \t@Override\n-\tpublic boolean matches(Element element) {\n+\tpublic boolean matches(Element root, Element element) {\n \t\t\n \n \t\tfor(Element e : element.getAllElements()) {\n-\t\t\tif(e != element && sel.matches(e))\n+\t\t\tif(e != element && sel.matches(root, e))\n \t\t\t\treturn true;\n \t\t}\n \t\t\n--- a/src/main/java/org/jsoup/select/ng/ImmediateParentSelector.java\n+++ b/src/main/java/org/jsoup/select/ng/ImmediateParentSelector.java\n \t}\n \n \t@Override\n-\tpublic boolean matches(Element element) {\n+\tpublic boolean matches(Element root, Element element) {\n \t\t\n \t\tElement parent = element.parent();\n \n \t\tif(parent != null)\n-\t\t\treturn sel.matches(parent);\n+\t\t\treturn sel.matches(root, parent);\n \n \t\treturn false;\n \t}\n--- a/src/main/java/org/jsoup/select/ng/NotSelector.java\n+++ b/src/main/java/org/jsoup/select/ng/NotSelector.java\n \n \n \t@Override\n-\tpublic boolean matches(Element node) {\n-\t\treturn !sel.matches(node);\n+\tpublic boolean matches(Element root, Element node) {\n+\t\treturn !sel.matches(root, node);\n \t}\n \t\n \t@Override\n--- a/src/main/java/org/jsoup/select/ng/OrSelector.java\n+++ b/src/main/java/org/jsoup/select/ng/OrSelector.java\n \n \n \t@Override\n-\tpublic boolean matches(Element node) {\n+\tpublic boolean matches(Element root, Element node) {\n \t\tfor(Evaluator s : selectors) {\n-\t\t\tif(s.matches(node))\n+\t\t\tif(s.matches(root, node))\n \t\t\t\treturn true;\n \t\t}\n \t\t\n--- a/src/main/java/org/jsoup/select/ng/ParentSelector.java\n+++ b/src/main/java/org/jsoup/select/ng/ParentSelector.java\n \t}\n \n \t@Override\n-\tpublic boolean matches(Element element) {\n+\tpublic boolean matches(Element root, Element element) {\n \t\t\n \t\tElement parent = element.parent();\n \t\t\n \t\twhile(parent != null) {\n-\t\t\tif(sel.matches(parent))\n+\t\t\tif(sel.matches(root, parent))\n \t\t\t\treturn true;\n \t\t\t\n \t\t\tparent = parent.parent();\n--- a/src/main/java/org/jsoup/select/ng/PrevSiblingSelector.java\n+++ b/src/main/java/org/jsoup/select/ng/PrevSiblingSelector.java\n \t}\n \n \t@Override\n-\tpublic boolean matches(Element element) {\n+\tpublic boolean matches(Element root, Element element) {\n \t\tElement prev = element.previousElementSibling();\n \t\t\n-\t\tif(prev != null && sel.matches(prev))\n+\t\tif(prev != null && sel.matches(root, prev))\n \t\t\treturn true;\n \t\t\n \t\treturn false;\n--- a/src/main/java/org/jsoup/select/ng/PreviousSequentSiblingSelector.java\n+++ b/src/main/java/org/jsoup/select/ng/PreviousSequentSiblingSelector.java\n \n \n \t@Override\n-\tpublic boolean matches(Element element) {\n+\tpublic boolean matches(Element root, Element element) {\n \t\tElement prev = element.previousElementSibling();\n \t\t\n \t\twhile(prev != null) {\n-\t\t\tif(sel.matches(prev))\n+\t\t\tif(sel.matches(root, prev))\n \t\t\t\treturn true;\n \t\t\t\n \t\t\tprev = prev.previousElementSibling();\n--- a/src/main/java/org/jsoup/select/ng/SelectMatch.java\n+++ b/src/main/java/org/jsoup/select/ng/SelectMatch.java\n \t\tthis.sel = sel;\n \t}\n \t\n-\tpublic Elements match(Node root) {\n-\t\treturn new Elements(match(root, new ArrayList<Element>()));\n+\tpublic Elements match(Element root) {\n+\t\treturn new Elements(match(root, root, new ArrayList<Element>()));\n \t}\n \t\n \tpublic Elements match(Elements elements) {\n \t\tList<Element> matched = new ArrayList<Element>();\n \t\t\n \t\tfor(Element el : elements) {\n-\t\t\tmatch(el, matched);\n+\t\t\tmatch(el, el, matched);\n \t\t}\n \t\t\n \t\treturn new Elements(matched);\n \t}\n \t\n-\tpublic List<Element> match(Node root, List<Element> matched) {\n-\t\tif((root instanceof Element) && sel.matches((Element)root))\n-\t\t\tmatched.add((Element)root);\n+\tList<Element> match(Element root, Element test, List<Element> matched) {\n+\t\tif(sel.matches(root, test))\n+\t\t\tmatched.add((Element)test);\n \t\t\n-\t\tfor(Node n : root.childNodes())\n+\t\tfor(Node n : test.childNodes())\n \t\t\tif(n instanceof Element)\n-\t\t\t\tmatch(n, matched);\n+\t\t\t\tmatch(root, (Element)n, matched);\n \t\t\n \t\treturn matched;\n \t}\n \t\treturn matched;\n \t}*/\n \t\n-\tpublic static Elements match(Node root, Evaluator sel) {\n+\tpublic static Elements match(Element root, Evaluator sel) {\n \t\tSelectMatch sm = new SelectMatch(sel);\n \t\t\n \t\treturn sm.match(root);\n \t\treturn sm.match(elements);\n \t}\n \t\n-\tpublic static Elements match(Node root, Evaluator... sel) {\n+\tpublic static Elements match(Element root, Evaluator... sel) {\n \t\tSelectMatch sm = new SelectMatch(new AndSelector(Arrays.asList(sel)));\n \t\t\n \t\treturn sm.match(root);", "timestamp": 1309605124, "metainfo": ""}