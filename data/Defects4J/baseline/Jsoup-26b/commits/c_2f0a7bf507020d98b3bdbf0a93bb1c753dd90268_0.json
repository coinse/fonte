{"sha": "2f0a7bf507020d98b3bdbf0a93bb1c753dd90268", "log": "Reimplemented parser.", "commit": "\n--- a/src/main/java/org/jsoup/nodes/Attributes.java\n+++ b/src/main/java/org/jsoup/nodes/Attributes.java\n \n import org.apache.commons.lang.Validate;\n \n-import java.util.LinkedHashMap;\n+import java.util.*;\n \n /**\n  Element attribute list.\n \n  @author Jonathan Hedley, jonathan@hedley.net */\n-public class Attributes {\n+public class Attributes implements Iterable<Attribute> {\n     private LinkedHashMap<String, String> attributes = new LinkedHashMap<String, String>(); // linked hash map to preserve insertion order.\n \n     public String get(String key) {\n         return attributes.size();\n     }\n \n-    // todo: toString, list (as List<Attribute>)\n+    public void mergeAttributes(Attributes incoming) {\n+        for (Attribute attribute : incoming) {\n+            this.put(attribute);\n+        }\n+    }\n+\n+    public Iterator<Attribute> iterator() {\n+        return asList().iterator();\n+    }\n+\n+    public List<Attribute> asList() {\n+        List<Attribute> list = new ArrayList<Attribute>(attributes.size());\n+        for (Map.Entry<String, String> entry : attributes.entrySet()) {\n+            Attribute attribute = new Attribute(entry.getKey(), entry.getValue());\n+            list.add(attribute);\n+        }\n+        return Collections.unmodifiableList(list);\n+    }\n+\n+    // todo: toString\n \n \n }\n--- a/src/main/java/org/jsoup/nodes/Document.java\n+++ b/src/main/java/org/jsoup/nodes/Document.java\n \n     public Document() {\n         super(new StartTag(Tag.valueOf(\"html\")));\n+        head = new Element (new StartTag(Tag.valueOf(\"head\")));\n+        body = new Element (new StartTag(Tag.valueOf(\"body\")));\n+\n+        this.addChild(head);\n+        this.addChild(body);\n+    }\n+\n+    public Element getHead() {\n+        return head;\n+    }\n+\n+    public Element getBody() {\n+        return body;\n     }\n }\n+\n--- /dev/null\n+++ b/src/main/java/org/jsoup/nodes/XmlDeclaration.java\n+package org.jsoup.nodes;\n+\n+/**\n+ An XML Declaration.\n+\n+ @author Jonathan Hedley, jonathan@hedley.net */\n+public class XmlDeclaration extends Node {\n+    private static final String DECL_KEY = \"declaration\";\n+\n+    public XmlDeclaration(String data) {\n+        super();\n+        attributes.put(DECL_KEY, data);\n+    }\n+\n+    public String nodeName() {\n+        return \"#declaration\";\n+    }\n+\n+    public String getWholeDeclaration() {\n+        return attributes.get(DECL_KEY);\n+    }\n+}\n--- a/src/main/java/org/jsoup/parser/Parser.java\n+++ b/src/main/java/org/jsoup/parser/Parser.java\n import org.apache.commons.lang.Validate;\n import org.jsoup.nodes.*;\n \n-import java.util.LinkedList;\n+import java.util.*;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n \n /**\n- Parses a {@link TokenStream} into a {@link Document}\n+ Parses HTML into a {@link Document}\n \n  @author Jonathan Hedley, jonathan@hedley.net */\n public class Parser {\n-    private TokenStream tokenStream;\n+    private static String SQ = \"'\";\n+    private static String DQ = \"\\\"\";\n+    private static Tag htmlTag = Tag.valueOf(\"html\");\n+    private static Tag headTag = Tag.valueOf(\"head\");\n+    private static Tag bodyTag = Tag.valueOf(\"body\");\n+\n     private LinkedList<Element> stack;\n-    private AttributeParser attributeParser;\n-\n-    public Parser(TokenStream tokenStream) {\n-        Validate.notNull(tokenStream);\n-\n-        this.tokenStream = tokenStream;\n+    private LinkedList<Character> queue;\n+    private Document doc;\n+\n+    public Parser(String html) {\n+        Validate.notNull(html);\n+\n         this.stack = new LinkedList<Element>();\n-        this.attributeParser = new AttributeParser();\n+        this.queue = new LinkedList<Character>();\n+        char[] chars = html.toCharArray();\n+        for (char c : chars) {\n+            queue.add(c);\n+        }\n+\n+        doc = new Document();\n+        stack.add(doc);\n+        stack.add(doc.getHead());\n     }\n \n     public static Document parse(String html) {\n-        TokenStream ts = TokenStream.create(html);\n-        Parser parser = new Parser(ts);\n+        Parser parser = new Parser(html);\n         return parser.parse();\n     }\n \n     public Document parse() {\n-        // TODO: figure out implicit head & body elements\n-        Document doc = new Document();\n-        stack.add(doc);\n-\n-        StringBuilder commentAccum = null;\n-\n-        while (tokenStream.hasNext()) {\n-            Token token = tokenStream.next();\n-\n-            if (token.isFullComment()) { // <!-- comment -->\n-                Comment comment = new Comment(token.getCommentData());\n-                stack.getLast().addChild(comment);\n-            } else if (token.isStartComment()) { // <!-- comment\n-                commentAccum = new StringBuilder(token.getCommentData());\n-            } else if (token.isEndComment() && commentAccum != null) { // comment -->\n-                commentAccum.append(token.getCommentData());\n-                Comment comment = new Comment(commentAccum.toString());\n-                stack.getLast().addChild(comment);\n-                commentAccum = null;\n-            } else if (commentAccum != null) { // within a comment\n-                commentAccum.append(token.getData());\n-            }\n-\n-            else if (token.isStartTag()) {\n-                Attributes attributes = attributeParser.parse(token.getAttributeString());\n-                Tag tag = Tag.valueOf(token.getTagName());\n-                StartTag startTag = new StartTag(tag, attributes);\n-\n-                // if tag is \"html\", we already have it, so OK to ignore skip. todo: abstract this. and can there be attributes to set?\n-                if (doc.getTag().equals(tag)) continue;\n-\n-                Element parent = popStackToSuitableContainer(tag);\n-                Validate.notNull(parent, \"Should always have a viable container\");\n-                Element node = new Element(startTag);\n-                parent.addChild(node);\n-                stack.add(node);\n-            }\n-\n-            if (token.isEndTag() && commentAccum == null) { // empty tags are both start and end tags\n-                stack.removeLast();\n-            }\n-\n-\n-\n-            // TODO[must] handle comments\n-\n-            else if (token.isTextNode()) {\n-                String text = token.getData();\n-                TextNode textNode = new TextNode(text);\n-                stack.getLast().addChild(textNode);\n+        while (!queue.isEmpty()) {\n+            if (matches(\"<!--\")) {\n+                parseComment();\n+            } else if (matches(\"<?\") || matches(\"<!\")) {\n+                parseXmlDecl();\n+            } else if (matches(\"</\")) {\n+                parseEndTag();\n+            } else if (matches(\"<\")) {\n+                parseStartTag();\n+            } else {\n+                parseText();\n             }\n         }\n         return doc;\n     }\n \n+    private void parseComment() {\n+        consume(\"<!--\");\n+        String data = chompTo(\"->\");\n+\n+        if (data.endsWith(\"-\")) // i.e. was -->\n+            data = data.substring(0, data.length()-1);\n+        Comment comment = new Comment(data);\n+        last().addChild(comment);\n+    }\n+\n+    private void parseXmlDecl() {\n+        consume(\"<\"); consume(); // <? or <!, from initial match.\n+        String data = chompTo(\">\");\n+\n+        XmlDeclaration decl = new XmlDeclaration(data);\n+        last().addChild(decl);\n+    }\n+\n+    private void parseEndTag() {\n+        consume(\"</\");\n+        String tagName = consumeWord();\n+        chompTo(\">\");\n+\n+        if (!tagName.isEmpty()) {\n+            Tag tag = Tag.valueOf(tagName);\n+            popStackToClose(tag);\n+        }\n+    }\n+\n+    private void parseStartTag() {\n+        consume(\"<\");\n+        Attributes attributes = new Attributes();\n+\n+        String tagName = consumeWord();\n+        while (!matches(\"/>\") && !matches(\">\")) {\n+            Attribute attribute = parseAttribute();\n+            if (attribute != null)\n+                attributes.put(attribute);\n+        }\n+\n+        Tag tag = Tag.valueOf(tagName);\n+        StartTag startTag = new StartTag(tag, attributes);\n+        Element child = new Element(startTag);\n+\n+        boolean emptyTag;\n+        if (matches(\"/>\")) { // empty tag, don't add to stack\n+            consume(\"/>\");\n+            emptyTag = true;\n+        } else {\n+            consume(\">\");\n+            emptyTag = false;\n+        }\n+\n+        // switch between html, head, body, to preserve doc structure\n+        if (tag.equals(htmlTag)) {\n+            doc.getAttributes().mergeAttributes(attributes);\n+        } else if (tag.equals(headTag)) {\n+            doc.getHead().getAttributes().mergeAttributes(attributes);\n+            // head is on stack from start, no action required\n+        } else if (last().getTag().equals(headTag) && !headTag.canContain(tag)) {\n+            // switch to body\n+            stack.removeLast();\n+            stack.addLast(doc.getBody());\n+            last().addChild(child);\n+            if (!emptyTag)\n+                stack.addLast(child);\n+        } else if (tag.equals(bodyTag) && last().getTag().equals(htmlTag)) {\n+            doc.getBody().getAttributes().mergeAttributes(attributes);\n+            stack.removeLast();\n+            stack.addLast(doc.getBody());\n+        } else {\n+            Element parent = popStackToSuitableContainer(tag);\n+            parent.addChild(child);\n+            if (!emptyTag)\n+                stack.addLast(child);\n+        }\n+    }\n+\n+    private Attribute parseAttribute() {\n+        consumeWhitespace();\n+        String key = consumeWord();\n+        String value = \"\";\n+        consumeWhitespace();\n+        if (matches(\"=\")) {\n+            consume(\"=\");\n+            consumeWhitespace();\n+\n+            if (matches(SQ)) {\n+                consume(SQ);\n+                value = chompTo(SQ);\n+            } else if (matches(DQ)) {\n+                consume(DQ);\n+                value = chompTo(DQ);\n+            } else {\n+                StringBuilder valueAccum = new StringBuilder();\n+                while (!matches(\"/>\") && !matches(\">\") && !Character.isWhitespace(queue.peekFirst())) {\n+                    valueAccum.append(consume());\n+                }\n+                value = valueAccum.toString();\n+            }\n+            consumeWhitespace();\n+        }\n+        if (!key.isEmpty())\n+            return new Attribute(key, value);\n+        else {\n+            consume(); // unknown char, keep popping so not get stuck\n+            return null;\n+        }\n+    }\n+\n+    private void parseText() {\n+        // TODO: work out whitespace requirements (between blocks, between inlines)\n+        StringBuilder textAccum = new StringBuilder();\n+        while (!matches(\"<\")) {\n+            textAccum.append(consume());\n+        }\n+        TextNode textNode = new TextNode(textAccum.toString());\n+        last().addChild(textNode);\n+    }\n+\n+    /**\n+     * Pulls a string off the queue, up to but exclusive of the match sequence, or to the queue running out.\n+     * @param seq String to end on (and not include in return, but leave on queue)\n+     * @return The matched data consumed from queue.\n+     */\n+    private String consumeTo(String seq) {\n+        StringBuilder accum = new StringBuilder();\n+        while (!queue.isEmpty() && !matches(seq))\n+            accum.append(consume());\n+\n+        return accum.toString();\n+    }\n+\n+    /**\n+     * Pulls a string off the queue (like consumeTo), and then pulls off the matched string (but does not return it).\n+     * @param seq String to match up to, and not include in return, and to pull off queue\n+     * @return Data matched from queue.\n+     */\n+    private String chompTo(String seq) {\n+        String data = consumeTo(seq);\n+        consume(seq);\n+        return data;\n+    }\n+\n+    /**\n+     * Consume one character off queue.\n+     * @return first character on queue.\n+     */\n+    private Character consume() {\n+        return queue.removeFirst();\n+    }\n+\n+    private void consume(String seq) {\n+        int len = seq.length();\n+        if (len > queue.size())\n+            throw new IllegalStateException(\"Queue not long enough to consume sequence\");\n+        char[] seqChars = seq.toCharArray();\n+        for (int i = 0; i < len; i++) {\n+            Character qChar = consume();\n+            if (!qChar.equals(seqChars[i]))\n+                throw new IllegalStateException(\"Queue did not match expected sequence\");\n+        }\n+    }\n+\n+    private void consumeWhitespace() {\n+        while (Character.isWhitespace(queue.peekFirst())) {\n+            consume();\n+        }\n+    }\n+\n+    private String consumeWord() {\n+        StringBuilder wordAccum = new StringBuilder();\n+        while (Character.isLetterOrDigit(queue.peekFirst())) {\n+            wordAccum.append(queue.removeFirst());\n+        }\n+        return wordAccum.toString();\n+    }\n+\n+    private boolean matches(String seq) {\n+        int len = seq.length();\n+        if (len > queue.size())\n+            return false;\n+        List<Character> chars = queue.subList(0, len);\n+        char[] seqChars = seq.toCharArray();\n+        for (int i = 0; i < len; i++) {\n+            if (!chars.get(i).equals(seqChars[i]))\n+                return false;\n+        }\n+        return true;\n+    }\n+\n     private Element popStackToSuitableContainer(Tag tag) {\n-        while (stack.size() > 0) {\n-            if (stack.getLast().getTag().canContain(tag))\n-                return stack.getLast();\n+        while (!stack.isEmpty()) {\n+            if (last().getTag().canContain(tag))\n+                return last();\n             else\n                 stack.removeLast();\n         }\n         return null;\n     }\n+\n+    private Element popStackToClose(Tag tag) {\n+        // first check to see if stack contains this tag; if so pop to there, otherwise ignore\n+        int counter = 0;\n+        Element elToClose = null;\n+        for (int i = stack.size() -1; i > 0; i--) {\n+            counter++;\n+            Element el = stack.get(i);\n+            if (el.getTag().equals(tag)) {\n+                elToClose = el;\n+                break;\n+            }\n+        }\n+        if (elToClose != null) {\n+            for (int i = 0; i < counter; i++) {\n+                stack.removeLast();\n+            }\n+        }\n+        return elToClose;\n+    }\n+\n+    private Element last() {\n+        return stack.getLast();\n+    }\n }\n--- a/src/main/java/org/jsoup/parser/Tag.java\n+++ b/src/main/java/org/jsoup/parser/Tag.java\n \n         if (this.empty)\n             return false;\n+\n+        // head can only contain a few. if more than head in here, modify to have a list of valids\n+        // TODO[must] - lookup what head can contain\n+        // from memory: base, script, link, meta, title\n+        if (this.tagName.equals(\"head\")) {\n+            if (child.tagName.equals(\"base\") || child.tagName.equals(\"script\") || child.tagName.equals(\"link\") ||\n+                    child.tagName.equals(\"meta\") || child.tagName.equals(\"title\")) {\n+                return true;\n+            }\n+            return false;\n+        }\n \n         return true;\n     }\n--- /dev/null\n+++ b/src/test/java/org/jsoup/parser/AttributeParseTest.java\n+package org.jsoup.parser;\n+\n+import org.jsoup.Jsoup;\n+import org.jsoup.nodes.Attributes;\n+import org.jsoup.nodes.Element;\n+import org.junit.Test;\n+\n+import static org.junit.Assert.*;\n+\n+/**\n+ Test suite for attribute parser.\n+\n+ @author Jonathan Hedley, jonathan@hedley.net */\n+public class AttributeParseTest {\n+\n+    @Test public void parsesRoughAttributeString() {\n+        String html = \"<a id=\\\"123\\\" class=\\\"baz = 'bar'\\\" style = 'border: 2px'qux zim foo = 12 mux.=18 />\";\n+        // should be: <id=123>, <class=baz = 'bar'>, <qux=>, <zim=>, <foo=12>, <mux.=18>\n+\n+        Element el = Jsoup.parse(html).getElementsByTag(\"a\").get(0);\n+        Attributes attr = el.getAttributes();\n+        assertEquals(7, attr.size());\n+        assertEquals(\"123\", attr.get(\"id\"));\n+        assertEquals(\"baz = 'bar'\", attr.get(\"class\"));\n+        assertEquals(\"border: 2px\", attr.get(\"style\"));\n+        assertEquals(\"\", attr.get(\"qux\"));\n+        assertEquals(\"\", attr.get(\"zim\"));\n+        assertEquals(\"12\", attr.get(\"foo\"));\n+        assertEquals(\"18\", attr.get(\"mux.\"));\n+    }\n+\n+    @Test public void parsesEmptyString() {\n+        String html = \"<a />\";\n+        Element el = Jsoup.parse(html).getElementsByTag(\"a\").get(0);\n+        Attributes attr = el.getAttributes();\n+        assertEquals(0, attr.size());\n+    }\n+\n+    @Test public void emptyOnNoKey() {\n+        String html = \"<a =empty />\";\n+        Element el = Jsoup.parse(html).getElementsByTag(\"a\").get(0);\n+        Attributes attr = el.getAttributes();\n+        assertEquals(0, attr.size());\n+    }\n+}\n--- a/src/test/java/org/jsoup/parser/ParserTest.java\n+++ b/src/test/java/org/jsoup/parser/ParserTest.java\n package org.jsoup.parser;\n \n+import org.jsoup.Jsoup;\n import org.jsoup.nodes.Comment;\n import org.jsoup.nodes.Document;\n import org.jsoup.nodes.Element;\n public class ParserTest {\n \n     @Test public void testParsesSimpleDocument() {\n-        TokenStream tokenStream = TokenStream.create(\"<html><head><title>First!</title></head><body><p>First post! <img src=\\\"foo.png\\\" /></p></body></html>\");\n-        Parser parser = new Parser(tokenStream);\n-        Document doc = parser.parse();\n+        String html = \"<html><head><title>First!</title></head><body><p>First post! <img src=\\\"foo.png\\\" /></p></body></html>\";\n+        Document doc = Jsoup.parse(html);\n         // need a better way to verify these:\n         Element p = doc.child(1).child(0);\n         assertEquals(\"p\", p.tagName());\n     }\n \n     @Test public void testParsesRoughAttributes() {\n-        TokenStream tokenStream = TokenStream.create(\"<html><head><title>First!</title></head><body><p class=\\\"foo > bar\\\">First post! <img src=\\\"foo.png\\\" /></p></body></html>\");\n-        Parser parser = new Parser(tokenStream);\n-        Document doc = parser.parse();\n+        String html = \"<html><head><title>First!</title></head><body><p class=\\\"foo > bar\\\">First post! <img src=\\\"foo.png\\\" /></p></body></html>\";\n+        Document doc = Jsoup.parse(html);\n+\n         // need a better way to verify these:\n         Element p = doc.child(1).child(0);\n         assertEquals(\"p\", p.tagName());\n     }\n \n     @Test public void testParsesComments() {\n-        TokenStream ts = TokenStream.create(\"<html><head></head><body><!-- <table><tr><td></table> --><p>Hello</p></body></html>\");\n-        Document doc = new Parser(ts).parse();\n+        String html = \"<html><head></head><body><!-- <table><tr><td></table> --><p>Hello</p></body></html>\";\n+        Document doc = Jsoup.parse(html);\n+        \n         Element body = doc.child(1);\n         Comment comment = (Comment) body.childNode(0);\n-        assertEquals(\"<table><tr><td></table>\", comment.getData());\n+        assertEquals(\" <table><tr><td></table> \", comment.getData());\n         Element p = body.child(0);\n         TextNode text = (TextNode) p.childNode(0);\n         assertEquals(\"Hello\", text.getWholeText());", "timestamp": 1309605100, "metainfo": ""}