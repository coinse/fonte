{
  "origin": "codeshovel",
  "repositoryName": "Jsoup-47b",
  "repositoryPath": "/tmp/Jsoup-47b//.git",
  "startCommitName": "HEAD",
  "sourceFileName": "Entities.java",
  "functionName": "escape",
  "functionId": "escape___accum-StringBuilder__string-String__out-Document.OutputSettings__inAttribute-boolean__normaliseWhite-boolean__stripLeadingWhite-boolean",
  "sourceFilePath": "src/main/java/org/jsoup/nodes/Entities.java",
  "functionAnnotation": "",
  "functionDoc": "",
  "functionStartLine": 79,
  "functionEndLine": 154,
  "numCommitsSeen": 48,
  "timeTaken": 1433,
  "changeHistory": [
    "3ba88d8c2ab500c07f9e2ddbc07a4bd01fadbd78",
    "b14e7357248a0f683b8252be3e68f5e171fb8529",
    "6c4f16f233cdfd7aedef33374609e9aa4ede255c",
    "a991deb4430343e8f22de5d5aa51f829bab52315",
    "ae51709b8c07098fa688ec6be0b5a7dec7654178",
    "43cd48ba8e4701d429c8a7c1eea503ad139aaf90",
    "c2a9605b70fdae3c064b49bf2a0b633c935322cc",
    "f4f2efb22f24378eb608aa308ba30cbfee3b3df2",
    "09d99e7e5edc96348b9fa50131274aed3ee1bd2e",
    "f8841edabba28d6125dd87ed72f557e85570066b",
    "17486e2fa5b542b1f68b9b60efbefecd216a4a48"
  ],
  "changeHistoryShort": {
    "3ba88d8c2ab500c07f9e2ddbc07a4bd01fadbd78": "Ybodychange",
    "b14e7357248a0f683b8252be3e68f5e171fb8529": "Ybodychange",
    "6c4f16f233cdfd7aedef33374609e9aa4ede255c": "Ymultichange(Yparameterchange,Yreturntypechange,Ybodychange)",
    "a991deb4430343e8f22de5d5aa51f829bab52315": "Ybodychange",
    "ae51709b8c07098fa688ec6be0b5a7dec7654178": "Ybodychange",
    "43cd48ba8e4701d429c8a7c1eea503ad139aaf90": "Ybodychange",
    "c2a9605b70fdae3c064b49bf2a0b633c935322cc": "Ybodychange",
    "f4f2efb22f24378eb608aa308ba30cbfee3b3df2": "Ybodychange",
    "09d99e7e5edc96348b9fa50131274aed3ee1bd2e": "Ybodychange",
    "f8841edabba28d6125dd87ed72f557e85570066b": "Ymultichange(Yfilerename,Ybodychange,Yparameterchange)",
    "17486e2fa5b542b1f68b9b60efbefecd216a4a48": "Yintroduced"
  },
  "changeHistoryDetails": {
    "3ba88d8c2ab500c07f9e2ddbc07a4bd01fadbd78": {
      "type": "Ybodychange",
      "commitMessage": "Fixed \u0026nbsp; for XHTML in Shift_JS\n\nFixes #523\n",
      "commitDate": "7/5/15, 11:45 PM",
      "commitName": "3ba88d8c2ab500c07f9e2ddbc07a4bd01fadbd78",
      "commitAuthor": "Jonathan Hedley",
      "commitDateOld": "4/6/15, 7:30 PM",
      "commitNameOld": "b14e7357248a0f683b8252be3e68f5e171fb8529",
      "commitAuthorOld": "Jonathan Hedley",
      "daysBetweenCommits": 90.18,
      "commitsBetweenForRepo": 34,
      "commitsBetweenForFile": 1,
      "actualSource": "static void escape(StringBuilder accum, String string, Document.OutputSettings out, boolean inAttribute, boolean normaliseWhite, boolean stripLeadingWhite) {\n    boolean lastWasWhite \u003d false;\n    boolean reachedNonWhite \u003d false;\n    final EscapeMode escapeMode \u003d out.escapeMode();\n    final CharsetEncoder encoder \u003d out.encoder();\n    final CoreCharset coreCharset \u003d CoreCharset.byName(encoder.charset().name());\n    final Map\u003cCharacter, String\u003e map \u003d escapeMode.getMap();\n    final int length \u003d string.length();\n    int codePoint;\n    for (int offset \u003d 0; offset \u003c length; offset +\u003d Character.charCount(codePoint)) {\n        codePoint \u003d string.codePointAt(offset);\n        if (normaliseWhite) {\n            if (StringUtil.isWhitespace(codePoint)) {\n                if ((stripLeadingWhite \u0026\u0026 !reachedNonWhite) || lastWasWhite)\n                    continue;\n                accum.append(\u0027 \u0027);\n                lastWasWhite \u003d true;\n                continue;\n            } else {\n                lastWasWhite \u003d false;\n                reachedNonWhite \u003d true;\n            }\n        }\n        if (codePoint \u003c Character.MIN_SUPPLEMENTARY_CODE_POINT) {\n            final char c \u003d (char) codePoint;\n            switch(c) {\n                case \u0027\u0026\u0027:\n                    accum.append(\"\u0026amp;\");\n                    break;\n                case 0xA0:\n                    if (escapeMode !\u003d EscapeMode.xhtml)\n                        accum.append(\"\u0026nbsp;\");\n                    else\n                        accum.append(\"\u0026#xa0;\");\n                    break;\n                case \u0027\u003c\u0027:\n                    if (!inAttribute)\n                        accum.append(\"\u0026lt;\");\n                    else\n                        accum.append(c);\n                    break;\n                case \u0027\u003e\u0027:\n                    if (!inAttribute)\n                        accum.append(\"\u0026gt;\");\n                    else\n                        accum.append(c);\n                    break;\n                case \u0027\"\u0027:\n                    if (inAttribute)\n                        accum.append(\"\u0026quot;\");\n                    else\n                        accum.append(c);\n                    break;\n                default:\n                    if (canEncode(coreCharset, c, encoder))\n                        accum.append(c);\n                    else if (map.containsKey(c))\n                        accum.append(\u0027\u0026\u0027).append(map.get(c)).append(\u0027;\u0027);\n                    else\n                        accum.append(\"\u0026#x\").append(Integer.toHexString(codePoint)).append(\u0027;\u0027);\n            }\n        } else {\n            final String c \u003d new String(Character.toChars(codePoint));\n            if (encoder.canEncode(c))\n                accum.append(c);\n            else\n                accum.append(\"\u0026#x\").append(Integer.toHexString(codePoint)).append(\u0027;\u0027);\n        }\n    }\n}",
      "path": "src/main/java/org/jsoup/nodes/Entities.java",
      "functionStartLine": 79,
      "functionName": "escape",
      "functionAnnotation": "",
      "functionDoc": "",
      "diff": "@@ -1,70 +1,70 @@\n static void escape(StringBuilder accum, String string, Document.OutputSettings out, boolean inAttribute, boolean normaliseWhite, boolean stripLeadingWhite) {\n     boolean lastWasWhite \u003d false;\n     boolean reachedNonWhite \u003d false;\n     final EscapeMode escapeMode \u003d out.escapeMode();\n     final CharsetEncoder encoder \u003d out.encoder();\n     final CoreCharset coreCharset \u003d CoreCharset.byName(encoder.charset().name());\n     final Map\u003cCharacter, String\u003e map \u003d escapeMode.getMap();\n     final int length \u003d string.length();\n     int codePoint;\n     for (int offset \u003d 0; offset \u003c length; offset +\u003d Character.charCount(codePoint)) {\n         codePoint \u003d string.codePointAt(offset);\n         if (normaliseWhite) {\n             if (StringUtil.isWhitespace(codePoint)) {\n                 if ((stripLeadingWhite \u0026\u0026 !reachedNonWhite) || lastWasWhite)\n                     continue;\n                 accum.append(\u0027 \u0027);\n                 lastWasWhite \u003d true;\n                 continue;\n             } else {\n                 lastWasWhite \u003d false;\n                 reachedNonWhite \u003d true;\n             }\n         }\n         if (codePoint \u003c Character.MIN_SUPPLEMENTARY_CODE_POINT) {\n             final char c \u003d (char) codePoint;\n             switch(c) {\n                 case \u0027\u0026\u0027:\n                     accum.append(\"\u0026amp;\");\n                     break;\n                 case 0xA0:\n                     if (escapeMode !\u003d EscapeMode.xhtml)\n                         accum.append(\"\u0026nbsp;\");\n                     else\n-                        accum.append(c);\n+                        accum.append(\"\u0026#xa0;\");\n                     break;\n                 case \u0027\u003c\u0027:\n                     if (!inAttribute)\n                         accum.append(\"\u0026lt;\");\n                     else\n                         accum.append(c);\n                     break;\n                 case \u0027\u003e\u0027:\n                     if (!inAttribute)\n                         accum.append(\"\u0026gt;\");\n                     else\n                         accum.append(c);\n                     break;\n                 case \u0027\"\u0027:\n                     if (inAttribute)\n                         accum.append(\"\u0026quot;\");\n                     else\n                         accum.append(c);\n                     break;\n                 default:\n                     if (canEncode(coreCharset, c, encoder))\n                         accum.append(c);\n                     else if (map.containsKey(c))\n                         accum.append(\u0027\u0026\u0027).append(map.get(c)).append(\u0027;\u0027);\n                     else\n                         accum.append(\"\u0026#x\").append(Integer.toHexString(codePoint)).append(\u0027;\u0027);\n             }\n         } else {\n             final String c \u003d new String(Character.toChars(codePoint));\n             if (encoder.canEncode(c))\n                 accum.append(c);\n             else\n                 accum.append(\"\u0026#x\").append(Integer.toHexString(codePoint)).append(\u0027;\u0027);\n         }\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "b14e7357248a0f683b8252be3e68f5e171fb8529": {
      "type": "Ybodychange",
      "commitMessage": "Speed fix for Android canEncode\n\nFixes #383\n",
      "commitDate": "4/6/15, 7:30 PM",
      "commitName": "b14e7357248a0f683b8252be3e68f5e171fb8529",
      "commitAuthor": "Jonathan Hedley",
      "commitDateOld": "1/3/15, 7:15 AM",
      "commitNameOld": "842977c381b8d48bf12719e3f5cf6fd669379957",
      "commitAuthorOld": "offa",
      "daysBetweenCommits": 93.47,
      "commitsBetweenForRepo": 20,
      "commitsBetweenForFile": 1,
      "actualSource": "static void escape(StringBuilder accum, String string, Document.OutputSettings out, boolean inAttribute, boolean normaliseWhite, boolean stripLeadingWhite) {\n    boolean lastWasWhite \u003d false;\n    boolean reachedNonWhite \u003d false;\n    final EscapeMode escapeMode \u003d out.escapeMode();\n    final CharsetEncoder encoder \u003d out.encoder();\n    final CoreCharset coreCharset \u003d CoreCharset.byName(encoder.charset().name());\n    final Map\u003cCharacter, String\u003e map \u003d escapeMode.getMap();\n    final int length \u003d string.length();\n    int codePoint;\n    for (int offset \u003d 0; offset \u003c length; offset +\u003d Character.charCount(codePoint)) {\n        codePoint \u003d string.codePointAt(offset);\n        if (normaliseWhite) {\n            if (StringUtil.isWhitespace(codePoint)) {\n                if ((stripLeadingWhite \u0026\u0026 !reachedNonWhite) || lastWasWhite)\n                    continue;\n                accum.append(\u0027 \u0027);\n                lastWasWhite \u003d true;\n                continue;\n            } else {\n                lastWasWhite \u003d false;\n                reachedNonWhite \u003d true;\n            }\n        }\n        if (codePoint \u003c Character.MIN_SUPPLEMENTARY_CODE_POINT) {\n            final char c \u003d (char) codePoint;\n            switch(c) {\n                case \u0027\u0026\u0027:\n                    accum.append(\"\u0026amp;\");\n                    break;\n                case 0xA0:\n                    if (escapeMode !\u003d EscapeMode.xhtml)\n                        accum.append(\"\u0026nbsp;\");\n                    else\n                        accum.append(c);\n                    break;\n                case \u0027\u003c\u0027:\n                    if (!inAttribute)\n                        accum.append(\"\u0026lt;\");\n                    else\n                        accum.append(c);\n                    break;\n                case \u0027\u003e\u0027:\n                    if (!inAttribute)\n                        accum.append(\"\u0026gt;\");\n                    else\n                        accum.append(c);\n                    break;\n                case \u0027\"\u0027:\n                    if (inAttribute)\n                        accum.append(\"\u0026quot;\");\n                    else\n                        accum.append(c);\n                    break;\n                default:\n                    if (canEncode(coreCharset, c, encoder))\n                        accum.append(c);\n                    else if (map.containsKey(c))\n                        accum.append(\u0027\u0026\u0027).append(map.get(c)).append(\u0027;\u0027);\n                    else\n                        accum.append(\"\u0026#x\").append(Integer.toHexString(codePoint)).append(\u0027;\u0027);\n            }\n        } else {\n            final String c \u003d new String(Character.toChars(codePoint));\n            if (encoder.canEncode(c))\n                accum.append(c);\n            else\n                accum.append(\"\u0026#x\").append(Integer.toHexString(codePoint)).append(\u0027;\u0027);\n        }\n    }\n}",
      "path": "src/main/java/org/jsoup/nodes/Entities.java",
      "functionStartLine": 79,
      "functionName": "escape",
      "functionAnnotation": "",
      "functionDoc": "",
      "diff": "@@ -1,69 +1,70 @@\n static void escape(StringBuilder accum, String string, Document.OutputSettings out, boolean inAttribute, boolean normaliseWhite, boolean stripLeadingWhite) {\n     boolean lastWasWhite \u003d false;\n     boolean reachedNonWhite \u003d false;\n-    EscapeMode escapeMode \u003d out.escapeMode();\n-    CharsetEncoder encoder \u003d out.encoder();\n-    Map\u003cCharacter, String\u003e map \u003d escapeMode.getMap();\n+    final EscapeMode escapeMode \u003d out.escapeMode();\n+    final CharsetEncoder encoder \u003d out.encoder();\n+    final CoreCharset coreCharset \u003d CoreCharset.byName(encoder.charset().name());\n+    final Map\u003cCharacter, String\u003e map \u003d escapeMode.getMap();\n     final int length \u003d string.length();\n     int codePoint;\n     for (int offset \u003d 0; offset \u003c length; offset +\u003d Character.charCount(codePoint)) {\n         codePoint \u003d string.codePointAt(offset);\n         if (normaliseWhite) {\n             if (StringUtil.isWhitespace(codePoint)) {\n                 if ((stripLeadingWhite \u0026\u0026 !reachedNonWhite) || lastWasWhite)\n                     continue;\n                 accum.append(\u0027 \u0027);\n                 lastWasWhite \u003d true;\n                 continue;\n             } else {\n                 lastWasWhite \u003d false;\n                 reachedNonWhite \u003d true;\n             }\n         }\n         if (codePoint \u003c Character.MIN_SUPPLEMENTARY_CODE_POINT) {\n             final char c \u003d (char) codePoint;\n             switch(c) {\n                 case \u0027\u0026\u0027:\n                     accum.append(\"\u0026amp;\");\n                     break;\n                 case 0xA0:\n                     if (escapeMode !\u003d EscapeMode.xhtml)\n                         accum.append(\"\u0026nbsp;\");\n                     else\n                         accum.append(c);\n                     break;\n                 case \u0027\u003c\u0027:\n                     if (!inAttribute)\n                         accum.append(\"\u0026lt;\");\n                     else\n                         accum.append(c);\n                     break;\n                 case \u0027\u003e\u0027:\n                     if (!inAttribute)\n                         accum.append(\"\u0026gt;\");\n                     else\n                         accum.append(c);\n                     break;\n                 case \u0027\"\u0027:\n                     if (inAttribute)\n                         accum.append(\"\u0026quot;\");\n                     else\n                         accum.append(c);\n                     break;\n                 default:\n-                    if (encoder.canEncode(c))\n+                    if (canEncode(coreCharset, c, encoder))\n                         accum.append(c);\n                     else if (map.containsKey(c))\n                         accum.append(\u0027\u0026\u0027).append(map.get(c)).append(\u0027;\u0027);\n                     else\n                         accum.append(\"\u0026#x\").append(Integer.toHexString(codePoint)).append(\u0027;\u0027);\n             }\n         } else {\n             final String c \u003d new String(Character.toChars(codePoint));\n             if (encoder.canEncode(c))\n                 accum.append(c);\n             else\n                 accum.append(\"\u0026#x\").append(Integer.toHexString(codePoint)).append(\u0027;\u0027);\n         }\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "6c4f16f233cdfd7aedef33374609e9aa4ede255c": {
      "type": "Ymultichange(Yparameterchange,Yreturntypechange,Ybodychange)",
      "commitMessage": "Support for HTML output syntax, enabled by default\n\nIntroduced the ability to chose between HTML and XML output, and made\nHTML the default. This means img tags are\noutput as \u003cimg\u003e, not \u003cimg /\u003e. XML is the default when using the\nXmlTreeBuilder. Control this with the\nDocument.OutputSettings.syntax() method.\n\nTightened the scope of what characters are escaped in attributes and\ntextnodes, to align with the spec. Also, when\nusing the extended escape entities map, only escape a character if the\ncurrent output charset does not support it.\nThis produces smaller, more legible HTML, with greated control over the\noutput (by setting charset and escape mode).\n\nFixes #322\nFixes #373\nFixes #346\nFixes #150\n",
      "commitDate": "11/17/13, 7:11 PM",
      "commitName": "6c4f16f233cdfd7aedef33374609e9aa4ede255c",
      "commitAuthor": "Jonathan Hedley",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "Support for HTML output syntax, enabled by default\n\nIntroduced the ability to chose between HTML and XML output, and made\nHTML the default. This means img tags are\noutput as \u003cimg\u003e, not \u003cimg /\u003e. XML is the default when using the\nXmlTreeBuilder. Control this with the\nDocument.OutputSettings.syntax() method.\n\nTightened the scope of what characters are escaped in attributes and\ntextnodes, to align with the spec. Also, when\nusing the extended escape entities map, only escape a character if the\ncurrent output charset does not support it.\nThis produces smaller, more legible HTML, with greated control over the\noutput (by setting charset and escape mode).\n\nFixes #322\nFixes #373\nFixes #346\nFixes #150\n",
          "commitDate": "11/17/13, 7:11 PM",
          "commitName": "6c4f16f233cdfd7aedef33374609e9aa4ede255c",
          "commitAuthor": "Jonathan Hedley",
          "commitDateOld": "11/16/13, 1:58 PM",
          "commitNameOld": "5e6e9fc84826cb79a24906987cc5d54677482a70",
          "commitAuthorOld": "Jonathan Hedley",
          "daysBetweenCommits": 1.22,
          "commitsBetweenForRepo": 6,
          "commitsBetweenForFile": 1,
          "actualSource": "static void escape(StringBuilder accum, String string, Document.OutputSettings out, boolean inAttribute, boolean normaliseWhite, boolean stripLeadingWhite) {\n    boolean lastWasWhite \u003d false;\n    boolean reachedNonWhite \u003d false;\n    EscapeMode escapeMode \u003d out.escapeMode();\n    CharsetEncoder encoder \u003d out.encoder();\n    Map\u003cCharacter, String\u003e map \u003d escapeMode.getMap();\n    final int length \u003d string.length();\n    int codePoint;\n    for (int offset \u003d 0; offset \u003c length; offset +\u003d Character.charCount(codePoint)) {\n        codePoint \u003d string.codePointAt(offset);\n        if (normaliseWhite) {\n            if (StringUtil.isWhitespace(codePoint)) {\n                if ((stripLeadingWhite \u0026\u0026 !reachedNonWhite) || lastWasWhite)\n                    continue;\n                accum.append(\u0027 \u0027);\n                lastWasWhite \u003d true;\n                continue;\n            } else {\n                lastWasWhite \u003d false;\n                reachedNonWhite \u003d true;\n            }\n        }\n        if (codePoint \u003c Character.MIN_SUPPLEMENTARY_CODE_POINT) {\n            final char c \u003d (char) codePoint;\n            switch(c) {\n                case \u0027\u0026\u0027:\n                    accum.append(\"\u0026amp;\");\n                    break;\n                case 0xA0:\n                    if (escapeMode !\u003d EscapeMode.xhtml)\n                        accum.append(\"\u0026nbsp;\");\n                    else\n                        accum.append(c);\n                    break;\n                case \u0027\u003c\u0027:\n                    if (!inAttribute)\n                        accum.append(\"\u0026lt;\");\n                    else\n                        accum.append(c);\n                    break;\n                case \u0027\u003e\u0027:\n                    if (!inAttribute)\n                        accum.append(\"\u0026gt;\");\n                    else\n                        accum.append(c);\n                    break;\n                case \u0027\"\u0027:\n                    if (inAttribute)\n                        accum.append(\"\u0026quot;\");\n                    else\n                        accum.append(c);\n                    break;\n                default:\n                    if (encoder.canEncode(c))\n                        accum.append(c);\n                    else if (map.containsKey(c))\n                        accum.append(\u0027\u0026\u0027).append(map.get(c)).append(\u0027;\u0027);\n                    else\n                        accum.append(\"\u0026#x\").append(Integer.toHexString(codePoint)).append(\u0027;\u0027);\n            }\n        } else {\n            final String c \u003d new String(Character.toChars(codePoint));\n            if (encoder.canEncode(c))\n                accum.append(c);\n            else\n                accum.append(\"\u0026#x\").append(Integer.toHexString(codePoint)).append(\u0027;\u0027);\n        }\n    }\n}",
          "path": "src/main/java/org/jsoup/nodes/Entities.java",
          "functionStartLine": 81,
          "functionName": "escape",
          "functionAnnotation": "",
          "functionDoc": "",
          "diff": "@@ -1,25 +1,69 @@\n-static String escape(String string, CharsetEncoder encoder, EscapeMode escapeMode) {\n-    StringBuilder accum \u003d new StringBuilder(string.length() * 2);\n+static void escape(StringBuilder accum, String string, Document.OutputSettings out, boolean inAttribute, boolean normaliseWhite, boolean stripLeadingWhite) {\n+    boolean lastWasWhite \u003d false;\n+    boolean reachedNonWhite \u003d false;\n+    EscapeMode escapeMode \u003d out.escapeMode();\n+    CharsetEncoder encoder \u003d out.encoder();\n     Map\u003cCharacter, String\u003e map \u003d escapeMode.getMap();\n     final int length \u003d string.length();\n-    for (int offset \u003d 0; offset \u003c length; ) {\n-        final int codePoint \u003d string.codePointAt(offset);\n+    int codePoint;\n+    for (int offset \u003d 0; offset \u003c length; offset +\u003d Character.charCount(codePoint)) {\n+        codePoint \u003d string.codePointAt(offset);\n+        if (normaliseWhite) {\n+            if (StringUtil.isWhitespace(codePoint)) {\n+                if ((stripLeadingWhite \u0026\u0026 !reachedNonWhite) || lastWasWhite)\n+                    continue;\n+                accum.append(\u0027 \u0027);\n+                lastWasWhite \u003d true;\n+                continue;\n+            } else {\n+                lastWasWhite \u003d false;\n+                reachedNonWhite \u003d true;\n+            }\n+        }\n         if (codePoint \u003c Character.MIN_SUPPLEMENTARY_CODE_POINT) {\n             final char c \u003d (char) codePoint;\n-            if (map.containsKey(c))\n-                accum.append(\u0027\u0026\u0027).append(map.get(c)).append(\u0027;\u0027);\n-            else if (encoder.canEncode(c))\n-                accum.append(c);\n-            else\n-                accum.append(\"\u0026#x\").append(Integer.toHexString(codePoint)).append(\u0027;\u0027);\n+            switch(c) {\n+                case \u0027\u0026\u0027:\n+                    accum.append(\"\u0026amp;\");\n+                    break;\n+                case 0xA0:\n+                    if (escapeMode !\u003d EscapeMode.xhtml)\n+                        accum.append(\"\u0026nbsp;\");\n+                    else\n+                        accum.append(c);\n+                    break;\n+                case \u0027\u003c\u0027:\n+                    if (!inAttribute)\n+                        accum.append(\"\u0026lt;\");\n+                    else\n+                        accum.append(c);\n+                    break;\n+                case \u0027\u003e\u0027:\n+                    if (!inAttribute)\n+                        accum.append(\"\u0026gt;\");\n+                    else\n+                        accum.append(c);\n+                    break;\n+                case \u0027\"\u0027:\n+                    if (inAttribute)\n+                        accum.append(\"\u0026quot;\");\n+                    else\n+                        accum.append(c);\n+                    break;\n+                default:\n+                    if (encoder.canEncode(c))\n+                        accum.append(c);\n+                    else if (map.containsKey(c))\n+                        accum.append(\u0027\u0026\u0027).append(map.get(c)).append(\u0027;\u0027);\n+                    else\n+                        accum.append(\"\u0026#x\").append(Integer.toHexString(codePoint)).append(\u0027;\u0027);\n+            }\n         } else {\n             final String c \u003d new String(Character.toChars(codePoint));\n             if (encoder.canEncode(c))\n                 accum.append(c);\n             else\n                 accum.append(\"\u0026#x\").append(Integer.toHexString(codePoint)).append(\u0027;\u0027);\n         }\n-        offset +\u003d Character.charCount(codePoint);\n     }\n-    return accum.toString();\n }\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldValue": "[string-String, encoder-CharsetEncoder, escapeMode-EscapeMode]",
            "newValue": "[accum-StringBuilder, string-String, out-Document.OutputSettings, inAttribute-boolean, normaliseWhite-boolean, stripLeadingWhite-boolean]"
          }
        },
        {
          "type": "Yreturntypechange",
          "commitMessage": "Support for HTML output syntax, enabled by default\n\nIntroduced the ability to chose between HTML and XML output, and made\nHTML the default. This means img tags are\noutput as \u003cimg\u003e, not \u003cimg /\u003e. XML is the default when using the\nXmlTreeBuilder. Control this with the\nDocument.OutputSettings.syntax() method.\n\nTightened the scope of what characters are escaped in attributes and\ntextnodes, to align with the spec. Also, when\nusing the extended escape entities map, only escape a character if the\ncurrent output charset does not support it.\nThis produces smaller, more legible HTML, with greated control over the\noutput (by setting charset and escape mode).\n\nFixes #322\nFixes #373\nFixes #346\nFixes #150\n",
          "commitDate": "11/17/13, 7:11 PM",
          "commitName": "6c4f16f233cdfd7aedef33374609e9aa4ede255c",
          "commitAuthor": "Jonathan Hedley",
          "commitDateOld": "11/16/13, 1:58 PM",
          "commitNameOld": "5e6e9fc84826cb79a24906987cc5d54677482a70",
          "commitAuthorOld": "Jonathan Hedley",
          "daysBetweenCommits": 1.22,
          "commitsBetweenForRepo": 6,
          "commitsBetweenForFile": 1,
          "actualSource": "static void escape(StringBuilder accum, String string, Document.OutputSettings out, boolean inAttribute, boolean normaliseWhite, boolean stripLeadingWhite) {\n    boolean lastWasWhite \u003d false;\n    boolean reachedNonWhite \u003d false;\n    EscapeMode escapeMode \u003d out.escapeMode();\n    CharsetEncoder encoder \u003d out.encoder();\n    Map\u003cCharacter, String\u003e map \u003d escapeMode.getMap();\n    final int length \u003d string.length();\n    int codePoint;\n    for (int offset \u003d 0; offset \u003c length; offset +\u003d Character.charCount(codePoint)) {\n        codePoint \u003d string.codePointAt(offset);\n        if (normaliseWhite) {\n            if (StringUtil.isWhitespace(codePoint)) {\n                if ((stripLeadingWhite \u0026\u0026 !reachedNonWhite) || lastWasWhite)\n                    continue;\n                accum.append(\u0027 \u0027);\n                lastWasWhite \u003d true;\n                continue;\n            } else {\n                lastWasWhite \u003d false;\n                reachedNonWhite \u003d true;\n            }\n        }\n        if (codePoint \u003c Character.MIN_SUPPLEMENTARY_CODE_POINT) {\n            final char c \u003d (char) codePoint;\n            switch(c) {\n                case \u0027\u0026\u0027:\n                    accum.append(\"\u0026amp;\");\n                    break;\n                case 0xA0:\n                    if (escapeMode !\u003d EscapeMode.xhtml)\n                        accum.append(\"\u0026nbsp;\");\n                    else\n                        accum.append(c);\n                    break;\n                case \u0027\u003c\u0027:\n                    if (!inAttribute)\n                        accum.append(\"\u0026lt;\");\n                    else\n                        accum.append(c);\n                    break;\n                case \u0027\u003e\u0027:\n                    if (!inAttribute)\n                        accum.append(\"\u0026gt;\");\n                    else\n                        accum.append(c);\n                    break;\n                case \u0027\"\u0027:\n                    if (inAttribute)\n                        accum.append(\"\u0026quot;\");\n                    else\n                        accum.append(c);\n                    break;\n                default:\n                    if (encoder.canEncode(c))\n                        accum.append(c);\n                    else if (map.containsKey(c))\n                        accum.append(\u0027\u0026\u0027).append(map.get(c)).append(\u0027;\u0027);\n                    else\n                        accum.append(\"\u0026#x\").append(Integer.toHexString(codePoint)).append(\u0027;\u0027);\n            }\n        } else {\n            final String c \u003d new String(Character.toChars(codePoint));\n            if (encoder.canEncode(c))\n                accum.append(c);\n            else\n                accum.append(\"\u0026#x\").append(Integer.toHexString(codePoint)).append(\u0027;\u0027);\n        }\n    }\n}",
          "path": "src/main/java/org/jsoup/nodes/Entities.java",
          "functionStartLine": 81,
          "functionName": "escape",
          "functionAnnotation": "",
          "functionDoc": "",
          "diff": "@@ -1,25 +1,69 @@\n-static String escape(String string, CharsetEncoder encoder, EscapeMode escapeMode) {\n-    StringBuilder accum \u003d new StringBuilder(string.length() * 2);\n+static void escape(StringBuilder accum, String string, Document.OutputSettings out, boolean inAttribute, boolean normaliseWhite, boolean stripLeadingWhite) {\n+    boolean lastWasWhite \u003d false;\n+    boolean reachedNonWhite \u003d false;\n+    EscapeMode escapeMode \u003d out.escapeMode();\n+    CharsetEncoder encoder \u003d out.encoder();\n     Map\u003cCharacter, String\u003e map \u003d escapeMode.getMap();\n     final int length \u003d string.length();\n-    for (int offset \u003d 0; offset \u003c length; ) {\n-        final int codePoint \u003d string.codePointAt(offset);\n+    int codePoint;\n+    for (int offset \u003d 0; offset \u003c length; offset +\u003d Character.charCount(codePoint)) {\n+        codePoint \u003d string.codePointAt(offset);\n+        if (normaliseWhite) {\n+            if (StringUtil.isWhitespace(codePoint)) {\n+                if ((stripLeadingWhite \u0026\u0026 !reachedNonWhite) || lastWasWhite)\n+                    continue;\n+                accum.append(\u0027 \u0027);\n+                lastWasWhite \u003d true;\n+                continue;\n+            } else {\n+                lastWasWhite \u003d false;\n+                reachedNonWhite \u003d true;\n+            }\n+        }\n         if (codePoint \u003c Character.MIN_SUPPLEMENTARY_CODE_POINT) {\n             final char c \u003d (char) codePoint;\n-            if (map.containsKey(c))\n-                accum.append(\u0027\u0026\u0027).append(map.get(c)).append(\u0027;\u0027);\n-            else if (encoder.canEncode(c))\n-                accum.append(c);\n-            else\n-                accum.append(\"\u0026#x\").append(Integer.toHexString(codePoint)).append(\u0027;\u0027);\n+            switch(c) {\n+                case \u0027\u0026\u0027:\n+                    accum.append(\"\u0026amp;\");\n+                    break;\n+                case 0xA0:\n+                    if (escapeMode !\u003d EscapeMode.xhtml)\n+                        accum.append(\"\u0026nbsp;\");\n+                    else\n+                        accum.append(c);\n+                    break;\n+                case \u0027\u003c\u0027:\n+                    if (!inAttribute)\n+                        accum.append(\"\u0026lt;\");\n+                    else\n+                        accum.append(c);\n+                    break;\n+                case \u0027\u003e\u0027:\n+                    if (!inAttribute)\n+                        accum.append(\"\u0026gt;\");\n+                    else\n+                        accum.append(c);\n+                    break;\n+                case \u0027\"\u0027:\n+                    if (inAttribute)\n+                        accum.append(\"\u0026quot;\");\n+                    else\n+                        accum.append(c);\n+                    break;\n+                default:\n+                    if (encoder.canEncode(c))\n+                        accum.append(c);\n+                    else if (map.containsKey(c))\n+                        accum.append(\u0027\u0026\u0027).append(map.get(c)).append(\u0027;\u0027);\n+                    else\n+                        accum.append(\"\u0026#x\").append(Integer.toHexString(codePoint)).append(\u0027;\u0027);\n+            }\n         } else {\n             final String c \u003d new String(Character.toChars(codePoint));\n             if (encoder.canEncode(c))\n                 accum.append(c);\n             else\n                 accum.append(\"\u0026#x\").append(Integer.toHexString(codePoint)).append(\u0027;\u0027);\n         }\n-        offset +\u003d Character.charCount(codePoint);\n     }\n-    return accum.toString();\n }\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldValue": "String",
            "newValue": "void"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "Support for HTML output syntax, enabled by default\n\nIntroduced the ability to chose between HTML and XML output, and made\nHTML the default. This means img tags are\noutput as \u003cimg\u003e, not \u003cimg /\u003e. XML is the default when using the\nXmlTreeBuilder. Control this with the\nDocument.OutputSettings.syntax() method.\n\nTightened the scope of what characters are escaped in attributes and\ntextnodes, to align with the spec. Also, when\nusing the extended escape entities map, only escape a character if the\ncurrent output charset does not support it.\nThis produces smaller, more legible HTML, with greated control over the\noutput (by setting charset and escape mode).\n\nFixes #322\nFixes #373\nFixes #346\nFixes #150\n",
          "commitDate": "11/17/13, 7:11 PM",
          "commitName": "6c4f16f233cdfd7aedef33374609e9aa4ede255c",
          "commitAuthor": "Jonathan Hedley",
          "commitDateOld": "11/16/13, 1:58 PM",
          "commitNameOld": "5e6e9fc84826cb79a24906987cc5d54677482a70",
          "commitAuthorOld": "Jonathan Hedley",
          "daysBetweenCommits": 1.22,
          "commitsBetweenForRepo": 6,
          "commitsBetweenForFile": 1,
          "actualSource": "static void escape(StringBuilder accum, String string, Document.OutputSettings out, boolean inAttribute, boolean normaliseWhite, boolean stripLeadingWhite) {\n    boolean lastWasWhite \u003d false;\n    boolean reachedNonWhite \u003d false;\n    EscapeMode escapeMode \u003d out.escapeMode();\n    CharsetEncoder encoder \u003d out.encoder();\n    Map\u003cCharacter, String\u003e map \u003d escapeMode.getMap();\n    final int length \u003d string.length();\n    int codePoint;\n    for (int offset \u003d 0; offset \u003c length; offset +\u003d Character.charCount(codePoint)) {\n        codePoint \u003d string.codePointAt(offset);\n        if (normaliseWhite) {\n            if (StringUtil.isWhitespace(codePoint)) {\n                if ((stripLeadingWhite \u0026\u0026 !reachedNonWhite) || lastWasWhite)\n                    continue;\n                accum.append(\u0027 \u0027);\n                lastWasWhite \u003d true;\n                continue;\n            } else {\n                lastWasWhite \u003d false;\n                reachedNonWhite \u003d true;\n            }\n        }\n        if (codePoint \u003c Character.MIN_SUPPLEMENTARY_CODE_POINT) {\n            final char c \u003d (char) codePoint;\n            switch(c) {\n                case \u0027\u0026\u0027:\n                    accum.append(\"\u0026amp;\");\n                    break;\n                case 0xA0:\n                    if (escapeMode !\u003d EscapeMode.xhtml)\n                        accum.append(\"\u0026nbsp;\");\n                    else\n                        accum.append(c);\n                    break;\n                case \u0027\u003c\u0027:\n                    if (!inAttribute)\n                        accum.append(\"\u0026lt;\");\n                    else\n                        accum.append(c);\n                    break;\n                case \u0027\u003e\u0027:\n                    if (!inAttribute)\n                        accum.append(\"\u0026gt;\");\n                    else\n                        accum.append(c);\n                    break;\n                case \u0027\"\u0027:\n                    if (inAttribute)\n                        accum.append(\"\u0026quot;\");\n                    else\n                        accum.append(c);\n                    break;\n                default:\n                    if (encoder.canEncode(c))\n                        accum.append(c);\n                    else if (map.containsKey(c))\n                        accum.append(\u0027\u0026\u0027).append(map.get(c)).append(\u0027;\u0027);\n                    else\n                        accum.append(\"\u0026#x\").append(Integer.toHexString(codePoint)).append(\u0027;\u0027);\n            }\n        } else {\n            final String c \u003d new String(Character.toChars(codePoint));\n            if (encoder.canEncode(c))\n                accum.append(c);\n            else\n                accum.append(\"\u0026#x\").append(Integer.toHexString(codePoint)).append(\u0027;\u0027);\n        }\n    }\n}",
          "path": "src/main/java/org/jsoup/nodes/Entities.java",
          "functionStartLine": 81,
          "functionName": "escape",
          "functionAnnotation": "",
          "functionDoc": "",
          "diff": "@@ -1,25 +1,69 @@\n-static String escape(String string, CharsetEncoder encoder, EscapeMode escapeMode) {\n-    StringBuilder accum \u003d new StringBuilder(string.length() * 2);\n+static void escape(StringBuilder accum, String string, Document.OutputSettings out, boolean inAttribute, boolean normaliseWhite, boolean stripLeadingWhite) {\n+    boolean lastWasWhite \u003d false;\n+    boolean reachedNonWhite \u003d false;\n+    EscapeMode escapeMode \u003d out.escapeMode();\n+    CharsetEncoder encoder \u003d out.encoder();\n     Map\u003cCharacter, String\u003e map \u003d escapeMode.getMap();\n     final int length \u003d string.length();\n-    for (int offset \u003d 0; offset \u003c length; ) {\n-        final int codePoint \u003d string.codePointAt(offset);\n+    int codePoint;\n+    for (int offset \u003d 0; offset \u003c length; offset +\u003d Character.charCount(codePoint)) {\n+        codePoint \u003d string.codePointAt(offset);\n+        if (normaliseWhite) {\n+            if (StringUtil.isWhitespace(codePoint)) {\n+                if ((stripLeadingWhite \u0026\u0026 !reachedNonWhite) || lastWasWhite)\n+                    continue;\n+                accum.append(\u0027 \u0027);\n+                lastWasWhite \u003d true;\n+                continue;\n+            } else {\n+                lastWasWhite \u003d false;\n+                reachedNonWhite \u003d true;\n+            }\n+        }\n         if (codePoint \u003c Character.MIN_SUPPLEMENTARY_CODE_POINT) {\n             final char c \u003d (char) codePoint;\n-            if (map.containsKey(c))\n-                accum.append(\u0027\u0026\u0027).append(map.get(c)).append(\u0027;\u0027);\n-            else if (encoder.canEncode(c))\n-                accum.append(c);\n-            else\n-                accum.append(\"\u0026#x\").append(Integer.toHexString(codePoint)).append(\u0027;\u0027);\n+            switch(c) {\n+                case \u0027\u0026\u0027:\n+                    accum.append(\"\u0026amp;\");\n+                    break;\n+                case 0xA0:\n+                    if (escapeMode !\u003d EscapeMode.xhtml)\n+                        accum.append(\"\u0026nbsp;\");\n+                    else\n+                        accum.append(c);\n+                    break;\n+                case \u0027\u003c\u0027:\n+                    if (!inAttribute)\n+                        accum.append(\"\u0026lt;\");\n+                    else\n+                        accum.append(c);\n+                    break;\n+                case \u0027\u003e\u0027:\n+                    if (!inAttribute)\n+                        accum.append(\"\u0026gt;\");\n+                    else\n+                        accum.append(c);\n+                    break;\n+                case \u0027\"\u0027:\n+                    if (inAttribute)\n+                        accum.append(\"\u0026quot;\");\n+                    else\n+                        accum.append(c);\n+                    break;\n+                default:\n+                    if (encoder.canEncode(c))\n+                        accum.append(c);\n+                    else if (map.containsKey(c))\n+                        accum.append(\u0027\u0026\u0027).append(map.get(c)).append(\u0027;\u0027);\n+                    else\n+                        accum.append(\"\u0026#x\").append(Integer.toHexString(codePoint)).append(\u0027;\u0027);\n+            }\n         } else {\n             final String c \u003d new String(Character.toChars(codePoint));\n             if (encoder.canEncode(c))\n                 accum.append(c);\n             else\n                 accum.append(\"\u0026#x\").append(Integer.toHexString(codePoint)).append(\u0027;\u0027);\n         }\n-        offset +\u003d Character.charCount(codePoint);\n     }\n-    return accum.toString();\n }\n\\ No newline at end of file\n",
          "extendedDetails": {}
        }
      ]
    },
    "a991deb4430343e8f22de5d5aa51f829bab52315": {
      "type": "Ybodychange",
      "commitMessage": "Output valid hex escapes this time.\n",
      "commitDate": "1/27/13, 2:03 PM",
      "commitName": "a991deb4430343e8f22de5d5aa51f829bab52315",
      "commitAuthor": "Jonathan Hedley",
      "commitDateOld": "1/27/13, 1:58 PM",
      "commitNameOld": "ae51709b8c07098fa688ec6be0b5a7dec7654178",
      "commitAuthorOld": "Jonathan Hedley",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "static String escape(String string, CharsetEncoder encoder, EscapeMode escapeMode) {\n    StringBuilder accum \u003d new StringBuilder(string.length() * 2);\n    Map\u003cCharacter, String\u003e map \u003d escapeMode.getMap();\n    final int length \u003d string.length();\n    for (int offset \u003d 0; offset \u003c length; ) {\n        final int codePoint \u003d string.codePointAt(offset);\n        if (codePoint \u003c Character.MIN_SUPPLEMENTARY_CODE_POINT) {\n            final char c \u003d (char) codePoint;\n            if (map.containsKey(c))\n                accum.append(\u0027\u0026\u0027).append(map.get(c)).append(\u0027;\u0027);\n            else if (encoder.canEncode(c))\n                accum.append(c);\n            else\n                accum.append(\"\u0026#x\").append(Integer.toHexString(codePoint)).append(\u0027;\u0027);\n        } else {\n            final String c \u003d new String(Character.toChars(codePoint));\n            if (encoder.canEncode(c))\n                accum.append(c);\n            else\n                accum.append(\"\u0026#x\").append(Integer.toHexString(codePoint)).append(\u0027;\u0027);\n        }\n        offset +\u003d Character.charCount(codePoint);\n    }\n    return accum.toString();\n}",
      "path": "src/main/java/org/jsoup/nodes/Entities.java",
      "functionStartLine": 79,
      "functionName": "escape",
      "functionAnnotation": "",
      "functionDoc": "",
      "diff": "@@ -1,25 +1,25 @@\n static String escape(String string, CharsetEncoder encoder, EscapeMode escapeMode) {\n     StringBuilder accum \u003d new StringBuilder(string.length() * 2);\n     Map\u003cCharacter, String\u003e map \u003d escapeMode.getMap();\n     final int length \u003d string.length();\n     for (int offset \u003d 0; offset \u003c length; ) {\n         final int codePoint \u003d string.codePointAt(offset);\n         if (codePoint \u003c Character.MIN_SUPPLEMENTARY_CODE_POINT) {\n             final char c \u003d (char) codePoint;\n             if (map.containsKey(c))\n                 accum.append(\u0027\u0026\u0027).append(map.get(c)).append(\u0027;\u0027);\n             else if (encoder.canEncode(c))\n                 accum.append(c);\n             else\n-                accum.append(\"\u0026x\").append(Integer.toHexString(codePoint)).append(\u0027;\u0027);\n+                accum.append(\"\u0026#x\").append(Integer.toHexString(codePoint)).append(\u0027;\u0027);\n         } else {\n             final String c \u003d new String(Character.toChars(codePoint));\n             if (encoder.canEncode(c))\n                 accum.append(c);\n             else\n-                accum.append(\"\u0026x\").append(Integer.toHexString(codePoint)).append(\u0027;\u0027);\n+                accum.append(\"\u0026#x\").append(Integer.toHexString(codePoint)).append(\u0027;\u0027);\n         }\n         offset +\u003d Character.charCount(codePoint);\n     }\n     return accum.toString();\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "ae51709b8c07098fa688ec6be0b5a7dec7654178": {
      "type": "Ybodychange",
      "commitMessage": "Output escape codes in hex instead of decimal.\n\nFor characters that need to be escaped, this produces a smaller more\nlegible escape code, and Unicode chars are generally described in hex,\nnot dec.\n",
      "commitDate": "1/27/13, 1:58 PM",
      "commitName": "ae51709b8c07098fa688ec6be0b5a7dec7654178",
      "commitAuthor": "Jonathan Hedley",
      "commitDateOld": "1/27/13, 1:33 PM",
      "commitNameOld": "43cd48ba8e4701d429c8a7c1eea503ad139aaf90",
      "commitAuthorOld": "Jonathan Hedley",
      "daysBetweenCommits": 0.02,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "static String escape(String string, CharsetEncoder encoder, EscapeMode escapeMode) {\n    StringBuilder accum \u003d new StringBuilder(string.length() * 2);\n    Map\u003cCharacter, String\u003e map \u003d escapeMode.getMap();\n    final int length \u003d string.length();\n    for (int offset \u003d 0; offset \u003c length; ) {\n        final int codePoint \u003d string.codePointAt(offset);\n        if (codePoint \u003c Character.MIN_SUPPLEMENTARY_CODE_POINT) {\n            final char c \u003d (char) codePoint;\n            if (map.containsKey(c))\n                accum.append(\u0027\u0026\u0027).append(map.get(c)).append(\u0027;\u0027);\n            else if (encoder.canEncode(c))\n                accum.append(c);\n            else\n                accum.append(\"\u0026x\").append(Integer.toHexString(codePoint)).append(\u0027;\u0027);\n        } else {\n            final String c \u003d new String(Character.toChars(codePoint));\n            if (encoder.canEncode(c))\n                accum.append(c);\n            else\n                accum.append(\"\u0026x\").append(Integer.toHexString(codePoint)).append(\u0027;\u0027);\n        }\n        offset +\u003d Character.charCount(codePoint);\n    }\n    return accum.toString();\n}",
      "path": "src/main/java/org/jsoup/nodes/Entities.java",
      "functionStartLine": 79,
      "functionName": "escape",
      "functionAnnotation": "",
      "functionDoc": "",
      "diff": "@@ -1,25 +1,25 @@\n static String escape(String string, CharsetEncoder encoder, EscapeMode escapeMode) {\n     StringBuilder accum \u003d new StringBuilder(string.length() * 2);\n     Map\u003cCharacter, String\u003e map \u003d escapeMode.getMap();\n     final int length \u003d string.length();\n     for (int offset \u003d 0; offset \u003c length; ) {\n         final int codePoint \u003d string.codePointAt(offset);\n         if (codePoint \u003c Character.MIN_SUPPLEMENTARY_CODE_POINT) {\n             final char c \u003d (char) codePoint;\n             if (map.containsKey(c))\n                 accum.append(\u0027\u0026\u0027).append(map.get(c)).append(\u0027;\u0027);\n             else if (encoder.canEncode(c))\n                 accum.append(c);\n             else\n-                accum.append(\"\u0026#\").append(codePoint).append(\u0027;\u0027);\n+                accum.append(\"\u0026x\").append(Integer.toHexString(codePoint)).append(\u0027;\u0027);\n         } else {\n             final String c \u003d new String(Character.toChars(codePoint));\n             if (encoder.canEncode(c))\n                 accum.append(c);\n             else\n-                accum.append(\"\u0026#\").append(codePoint).append(\u0027;\u0027);\n+                accum.append(\"\u0026x\").append(Integer.toHexString(codePoint)).append(\u0027;\u0027);\n         }\n         offset +\u003d Character.charCount(codePoint);\n     }\n     return accum.toString();\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "43cd48ba8e4701d429c8a7c1eea503ad139aaf90": {
      "type": "Ybodychange",
      "commitMessage": "Tweaked mingfai\u0027s surrogate pair implementation for efficiency.\n\nOn the core cases where characters are not surrogate pairs, I\u0027ve kept\nto pushing chars around. This is to try and minimize the number of\nshort-lived String objects.\n",
      "commitDate": "1/27/13, 1:33 PM",
      "commitName": "43cd48ba8e4701d429c8a7c1eea503ad139aaf90",
      "commitAuthor": "Jonathan Hedley",
      "commitDateOld": "1/25/13, 11:15 PM",
      "commitNameOld": "c2a9605b70fdae3c064b49bf2a0b633c935322cc",
      "commitAuthorOld": "mingfai.ma",
      "daysBetweenCommits": 1.6,
      "commitsBetweenForRepo": 9,
      "commitsBetweenForFile": 1,
      "actualSource": "static String escape(String string, CharsetEncoder encoder, EscapeMode escapeMode) {\n    StringBuilder accum \u003d new StringBuilder(string.length() * 2);\n    Map\u003cCharacter, String\u003e map \u003d escapeMode.getMap();\n    final int length \u003d string.length();\n    for (int offset \u003d 0; offset \u003c length; ) {\n        final int codePoint \u003d string.codePointAt(offset);\n        if (codePoint \u003c Character.MIN_SUPPLEMENTARY_CODE_POINT) {\n            final char c \u003d (char) codePoint;\n            if (map.containsKey(c))\n                accum.append(\u0027\u0026\u0027).append(map.get(c)).append(\u0027;\u0027);\n            else if (encoder.canEncode(c))\n                accum.append(c);\n            else\n                accum.append(\"\u0026#\").append(codePoint).append(\u0027;\u0027);\n        } else {\n            final String c \u003d new String(Character.toChars(codePoint));\n            if (encoder.canEncode(c))\n                accum.append(c);\n            else\n                accum.append(\"\u0026#\").append(codePoint).append(\u0027;\u0027);\n        }\n        offset +\u003d Character.charCount(codePoint);\n    }\n    return accum.toString();\n}",
      "path": "src/main/java/org/jsoup/nodes/Entities.java",
      "functionStartLine": 79,
      "functionName": "escape",
      "functionAnnotation": "",
      "functionDoc": "",
      "diff": "@@ -1,17 +1,25 @@\n static String escape(String string, CharsetEncoder encoder, EscapeMode escapeMode) {\n     StringBuilder accum \u003d new StringBuilder(string.length() * 2);\n     Map\u003cCharacter, String\u003e map \u003d escapeMode.getMap();\n     final int length \u003d string.length();\n     for (int offset \u003d 0; offset \u003c length; ) {\n         final int codePoint \u003d string.codePointAt(offset);\n-        char[] chars \u003d Character.toChars(codePoint);\n-        if (chars.length \u003d\u003d 1 \u0026\u0026 map.containsKey(chars[0]))\n-            accum.append(\u0027\u0026\u0027).append(map.get(chars[0])).append(\u0027;\u0027);\n-        else if (encoder.canEncode(new String(chars)))\n-            accum.append(new String(chars));\n-        else\n-            accum.append(\"\u0026#\").append(codePoint).append(\u0027;\u0027);\n+        if (codePoint \u003c Character.MIN_SUPPLEMENTARY_CODE_POINT) {\n+            final char c \u003d (char) codePoint;\n+            if (map.containsKey(c))\n+                accum.append(\u0027\u0026\u0027).append(map.get(c)).append(\u0027;\u0027);\n+            else if (encoder.canEncode(c))\n+                accum.append(c);\n+            else\n+                accum.append(\"\u0026#\").append(codePoint).append(\u0027;\u0027);\n+        } else {\n+            final String c \u003d new String(Character.toChars(codePoint));\n+            if (encoder.canEncode(c))\n+                accum.append(c);\n+            else\n+                accum.append(\"\u0026#\").append(codePoint).append(\u0027;\u0027);\n+        }\n         offset +\u003d Character.charCount(codePoint);\n     }\n     return accum.toString();\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "c2a9605b70fdae3c064b49bf2a0b633c935322cc": {
      "type": "Ybodychange",
      "commitMessage": "changed Entities.escape to escape String with supplementary characters correctly, and added two test cases to verify\n",
      "commitDate": "1/25/13, 11:15 PM",
      "commitName": "c2a9605b70fdae3c064b49bf2a0b633c935322cc",
      "commitAuthor": "mingfai.ma",
      "commitDateOld": "9/23/12, 12:16 PM",
      "commitNameOld": "a31ec08e102fd3832f3ff4449e9163440f0afb2c",
      "commitAuthorOld": "Jonathan Hedley",
      "daysBetweenCommits": 124.5,
      "commitsBetweenForRepo": 26,
      "commitsBetweenForFile": 1,
      "actualSource": "static String escape(String string, CharsetEncoder encoder, EscapeMode escapeMode) {\n    StringBuilder accum \u003d new StringBuilder(string.length() * 2);\n    Map\u003cCharacter, String\u003e map \u003d escapeMode.getMap();\n    final int length \u003d string.length();\n    for (int offset \u003d 0; offset \u003c length; ) {\n        final int codePoint \u003d string.codePointAt(offset);\n        char[] chars \u003d Character.toChars(codePoint);\n        if (chars.length \u003d\u003d 1 \u0026\u0026 map.containsKey(chars[0]))\n            accum.append(\u0027\u0026\u0027).append(map.get(chars[0])).append(\u0027;\u0027);\n        else if (encoder.canEncode(new String(chars)))\n            accum.append(new String(chars));\n        else\n            accum.append(\"\u0026#\").append(codePoint).append(\u0027;\u0027);\n        offset +\u003d Character.charCount(codePoint);\n    }\n    return accum.toString();\n}",
      "path": "src/main/java/org/jsoup/nodes/Entities.java",
      "functionStartLine": 79,
      "functionName": "escape",
      "functionAnnotation": "",
      "functionDoc": "",
      "diff": "@@ -1,14 +1,17 @@\n static String escape(String string, CharsetEncoder encoder, EscapeMode escapeMode) {\n     StringBuilder accum \u003d new StringBuilder(string.length() * 2);\n     Map\u003cCharacter, String\u003e map \u003d escapeMode.getMap();\n-    for (int pos \u003d 0; pos \u003c string.length(); pos++) {\n-        Character c \u003d string.charAt(pos);\n-        if (map.containsKey(c))\n-            accum.append(\u0027\u0026\u0027).append(map.get(c)).append(\u0027;\u0027);\n-        else if (encoder.canEncode(c))\n-            accum.append(c.charValue());\n+    final int length \u003d string.length();\n+    for (int offset \u003d 0; offset \u003c length; ) {\n+        final int codePoint \u003d string.codePointAt(offset);\n+        char[] chars \u003d Character.toChars(codePoint);\n+        if (chars.length \u003d\u003d 1 \u0026\u0026 map.containsKey(chars[0]))\n+            accum.append(\u0027\u0026\u0027).append(map.get(chars[0])).append(\u0027;\u0027);\n+        else if (encoder.canEncode(new String(chars)))\n+            accum.append(new String(chars));\n         else\n-            accum.append(\"\u0026#\").append((int) c).append(\u0027;\u0027);\n+            accum.append(\"\u0026#\").append(codePoint).append(\u0027;\u0027);\n+        offset +\u003d Character.charCount(codePoint);\n     }\n     return accum.toString();\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "f4f2efb22f24378eb608aa308ba30cbfee3b3df2": {
      "type": "Ybodychange",
      "commitMessage": "added EscapeMode.minimum\n",
      "commitDate": "7/2/11, 4:12 AM",
      "commitName": "f4f2efb22f24378eb608aa308ba30cbfee3b3df2",
      "commitAuthor": "Akira Ueda",
      "commitDateOld": "7/2/11, 4:12 AM",
      "commitNameOld": "20ed24cefb5df53c48021459af98bef83c55f241",
      "commitAuthorOld": "Jonathan Hedley",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "static String escape(String string, CharsetEncoder encoder, EscapeMode escapeMode) {\n    StringBuilder accum \u003d new StringBuilder(string.length() * 2);\n    Map\u003cCharacter, String\u003e map \u003d escapeMode.getMap();\n    for (int pos \u003d 0; pos \u003c string.length(); pos++) {\n        Character c \u003d string.charAt(pos);\n        if (map.containsKey(c))\n            accum.append(\u0027\u0026\u0027).append(map.get(c)).append(\u0027;\u0027);\n        else if (encoder.canEncode(c))\n            accum.append(c.charValue());\n        else\n            accum.append(\"\u0026#\").append((int) c).append(\u0027;\u0027);\n    }\n    return accum.toString();\n}",
      "path": "src/main/java/org/jsoup/nodes/Entities.java",
      "functionStartLine": 39,
      "functionName": "escape",
      "functionAnnotation": "",
      "functionDoc": "",
      "diff": "@@ -1,14 +1,14 @@\n static String escape(String string, CharsetEncoder encoder, EscapeMode escapeMode) {\n     StringBuilder accum \u003d new StringBuilder(string.length() * 2);\n-    Map\u003cCharacter, String\u003e map \u003d escapeMode \u003d\u003d EscapeMode.extended ? fullByVal : baseByVal;\n+    Map\u003cCharacter, String\u003e map \u003d escapeMode.getMap();\n     for (int pos \u003d 0; pos \u003c string.length(); pos++) {\n         Character c \u003d string.charAt(pos);\n         if (map.containsKey(c))\n             accum.append(\u0027\u0026\u0027).append(map.get(c)).append(\u0027;\u0027);\n         else if (encoder.canEncode(c))\n             accum.append(c.charValue());\n         else\n             accum.append(\"\u0026#\").append((int) c).append(\u0027;\u0027);\n     }\n     return accum.toString();\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "09d99e7e5edc96348b9fa50131274aed3ee1bd2e": {
      "type": "Ybodychange",
      "commitMessage": "Mini optimisations\n",
      "commitDate": "7/2/11, 4:11 AM",
      "commitName": "09d99e7e5edc96348b9fa50131274aed3ee1bd2e",
      "commitAuthor": "Jonathan Hedley",
      "commitDateOld": "7/2/11, 4:11 AM",
      "commitNameOld": "57bce6dc8424637621f6b660855f23e72a08c4b3",
      "commitAuthorOld": "Jonathan Hedley",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 8,
      "commitsBetweenForFile": 1,
      "actualSource": "static String escape(String string, CharsetEncoder encoder, EscapeMode escapeMode) {\n    StringBuilder accum \u003d new StringBuilder(string.length() * 2);\n    Map\u003cCharacter, String\u003e map \u003d escapeMode \u003d\u003d EscapeMode.extended ? fullByVal : baseByVal;\n    for (int pos \u003d 0; pos \u003c string.length(); pos++) {\n        Character c \u003d string.charAt(pos);\n        if (map.containsKey(c))\n            accum.append(\u0027\u0026\u0027).append(map.get(c)).append(\u0027;\u0027);\n        else if (encoder.canEncode(c))\n            accum.append(c.charValue());\n        else\n            accum.append(\"\u0026#\").append((int) c).append(\u0027;\u0027);\n    }\n    return accum.toString();\n}",
      "path": "src/main/java/org/jsoup/nodes/Entities.java",
      "functionStartLine": 31,
      "functionName": "escape",
      "functionAnnotation": "",
      "functionDoc": "",
      "diff": "@@ -1,14 +1,14 @@\n static String escape(String string, CharsetEncoder encoder, EscapeMode escapeMode) {\n     StringBuilder accum \u003d new StringBuilder(string.length() * 2);\n     Map\u003cCharacter, String\u003e map \u003d escapeMode \u003d\u003d EscapeMode.extended ? fullByVal : baseByVal;\n     for (int pos \u003d 0; pos \u003c string.length(); pos++) {\n         Character c \u003d string.charAt(pos);\n         if (map.containsKey(c))\n-            accum.append(\"\u0026\").append(map.get(c)).append(\";\");\n+            accum.append(\u0027\u0026\u0027).append(map.get(c)).append(\u0027;\u0027);\n         else if (encoder.canEncode(c))\n-            accum.append(c);\n+            accum.append(c.charValue());\n         else\n-            accum.append(\"\u0026#\").append((int) c).append(\";\");\n+            accum.append(\"\u0026#\").append((int) c).append(\u0027;\u0027);\n     }\n     return accum.toString();\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "f8841edabba28d6125dd87ed72f557e85570066b": {
      "type": "Ymultichange(Yfilerename,Ybodychange,Yparameterchange)",
      "commitMessage": "Working on escape/unescape routine.\n",
      "commitDate": "7/2/11, 4:11 AM",
      "commitName": "f8841edabba28d6125dd87ed72f557e85570066b",
      "commitAuthor": "Jonathan Hedley",
      "subchanges": [
        {
          "type": "Yfilerename",
          "commitMessage": "Working on escape/unescape routine.\n",
          "commitDate": "7/2/11, 4:11 AM",
          "commitName": "f8841edabba28d6125dd87ed72f557e85570066b",
          "commitAuthor": "Jonathan Hedley",
          "commitDateOld": "7/2/11, 4:11 AM",
          "commitNameOld": "17486e2fa5b542b1f68b9b60efbefecd216a4a48",
          "commitAuthorOld": "Jonathan Hedley",
          "daysBetweenCommits": 0.0,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "actualSource": "static String escape(String string, CharsetEncoder encoder, EscapeMode escapeMode) {\n    StringBuilder accum \u003d new StringBuilder(string.length() * 2);\n    Map\u003cCharacter, String\u003e map \u003d escapeMode \u003d\u003d EscapeMode.extended ? fullByVal : baseByVal;\n    for (int pos \u003d 0; pos \u003c string.length(); pos++) {\n        Character c \u003d string.charAt(pos);\n        if (map.containsKey(c))\n            accum.append(\"\u0026\").append(map.get(c)).append(\";\");\n        else if (encoder.canEncode(c))\n            accum.append(c);\n        else\n            accum.append(\"\u0026#\").append((int) c).append(\";\");\n    }\n    return accum.toString();\n}",
          "path": "src/main/java/org/jsoup/nodes/Entities.java",
          "functionStartLine": 27,
          "functionName": "escape",
          "functionAnnotation": "",
          "functionDoc": "",
          "diff": "@@ -1,14 +1,14 @@\n-static String escape(String string, Charset charset) {\n-    StringBuilder accum \u003d new StringBuilder((int) (string.length() * 1.5));\n-    CharsetEncoder encoder \u003d charset.newEncoder();\n+static String escape(String string, CharsetEncoder encoder, EscapeMode escapeMode) {\n+    StringBuilder accum \u003d new StringBuilder(string.length() * 2);\n+    Map\u003cCharacter, String\u003e map \u003d escapeMode \u003d\u003d EscapeMode.extended ? fullByVal : baseByVal;\n     for (int pos \u003d 0; pos \u003c string.length(); pos++) {\n         Character c \u003d string.charAt(pos);\n-        if (fullByVal.containsKey((int) c))\n-            accum.append(\"\u0026\").append(fullByVal.get((int) c)).append(\";\");\n+        if (map.containsKey(c))\n+            accum.append(\"\u0026\").append(map.get(c)).append(\";\");\n         else if (encoder.canEncode(c))\n             accum.append(c);\n         else\n             accum.append(\"\u0026#\").append((int) c).append(\";\");\n     }\n     return accum.toString();\n }\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldPath": "src/main/java/org/jsoup/Entities.java",
            "newPath": "src/main/java/org/jsoup/nodes/Entities.java"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "Working on escape/unescape routine.\n",
          "commitDate": "7/2/11, 4:11 AM",
          "commitName": "f8841edabba28d6125dd87ed72f557e85570066b",
          "commitAuthor": "Jonathan Hedley",
          "commitDateOld": "7/2/11, 4:11 AM",
          "commitNameOld": "17486e2fa5b542b1f68b9b60efbefecd216a4a48",
          "commitAuthorOld": "Jonathan Hedley",
          "daysBetweenCommits": 0.0,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "actualSource": "static String escape(String string, CharsetEncoder encoder, EscapeMode escapeMode) {\n    StringBuilder accum \u003d new StringBuilder(string.length() * 2);\n    Map\u003cCharacter, String\u003e map \u003d escapeMode \u003d\u003d EscapeMode.extended ? fullByVal : baseByVal;\n    for (int pos \u003d 0; pos \u003c string.length(); pos++) {\n        Character c \u003d string.charAt(pos);\n        if (map.containsKey(c))\n            accum.append(\"\u0026\").append(map.get(c)).append(\";\");\n        else if (encoder.canEncode(c))\n            accum.append(c);\n        else\n            accum.append(\"\u0026#\").append((int) c).append(\";\");\n    }\n    return accum.toString();\n}",
          "path": "src/main/java/org/jsoup/nodes/Entities.java",
          "functionStartLine": 27,
          "functionName": "escape",
          "functionAnnotation": "",
          "functionDoc": "",
          "diff": "@@ -1,14 +1,14 @@\n-static String escape(String string, Charset charset) {\n-    StringBuilder accum \u003d new StringBuilder((int) (string.length() * 1.5));\n-    CharsetEncoder encoder \u003d charset.newEncoder();\n+static String escape(String string, CharsetEncoder encoder, EscapeMode escapeMode) {\n+    StringBuilder accum \u003d new StringBuilder(string.length() * 2);\n+    Map\u003cCharacter, String\u003e map \u003d escapeMode \u003d\u003d EscapeMode.extended ? fullByVal : baseByVal;\n     for (int pos \u003d 0; pos \u003c string.length(); pos++) {\n         Character c \u003d string.charAt(pos);\n-        if (fullByVal.containsKey((int) c))\n-            accum.append(\"\u0026\").append(fullByVal.get((int) c)).append(\";\");\n+        if (map.containsKey(c))\n+            accum.append(\"\u0026\").append(map.get(c)).append(\";\");\n         else if (encoder.canEncode(c))\n             accum.append(c);\n         else\n             accum.append(\"\u0026#\").append((int) c).append(\";\");\n     }\n     return accum.toString();\n }\n\\ No newline at end of file\n",
          "extendedDetails": {}
        },
        {
          "type": "Yparameterchange",
          "commitMessage": "Working on escape/unescape routine.\n",
          "commitDate": "7/2/11, 4:11 AM",
          "commitName": "f8841edabba28d6125dd87ed72f557e85570066b",
          "commitAuthor": "Jonathan Hedley",
          "commitDateOld": "7/2/11, 4:11 AM",
          "commitNameOld": "17486e2fa5b542b1f68b9b60efbefecd216a4a48",
          "commitAuthorOld": "Jonathan Hedley",
          "daysBetweenCommits": 0.0,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "actualSource": "static String escape(String string, CharsetEncoder encoder, EscapeMode escapeMode) {\n    StringBuilder accum \u003d new StringBuilder(string.length() * 2);\n    Map\u003cCharacter, String\u003e map \u003d escapeMode \u003d\u003d EscapeMode.extended ? fullByVal : baseByVal;\n    for (int pos \u003d 0; pos \u003c string.length(); pos++) {\n        Character c \u003d string.charAt(pos);\n        if (map.containsKey(c))\n            accum.append(\"\u0026\").append(map.get(c)).append(\";\");\n        else if (encoder.canEncode(c))\n            accum.append(c);\n        else\n            accum.append(\"\u0026#\").append((int) c).append(\";\");\n    }\n    return accum.toString();\n}",
          "path": "src/main/java/org/jsoup/nodes/Entities.java",
          "functionStartLine": 27,
          "functionName": "escape",
          "functionAnnotation": "",
          "functionDoc": "",
          "diff": "@@ -1,14 +1,14 @@\n-static String escape(String string, Charset charset) {\n-    StringBuilder accum \u003d new StringBuilder((int) (string.length() * 1.5));\n-    CharsetEncoder encoder \u003d charset.newEncoder();\n+static String escape(String string, CharsetEncoder encoder, EscapeMode escapeMode) {\n+    StringBuilder accum \u003d new StringBuilder(string.length() * 2);\n+    Map\u003cCharacter, String\u003e map \u003d escapeMode \u003d\u003d EscapeMode.extended ? fullByVal : baseByVal;\n     for (int pos \u003d 0; pos \u003c string.length(); pos++) {\n         Character c \u003d string.charAt(pos);\n-        if (fullByVal.containsKey((int) c))\n-            accum.append(\"\u0026\").append(fullByVal.get((int) c)).append(\";\");\n+        if (map.containsKey(c))\n+            accum.append(\"\u0026\").append(map.get(c)).append(\";\");\n         else if (encoder.canEncode(c))\n             accum.append(c);\n         else\n             accum.append(\"\u0026#\").append((int) c).append(\";\");\n     }\n     return accum.toString();\n }\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldValue": "[string-String, charset-Charset]",
            "newValue": "[string-String, encoder-CharsetEncoder, escapeMode-EscapeMode]"
          }
        }
      ]
    },
    "17486e2fa5b542b1f68b9b60efbefecd216a4a48": {
      "type": "Yintroduced",
      "commitMessage": "Draft implementation of Entities, for customisable entity escaping.\n",
      "commitDate": "7/2/11, 4:11 AM",
      "commitName": "17486e2fa5b542b1f68b9b60efbefecd216a4a48",
      "commitAuthor": "Jonathan Hedley",
      "diff": "@@ -0,0 +1,14 @@\n+static String escape(String string, Charset charset) {\n+    StringBuilder accum \u003d new StringBuilder((int) (string.length() * 1.5));\n+    CharsetEncoder encoder \u003d charset.newEncoder();\n+    for (int pos \u003d 0; pos \u003c string.length(); pos++) {\n+        Character c \u003d string.charAt(pos);\n+        if (fullByVal.containsKey((int) c))\n+            accum.append(\"\u0026\").append(fullByVal.get((int) c)).append(\";\");\n+        else if (encoder.canEncode(c))\n+            accum.append(c);\n+        else\n+            accum.append(\"\u0026#\").append((int) c).append(\";\");\n+    }\n+    return accum.toString();\n+}\n\\ No newline at end of file\n",
      "actualSource": "static String escape(String string, Charset charset) {\n    StringBuilder accum \u003d new StringBuilder((int) (string.length() * 1.5));\n    CharsetEncoder encoder \u003d charset.newEncoder();\n    for (int pos \u003d 0; pos \u003c string.length(); pos++) {\n        Character c \u003d string.charAt(pos);\n        if (fullByVal.containsKey((int) c))\n            accum.append(\"\u0026\").append(fullByVal.get((int) c)).append(\";\");\n        else if (encoder.canEncode(c))\n            accum.append(c);\n        else\n            accum.append(\"\u0026#\").append((int) c).append(\";\");\n    }\n    return accum.toString();\n}",
      "path": "src/main/java/org/jsoup/Entities.java",
      "functionStartLine": 20,
      "functionName": "escape",
      "functionAnnotation": "",
      "functionDoc": ""
    }
  }
}