{
  "origin": "codeshovel",
  "repositoryName": "JxPath-10b",
  "repositoryPath": "/tmp/JxPath-10b//.git",
  "startCommitName": "HEAD",
  "sourceFileName": "TypeUtils.java",
  "functionName": "convert",
  "functionId": "convert___object-Object__toType-Class",
  "sourceFilePath": "src/java/org/apache/commons/jxpath/util/TypeUtils.java",
  "functionAnnotation": "",
  "functionDoc": "Converts the supplied object to the specified type. May\nthrow a RuntimeException.\n",
  "functionStartLine": 68,
  "functionEndLine": 70,
  "numCommitsSeen": 18,
  "timeTaken": 837,
  "changeHistory": [
    "ab914f400352a3a525ba0a5d189eb2e4e1ade268",
    "73f1fffe48c5f26e2c29280385bf0e8f2b9627ac",
    "8a8545ddd784bca69bd9d1277663915b957e0232",
    "c6d36b46057b4d441556e6275bcd7d13d242fa02",
    "0f6e852a0bce6f051383f3003f41f99bcd816b31",
    "a6e246c774fb91eefeadf28c46a10e768ac8cc7b",
    "34b7a47ae949c763178a457582a5df2cb564f53d",
    "bc53a66311b9b22e471dd74860c7df75eebe9837"
  ],
  "changeHistoryShort": {
    "ab914f400352a3a525ba0a5d189eb2e4e1ade268": "Ydocchange",
    "73f1fffe48c5f26e2c29280385bf0e8f2b9627ac": "Ybodychange",
    "8a8545ddd784bca69bd9d1277663915b957e0232": "Ybodychange",
    "c6d36b46057b4d441556e6275bcd7d13d242fa02": "Ybodychange",
    "0f6e852a0bce6f051383f3003f41f99bcd816b31": "Ybodychange",
    "a6e246c774fb91eefeadf28c46a10e768ac8cc7b": "Yfilerename",
    "34b7a47ae949c763178a457582a5df2cb564f53d": "Ybodychange",
    "bc53a66311b9b22e471dd74860c7df75eebe9837": "Yintroduced"
  },
  "changeHistoryDetails": {
    "ab914f400352a3a525ba0a5d189eb2e4e1ade268": {
      "type": "Ydocchange",
      "commitMessage": "Documentation clean-up and removal of deprecated methods\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/jakarta/commons/proper/jxpath/trunk@136768 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "6/15/02, 8:22 PM",
      "commitName": "ab914f400352a3a525ba0a5d189eb2e4e1ade268",
      "commitAuthor": "Dmitri Plotnikov",
      "commitDateOld": "6/12/02, 2:02 PM",
      "commitNameOld": "73f1fffe48c5f26e2c29280385bf0e8f2b9627ac",
      "commitAuthorOld": "Dmitri Plotnikov",
      "daysBetweenCommits": 3.26,
      "commitsBetweenForRepo": 2,
      "commitsBetweenForFile": 1,
      "actualSource": "public static Object convert(Object object, Class toType) {\n    return typeConverter.convert(object, toType);\n}",
      "path": "src/java/org/apache/commons/jxpath/util/TypeUtils.java",
      "functionStartLine": 106,
      "functionName": "convert",
      "functionAnnotation": "",
      "functionDoc": "Converts the supplied object to the specified type. May\nthrow a RuntimeException.\n",
      "diff": "",
      "extendedDetails": {
        "oldValue": "",
        "newValue": "Converts the supplied object to the specified type. May\nthrow a RuntimeException.\n"
      }
    },
    "73f1fffe48c5f26e2c29280385bf0e8f2b9627ac": {
      "type": "Ybodychange",
      "commitMessage": "Made type converter configurable\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/jakarta/commons/proper/jxpath/trunk@136766 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "6/12/02, 2:02 PM",
      "commitName": "73f1fffe48c5f26e2c29280385bf0e8f2b9627ac",
      "commitAuthor": "Dmitri Plotnikov",
      "commitDateOld": "5/8/02, 4:03 PM",
      "commitNameOld": "8a8545ddd784bca69bd9d1277663915b957e0232",
      "commitAuthorOld": "Dmitri Plotnikov",
      "daysBetweenCommits": 34.92,
      "commitsBetweenForRepo": 18,
      "commitsBetweenForFile": 1,
      "actualSource": "public static Object convert(Object object, Class toType) {\n    return typeConverter.convert(object, toType);\n}",
      "path": "src/java/org/apache/commons/jxpath/util/TypeUtils.java",
      "functionStartLine": 119,
      "functionName": "convert",
      "functionAnnotation": "",
      "functionDoc": "",
      "diff": "@@ -1,153 +1,3 @@\n public static Object convert(Object object, Class toType) {\n-    if (object \u003d\u003d null) {\n-        if (toType.isPrimitive()) {\n-            if (toType \u003d\u003d boolean.class) {\n-                return Boolean.FALSE;\n-            }\n-            if (toType \u003d\u003d char.class) {\n-                return new Character(\u0027\\0\u0027);\n-            }\n-            if (toType \u003d\u003d byte.class) {\n-                return new Byte((byte) 0);\n-            }\n-            if (toType \u003d\u003d short.class) {\n-                return new Short((short) 0);\n-            }\n-            if (toType \u003d\u003d int.class) {\n-                return new Integer(0);\n-            }\n-            if (toType \u003d\u003d long.class) {\n-                return new Long(0l);\n-            }\n-            if (toType \u003d\u003d float.class) {\n-                return new Float(0.0f);\n-            }\n-            if (toType \u003d\u003d double.class) {\n-                return new Double(0.0);\n-            }\n-        }\n-        return null;\n-    }\n-    if (toType \u003d\u003d Object.class) {\n-        return object;\n-    }\n-    if (object instanceof ExpressionContext) {\n-        if (Collection.class.isAssignableFrom(toType)) {\n-            List list \u003d ((ExpressionContext) object).getContextNodeList();\n-            Collection result \u003d new ArrayList();\n-            if (toType \u003d\u003d List.class || toType \u003d\u003d ArrayList.class) {\n-                result \u003d new ArrayList();\n-            } else if (toType \u003d\u003d Vector.class) {\n-                result \u003d new Vector();\n-            } else if (toType \u003d\u003d Set.class || toType \u003d\u003d HashSet.class) {\n-                result \u003d new HashSet();\n-            }\n-            int count \u003d list.size();\n-            for (int i \u003d 0; i \u003c count; i++) {\n-                Pointer ptr \u003d (Pointer) list.get(i);\n-                result.add(ptr.getValue());\n-            }\n-            return result;\n-        } else {\n-            Object value \u003d ((ExpressionContext) object).getContextNodePointer().getValue();\n-            return convert(value, toType);\n-        }\n-    }\n-    Class fromType \u003d object.getClass();\n-    if (fromType.equals(toType) || toType.isAssignableFrom(fromType)) {\n-        return object;\n-    }\n-    if (toType \u003d\u003d String.class) {\n-        return object.toString();\n-    }\n-    if (object instanceof Boolean) {\n-        if (toType \u003d\u003d boolean.class) {\n-            return object;\n-        }\n-        boolean value \u003d ((Boolean) object).booleanValue();\n-        return allocateNumber(toType, value ? 1 : 0);\n-    } else if (object instanceof Number) {\n-        double value \u003d ((Number) object).doubleValue();\n-        if (toType \u003d\u003d boolean.class || toType \u003d\u003d Boolean.class) {\n-            return value \u003d\u003d 0.0 ? Boolean.FALSE : Boolean.TRUE;\n-        }\n-        if (toType.isPrimitive() || Number.class.isAssignableFrom(toType)) {\n-            return allocateNumber(toType, value);\n-        }\n-    } else if (object instanceof Character) {\n-        if (toType \u003d\u003d char.class) {\n-            return object;\n-        }\n-    } else if (object instanceof String) {\n-        if (toType \u003d\u003d boolean.class || toType \u003d\u003d Boolean.class) {\n-            return Boolean.valueOf((String) object);\n-        }\n-        if (toType \u003d\u003d char.class || toType \u003d\u003d Character.class) {\n-            return new Character(((String) object).charAt(0));\n-        }\n-        if (toType \u003d\u003d byte.class || toType \u003d\u003d Byte.class) {\n-            return new Byte((String) object);\n-        }\n-        if (toType \u003d\u003d short.class || toType \u003d\u003d Short.class) {\n-            return new Short((String) object);\n-        }\n-        if (toType \u003d\u003d int.class || toType \u003d\u003d Integer.class) {\n-            return new Integer((String) object);\n-        }\n-        if (toType \u003d\u003d long.class || toType \u003d\u003d Long.class) {\n-            return new Long((String) object);\n-        }\n-        if (toType \u003d\u003d float.class || toType \u003d\u003d Float.class) {\n-            return new Float((String) object);\n-        }\n-        if (toType \u003d\u003d double.class || toType \u003d\u003d Double.class) {\n-            return new Double((String) object);\n-        }\n-    } else if (fromType.isArray()) {\n-        int length \u003d Array.getLength(object);\n-        if (toType.isArray()) {\n-            Class cType \u003d toType.getComponentType();\n-            Object array \u003d Array.newInstance(cType, length);\n-            for (int i \u003d 0; i \u003c length; i++) {\n-                Object value \u003d Array.get(object, i);\n-                Array.set(array, i, convert(value, cType));\n-            }\n-            return array;\n-        } else if (Collection.class.isAssignableFrom(toType)) {\n-            Collection collection \u003d allocateCollection(toType);\n-            for (int i \u003d 0; i \u003c length; i++) {\n-                collection.add(Array.get(object, i));\n-            }\n-            return collection;\n-        } else if (length \u003d\u003d 1) {\n-            Object value \u003d Array.get(object, 0);\n-            return convert(value, toType);\n-        }\n-    } else if (object instanceof Collection) {\n-        int length \u003d ((Collection) object).size();\n-        if (toType.isArray()) {\n-            Class cType \u003d toType.getComponentType();\n-            Object array \u003d Array.newInstance(cType, length);\n-            Iterator it \u003d ((Collection) object).iterator();\n-            for (int i \u003d 0; i \u003c length; i++) {\n-                Object value \u003d it.next();\n-                Array.set(array, i, convert(value, cType));\n-            }\n-            return array;\n-        } else if (Collection.class.isAssignableFrom(toType)) {\n-            Collection collection \u003d allocateCollection(toType);\n-            collection.addAll((Collection) object);\n-            return collection;\n-        } else if (length \u003d\u003d 1) {\n-            Object value;\n-            if (object instanceof List) {\n-                value \u003d ((List) object).get(0);\n-            } else {\n-                Iterator it \u003d ((Collection) object).iterator();\n-                value \u003d it.next();\n-            }\n-            return convert(value, toType);\n-        }\n-    }\n-    throw new RuntimeException(\"Cannot convert \" + object.getClass() + \" to \" + toType);\n+    return typeConverter.convert(object, toType);\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "8a8545ddd784bca69bd9d1277663915b957e0232": {
      "type": "Ybodychange",
      "commitMessage": "Added conversion from null to primitive\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/jakarta/commons/proper/jxpath/trunk@136747 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "5/8/02, 4:03 PM",
      "commitName": "8a8545ddd784bca69bd9d1277663915b957e0232",
      "commitAuthor": "Dmitri Plotnikov",
      "commitDateOld": "5/7/02, 5:39 PM",
      "commitNameOld": "c6d36b46057b4d441556e6275bcd7d13d242fa02",
      "commitAuthorOld": "Dmitri Plotnikov",
      "daysBetweenCommits": 0.93,
      "commitsBetweenForRepo": 5,
      "commitsBetweenForFile": 1,
      "actualSource": "public static Object convert(Object object, Class toType) {\n    if (object \u003d\u003d null) {\n        if (toType.isPrimitive()) {\n            if (toType \u003d\u003d boolean.class) {\n                return Boolean.FALSE;\n            }\n            if (toType \u003d\u003d char.class) {\n                return new Character(\u0027\\0\u0027);\n            }\n            if (toType \u003d\u003d byte.class) {\n                return new Byte((byte) 0);\n            }\n            if (toType \u003d\u003d short.class) {\n                return new Short((short) 0);\n            }\n            if (toType \u003d\u003d int.class) {\n                return new Integer(0);\n            }\n            if (toType \u003d\u003d long.class) {\n                return new Long(0l);\n            }\n            if (toType \u003d\u003d float.class) {\n                return new Float(0.0f);\n            }\n            if (toType \u003d\u003d double.class) {\n                return new Double(0.0);\n            }\n        }\n        return null;\n    }\n    if (toType \u003d\u003d Object.class) {\n        return object;\n    }\n    if (object instanceof ExpressionContext) {\n        if (Collection.class.isAssignableFrom(toType)) {\n            List list \u003d ((ExpressionContext) object).getContextNodeList();\n            Collection result \u003d new ArrayList();\n            if (toType \u003d\u003d List.class || toType \u003d\u003d ArrayList.class) {\n                result \u003d new ArrayList();\n            } else if (toType \u003d\u003d Vector.class) {\n                result \u003d new Vector();\n            } else if (toType \u003d\u003d Set.class || toType \u003d\u003d HashSet.class) {\n                result \u003d new HashSet();\n            }\n            int count \u003d list.size();\n            for (int i \u003d 0; i \u003c count; i++) {\n                Pointer ptr \u003d (Pointer) list.get(i);\n                result.add(ptr.getValue());\n            }\n            return result;\n        } else {\n            Object value \u003d ((ExpressionContext) object).getContextNodePointer().getValue();\n            return convert(value, toType);\n        }\n    }\n    Class fromType \u003d object.getClass();\n    if (fromType.equals(toType) || toType.isAssignableFrom(fromType)) {\n        return object;\n    }\n    if (toType \u003d\u003d String.class) {\n        return object.toString();\n    }\n    if (object instanceof Boolean) {\n        if (toType \u003d\u003d boolean.class) {\n            return object;\n        }\n        boolean value \u003d ((Boolean) object).booleanValue();\n        return allocateNumber(toType, value ? 1 : 0);\n    } else if (object instanceof Number) {\n        double value \u003d ((Number) object).doubleValue();\n        if (toType \u003d\u003d boolean.class || toType \u003d\u003d Boolean.class) {\n            return value \u003d\u003d 0.0 ? Boolean.FALSE : Boolean.TRUE;\n        }\n        if (toType.isPrimitive() || Number.class.isAssignableFrom(toType)) {\n            return allocateNumber(toType, value);\n        }\n    } else if (object instanceof Character) {\n        if (toType \u003d\u003d char.class) {\n            return object;\n        }\n    } else if (object instanceof String) {\n        if (toType \u003d\u003d boolean.class || toType \u003d\u003d Boolean.class) {\n            return Boolean.valueOf((String) object);\n        }\n        if (toType \u003d\u003d char.class || toType \u003d\u003d Character.class) {\n            return new Character(((String) object).charAt(0));\n        }\n        if (toType \u003d\u003d byte.class || toType \u003d\u003d Byte.class) {\n            return new Byte((String) object);\n        }\n        if (toType \u003d\u003d short.class || toType \u003d\u003d Short.class) {\n            return new Short((String) object);\n        }\n        if (toType \u003d\u003d int.class || toType \u003d\u003d Integer.class) {\n            return new Integer((String) object);\n        }\n        if (toType \u003d\u003d long.class || toType \u003d\u003d Long.class) {\n            return new Long((String) object);\n        }\n        if (toType \u003d\u003d float.class || toType \u003d\u003d Float.class) {\n            return new Float((String) object);\n        }\n        if (toType \u003d\u003d double.class || toType \u003d\u003d Double.class) {\n            return new Double((String) object);\n        }\n    } else if (fromType.isArray()) {\n        int length \u003d Array.getLength(object);\n        if (toType.isArray()) {\n            Class cType \u003d toType.getComponentType();\n            Object array \u003d Array.newInstance(cType, length);\n            for (int i \u003d 0; i \u003c length; i++) {\n                Object value \u003d Array.get(object, i);\n                Array.set(array, i, convert(value, cType));\n            }\n            return array;\n        } else if (Collection.class.isAssignableFrom(toType)) {\n            Collection collection \u003d allocateCollection(toType);\n            for (int i \u003d 0; i \u003c length; i++) {\n                collection.add(Array.get(object, i));\n            }\n            return collection;\n        } else if (length \u003d\u003d 1) {\n            Object value \u003d Array.get(object, 0);\n            return convert(value, toType);\n        }\n    } else if (object instanceof Collection) {\n        int length \u003d ((Collection) object).size();\n        if (toType.isArray()) {\n            Class cType \u003d toType.getComponentType();\n            Object array \u003d Array.newInstance(cType, length);\n            Iterator it \u003d ((Collection) object).iterator();\n            for (int i \u003d 0; i \u003c length; i++) {\n                Object value \u003d it.next();\n                Array.set(array, i, convert(value, cType));\n            }\n            return array;\n        } else if (Collection.class.isAssignableFrom(toType)) {\n            Collection collection \u003d allocateCollection(toType);\n            collection.addAll((Collection) object);\n            return collection;\n        } else if (length \u003d\u003d 1) {\n            Object value;\n            if (object instanceof List) {\n                value \u003d ((List) object).get(0);\n            } else {\n                Iterator it \u003d ((Collection) object).iterator();\n                value \u003d it.next();\n            }\n            return convert(value, toType);\n        }\n    }\n    throw new RuntimeException(\"Cannot convert \" + object.getClass() + \" to \" + toType);\n}",
      "path": "src/java/org/apache/commons/jxpath/util/TypeUtils.java",
      "functionStartLine": 419,
      "functionName": "convert",
      "functionAnnotation": "",
      "functionDoc": "",
      "diff": "@@ -1,127 +1,153 @@\n public static Object convert(Object object, Class toType) {\n     if (object \u003d\u003d null) {\n+        if (toType.isPrimitive()) {\n+            if (toType \u003d\u003d boolean.class) {\n+                return Boolean.FALSE;\n+            }\n+            if (toType \u003d\u003d char.class) {\n+                return new Character(\u0027\\0\u0027);\n+            }\n+            if (toType \u003d\u003d byte.class) {\n+                return new Byte((byte) 0);\n+            }\n+            if (toType \u003d\u003d short.class) {\n+                return new Short((short) 0);\n+            }\n+            if (toType \u003d\u003d int.class) {\n+                return new Integer(0);\n+            }\n+            if (toType \u003d\u003d long.class) {\n+                return new Long(0l);\n+            }\n+            if (toType \u003d\u003d float.class) {\n+                return new Float(0.0f);\n+            }\n+            if (toType \u003d\u003d double.class) {\n+                return new Double(0.0);\n+            }\n+        }\n         return null;\n     }\n     if (toType \u003d\u003d Object.class) {\n         return object;\n     }\n     if (object instanceof ExpressionContext) {\n         if (Collection.class.isAssignableFrom(toType)) {\n             List list \u003d ((ExpressionContext) object).getContextNodeList();\n             Collection result \u003d new ArrayList();\n             if (toType \u003d\u003d List.class || toType \u003d\u003d ArrayList.class) {\n                 result \u003d new ArrayList();\n             } else if (toType \u003d\u003d Vector.class) {\n                 result \u003d new Vector();\n             } else if (toType \u003d\u003d Set.class || toType \u003d\u003d HashSet.class) {\n                 result \u003d new HashSet();\n             }\n             int count \u003d list.size();\n             for (int i \u003d 0; i \u003c count; i++) {\n                 Pointer ptr \u003d (Pointer) list.get(i);\n                 result.add(ptr.getValue());\n             }\n             return result;\n         } else {\n             Object value \u003d ((ExpressionContext) object).getContextNodePointer().getValue();\n             return convert(value, toType);\n         }\n     }\n     Class fromType \u003d object.getClass();\n     if (fromType.equals(toType) || toType.isAssignableFrom(fromType)) {\n         return object;\n     }\n     if (toType \u003d\u003d String.class) {\n         return object.toString();\n     }\n     if (object instanceof Boolean) {\n         if (toType \u003d\u003d boolean.class) {\n             return object;\n         }\n         boolean value \u003d ((Boolean) object).booleanValue();\n         return allocateNumber(toType, value ? 1 : 0);\n     } else if (object instanceof Number) {\n         double value \u003d ((Number) object).doubleValue();\n         if (toType \u003d\u003d boolean.class || toType \u003d\u003d Boolean.class) {\n             return value \u003d\u003d 0.0 ? Boolean.FALSE : Boolean.TRUE;\n         }\n         if (toType.isPrimitive() || Number.class.isAssignableFrom(toType)) {\n             return allocateNumber(toType, value);\n         }\n     } else if (object instanceof Character) {\n         if (toType \u003d\u003d char.class) {\n             return object;\n         }\n     } else if (object instanceof String) {\n         if (toType \u003d\u003d boolean.class || toType \u003d\u003d Boolean.class) {\n             return Boolean.valueOf((String) object);\n         }\n         if (toType \u003d\u003d char.class || toType \u003d\u003d Character.class) {\n             return new Character(((String) object).charAt(0));\n         }\n         if (toType \u003d\u003d byte.class || toType \u003d\u003d Byte.class) {\n             return new Byte((String) object);\n         }\n         if (toType \u003d\u003d short.class || toType \u003d\u003d Short.class) {\n             return new Short((String) object);\n         }\n         if (toType \u003d\u003d int.class || toType \u003d\u003d Integer.class) {\n             return new Integer((String) object);\n         }\n         if (toType \u003d\u003d long.class || toType \u003d\u003d Long.class) {\n             return new Long((String) object);\n         }\n         if (toType \u003d\u003d float.class || toType \u003d\u003d Float.class) {\n             return new Float((String) object);\n         }\n         if (toType \u003d\u003d double.class || toType \u003d\u003d Double.class) {\n             return new Double((String) object);\n         }\n     } else if (fromType.isArray()) {\n         int length \u003d Array.getLength(object);\n         if (toType.isArray()) {\n             Class cType \u003d toType.getComponentType();\n             Object array \u003d Array.newInstance(cType, length);\n             for (int i \u003d 0; i \u003c length; i++) {\n                 Object value \u003d Array.get(object, i);\n                 Array.set(array, i, convert(value, cType));\n             }\n             return array;\n         } else if (Collection.class.isAssignableFrom(toType)) {\n             Collection collection \u003d allocateCollection(toType);\n             for (int i \u003d 0; i \u003c length; i++) {\n                 collection.add(Array.get(object, i));\n             }\n             return collection;\n         } else if (length \u003d\u003d 1) {\n             Object value \u003d Array.get(object, 0);\n             return convert(value, toType);\n         }\n     } else if (object instanceof Collection) {\n         int length \u003d ((Collection) object).size();\n         if (toType.isArray()) {\n             Class cType \u003d toType.getComponentType();\n             Object array \u003d Array.newInstance(cType, length);\n             Iterator it \u003d ((Collection) object).iterator();\n             for (int i \u003d 0; i \u003c length; i++) {\n                 Object value \u003d it.next();\n                 Array.set(array, i, convert(value, cType));\n             }\n             return array;\n         } else if (Collection.class.isAssignableFrom(toType)) {\n             Collection collection \u003d allocateCollection(toType);\n             collection.addAll((Collection) object);\n             return collection;\n         } else if (length \u003d\u003d 1) {\n             Object value;\n             if (object instanceof List) {\n                 value \u003d ((List) object).get(0);\n             } else {\n                 Iterator it \u003d ((Collection) object).iterator();\n                 value \u003d it.next();\n             }\n             return convert(value, toType);\n         }\n     }\n     throw new RuntimeException(\"Cannot convert \" + object.getClass() + \" to \" + toType);\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "c6d36b46057b4d441556e6275bcd7d13d242fa02": {
      "type": "Ybodychange",
      "commitMessage": "New conversion: arrays, collections\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/jakarta/commons/proper/jxpath/trunk@136742 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "5/7/02, 5:39 PM",
      "commitName": "c6d36b46057b4d441556e6275bcd7d13d242fa02",
      "commitAuthor": "Dmitri Plotnikov",
      "commitDateOld": "4/25/02, 8:28 PM",
      "commitNameOld": "34d1c6cad33a94c24e55d456b550302db4914130",
      "commitAuthorOld": "Dmitri Plotnikov",
      "daysBetweenCommits": 11.88,
      "commitsBetweenForRepo": 10,
      "commitsBetweenForFile": 1,
      "actualSource": "public static Object convert(Object object, Class toType) {\n    if (object \u003d\u003d null) {\n        return null;\n    }\n    if (toType \u003d\u003d Object.class) {\n        return object;\n    }\n    if (object instanceof ExpressionContext) {\n        if (Collection.class.isAssignableFrom(toType)) {\n            List list \u003d ((ExpressionContext) object).getContextNodeList();\n            Collection result \u003d new ArrayList();\n            if (toType \u003d\u003d List.class || toType \u003d\u003d ArrayList.class) {\n                result \u003d new ArrayList();\n            } else if (toType \u003d\u003d Vector.class) {\n                result \u003d new Vector();\n            } else if (toType \u003d\u003d Set.class || toType \u003d\u003d HashSet.class) {\n                result \u003d new HashSet();\n            }\n            int count \u003d list.size();\n            for (int i \u003d 0; i \u003c count; i++) {\n                Pointer ptr \u003d (Pointer) list.get(i);\n                result.add(ptr.getValue());\n            }\n            return result;\n        } else {\n            Object value \u003d ((ExpressionContext) object).getContextNodePointer().getValue();\n            return convert(value, toType);\n        }\n    }\n    Class fromType \u003d object.getClass();\n    if (fromType.equals(toType) || toType.isAssignableFrom(fromType)) {\n        return object;\n    }\n    if (toType \u003d\u003d String.class) {\n        return object.toString();\n    }\n    if (object instanceof Boolean) {\n        if (toType \u003d\u003d boolean.class) {\n            return object;\n        }\n        boolean value \u003d ((Boolean) object).booleanValue();\n        return allocateNumber(toType, value ? 1 : 0);\n    } else if (object instanceof Number) {\n        double value \u003d ((Number) object).doubleValue();\n        if (toType \u003d\u003d boolean.class || toType \u003d\u003d Boolean.class) {\n            return value \u003d\u003d 0.0 ? Boolean.FALSE : Boolean.TRUE;\n        }\n        if (toType.isPrimitive() || Number.class.isAssignableFrom(toType)) {\n            return allocateNumber(toType, value);\n        }\n    } else if (object instanceof Character) {\n        if (toType \u003d\u003d char.class) {\n            return object;\n        }\n    } else if (object instanceof String) {\n        if (toType \u003d\u003d boolean.class || toType \u003d\u003d Boolean.class) {\n            return Boolean.valueOf((String) object);\n        }\n        if (toType \u003d\u003d char.class || toType \u003d\u003d Character.class) {\n            return new Character(((String) object).charAt(0));\n        }\n        if (toType \u003d\u003d byte.class || toType \u003d\u003d Byte.class) {\n            return new Byte((String) object);\n        }\n        if (toType \u003d\u003d short.class || toType \u003d\u003d Short.class) {\n            return new Short((String) object);\n        }\n        if (toType \u003d\u003d int.class || toType \u003d\u003d Integer.class) {\n            return new Integer((String) object);\n        }\n        if (toType \u003d\u003d long.class || toType \u003d\u003d Long.class) {\n            return new Long((String) object);\n        }\n        if (toType \u003d\u003d float.class || toType \u003d\u003d Float.class) {\n            return new Float((String) object);\n        }\n        if (toType \u003d\u003d double.class || toType \u003d\u003d Double.class) {\n            return new Double((String) object);\n        }\n    } else if (fromType.isArray()) {\n        int length \u003d Array.getLength(object);\n        if (toType.isArray()) {\n            Class cType \u003d toType.getComponentType();\n            Object array \u003d Array.newInstance(cType, length);\n            for (int i \u003d 0; i \u003c length; i++) {\n                Object value \u003d Array.get(object, i);\n                Array.set(array, i, convert(value, cType));\n            }\n            return array;\n        } else if (Collection.class.isAssignableFrom(toType)) {\n            Collection collection \u003d allocateCollection(toType);\n            for (int i \u003d 0; i \u003c length; i++) {\n                collection.add(Array.get(object, i));\n            }\n            return collection;\n        } else if (length \u003d\u003d 1) {\n            Object value \u003d Array.get(object, 0);\n            return convert(value, toType);\n        }\n    } else if (object instanceof Collection) {\n        int length \u003d ((Collection) object).size();\n        if (toType.isArray()) {\n            Class cType \u003d toType.getComponentType();\n            Object array \u003d Array.newInstance(cType, length);\n            Iterator it \u003d ((Collection) object).iterator();\n            for (int i \u003d 0; i \u003c length; i++) {\n                Object value \u003d it.next();\n                Array.set(array, i, convert(value, cType));\n            }\n            return array;\n        } else if (Collection.class.isAssignableFrom(toType)) {\n            Collection collection \u003d allocateCollection(toType);\n            collection.addAll((Collection) object);\n            return collection;\n        } else if (length \u003d\u003d 1) {\n            Object value;\n            if (object instanceof List) {\n                value \u003d ((List) object).get(0);\n            } else {\n                Iterator it \u003d ((Collection) object).iterator();\n                value \u003d it.next();\n            }\n            return convert(value, toType);\n        }\n    }\n    throw new RuntimeException(\"Cannot convert \" + object.getClass() + \" to \" + toType);\n}",
      "path": "src/java/org/apache/commons/jxpath/util/TypeUtils.java",
      "functionStartLine": 419,
      "functionName": "convert",
      "functionAnnotation": "",
      "functionDoc": "",
      "diff": "@@ -1,92 +1,127 @@\n public static Object convert(Object object, Class toType) {\n     if (object \u003d\u003d null) {\n         return null;\n     }\n     if (toType \u003d\u003d Object.class) {\n         return object;\n     }\n     if (object instanceof ExpressionContext) {\n         if (Collection.class.isAssignableFrom(toType)) {\n             List list \u003d ((ExpressionContext) object).getContextNodeList();\n             Collection result \u003d new ArrayList();\n             if (toType \u003d\u003d List.class || toType \u003d\u003d ArrayList.class) {\n                 result \u003d new ArrayList();\n             } else if (toType \u003d\u003d Vector.class) {\n                 result \u003d new Vector();\n             } else if (toType \u003d\u003d Set.class || toType \u003d\u003d HashSet.class) {\n                 result \u003d new HashSet();\n             }\n             int count \u003d list.size();\n             for (int i \u003d 0; i \u003c count; i++) {\n                 Pointer ptr \u003d (Pointer) list.get(i);\n                 result.add(ptr.getValue());\n             }\n             return result;\n         } else {\n             Object value \u003d ((ExpressionContext) object).getContextNodePointer().getValue();\n             return convert(value, toType);\n         }\n     }\n     Class fromType \u003d object.getClass();\n     if (fromType.equals(toType) || toType.isAssignableFrom(fromType)) {\n         return object;\n     }\n     if (toType \u003d\u003d String.class) {\n         return object.toString();\n     }\n     if (object instanceof Boolean) {\n         if (toType \u003d\u003d boolean.class) {\n             return object;\n         }\n         boolean value \u003d ((Boolean) object).booleanValue();\n         return allocateNumber(toType, value ? 1 : 0);\n     } else if (object instanceof Number) {\n         double value \u003d ((Number) object).doubleValue();\n         if (toType \u003d\u003d boolean.class || toType \u003d\u003d Boolean.class) {\n             return value \u003d\u003d 0.0 ? Boolean.FALSE : Boolean.TRUE;\n         }\n         if (toType.isPrimitive() || Number.class.isAssignableFrom(toType)) {\n             return allocateNumber(toType, value);\n         }\n     } else if (object instanceof Character) {\n         if (toType \u003d\u003d char.class) {\n             return object;\n         }\n     } else if (object instanceof String) {\n         if (toType \u003d\u003d boolean.class || toType \u003d\u003d Boolean.class) {\n             return Boolean.valueOf((String) object);\n         }\n         if (toType \u003d\u003d char.class || toType \u003d\u003d Character.class) {\n             return new Character(((String) object).charAt(0));\n         }\n         if (toType \u003d\u003d byte.class || toType \u003d\u003d Byte.class) {\n             return new Byte((String) object);\n         }\n         if (toType \u003d\u003d short.class || toType \u003d\u003d Short.class) {\n             return new Short((String) object);\n         }\n         if (toType \u003d\u003d int.class || toType \u003d\u003d Integer.class) {\n             return new Integer((String) object);\n         }\n         if (toType \u003d\u003d long.class || toType \u003d\u003d Long.class) {\n             return new Long((String) object);\n         }\n         if (toType \u003d\u003d float.class || toType \u003d\u003d Float.class) {\n             return new Float((String) object);\n         }\n         if (toType \u003d\u003d double.class || toType \u003d\u003d Double.class) {\n             return new Double((String) object);\n         }\n     } else if (fromType.isArray()) {\n-        Object value \u003d Array.get(object, 0);\n-        return convert(value, toType);\n-    } else if (object instanceof List) {\n-        Object value \u003d ((List) object).get(0);\n-        return convert(value, toType);\n+        int length \u003d Array.getLength(object);\n+        if (toType.isArray()) {\n+            Class cType \u003d toType.getComponentType();\n+            Object array \u003d Array.newInstance(cType, length);\n+            for (int i \u003d 0; i \u003c length; i++) {\n+                Object value \u003d Array.get(object, i);\n+                Array.set(array, i, convert(value, cType));\n+            }\n+            return array;\n+        } else if (Collection.class.isAssignableFrom(toType)) {\n+            Collection collection \u003d allocateCollection(toType);\n+            for (int i \u003d 0; i \u003c length; i++) {\n+                collection.add(Array.get(object, i));\n+            }\n+            return collection;\n+        } else if (length \u003d\u003d 1) {\n+            Object value \u003d Array.get(object, 0);\n+            return convert(value, toType);\n+        }\n     } else if (object instanceof Collection) {\n-        Iterator it \u003d ((Collection) object).iterator();\n-        Object value \u003d it.next();\n-        return convert(value, toType);\n+        int length \u003d ((Collection) object).size();\n+        if (toType.isArray()) {\n+            Class cType \u003d toType.getComponentType();\n+            Object array \u003d Array.newInstance(cType, length);\n+            Iterator it \u003d ((Collection) object).iterator();\n+            for (int i \u003d 0; i \u003c length; i++) {\n+                Object value \u003d it.next();\n+                Array.set(array, i, convert(value, cType));\n+            }\n+            return array;\n+        } else if (Collection.class.isAssignableFrom(toType)) {\n+            Collection collection \u003d allocateCollection(toType);\n+            collection.addAll((Collection) object);\n+            return collection;\n+        } else if (length \u003d\u003d 1) {\n+            Object value;\n+            if (object instanceof List) {\n+                value \u003d ((List) object).get(0);\n+            } else {\n+                Iterator it \u003d ((Collection) object).iterator();\n+                value \u003d it.next();\n+            }\n+            return convert(value, toType);\n+        }\n     }\n-    return object;\n+    throw new RuntimeException(\"Cannot convert \" + object.getClass() + \" to \" + toType);\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "0f6e852a0bce6f051383f3003f41f99bcd816b31": {
      "type": "Ybodychange",
      "commitMessage": "Fixed String-\u003ePrimary conversion\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/jakarta/commons/proper/jxpath/trunk@136729 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "4/25/02, 5:57 PM",
      "commitName": "0f6e852a0bce6f051383f3003f41f99bcd816b31",
      "commitAuthor": "Dmitri Plotnikov",
      "commitDateOld": "4/23/02, 9:06 PM",
      "commitNameOld": "3b6b30adb846a9f2f0fa070f9c8c848f04d8b37f",
      "commitAuthorOld": "Dmitri Plotnikov",
      "daysBetweenCommits": 1.87,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "public static Object convert(Object object, Class toType) {\n    if (object \u003d\u003d null) {\n        return null;\n    }\n    if (toType \u003d\u003d Object.class) {\n        return object;\n    }\n    if (object instanceof ExpressionContext) {\n        if (Collection.class.isAssignableFrom(toType)) {\n            List list \u003d ((ExpressionContext) object).getContextNodeList();\n            Collection result \u003d new ArrayList();\n            if (toType \u003d\u003d List.class || toType \u003d\u003d ArrayList.class) {\n                result \u003d new ArrayList();\n            } else if (toType \u003d\u003d Vector.class) {\n                result \u003d new Vector();\n            } else if (toType \u003d\u003d Set.class || toType \u003d\u003d HashSet.class) {\n                result \u003d new HashSet();\n            }\n            int count \u003d list.size();\n            for (int i \u003d 0; i \u003c count; i++) {\n                Pointer ptr \u003d (Pointer) list.get(i);\n                result.add(ptr.getValue());\n            }\n            return result;\n        } else {\n            Object value \u003d ((ExpressionContext) object).getContextNodePointer().getValue();\n            return convert(value, toType);\n        }\n    }\n    Class fromType \u003d object.getClass();\n    if (fromType.equals(toType) || toType.isAssignableFrom(fromType)) {\n        return object;\n    }\n    if (toType \u003d\u003d String.class) {\n        return object.toString();\n    }\n    if (object instanceof Boolean) {\n        if (toType \u003d\u003d boolean.class) {\n            return object;\n        }\n        boolean value \u003d ((Boolean) object).booleanValue();\n        return allocateNumber(toType, value ? 1 : 0);\n    } else if (object instanceof Number) {\n        double value \u003d ((Number) object).doubleValue();\n        if (toType \u003d\u003d boolean.class || toType \u003d\u003d Boolean.class) {\n            return value \u003d\u003d 0.0 ? Boolean.FALSE : Boolean.TRUE;\n        }\n        if (toType.isPrimitive() || Number.class.isAssignableFrom(toType)) {\n            return allocateNumber(toType, value);\n        }\n    } else if (object instanceof Character) {\n        if (toType \u003d\u003d char.class) {\n            return object;\n        }\n    } else if (object instanceof String) {\n        if (toType \u003d\u003d boolean.class || toType \u003d\u003d Boolean.class) {\n            return Boolean.valueOf((String) object);\n        }\n        if (toType \u003d\u003d char.class || toType \u003d\u003d Character.class) {\n            return new Character(((String) object).charAt(0));\n        }\n        if (toType \u003d\u003d byte.class || toType \u003d\u003d Byte.class) {\n            return new Byte((String) object);\n        }\n        if (toType \u003d\u003d short.class || toType \u003d\u003d Short.class) {\n            return new Short((String) object);\n        }\n        if (toType \u003d\u003d int.class || toType \u003d\u003d Integer.class) {\n            return new Integer((String) object);\n        }\n        if (toType \u003d\u003d long.class || toType \u003d\u003d Long.class) {\n            return new Long((String) object);\n        }\n        if (toType \u003d\u003d float.class || toType \u003d\u003d Float.class) {\n            return new Float((String) object);\n        }\n        if (toType \u003d\u003d double.class || toType \u003d\u003d Double.class) {\n            return new Double((String) object);\n        }\n    } else if (fromType.isArray()) {\n        Object value \u003d Array.get(object, 0);\n        return convert(value, toType);\n    } else if (object instanceof List) {\n        Object value \u003d ((List) object).get(0);\n        return convert(value, toType);\n    } else if (object instanceof Collection) {\n        Iterator it \u003d ((Collection) object).iterator();\n        Object value \u003d it.next();\n        return convert(value, toType);\n    }\n    return object;\n}",
      "path": "src/java/org/apache/commons/jxpath/util/TypeUtils.java",
      "functionStartLine": 388,
      "functionName": "convert",
      "functionAnnotation": "",
      "functionDoc": "",
      "diff": "@@ -1,92 +1,92 @@\n public static Object convert(Object object, Class toType) {\n     if (object \u003d\u003d null) {\n         return null;\n     }\n     if (toType \u003d\u003d Object.class) {\n         return object;\n     }\n     if (object instanceof ExpressionContext) {\n         if (Collection.class.isAssignableFrom(toType)) {\n             List list \u003d ((ExpressionContext) object).getContextNodeList();\n             Collection result \u003d new ArrayList();\n             if (toType \u003d\u003d List.class || toType \u003d\u003d ArrayList.class) {\n                 result \u003d new ArrayList();\n             } else if (toType \u003d\u003d Vector.class) {\n                 result \u003d new Vector();\n             } else if (toType \u003d\u003d Set.class || toType \u003d\u003d HashSet.class) {\n                 result \u003d new HashSet();\n             }\n             int count \u003d list.size();\n             for (int i \u003d 0; i \u003c count; i++) {\n                 Pointer ptr \u003d (Pointer) list.get(i);\n                 result.add(ptr.getValue());\n             }\n             return result;\n         } else {\n             Object value \u003d ((ExpressionContext) object).getContextNodePointer().getValue();\n             return convert(value, toType);\n         }\n     }\n     Class fromType \u003d object.getClass();\n     if (fromType.equals(toType) || toType.isAssignableFrom(fromType)) {\n         return object;\n     }\n     if (toType \u003d\u003d String.class) {\n         return object.toString();\n     }\n     if (object instanceof Boolean) {\n         if (toType \u003d\u003d boolean.class) {\n             return object;\n         }\n         boolean value \u003d ((Boolean) object).booleanValue();\n         return allocateNumber(toType, value ? 1 : 0);\n     } else if (object instanceof Number) {\n         double value \u003d ((Number) object).doubleValue();\n         if (toType \u003d\u003d boolean.class || toType \u003d\u003d Boolean.class) {\n             return value \u003d\u003d 0.0 ? Boolean.FALSE : Boolean.TRUE;\n         }\n         if (toType.isPrimitive() || Number.class.isAssignableFrom(toType)) {\n             return allocateNumber(toType, value);\n         }\n     } else if (object instanceof Character) {\n         if (toType \u003d\u003d char.class) {\n             return object;\n         }\n     } else if (object instanceof String) {\n         if (toType \u003d\u003d boolean.class || toType \u003d\u003d Boolean.class) {\n-            return new Boolean((String) object);\n+            return Boolean.valueOf((String) object);\n         }\n         if (toType \u003d\u003d char.class || toType \u003d\u003d Character.class) {\n             return new Character(((String) object).charAt(0));\n         }\n         if (toType \u003d\u003d byte.class || toType \u003d\u003d Byte.class) {\n             return new Byte((String) object);\n         }\n         if (toType \u003d\u003d short.class || toType \u003d\u003d Short.class) {\n             return new Short((String) object);\n         }\n         if (toType \u003d\u003d int.class || toType \u003d\u003d Integer.class) {\n             return new Integer((String) object);\n         }\n         if (toType \u003d\u003d long.class || toType \u003d\u003d Long.class) {\n             return new Long((String) object);\n         }\n         if (toType \u003d\u003d float.class || toType \u003d\u003d Float.class) {\n             return new Float((String) object);\n         }\n         if (toType \u003d\u003d double.class || toType \u003d\u003d Double.class) {\n             return new Double((String) object);\n         }\n     } else if (fromType.isArray()) {\n         Object value \u003d Array.get(object, 0);\n         return convert(value, toType);\n     } else if (object instanceof List) {\n         Object value \u003d ((List) object).get(0);\n         return convert(value, toType);\n     } else if (object instanceof Collection) {\n         Iterator it \u003d ((Collection) object).iterator();\n         Object value \u003d it.next();\n         return convert(value, toType);\n     }\n     return object;\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "a6e246c774fb91eefeadf28c46a10e768ac8cc7b": {
      "type": "Yfilerename",
      "commitMessage": "Major refactoring\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/jakarta/commons/proper/jxpath/trunk@136721 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "4/21/02, 2:52 PM",
      "commitName": "a6e246c774fb91eefeadf28c46a10e768ac8cc7b",
      "commitAuthor": "Dmitri Plotnikov",
      "commitDateOld": "4/11/02, 7:28 PM",
      "commitNameOld": "65bf4da7590edc460ec68e18f35d201ec685bf86",
      "commitAuthorOld": "Dmitri Plotnikov",
      "daysBetweenCommits": 9.81,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "public static Object convert(Object object, Class toType) {\n    if (object \u003d\u003d null) {\n        return null;\n    }\n    if (toType \u003d\u003d Object.class) {\n        return object;\n    }\n    if (object instanceof ExpressionContext) {\n        if (Collection.class.isAssignableFrom(toType)) {\n            List list \u003d ((ExpressionContext) object).getContextNodeList();\n            Collection result \u003d new ArrayList();\n            if (toType \u003d\u003d List.class || toType \u003d\u003d ArrayList.class) {\n                result \u003d new ArrayList();\n            } else if (toType \u003d\u003d Vector.class) {\n                result \u003d new Vector();\n            } else if (toType \u003d\u003d Set.class || toType \u003d\u003d HashSet.class) {\n                result \u003d new HashSet();\n            }\n            int count \u003d list.size();\n            for (int i \u003d 0; i \u003c count; i++) {\n                Pointer ptr \u003d (Pointer) list.get(i);\n                result.add(ptr.getValue());\n            }\n            return result;\n        } else {\n            Object value \u003d ((ExpressionContext) object).getContextNodePointer().getValue();\n            return convert(value, toType);\n        }\n    }\n    Class fromType \u003d object.getClass();\n    if (fromType.equals(toType) || toType.isAssignableFrom(fromType)) {\n        return object;\n    }\n    if (toType \u003d\u003d String.class) {\n        return object.toString();\n    }\n    if (object instanceof Boolean) {\n        if (toType \u003d\u003d boolean.class) {\n            return object;\n        }\n        boolean value \u003d ((Boolean) object).booleanValue();\n        return allocateNumber(toType, value ? 1 : 0);\n    } else if (object instanceof Number) {\n        double value \u003d ((Number) object).doubleValue();\n        if (toType \u003d\u003d boolean.class || toType \u003d\u003d Boolean.class) {\n            return value \u003d\u003d 0.0 ? Boolean.FALSE : Boolean.TRUE;\n        }\n        if (toType.isPrimitive() || Number.class.isAssignableFrom(toType)) {\n            return allocateNumber(toType, value);\n        }\n    } else if (object instanceof Character) {\n        if (toType \u003d\u003d char.class) {\n            return object;\n        }\n    } else if (object instanceof String) {\n        if (toType \u003d\u003d boolean.class || toType \u003d\u003d Boolean.class) {\n            return new Boolean((String) object);\n        }\n        if (toType \u003d\u003d char.class || toType \u003d\u003d Character.class) {\n            return new Character(((String) object).charAt(0));\n        }\n        if (toType \u003d\u003d byte.class || toType \u003d\u003d Byte.class) {\n            return new Byte((String) object);\n        }\n        if (toType \u003d\u003d short.class || toType \u003d\u003d Short.class) {\n            return new Short((String) object);\n        }\n        if (toType \u003d\u003d int.class || toType \u003d\u003d Integer.class) {\n            return new Integer((String) object);\n        }\n        if (toType \u003d\u003d long.class || toType \u003d\u003d Long.class) {\n            return new Long((String) object);\n        }\n        if (toType \u003d\u003d float.class || toType \u003d\u003d Float.class) {\n            return new Float((String) object);\n        }\n        if (toType \u003d\u003d double.class || toType \u003d\u003d Double.class) {\n            return new Double((String) object);\n        }\n    } else if (fromType.isArray()) {\n        Object value \u003d Array.get(object, 0);\n        return convert(value, toType);\n    } else if (object instanceof List) {\n        Object value \u003d ((List) object).get(0);\n        return convert(value, toType);\n    } else if (object instanceof Collection) {\n        Iterator it \u003d ((Collection) object).iterator();\n        Object value \u003d it.next();\n        return convert(value, toType);\n    }\n    return object;\n}",
      "path": "src/java/org/apache/commons/jxpath/util/TypeUtils.java",
      "functionStartLine": 376,
      "functionName": "convert",
      "functionAnnotation": "",
      "functionDoc": "",
      "diff": "",
      "extendedDetails": {
        "oldPath": "src/java/org/apache/commons/jxpath/functions/Types.java",
        "newPath": "src/java/org/apache/commons/jxpath/util/TypeUtils.java"
      }
    },
    "34b7a47ae949c763178a457582a5df2cb564f53d": {
      "type": "Ybodychange",
      "commitMessage": "Multiple changes\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/jakarta/commons/proper/jxpath/trunk@136712 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "4/9/02, 8:40 PM",
      "commitName": "34b7a47ae949c763178a457582a5df2cb564f53d",
      "commitAuthor": "Dmitri Plotnikov",
      "commitDateOld": "8/22/01, 5:47 PM",
      "commitNameOld": "bc53a66311b9b22e471dd74860c7df75eebe9837",
      "commitAuthorOld": "Dmitri Plotnikov",
      "daysBetweenCommits": 230.12,
      "commitsBetweenForRepo": 12,
      "commitsBetweenForFile": 1,
      "actualSource": "public static Object convert(Object object, Class toType) {\n    if (object \u003d\u003d null) {\n        return null;\n    }\n    if (toType \u003d\u003d Object.class) {\n        return object;\n    }\n    if (object instanceof ExpressionContext) {\n        if (Collection.class.isAssignableFrom(toType)) {\n            List list \u003d ((ExpressionContext) object).getContextNodeList();\n            Collection result \u003d new ArrayList();\n            if (toType \u003d\u003d List.class || toType \u003d\u003d ArrayList.class) {\n                result \u003d new ArrayList();\n            } else if (toType \u003d\u003d Vector.class) {\n                result \u003d new Vector();\n            } else if (toType \u003d\u003d Set.class || toType \u003d\u003d HashSet.class) {\n                result \u003d new HashSet();\n            }\n            int count \u003d list.size();\n            for (int i \u003d 0; i \u003c count; i++) {\n                Pointer ptr \u003d (Pointer) list.get(i);\n                result.add(ptr.getValue());\n            }\n            return result;\n        } else {\n            Object value \u003d ((ExpressionContext) object).getContextNodePointer().getValue();\n            return convert(value, toType);\n        }\n    }\n    Class fromType \u003d object.getClass();\n    if (fromType.equals(toType) || toType.isAssignableFrom(fromType)) {\n        return object;\n    }\n    if (toType \u003d\u003d String.class) {\n        return object.toString();\n    }\n    if (object instanceof Boolean) {\n        if (toType \u003d\u003d boolean.class) {\n            return object;\n        }\n        boolean value \u003d ((Boolean) object).booleanValue();\n        return allocateNumber(toType, value ? 1 : 0);\n    } else if (object instanceof Number) {\n        double value \u003d ((Number) object).doubleValue();\n        if (toType \u003d\u003d boolean.class || toType \u003d\u003d Boolean.class) {\n            return value \u003d\u003d 0.0 ? Boolean.FALSE : Boolean.TRUE;\n        }\n        if (toType.isPrimitive() || Number.class.isAssignableFrom(toType)) {\n            return allocateNumber(toType, value);\n        }\n    } else if (object instanceof Character) {\n        if (toType \u003d\u003d char.class) {\n            return object;\n        }\n    } else if (object instanceof String) {\n        if (toType \u003d\u003d boolean.class || toType \u003d\u003d Boolean.class) {\n            return new Boolean((String) object);\n        }\n        if (toType \u003d\u003d char.class || toType \u003d\u003d Character.class) {\n            return new Character(((String) object).charAt(0));\n        }\n        if (toType \u003d\u003d byte.class || toType \u003d\u003d Byte.class) {\n            return new Byte((String) object);\n        }\n        if (toType \u003d\u003d short.class || toType \u003d\u003d Short.class) {\n            return new Short((String) object);\n        }\n        if (toType \u003d\u003d int.class || toType \u003d\u003d Integer.class) {\n            return new Integer((String) object);\n        }\n        if (toType \u003d\u003d long.class || toType \u003d\u003d Long.class) {\n            return new Long((String) object);\n        }\n        if (toType \u003d\u003d float.class || toType \u003d\u003d Float.class) {\n            return new Float((String) object);\n        }\n        if (toType \u003d\u003d double.class || toType \u003d\u003d Double.class) {\n            return new Double((String) object);\n        }\n    } else if (fromType.isArray()) {\n        Object value \u003d Array.get(object, 0);\n        return convert(value, toType);\n    } else if (object instanceof List) {\n        Object value \u003d ((List) object).get(0);\n        return convert(value, toType);\n    } else if (object instanceof Collection) {\n        Iterator it \u003d ((Collection) object).iterator();\n        Object value \u003d it.next();\n        return convert(value, toType);\n    }\n    return object;\n}",
      "path": "src/java/org/apache/commons/jxpath/functions/Types.java",
      "functionStartLine": 376,
      "functionName": "convert",
      "functionAnnotation": "",
      "functionDoc": "",
      "diff": "@@ -1,79 +1,92 @@\n public static Object convert(Object object, Class toType) {\n     if (object \u003d\u003d null) {\n         return null;\n     }\n+    if (toType \u003d\u003d Object.class) {\n+        return object;\n+    }\n     if (object instanceof ExpressionContext) {\n         if (Collection.class.isAssignableFrom(toType)) {\n             List list \u003d ((ExpressionContext) object).getContextNodeList();\n             Collection result \u003d new ArrayList();\n             if (toType \u003d\u003d List.class || toType \u003d\u003d ArrayList.class) {\n                 result \u003d new ArrayList();\n             } else if (toType \u003d\u003d Vector.class) {\n                 result \u003d new Vector();\n             } else if (toType \u003d\u003d Set.class || toType \u003d\u003d HashSet.class) {\n                 result \u003d new HashSet();\n             }\n             int count \u003d list.size();\n             for (int i \u003d 0; i \u003c count; i++) {\n                 Pointer ptr \u003d (Pointer) list.get(i);\n                 result.add(ptr.getValue());\n             }\n             return result;\n         } else {\n             Object value \u003d ((ExpressionContext) object).getContextNodePointer().getValue();\n             return convert(value, toType);\n         }\n     }\n     Class fromType \u003d object.getClass();\n     if (fromType.equals(toType) || toType.isAssignableFrom(fromType)) {\n         return object;\n     }\n     if (toType \u003d\u003d String.class) {\n         return object.toString();\n     }\n     if (object instanceof Boolean) {\n         if (toType \u003d\u003d boolean.class) {\n             return object;\n         }\n         boolean value \u003d ((Boolean) object).booleanValue();\n         return allocateNumber(toType, value ? 1 : 0);\n     } else if (object instanceof Number) {\n         double value \u003d ((Number) object).doubleValue();\n         if (toType \u003d\u003d boolean.class || toType \u003d\u003d Boolean.class) {\n             return value \u003d\u003d 0.0 ? Boolean.FALSE : Boolean.TRUE;\n         }\n         if (toType.isPrimitive() || Number.class.isAssignableFrom(toType)) {\n             return allocateNumber(toType, value);\n         }\n     } else if (object instanceof Character) {\n         if (toType \u003d\u003d char.class) {\n             return object;\n         }\n     } else if (object instanceof String) {\n         if (toType \u003d\u003d boolean.class || toType \u003d\u003d Boolean.class) {\n             return new Boolean((String) object);\n         }\n         if (toType \u003d\u003d char.class || toType \u003d\u003d Character.class) {\n             return new Character(((String) object).charAt(0));\n         }\n         if (toType \u003d\u003d byte.class || toType \u003d\u003d Byte.class) {\n             return new Byte((String) object);\n         }\n         if (toType \u003d\u003d short.class || toType \u003d\u003d Short.class) {\n             return new Short((String) object);\n         }\n         if (toType \u003d\u003d int.class || toType \u003d\u003d Integer.class) {\n             return new Integer((String) object);\n         }\n         if (toType \u003d\u003d long.class || toType \u003d\u003d Long.class) {\n             return new Long((String) object);\n         }\n         if (toType \u003d\u003d float.class || toType \u003d\u003d Float.class) {\n             return new Float((String) object);\n         }\n         if (toType \u003d\u003d double.class || toType \u003d\u003d Double.class) {\n             return new Double((String) object);\n         }\n+    } else if (fromType.isArray()) {\n+        Object value \u003d Array.get(object, 0);\n+        return convert(value, toType);\n+    } else if (object instanceof List) {\n+        Object value \u003d ((List) object).get(0);\n+        return convert(value, toType);\n+    } else if (object instanceof Collection) {\n+        Iterator it \u003d ((Collection) object).iterator();\n+        Object value \u003d it.next();\n+        return convert(value, toType);\n     }\n     return object;\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "bc53a66311b9b22e471dd74860c7df75eebe9837": {
      "type": "Yintroduced",
      "commitMessage": "Initial submission\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/jakarta/commons/proper/jxpath/trunk@136698 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "8/22/01, 5:47 PM",
      "commitName": "bc53a66311b9b22e471dd74860c7df75eebe9837",
      "commitAuthor": "Dmitri Plotnikov",
      "diff": "@@ -0,0 +1,79 @@\n+public static Object convert(Object object, Class toType) {\n+    if (object \u003d\u003d null) {\n+        return null;\n+    }\n+    if (object instanceof ExpressionContext) {\n+        if (Collection.class.isAssignableFrom(toType)) {\n+            List list \u003d ((ExpressionContext) object).getContextNodeList();\n+            Collection result \u003d new ArrayList();\n+            if (toType \u003d\u003d List.class || toType \u003d\u003d ArrayList.class) {\n+                result \u003d new ArrayList();\n+            } else if (toType \u003d\u003d Vector.class) {\n+                result \u003d new Vector();\n+            } else if (toType \u003d\u003d Set.class || toType \u003d\u003d HashSet.class) {\n+                result \u003d new HashSet();\n+            }\n+            int count \u003d list.size();\n+            for (int i \u003d 0; i \u003c count; i++) {\n+                Pointer ptr \u003d (Pointer) list.get(i);\n+                result.add(ptr.getValue());\n+            }\n+            return result;\n+        } else {\n+            Object value \u003d ((ExpressionContext) object).getContextNodePointer().getValue();\n+            return convert(value, toType);\n+        }\n+    }\n+    Class fromType \u003d object.getClass();\n+    if (fromType.equals(toType) || toType.isAssignableFrom(fromType)) {\n+        return object;\n+    }\n+    if (toType \u003d\u003d String.class) {\n+        return object.toString();\n+    }\n+    if (object instanceof Boolean) {\n+        if (toType \u003d\u003d boolean.class) {\n+            return object;\n+        }\n+        boolean value \u003d ((Boolean) object).booleanValue();\n+        return allocateNumber(toType, value ? 1 : 0);\n+    } else if (object instanceof Number) {\n+        double value \u003d ((Number) object).doubleValue();\n+        if (toType \u003d\u003d boolean.class || toType \u003d\u003d Boolean.class) {\n+            return value \u003d\u003d 0.0 ? Boolean.FALSE : Boolean.TRUE;\n+        }\n+        if (toType.isPrimitive() || Number.class.isAssignableFrom(toType)) {\n+            return allocateNumber(toType, value);\n+        }\n+    } else if (object instanceof Character) {\n+        if (toType \u003d\u003d char.class) {\n+            return object;\n+        }\n+    } else if (object instanceof String) {\n+        if (toType \u003d\u003d boolean.class || toType \u003d\u003d Boolean.class) {\n+            return new Boolean((String) object);\n+        }\n+        if (toType \u003d\u003d char.class || toType \u003d\u003d Character.class) {\n+            return new Character(((String) object).charAt(0));\n+        }\n+        if (toType \u003d\u003d byte.class || toType \u003d\u003d Byte.class) {\n+            return new Byte((String) object);\n+        }\n+        if (toType \u003d\u003d short.class || toType \u003d\u003d Short.class) {\n+            return new Short((String) object);\n+        }\n+        if (toType \u003d\u003d int.class || toType \u003d\u003d Integer.class) {\n+            return new Integer((String) object);\n+        }\n+        if (toType \u003d\u003d long.class || toType \u003d\u003d Long.class) {\n+            return new Long((String) object);\n+        }\n+        if (toType \u003d\u003d float.class || toType \u003d\u003d Float.class) {\n+            return new Float((String) object);\n+        }\n+        if (toType \u003d\u003d double.class || toType \u003d\u003d Double.class) {\n+            return new Double((String) object);\n+        }\n+    }\n+    return object;\n+}\n\\ No newline at end of file\n",
      "actualSource": "public static Object convert(Object object, Class toType) {\n    if (object \u003d\u003d null) {\n        return null;\n    }\n    if (object instanceof ExpressionContext) {\n        if (Collection.class.isAssignableFrom(toType)) {\n            List list \u003d ((ExpressionContext) object).getContextNodeList();\n            Collection result \u003d new ArrayList();\n            if (toType \u003d\u003d List.class || toType \u003d\u003d ArrayList.class) {\n                result \u003d new ArrayList();\n            } else if (toType \u003d\u003d Vector.class) {\n                result \u003d new Vector();\n            } else if (toType \u003d\u003d Set.class || toType \u003d\u003d HashSet.class) {\n                result \u003d new HashSet();\n            }\n            int count \u003d list.size();\n            for (int i \u003d 0; i \u003c count; i++) {\n                Pointer ptr \u003d (Pointer) list.get(i);\n                result.add(ptr.getValue());\n            }\n            return result;\n        } else {\n            Object value \u003d ((ExpressionContext) object).getContextNodePointer().getValue();\n            return convert(value, toType);\n        }\n    }\n    Class fromType \u003d object.getClass();\n    if (fromType.equals(toType) || toType.isAssignableFrom(fromType)) {\n        return object;\n    }\n    if (toType \u003d\u003d String.class) {\n        return object.toString();\n    }\n    if (object instanceof Boolean) {\n        if (toType \u003d\u003d boolean.class) {\n            return object;\n        }\n        boolean value \u003d ((Boolean) object).booleanValue();\n        return allocateNumber(toType, value ? 1 : 0);\n    } else if (object instanceof Number) {\n        double value \u003d ((Number) object).doubleValue();\n        if (toType \u003d\u003d boolean.class || toType \u003d\u003d Boolean.class) {\n            return value \u003d\u003d 0.0 ? Boolean.FALSE : Boolean.TRUE;\n        }\n        if (toType.isPrimitive() || Number.class.isAssignableFrom(toType)) {\n            return allocateNumber(toType, value);\n        }\n    } else if (object instanceof Character) {\n        if (toType \u003d\u003d char.class) {\n            return object;\n        }\n    } else if (object instanceof String) {\n        if (toType \u003d\u003d boolean.class || toType \u003d\u003d Boolean.class) {\n            return new Boolean((String) object);\n        }\n        if (toType \u003d\u003d char.class || toType \u003d\u003d Character.class) {\n            return new Character(((String) object).charAt(0));\n        }\n        if (toType \u003d\u003d byte.class || toType \u003d\u003d Byte.class) {\n            return new Byte((String) object);\n        }\n        if (toType \u003d\u003d short.class || toType \u003d\u003d Short.class) {\n            return new Short((String) object);\n        }\n        if (toType \u003d\u003d int.class || toType \u003d\u003d Integer.class) {\n            return new Integer((String) object);\n        }\n        if (toType \u003d\u003d long.class || toType \u003d\u003d Long.class) {\n            return new Long((String) object);\n        }\n        if (toType \u003d\u003d float.class || toType \u003d\u003d Float.class) {\n            return new Float((String) object);\n        }\n        if (toType \u003d\u003d double.class || toType \u003d\u003d Double.class) {\n            return new Double((String) object);\n        }\n    }\n    return object;\n}",
      "path": "src/java/org/apache/commons/jxpath/functions/Types.java",
      "functionStartLine": 342,
      "functionName": "convert",
      "functionAnnotation": "",
      "functionDoc": ""
    }
  }
}