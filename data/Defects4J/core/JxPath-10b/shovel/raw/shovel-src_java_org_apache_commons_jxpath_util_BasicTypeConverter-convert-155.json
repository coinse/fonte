{
  "origin": "codeshovel",
  "repositoryName": "JxPath-10b",
  "repositoryPath": "/tmp/JxPath-10b//.git",
  "startCommitName": "HEAD",
  "sourceFileName": "BasicTypeConverter.java",
  "functionName": "convert",
  "functionId": "convert___object-Object__toType-Class(modifiers-final)",
  "sourceFilePath": "src/java/org/apache/commons/jxpath/util/BasicTypeConverter.java",
  "functionAnnotation": "",
  "functionDoc": "Converts the supplied object to the specified\ntype. Throws a runtime exception if the conversion is\nnot possible.\n",
  "functionStartLine": 155,
  "functionEndLine": 276,
  "numCommitsSeen": 39,
  "timeTaken": 1168,
  "changeHistory": [
    "8778c3cbe1146ece404662cc9f2611a1c819b883",
    "30e4fdde61866403ce8912dfb8afe328502c4d20",
    "c5808a90cd91bc01d78c7f3da8718b6dcf429fa0",
    "7b914c03b7c6f09844bc1a923f0f4b042193c79a",
    "9871c3f7a3db48cb9d627eb527d2adb58a692287",
    "e7ecdaf5a2ea7c59b20edfbc92dfc31d6002945a",
    "77af585d9f0e629db4ecf8d468ef7b71c9d98e39",
    "4ab5b9e453d0e0ef51fc1d36a5e21aaf21b44c81",
    "348acabaadc57e04f25de5c79c72bc34a4e41723",
    "2327c42440cd4927ac5fc91ed93756cb0c87c96d",
    "73f1fffe48c5f26e2c29280385bf0e8f2b9627ac"
  ],
  "changeHistoryShort": {
    "8778c3cbe1146ece404662cc9f2611a1c819b883": "Ymultichange(Ybodychange,Yparametermetachange)",
    "30e4fdde61866403ce8912dfb8afe328502c4d20": "Ybodychange",
    "c5808a90cd91bc01d78c7f3da8718b6dcf429fa0": "Ybodychange",
    "7b914c03b7c6f09844bc1a923f0f4b042193c79a": "Ybodychange",
    "9871c3f7a3db48cb9d627eb527d2adb58a692287": "Ybodychange",
    "e7ecdaf5a2ea7c59b20edfbc92dfc31d6002945a": "Ybodychange",
    "77af585d9f0e629db4ecf8d468ef7b71c9d98e39": "Ybodychange",
    "4ab5b9e453d0e0ef51fc1d36a5e21aaf21b44c81": "Ybodychange",
    "348acabaadc57e04f25de5c79c72bc34a4e41723": "Ybodychange",
    "2327c42440cd4927ac5fc91ed93756cb0c87c96d": "Ybodychange",
    "73f1fffe48c5f26e2c29280385bf0e8f2b9627ac": "Yintroduced"
  },
  "changeHistoryDetails": {
    "8778c3cbe1146ece404662cc9f2611a1c819b883": {
      "type": "Ymultichange(Ybodychange,Yparametermetachange)",
      "commitMessage": "simplify BasicTypeConverter code; add support for untreated Number types + AtomicBoolean\n\ngit-svn-id: https://svn.apache.org/repos/asf/jakarta/commons/proper/jxpath/trunk@552965 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "7/3/07, 1:07 PM",
      "commitName": "8778c3cbe1146ece404662cc9f2611a1c819b883",
      "commitAuthor": "Matthew Jason Benson",
      "subchanges": [
        {
          "type": "Ybodychange",
          "commitMessage": "simplify BasicTypeConverter code; add support for untreated Number types + AtomicBoolean\n\ngit-svn-id: https://svn.apache.org/repos/asf/jakarta/commons/proper/jxpath/trunk@552965 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "7/3/07, 1:07 PM",
          "commitName": "8778c3cbe1146ece404662cc9f2611a1c819b883",
          "commitAuthor": "Matthew Jason Benson",
          "commitDateOld": "2/19/07, 3:24 PM",
          "commitNameOld": "30e4fdde61866403ce8912dfb8afe328502c4d20",
          "commitAuthorOld": "Matthew Jason Benson",
          "daysBetweenCommits": 133.86,
          "commitsBetweenForRepo": 26,
          "commitsBetweenForFile": 1,
          "actualSource": "public Object convert(Object object, final Class toType) {\n    if (object \u003d\u003d null) {\n        return toType.isPrimitive() ? convertNullToPrimitive(toType) : null;\n    }\n    if (toType \u003d\u003d Object.class) {\n        if (object instanceof NodeSet) {\n            return convert(((NodeSet) object).getValues(), toType);\n        }\n        if (object instanceof Pointer) {\n            return convert(((Pointer) object).getValue(), toType);\n        }\n        return object;\n    }\n    final Class useType \u003d TypeUtils.wrapPrimitive(toType);\n    Class fromType \u003d object.getClass();\n    if (useType.isAssignableFrom(fromType)) {\n        return object;\n    }\n    if (fromType.isArray()) {\n        int length \u003d Array.getLength(object);\n        if (useType.isArray()) {\n            Class cType \u003d useType.getComponentType();\n            Object array \u003d Array.newInstance(cType, length);\n            for (int i \u003d 0; i \u003c length; i++) {\n                Object value \u003d Array.get(object, i);\n                Array.set(array, i, convert(value, cType));\n            }\n            return array;\n        }\n        if (Collection.class.isAssignableFrom(useType)) {\n            Collection collection \u003d allocateCollection(useType);\n            for (int i \u003d 0; i \u003c length; i++) {\n                collection.add(Array.get(object, i));\n            }\n            return unmodifiableCollection(collection);\n        }\n        if (length \u003e 0) {\n            Object value \u003d Array.get(object, 0);\n            return convert(value, useType);\n        }\n        return convert(\"\", useType);\n    }\n    if (object instanceof Collection) {\n        int length \u003d ((Collection) object).size();\n        if (useType.isArray()) {\n            Class cType \u003d useType.getComponentType();\n            Object array \u003d Array.newInstance(cType, length);\n            Iterator it \u003d ((Collection) object).iterator();\n            for (int i \u003d 0; i \u003c length; i++) {\n                Object value \u003d it.next();\n                Array.set(array, i, convert(value, cType));\n            }\n            return array;\n        }\n        if (Collection.class.isAssignableFrom(useType)) {\n            Collection collection \u003d allocateCollection(useType);\n            collection.addAll((Collection) object);\n            return unmodifiableCollection(collection);\n        }\n        if (length \u003e 0) {\n            Object value;\n            if (object instanceof List) {\n                value \u003d ((List) object).get(0);\n            } else {\n                Iterator it \u003d ((Collection) object).iterator();\n                value \u003d it.next();\n            }\n            return convert(value, useType);\n        }\n        return convert(\"\", useType);\n    }\n    if (object instanceof NodeSet) {\n        return convert(((NodeSet) object).getValues(), useType);\n    }\n    if (object instanceof Pointer) {\n        return convert(((Pointer) object).getValue(), useType);\n    }\n    if (useType \u003d\u003d String.class) {\n        return object.toString();\n    }\n    if (object instanceof Boolean) {\n        if (Number.class.isAssignableFrom(useType)) {\n            return allocateNumber(useType, ((Boolean) object).booleanValue() ? 1 : 0);\n        }\n        if (\"java.util.concurrent.atomic.AtomicBoolean\".equals(useType.getName())) {\n            try {\n                return useType.getConstructor(new Class[] { boolean.class }).newInstance(new Object[] { object });\n            } catch (Exception e) {\n                throw new JXPathTypeConversionException(useType.getName(), e);\n            }\n        }\n    }\n    if (object instanceof Number) {\n        double value \u003d ((Number) object).doubleValue();\n        if (useType \u003d\u003d Boolean.class) {\n            return value \u003d\u003d 0.0 ? Boolean.FALSE : Boolean.TRUE;\n        }\n        if (Number.class.isAssignableFrom(useType)) {\n            return allocateNumber(useType, value);\n        }\n    }\n    if (object instanceof String) {\n        Object value \u003d convertStringToPrimitive(object, useType);\n        if (value !\u003d null) {\n            return value;\n        }\n    }\n    Converter converter \u003d ConvertUtils.lookup(useType);\n    if (converter !\u003d null) {\n        return converter.convert(useType, object);\n    }\n    throw new JXPathTypeConversionException(\"Cannot convert \" + object.getClass() + \" to \" + useType);\n}",
          "path": "src/java/org/apache/commons/jxpath/util/BasicTypeConverter.java",
          "functionStartLine": 155,
          "functionName": "convert",
          "functionAnnotation": "",
          "functionDoc": "Converts the supplied object to the specified\ntype. Throws a runtime exception if the conversion is\nnot possible.\n",
          "diff": "@@ -1,114 +1,113 @@\n-public Object convert(Object object, Class toType) {\n+public Object convert(Object object, final Class toType) {\n     if (object \u003d\u003d null) {\n         return toType.isPrimitive() ? convertNullToPrimitive(toType) : null;\n     }\n     if (toType \u003d\u003d Object.class) {\n         if (object instanceof NodeSet) {\n             return convert(((NodeSet) object).getValues(), toType);\n         }\n         if (object instanceof Pointer) {\n             return convert(((Pointer) object).getValue(), toType);\n         }\n         return object;\n     }\n+    final Class useType \u003d TypeUtils.wrapPrimitive(toType);\n     Class fromType \u003d object.getClass();\n-    if (fromType.equals(toType) || toType.isAssignableFrom(fromType)) {\n+    if (useType.isAssignableFrom(fromType)) {\n         return object;\n     }\n     if (fromType.isArray()) {\n         int length \u003d Array.getLength(object);\n-        if (toType.isArray()) {\n-            Class cType \u003d toType.getComponentType();\n+        if (useType.isArray()) {\n+            Class cType \u003d useType.getComponentType();\n             Object array \u003d Array.newInstance(cType, length);\n             for (int i \u003d 0; i \u003c length; i++) {\n                 Object value \u003d Array.get(object, i);\n                 Array.set(array, i, convert(value, cType));\n             }\n             return array;\n         }\n-        if (Collection.class.isAssignableFrom(toType)) {\n-            Collection collection \u003d allocateCollection(toType);\n+        if (Collection.class.isAssignableFrom(useType)) {\n+            Collection collection \u003d allocateCollection(useType);\n             for (int i \u003d 0; i \u003c length; i++) {\n                 collection.add(Array.get(object, i));\n             }\n             return unmodifiableCollection(collection);\n         }\n         if (length \u003e 0) {\n             Object value \u003d Array.get(object, 0);\n-            return convert(value, toType);\n+            return convert(value, useType);\n         }\n-        return convert(\"\", toType);\n+        return convert(\"\", useType);\n     }\n     if (object instanceof Collection) {\n         int length \u003d ((Collection) object).size();\n-        if (toType.isArray()) {\n-            Class cType \u003d toType.getComponentType();\n+        if (useType.isArray()) {\n+            Class cType \u003d useType.getComponentType();\n             Object array \u003d Array.newInstance(cType, length);\n             Iterator it \u003d ((Collection) object).iterator();\n             for (int i \u003d 0; i \u003c length; i++) {\n                 Object value \u003d it.next();\n                 Array.set(array, i, convert(value, cType));\n             }\n             return array;\n         }\n-        if (Collection.class.isAssignableFrom(toType)) {\n-            Collection collection \u003d allocateCollection(toType);\n+        if (Collection.class.isAssignableFrom(useType)) {\n+            Collection collection \u003d allocateCollection(useType);\n             collection.addAll((Collection) object);\n             return unmodifiableCollection(collection);\n         }\n         if (length \u003e 0) {\n             Object value;\n             if (object instanceof List) {\n                 value \u003d ((List) object).get(0);\n             } else {\n                 Iterator it \u003d ((Collection) object).iterator();\n                 value \u003d it.next();\n             }\n-            return convert(value, toType);\n+            return convert(value, useType);\n         }\n-        return convert(\"\", toType);\n+        return convert(\"\", useType);\n     }\n     if (object instanceof NodeSet) {\n-        return convert(((NodeSet) object).getValues(), toType);\n+        return convert(((NodeSet) object).getValues(), useType);\n     }\n     if (object instanceof Pointer) {\n-        return convert(((Pointer) object).getValue(), toType);\n+        return convert(((Pointer) object).getValue(), useType);\n     }\n-    if (toType \u003d\u003d String.class) {\n+    if (useType \u003d\u003d String.class) {\n         return object.toString();\n     }\n     if (object instanceof Boolean) {\n-        if (toType \u003d\u003d boolean.class) {\n-            return object;\n+        if (Number.class.isAssignableFrom(useType)) {\n+            return allocateNumber(useType, ((Boolean) object).booleanValue() ? 1 : 0);\n         }\n-        if (toType.isPrimitive() || Number.class.isAssignableFrom(toType)) {\n-            boolean value \u003d ((Boolean) object).booleanValue();\n-            return allocateNumber(toType, value ? 1 : 0);\n+        if (\"java.util.concurrent.atomic.AtomicBoolean\".equals(useType.getName())) {\n+            try {\n+                return useType.getConstructor(new Class[] { boolean.class }).newInstance(new Object[] { object });\n+            } catch (Exception e) {\n+                throw new JXPathTypeConversionException(useType.getName(), e);\n+            }\n         }\n     }\n     if (object instanceof Number) {\n         double value \u003d ((Number) object).doubleValue();\n-        if (toType \u003d\u003d boolean.class || toType \u003d\u003d Boolean.class) {\n+        if (useType \u003d\u003d Boolean.class) {\n             return value \u003d\u003d 0.0 ? Boolean.FALSE : Boolean.TRUE;\n         }\n-        if (toType.isPrimitive() || Number.class.isAssignableFrom(toType)) {\n-            return allocateNumber(toType, value);\n-        }\n-    }\n-    if (object instanceof Character) {\n-        if (toType \u003d\u003d char.class) {\n-            return object;\n+        if (Number.class.isAssignableFrom(useType)) {\n+            return allocateNumber(useType, value);\n         }\n     }\n     if (object instanceof String) {\n-        Object value \u003d convertStringToPrimitive(object, toType);\n+        Object value \u003d convertStringToPrimitive(object, useType);\n         if (value !\u003d null) {\n             return value;\n         }\n     }\n-    Converter converter \u003d ConvertUtils.lookup(toType);\n+    Converter converter \u003d ConvertUtils.lookup(useType);\n     if (converter !\u003d null) {\n-        return converter.convert(toType, object);\n+        return converter.convert(useType, object);\n     }\n-    throw new JXPathTypeConversionException(\"Cannot convert \" + object.getClass() + \" to \" + toType);\n+    throw new JXPathTypeConversionException(\"Cannot convert \" + object.getClass() + \" to \" + useType);\n }\n\\ No newline at end of file\n",
          "extendedDetails": {}
        },
        {
          "type": "Yparametermetachange",
          "commitMessage": "simplify BasicTypeConverter code; add support for untreated Number types + AtomicBoolean\n\ngit-svn-id: https://svn.apache.org/repos/asf/jakarta/commons/proper/jxpath/trunk@552965 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "7/3/07, 1:07 PM",
          "commitName": "8778c3cbe1146ece404662cc9f2611a1c819b883",
          "commitAuthor": "Matthew Jason Benson",
          "commitDateOld": "2/19/07, 3:24 PM",
          "commitNameOld": "30e4fdde61866403ce8912dfb8afe328502c4d20",
          "commitAuthorOld": "Matthew Jason Benson",
          "daysBetweenCommits": 133.86,
          "commitsBetweenForRepo": 26,
          "commitsBetweenForFile": 1,
          "actualSource": "public Object convert(Object object, final Class toType) {\n    if (object \u003d\u003d null) {\n        return toType.isPrimitive() ? convertNullToPrimitive(toType) : null;\n    }\n    if (toType \u003d\u003d Object.class) {\n        if (object instanceof NodeSet) {\n            return convert(((NodeSet) object).getValues(), toType);\n        }\n        if (object instanceof Pointer) {\n            return convert(((Pointer) object).getValue(), toType);\n        }\n        return object;\n    }\n    final Class useType \u003d TypeUtils.wrapPrimitive(toType);\n    Class fromType \u003d object.getClass();\n    if (useType.isAssignableFrom(fromType)) {\n        return object;\n    }\n    if (fromType.isArray()) {\n        int length \u003d Array.getLength(object);\n        if (useType.isArray()) {\n            Class cType \u003d useType.getComponentType();\n            Object array \u003d Array.newInstance(cType, length);\n            for (int i \u003d 0; i \u003c length; i++) {\n                Object value \u003d Array.get(object, i);\n                Array.set(array, i, convert(value, cType));\n            }\n            return array;\n        }\n        if (Collection.class.isAssignableFrom(useType)) {\n            Collection collection \u003d allocateCollection(useType);\n            for (int i \u003d 0; i \u003c length; i++) {\n                collection.add(Array.get(object, i));\n            }\n            return unmodifiableCollection(collection);\n        }\n        if (length \u003e 0) {\n            Object value \u003d Array.get(object, 0);\n            return convert(value, useType);\n        }\n        return convert(\"\", useType);\n    }\n    if (object instanceof Collection) {\n        int length \u003d ((Collection) object).size();\n        if (useType.isArray()) {\n            Class cType \u003d useType.getComponentType();\n            Object array \u003d Array.newInstance(cType, length);\n            Iterator it \u003d ((Collection) object).iterator();\n            for (int i \u003d 0; i \u003c length; i++) {\n                Object value \u003d it.next();\n                Array.set(array, i, convert(value, cType));\n            }\n            return array;\n        }\n        if (Collection.class.isAssignableFrom(useType)) {\n            Collection collection \u003d allocateCollection(useType);\n            collection.addAll((Collection) object);\n            return unmodifiableCollection(collection);\n        }\n        if (length \u003e 0) {\n            Object value;\n            if (object instanceof List) {\n                value \u003d ((List) object).get(0);\n            } else {\n                Iterator it \u003d ((Collection) object).iterator();\n                value \u003d it.next();\n            }\n            return convert(value, useType);\n        }\n        return convert(\"\", useType);\n    }\n    if (object instanceof NodeSet) {\n        return convert(((NodeSet) object).getValues(), useType);\n    }\n    if (object instanceof Pointer) {\n        return convert(((Pointer) object).getValue(), useType);\n    }\n    if (useType \u003d\u003d String.class) {\n        return object.toString();\n    }\n    if (object instanceof Boolean) {\n        if (Number.class.isAssignableFrom(useType)) {\n            return allocateNumber(useType, ((Boolean) object).booleanValue() ? 1 : 0);\n        }\n        if (\"java.util.concurrent.atomic.AtomicBoolean\".equals(useType.getName())) {\n            try {\n                return useType.getConstructor(new Class[] { boolean.class }).newInstance(new Object[] { object });\n            } catch (Exception e) {\n                throw new JXPathTypeConversionException(useType.getName(), e);\n            }\n        }\n    }\n    if (object instanceof Number) {\n        double value \u003d ((Number) object).doubleValue();\n        if (useType \u003d\u003d Boolean.class) {\n            return value \u003d\u003d 0.0 ? Boolean.FALSE : Boolean.TRUE;\n        }\n        if (Number.class.isAssignableFrom(useType)) {\n            return allocateNumber(useType, value);\n        }\n    }\n    if (object instanceof String) {\n        Object value \u003d convertStringToPrimitive(object, useType);\n        if (value !\u003d null) {\n            return value;\n        }\n    }\n    Converter converter \u003d ConvertUtils.lookup(useType);\n    if (converter !\u003d null) {\n        return converter.convert(useType, object);\n    }\n    throw new JXPathTypeConversionException(\"Cannot convert \" + object.getClass() + \" to \" + useType);\n}",
          "path": "src/java/org/apache/commons/jxpath/util/BasicTypeConverter.java",
          "functionStartLine": 155,
          "functionName": "convert",
          "functionAnnotation": "",
          "functionDoc": "Converts the supplied object to the specified\ntype. Throws a runtime exception if the conversion is\nnot possible.\n",
          "diff": "@@ -1,114 +1,113 @@\n-public Object convert(Object object, Class toType) {\n+public Object convert(Object object, final Class toType) {\n     if (object \u003d\u003d null) {\n         return toType.isPrimitive() ? convertNullToPrimitive(toType) : null;\n     }\n     if (toType \u003d\u003d Object.class) {\n         if (object instanceof NodeSet) {\n             return convert(((NodeSet) object).getValues(), toType);\n         }\n         if (object instanceof Pointer) {\n             return convert(((Pointer) object).getValue(), toType);\n         }\n         return object;\n     }\n+    final Class useType \u003d TypeUtils.wrapPrimitive(toType);\n     Class fromType \u003d object.getClass();\n-    if (fromType.equals(toType) || toType.isAssignableFrom(fromType)) {\n+    if (useType.isAssignableFrom(fromType)) {\n         return object;\n     }\n     if (fromType.isArray()) {\n         int length \u003d Array.getLength(object);\n-        if (toType.isArray()) {\n-            Class cType \u003d toType.getComponentType();\n+        if (useType.isArray()) {\n+            Class cType \u003d useType.getComponentType();\n             Object array \u003d Array.newInstance(cType, length);\n             for (int i \u003d 0; i \u003c length; i++) {\n                 Object value \u003d Array.get(object, i);\n                 Array.set(array, i, convert(value, cType));\n             }\n             return array;\n         }\n-        if (Collection.class.isAssignableFrom(toType)) {\n-            Collection collection \u003d allocateCollection(toType);\n+        if (Collection.class.isAssignableFrom(useType)) {\n+            Collection collection \u003d allocateCollection(useType);\n             for (int i \u003d 0; i \u003c length; i++) {\n                 collection.add(Array.get(object, i));\n             }\n             return unmodifiableCollection(collection);\n         }\n         if (length \u003e 0) {\n             Object value \u003d Array.get(object, 0);\n-            return convert(value, toType);\n+            return convert(value, useType);\n         }\n-        return convert(\"\", toType);\n+        return convert(\"\", useType);\n     }\n     if (object instanceof Collection) {\n         int length \u003d ((Collection) object).size();\n-        if (toType.isArray()) {\n-            Class cType \u003d toType.getComponentType();\n+        if (useType.isArray()) {\n+            Class cType \u003d useType.getComponentType();\n             Object array \u003d Array.newInstance(cType, length);\n             Iterator it \u003d ((Collection) object).iterator();\n             for (int i \u003d 0; i \u003c length; i++) {\n                 Object value \u003d it.next();\n                 Array.set(array, i, convert(value, cType));\n             }\n             return array;\n         }\n-        if (Collection.class.isAssignableFrom(toType)) {\n-            Collection collection \u003d allocateCollection(toType);\n+        if (Collection.class.isAssignableFrom(useType)) {\n+            Collection collection \u003d allocateCollection(useType);\n             collection.addAll((Collection) object);\n             return unmodifiableCollection(collection);\n         }\n         if (length \u003e 0) {\n             Object value;\n             if (object instanceof List) {\n                 value \u003d ((List) object).get(0);\n             } else {\n                 Iterator it \u003d ((Collection) object).iterator();\n                 value \u003d it.next();\n             }\n-            return convert(value, toType);\n+            return convert(value, useType);\n         }\n-        return convert(\"\", toType);\n+        return convert(\"\", useType);\n     }\n     if (object instanceof NodeSet) {\n-        return convert(((NodeSet) object).getValues(), toType);\n+        return convert(((NodeSet) object).getValues(), useType);\n     }\n     if (object instanceof Pointer) {\n-        return convert(((Pointer) object).getValue(), toType);\n+        return convert(((Pointer) object).getValue(), useType);\n     }\n-    if (toType \u003d\u003d String.class) {\n+    if (useType \u003d\u003d String.class) {\n         return object.toString();\n     }\n     if (object instanceof Boolean) {\n-        if (toType \u003d\u003d boolean.class) {\n-            return object;\n+        if (Number.class.isAssignableFrom(useType)) {\n+            return allocateNumber(useType, ((Boolean) object).booleanValue() ? 1 : 0);\n         }\n-        if (toType.isPrimitive() || Number.class.isAssignableFrom(toType)) {\n-            boolean value \u003d ((Boolean) object).booleanValue();\n-            return allocateNumber(toType, value ? 1 : 0);\n+        if (\"java.util.concurrent.atomic.AtomicBoolean\".equals(useType.getName())) {\n+            try {\n+                return useType.getConstructor(new Class[] { boolean.class }).newInstance(new Object[] { object });\n+            } catch (Exception e) {\n+                throw new JXPathTypeConversionException(useType.getName(), e);\n+            }\n         }\n     }\n     if (object instanceof Number) {\n         double value \u003d ((Number) object).doubleValue();\n-        if (toType \u003d\u003d boolean.class || toType \u003d\u003d Boolean.class) {\n+        if (useType \u003d\u003d Boolean.class) {\n             return value \u003d\u003d 0.0 ? Boolean.FALSE : Boolean.TRUE;\n         }\n-        if (toType.isPrimitive() || Number.class.isAssignableFrom(toType)) {\n-            return allocateNumber(toType, value);\n-        }\n-    }\n-    if (object instanceof Character) {\n-        if (toType \u003d\u003d char.class) {\n-            return object;\n+        if (Number.class.isAssignableFrom(useType)) {\n+            return allocateNumber(useType, value);\n         }\n     }\n     if (object instanceof String) {\n-        Object value \u003d convertStringToPrimitive(object, toType);\n+        Object value \u003d convertStringToPrimitive(object, useType);\n         if (value !\u003d null) {\n             return value;\n         }\n     }\n-    Converter converter \u003d ConvertUtils.lookup(toType);\n+    Converter converter \u003d ConvertUtils.lookup(useType);\n     if (converter !\u003d null) {\n-        return converter.convert(toType, object);\n+        return converter.convert(useType, object);\n     }\n-    throw new JXPathTypeConversionException(\"Cannot convert \" + object.getClass() + \" to \" + toType);\n+    throw new JXPathTypeConversionException(\"Cannot convert \" + object.getClass() + \" to \" + useType);\n }\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldValue": "[object-Object, toType-Class]",
            "newValue": "[object-Object, toType-Class(modifiers-final)]"
          }
        }
      ]
    },
    "30e4fdde61866403ce8912dfb8afe328502c4d20": {
      "type": "Ybodychange",
      "commitMessage": "bulled through JXPath codebase to get a little better familiarity; tiny refactorings and removals of unnecessary elses, etc. along the way\n\ngit-svn-id: https://svn.apache.org/repos/asf/jakarta/commons/proper/jxpath/trunk@509378 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "2/19/07, 3:24 PM",
      "commitName": "30e4fdde61866403ce8912dfb8afe328502c4d20",
      "commitAuthor": "Matthew Jason Benson",
      "commitDateOld": "11/28/06, 9:37 PM",
      "commitNameOld": "a78dc45a3795e3b9666daed8c13ccc7f4ff48806",
      "commitAuthorOld": "Henri Yandell",
      "daysBetweenCommits": 82.74,
      "commitsBetweenForRepo": 26,
      "commitsBetweenForFile": 1,
      "actualSource": "public Object convert(Object object, Class toType) {\n    if (object \u003d\u003d null) {\n        return toType.isPrimitive() ? convertNullToPrimitive(toType) : null;\n    }\n    if (toType \u003d\u003d Object.class) {\n        if (object instanceof NodeSet) {\n            return convert(((NodeSet) object).getValues(), toType);\n        }\n        if (object instanceof Pointer) {\n            return convert(((Pointer) object).getValue(), toType);\n        }\n        return object;\n    }\n    Class fromType \u003d object.getClass();\n    if (fromType.equals(toType) || toType.isAssignableFrom(fromType)) {\n        return object;\n    }\n    if (fromType.isArray()) {\n        int length \u003d Array.getLength(object);\n        if (toType.isArray()) {\n            Class cType \u003d toType.getComponentType();\n            Object array \u003d Array.newInstance(cType, length);\n            for (int i \u003d 0; i \u003c length; i++) {\n                Object value \u003d Array.get(object, i);\n                Array.set(array, i, convert(value, cType));\n            }\n            return array;\n        }\n        if (Collection.class.isAssignableFrom(toType)) {\n            Collection collection \u003d allocateCollection(toType);\n            for (int i \u003d 0; i \u003c length; i++) {\n                collection.add(Array.get(object, i));\n            }\n            return unmodifiableCollection(collection);\n        }\n        if (length \u003e 0) {\n            Object value \u003d Array.get(object, 0);\n            return convert(value, toType);\n        }\n        return convert(\"\", toType);\n    }\n    if (object instanceof Collection) {\n        int length \u003d ((Collection) object).size();\n        if (toType.isArray()) {\n            Class cType \u003d toType.getComponentType();\n            Object array \u003d Array.newInstance(cType, length);\n            Iterator it \u003d ((Collection) object).iterator();\n            for (int i \u003d 0; i \u003c length; i++) {\n                Object value \u003d it.next();\n                Array.set(array, i, convert(value, cType));\n            }\n            return array;\n        }\n        if (Collection.class.isAssignableFrom(toType)) {\n            Collection collection \u003d allocateCollection(toType);\n            collection.addAll((Collection) object);\n            return unmodifiableCollection(collection);\n        }\n        if (length \u003e 0) {\n            Object value;\n            if (object instanceof List) {\n                value \u003d ((List) object).get(0);\n            } else {\n                Iterator it \u003d ((Collection) object).iterator();\n                value \u003d it.next();\n            }\n            return convert(value, toType);\n        }\n        return convert(\"\", toType);\n    }\n    if (object instanceof NodeSet) {\n        return convert(((NodeSet) object).getValues(), toType);\n    }\n    if (object instanceof Pointer) {\n        return convert(((Pointer) object).getValue(), toType);\n    }\n    if (toType \u003d\u003d String.class) {\n        return object.toString();\n    }\n    if (object instanceof Boolean) {\n        if (toType \u003d\u003d boolean.class) {\n            return object;\n        }\n        if (toType.isPrimitive() || Number.class.isAssignableFrom(toType)) {\n            boolean value \u003d ((Boolean) object).booleanValue();\n            return allocateNumber(toType, value ? 1 : 0);\n        }\n    }\n    if (object instanceof Number) {\n        double value \u003d ((Number) object).doubleValue();\n        if (toType \u003d\u003d boolean.class || toType \u003d\u003d Boolean.class) {\n            return value \u003d\u003d 0.0 ? Boolean.FALSE : Boolean.TRUE;\n        }\n        if (toType.isPrimitive() || Number.class.isAssignableFrom(toType)) {\n            return allocateNumber(toType, value);\n        }\n    }\n    if (object instanceof Character) {\n        if (toType \u003d\u003d char.class) {\n            return object;\n        }\n    }\n    if (object instanceof String) {\n        Object value \u003d convertStringToPrimitive(object, toType);\n        if (value !\u003d null) {\n            return value;\n        }\n    }\n    Converter converter \u003d ConvertUtils.lookup(toType);\n    if (converter !\u003d null) {\n        return converter.convert(toType, object);\n    }\n    throw new JXPathTypeConversionException(\"Cannot convert \" + object.getClass() + \" to \" + toType);\n}",
      "path": "src/java/org/apache/commons/jxpath/util/BasicTypeConverter.java",
      "functionStartLine": 168,
      "functionName": "convert",
      "functionAnnotation": "",
      "functionDoc": "Converts the supplied object to the specified\ntype. Throws a runtime exception if the conversion is\nnot possible.\n",
      "diff": "@@ -1,108 +1,114 @@\n public Object convert(Object object, Class toType) {\n     if (object \u003d\u003d null) {\n-        if (toType.isPrimitive()) {\n-            return convertNullToPrimitive(toType);\n-        }\n-        return null;\n+        return toType.isPrimitive() ? convertNullToPrimitive(toType) : null;\n     }\n     if (toType \u003d\u003d Object.class) {\n         if (object instanceof NodeSet) {\n             return convert(((NodeSet) object).getValues(), toType);\n-        } else if (object instanceof Pointer) {\n+        }\n+        if (object instanceof Pointer) {\n             return convert(((Pointer) object).getValue(), toType);\n         }\n         return object;\n     }\n     Class fromType \u003d object.getClass();\n     if (fromType.equals(toType) || toType.isAssignableFrom(fromType)) {\n         return object;\n     }\n     if (fromType.isArray()) {\n         int length \u003d Array.getLength(object);\n         if (toType.isArray()) {\n             Class cType \u003d toType.getComponentType();\n             Object array \u003d Array.newInstance(cType, length);\n             for (int i \u003d 0; i \u003c length; i++) {\n                 Object value \u003d Array.get(object, i);\n                 Array.set(array, i, convert(value, cType));\n             }\n             return array;\n-        } else if (Collection.class.isAssignableFrom(toType)) {\n+        }\n+        if (Collection.class.isAssignableFrom(toType)) {\n             Collection collection \u003d allocateCollection(toType);\n             for (int i \u003d 0; i \u003c length; i++) {\n                 collection.add(Array.get(object, i));\n             }\n             return unmodifiableCollection(collection);\n-        } else {\n-            if (length \u003e 0) {\n-                Object value \u003d Array.get(object, 0);\n-                return convert(value, toType);\n-            } else {\n-                return convert(\"\", toType);\n-            }\n         }\n-    } else if (object instanceof Collection) {\n+        if (length \u003e 0) {\n+            Object value \u003d Array.get(object, 0);\n+            return convert(value, toType);\n+        }\n+        return convert(\"\", toType);\n+    }\n+    if (object instanceof Collection) {\n         int length \u003d ((Collection) object).size();\n         if (toType.isArray()) {\n             Class cType \u003d toType.getComponentType();\n             Object array \u003d Array.newInstance(cType, length);\n             Iterator it \u003d ((Collection) object).iterator();\n             for (int i \u003d 0; i \u003c length; i++) {\n                 Object value \u003d it.next();\n                 Array.set(array, i, convert(value, cType));\n             }\n             return array;\n-        } else if (Collection.class.isAssignableFrom(toType)) {\n+        }\n+        if (Collection.class.isAssignableFrom(toType)) {\n             Collection collection \u003d allocateCollection(toType);\n             collection.addAll((Collection) object);\n             return unmodifiableCollection(collection);\n-        } else {\n-            if (length \u003e 0) {\n-                Object value;\n-                if (object instanceof List) {\n-                    value \u003d ((List) object).get(0);\n-                } else {\n-                    Iterator it \u003d ((Collection) object).iterator();\n-                    value \u003d it.next();\n-                }\n-                return convert(value, toType);\n-            } else {\n-                return convert(\"\", toType);\n-            }\n         }\n-    } else if (object instanceof NodeSet) {\n+        if (length \u003e 0) {\n+            Object value;\n+            if (object instanceof List) {\n+                value \u003d ((List) object).get(0);\n+            } else {\n+                Iterator it \u003d ((Collection) object).iterator();\n+                value \u003d it.next();\n+            }\n+            return convert(value, toType);\n+        }\n+        return convert(\"\", toType);\n+    }\n+    if (object instanceof NodeSet) {\n         return convert(((NodeSet) object).getValues(), toType);\n-    } else if (object instanceof Pointer) {\n+    }\n+    if (object instanceof Pointer) {\n         return convert(((Pointer) object).getValue(), toType);\n-    } else if (toType \u003d\u003d String.class) {\n+    }\n+    if (toType \u003d\u003d String.class) {\n         return object.toString();\n-    } else if (object instanceof Boolean) {\n+    }\n+    if (object instanceof Boolean) {\n         if (toType \u003d\u003d boolean.class) {\n             return object;\n         }\n-        boolean value \u003d ((Boolean) object).booleanValue();\n-        return allocateNumber(toType, value ? 1 : 0);\n-    } else if (object instanceof Number) {\n+        if (toType.isPrimitive() || Number.class.isAssignableFrom(toType)) {\n+            boolean value \u003d ((Boolean) object).booleanValue();\n+            return allocateNumber(toType, value ? 1 : 0);\n+        }\n+    }\n+    if (object instanceof Number) {\n         double value \u003d ((Number) object).doubleValue();\n         if (toType \u003d\u003d boolean.class || toType \u003d\u003d Boolean.class) {\n             return value \u003d\u003d 0.0 ? Boolean.FALSE : Boolean.TRUE;\n         }\n         if (toType.isPrimitive() || Number.class.isAssignableFrom(toType)) {\n             return allocateNumber(toType, value);\n         }\n-    } else if (object instanceof Character) {\n+    }\n+    if (object instanceof Character) {\n         if (toType \u003d\u003d char.class) {\n             return object;\n         }\n-    } else if (object instanceof String) {\n+    }\n+    if (object instanceof String) {\n         Object value \u003d convertStringToPrimitive(object, toType);\n         if (value !\u003d null) {\n             return value;\n         }\n     }\n     Converter converter \u003d ConvertUtils.lookup(toType);\n     if (converter !\u003d null) {\n         return converter.convert(toType, object);\n     }\n     throw new JXPathTypeConversionException(\"Cannot convert \" + object.getClass() + \" to \" + toType);\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "c5808a90cd91bc01d78c7f3da8718b6dcf429fa0": {
      "type": "Ybodychange",
      "commitMessage": "Introduced specialized exceptions\n\ngit-svn-id: https://svn.apache.org/repos/asf/jakarta/commons/proper/jxpath/trunk@329481 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "10/29/05, 2:07 PM",
      "commitName": "c5808a90cd91bc01d78c7f3da8718b6dcf429fa0",
      "commitAuthor": "Dmitri Plotnikov",
      "commitDateOld": "2/26/05, 5:07 AM",
      "commitNameOld": "ecb571fc93e4a7bed9545a295c177d1ab4b1f4bf",
      "commitAuthorOld": "Dirk Verbeeck",
      "daysBetweenCommits": 245.33,
      "commitsBetweenForRepo": 11,
      "commitsBetweenForFile": 1,
      "actualSource": "public Object convert(Object object, Class toType) {\n    if (object \u003d\u003d null) {\n        if (toType.isPrimitive()) {\n            return convertNullToPrimitive(toType);\n        }\n        return null;\n    }\n    if (toType \u003d\u003d Object.class) {\n        if (object instanceof NodeSet) {\n            return convert(((NodeSet) object).getValues(), toType);\n        } else if (object instanceof Pointer) {\n            return convert(((Pointer) object).getValue(), toType);\n        }\n        return object;\n    }\n    Class fromType \u003d object.getClass();\n    if (fromType.equals(toType) || toType.isAssignableFrom(fromType)) {\n        return object;\n    }\n    if (fromType.isArray()) {\n        int length \u003d Array.getLength(object);\n        if (toType.isArray()) {\n            Class cType \u003d toType.getComponentType();\n            Object array \u003d Array.newInstance(cType, length);\n            for (int i \u003d 0; i \u003c length; i++) {\n                Object value \u003d Array.get(object, i);\n                Array.set(array, i, convert(value, cType));\n            }\n            return array;\n        } else if (Collection.class.isAssignableFrom(toType)) {\n            Collection collection \u003d allocateCollection(toType);\n            for (int i \u003d 0; i \u003c length; i++) {\n                collection.add(Array.get(object, i));\n            }\n            return unmodifiableCollection(collection);\n        } else {\n            if (length \u003e 0) {\n                Object value \u003d Array.get(object, 0);\n                return convert(value, toType);\n            } else {\n                return convert(\"\", toType);\n            }\n        }\n    } else if (object instanceof Collection) {\n        int length \u003d ((Collection) object).size();\n        if (toType.isArray()) {\n            Class cType \u003d toType.getComponentType();\n            Object array \u003d Array.newInstance(cType, length);\n            Iterator it \u003d ((Collection) object).iterator();\n            for (int i \u003d 0; i \u003c length; i++) {\n                Object value \u003d it.next();\n                Array.set(array, i, convert(value, cType));\n            }\n            return array;\n        } else if (Collection.class.isAssignableFrom(toType)) {\n            Collection collection \u003d allocateCollection(toType);\n            collection.addAll((Collection) object);\n            return unmodifiableCollection(collection);\n        } else {\n            if (length \u003e 0) {\n                Object value;\n                if (object instanceof List) {\n                    value \u003d ((List) object).get(0);\n                } else {\n                    Iterator it \u003d ((Collection) object).iterator();\n                    value \u003d it.next();\n                }\n                return convert(value, toType);\n            } else {\n                return convert(\"\", toType);\n            }\n        }\n    } else if (object instanceof NodeSet) {\n        return convert(((NodeSet) object).getValues(), toType);\n    } else if (object instanceof Pointer) {\n        return convert(((Pointer) object).getValue(), toType);\n    } else if (toType \u003d\u003d String.class) {\n        return object.toString();\n    } else if (object instanceof Boolean) {\n        if (toType \u003d\u003d boolean.class) {\n            return object;\n        }\n        boolean value \u003d ((Boolean) object).booleanValue();\n        return allocateNumber(toType, value ? 1 : 0);\n    } else if (object instanceof Number) {\n        double value \u003d ((Number) object).doubleValue();\n        if (toType \u003d\u003d boolean.class || toType \u003d\u003d Boolean.class) {\n            return value \u003d\u003d 0.0 ? Boolean.FALSE : Boolean.TRUE;\n        }\n        if (toType.isPrimitive() || Number.class.isAssignableFrom(toType)) {\n            return allocateNumber(toType, value);\n        }\n    } else if (object instanceof Character) {\n        if (toType \u003d\u003d char.class) {\n            return object;\n        }\n    } else if (object instanceof String) {\n        Object value \u003d convertStringToPrimitive(object, toType);\n        if (value !\u003d null) {\n            return value;\n        }\n    }\n    Converter converter \u003d ConvertUtils.lookup(toType);\n    if (converter !\u003d null) {\n        return converter.convert(toType, object);\n    }\n    throw new JXPathTypeConversionException(\"Cannot convert \" + object.getClass() + \" to \" + toType);\n}",
      "path": "src/java/org/apache/commons/jxpath/util/BasicTypeConverter.java",
      "functionStartLine": 174,
      "functionName": "convert",
      "functionAnnotation": "",
      "functionDoc": "Converts the supplied object to the specified\ntype. Throws a runtime exception if the conversion is\nnot possible.\n",
      "diff": "@@ -1,108 +1,108 @@\n public Object convert(Object object, Class toType) {\n     if (object \u003d\u003d null) {\n         if (toType.isPrimitive()) {\n             return convertNullToPrimitive(toType);\n         }\n         return null;\n     }\n     if (toType \u003d\u003d Object.class) {\n         if (object instanceof NodeSet) {\n             return convert(((NodeSet) object).getValues(), toType);\n         } else if (object instanceof Pointer) {\n             return convert(((Pointer) object).getValue(), toType);\n         }\n         return object;\n     }\n     Class fromType \u003d object.getClass();\n     if (fromType.equals(toType) || toType.isAssignableFrom(fromType)) {\n         return object;\n     }\n     if (fromType.isArray()) {\n         int length \u003d Array.getLength(object);\n         if (toType.isArray()) {\n             Class cType \u003d toType.getComponentType();\n             Object array \u003d Array.newInstance(cType, length);\n             for (int i \u003d 0; i \u003c length; i++) {\n                 Object value \u003d Array.get(object, i);\n                 Array.set(array, i, convert(value, cType));\n             }\n             return array;\n         } else if (Collection.class.isAssignableFrom(toType)) {\n             Collection collection \u003d allocateCollection(toType);\n             for (int i \u003d 0; i \u003c length; i++) {\n                 collection.add(Array.get(object, i));\n             }\n             return unmodifiableCollection(collection);\n         } else {\n             if (length \u003e 0) {\n                 Object value \u003d Array.get(object, 0);\n                 return convert(value, toType);\n             } else {\n                 return convert(\"\", toType);\n             }\n         }\n     } else if (object instanceof Collection) {\n         int length \u003d ((Collection) object).size();\n         if (toType.isArray()) {\n             Class cType \u003d toType.getComponentType();\n             Object array \u003d Array.newInstance(cType, length);\n             Iterator it \u003d ((Collection) object).iterator();\n             for (int i \u003d 0; i \u003c length; i++) {\n                 Object value \u003d it.next();\n                 Array.set(array, i, convert(value, cType));\n             }\n             return array;\n         } else if (Collection.class.isAssignableFrom(toType)) {\n             Collection collection \u003d allocateCollection(toType);\n             collection.addAll((Collection) object);\n             return unmodifiableCollection(collection);\n         } else {\n             if (length \u003e 0) {\n                 Object value;\n                 if (object instanceof List) {\n                     value \u003d ((List) object).get(0);\n                 } else {\n                     Iterator it \u003d ((Collection) object).iterator();\n                     value \u003d it.next();\n                 }\n                 return convert(value, toType);\n             } else {\n                 return convert(\"\", toType);\n             }\n         }\n     } else if (object instanceof NodeSet) {\n         return convert(((NodeSet) object).getValues(), toType);\n     } else if (object instanceof Pointer) {\n         return convert(((Pointer) object).getValue(), toType);\n     } else if (toType \u003d\u003d String.class) {\n         return object.toString();\n     } else if (object instanceof Boolean) {\n         if (toType \u003d\u003d boolean.class) {\n             return object;\n         }\n         boolean value \u003d ((Boolean) object).booleanValue();\n         return allocateNumber(toType, value ? 1 : 0);\n     } else if (object instanceof Number) {\n         double value \u003d ((Number) object).doubleValue();\n         if (toType \u003d\u003d boolean.class || toType \u003d\u003d Boolean.class) {\n             return value \u003d\u003d 0.0 ? Boolean.FALSE : Boolean.TRUE;\n         }\n         if (toType.isPrimitive() || Number.class.isAssignableFrom(toType)) {\n             return allocateNumber(toType, value);\n         }\n     } else if (object instanceof Character) {\n         if (toType \u003d\u003d char.class) {\n             return object;\n         }\n     } else if (object instanceof String) {\n         Object value \u003d convertStringToPrimitive(object, toType);\n         if (value !\u003d null) {\n             return value;\n         }\n     }\n     Converter converter \u003d ConvertUtils.lookup(toType);\n     if (converter !\u003d null) {\n         return converter.convert(toType, object);\n     }\n-    throw new RuntimeException(\"Cannot convert \" + object.getClass() + \" to \" + toType);\n+    throw new JXPathTypeConversionException(\"Cannot convert \" + object.getClass() + \" to \" + toType);\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "7b914c03b7c6f09844bc1a923f0f4b042193c79a": {
      "type": "Ybodychange",
      "commitMessage": "PR: 30272. Integration with ConverterUtils had a bug in it\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/jakarta/commons/proper/jxpath/trunk@136923 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "7/25/04, 6:16 AM",
      "commitName": "7b914c03b7c6f09844bc1a923f0f4b042193c79a",
      "commitAuthor": "Dmitri Plotnikov",
      "commitDateOld": "6/29/04, 2:50 PM",
      "commitNameOld": "9871c3f7a3db48cb9d627eb527d2adb58a692287",
      "commitAuthorOld": "Dmitri Plotnikov",
      "daysBetweenCommits": 25.64,
      "commitsBetweenForRepo": 10,
      "commitsBetweenForFile": 1,
      "actualSource": "public Object convert(Object object, Class toType) {\n    if (object \u003d\u003d null) {\n        if (toType.isPrimitive()) {\n            return convertNullToPrimitive(toType);\n        }\n        return null;\n    }\n    if (toType \u003d\u003d Object.class) {\n        if (object instanceof NodeSet) {\n            return convert(((NodeSet) object).getValues(), toType);\n        } else if (object instanceof Pointer) {\n            return convert(((Pointer) object).getValue(), toType);\n        }\n        return object;\n    }\n    Class fromType \u003d object.getClass();\n    if (fromType.equals(toType) || toType.isAssignableFrom(fromType)) {\n        return object;\n    }\n    if (fromType.isArray()) {\n        int length \u003d Array.getLength(object);\n        if (toType.isArray()) {\n            Class cType \u003d toType.getComponentType();\n            Object array \u003d Array.newInstance(cType, length);\n            for (int i \u003d 0; i \u003c length; i++) {\n                Object value \u003d Array.get(object, i);\n                Array.set(array, i, convert(value, cType));\n            }\n            return array;\n        } else if (Collection.class.isAssignableFrom(toType)) {\n            Collection collection \u003d allocateCollection(toType);\n            for (int i \u003d 0; i \u003c length; i++) {\n                collection.add(Array.get(object, i));\n            }\n            return unmodifiableCollection(collection);\n        } else {\n            if (length \u003e 0) {\n                Object value \u003d Array.get(object, 0);\n                return convert(value, toType);\n            } else {\n                return convert(\"\", toType);\n            }\n        }\n    } else if (object instanceof Collection) {\n        int length \u003d ((Collection) object).size();\n        if (toType.isArray()) {\n            Class cType \u003d toType.getComponentType();\n            Object array \u003d Array.newInstance(cType, length);\n            Iterator it \u003d ((Collection) object).iterator();\n            for (int i \u003d 0; i \u003c length; i++) {\n                Object value \u003d it.next();\n                Array.set(array, i, convert(value, cType));\n            }\n            return array;\n        } else if (Collection.class.isAssignableFrom(toType)) {\n            Collection collection \u003d allocateCollection(toType);\n            collection.addAll((Collection) object);\n            return unmodifiableCollection(collection);\n        } else {\n            if (length \u003e 0) {\n                Object value;\n                if (object instanceof List) {\n                    value \u003d ((List) object).get(0);\n                } else {\n                    Iterator it \u003d ((Collection) object).iterator();\n                    value \u003d it.next();\n                }\n                return convert(value, toType);\n            } else {\n                return convert(\"\", toType);\n            }\n        }\n    } else if (object instanceof NodeSet) {\n        return convert(((NodeSet) object).getValues(), toType);\n    } else if (object instanceof Pointer) {\n        return convert(((Pointer) object).getValue(), toType);\n    } else if (toType \u003d\u003d String.class) {\n        return object.toString();\n    } else if (object instanceof Boolean) {\n        if (toType \u003d\u003d boolean.class) {\n            return object;\n        }\n        boolean value \u003d ((Boolean) object).booleanValue();\n        return allocateNumber(toType, value ? 1 : 0);\n    } else if (object instanceof Number) {\n        double value \u003d ((Number) object).doubleValue();\n        if (toType \u003d\u003d boolean.class || toType \u003d\u003d Boolean.class) {\n            return value \u003d\u003d 0.0 ? Boolean.FALSE : Boolean.TRUE;\n        }\n        if (toType.isPrimitive() || Number.class.isAssignableFrom(toType)) {\n            return allocateNumber(toType, value);\n        }\n    } else if (object instanceof Character) {\n        if (toType \u003d\u003d char.class) {\n            return object;\n        }\n    } else if (object instanceof String) {\n        Object value \u003d convertStringToPrimitive(object, toType);\n        if (value !\u003d null) {\n            return value;\n        }\n    }\n    Converter converter \u003d ConvertUtils.lookup(toType);\n    if (converter !\u003d null) {\n        return converter.convert(toType, object);\n    }\n    throw new RuntimeException(\"Cannot convert \" + object.getClass() + \" to \" + toType);\n}",
      "path": "src/java/org/apache/commons/jxpath/util/BasicTypeConverter.java",
      "functionStartLine": 173,
      "functionName": "convert",
      "functionAnnotation": "",
      "functionDoc": "Converts the supplied object to the specified\ntype. Throws a runtime exception if the conversion is\nnot possible.\n",
      "diff": "@@ -1,107 +1,108 @@\n public Object convert(Object object, Class toType) {\n     if (object \u003d\u003d null) {\n         if (toType.isPrimitive()) {\n             return convertNullToPrimitive(toType);\n         }\n         return null;\n     }\n     if (toType \u003d\u003d Object.class) {\n         if (object instanceof NodeSet) {\n             return convert(((NodeSet) object).getValues(), toType);\n         } else if (object instanceof Pointer) {\n             return convert(((Pointer) object).getValue(), toType);\n         }\n         return object;\n     }\n     Class fromType \u003d object.getClass();\n     if (fromType.equals(toType) || toType.isAssignableFrom(fromType)) {\n         return object;\n     }\n     if (fromType.isArray()) {\n         int length \u003d Array.getLength(object);\n         if (toType.isArray()) {\n             Class cType \u003d toType.getComponentType();\n             Object array \u003d Array.newInstance(cType, length);\n             for (int i \u003d 0; i \u003c length; i++) {\n                 Object value \u003d Array.get(object, i);\n                 Array.set(array, i, convert(value, cType));\n             }\n             return array;\n         } else if (Collection.class.isAssignableFrom(toType)) {\n             Collection collection \u003d allocateCollection(toType);\n             for (int i \u003d 0; i \u003c length; i++) {\n                 collection.add(Array.get(object, i));\n             }\n             return unmodifiableCollection(collection);\n         } else {\n             if (length \u003e 0) {\n                 Object value \u003d Array.get(object, 0);\n                 return convert(value, toType);\n             } else {\n                 return convert(\"\", toType);\n             }\n         }\n     } else if (object instanceof Collection) {\n         int length \u003d ((Collection) object).size();\n         if (toType.isArray()) {\n             Class cType \u003d toType.getComponentType();\n             Object array \u003d Array.newInstance(cType, length);\n             Iterator it \u003d ((Collection) object).iterator();\n             for (int i \u003d 0; i \u003c length; i++) {\n                 Object value \u003d it.next();\n                 Array.set(array, i, convert(value, cType));\n             }\n             return array;\n         } else if (Collection.class.isAssignableFrom(toType)) {\n             Collection collection \u003d allocateCollection(toType);\n             collection.addAll((Collection) object);\n             return unmodifiableCollection(collection);\n         } else {\n             if (length \u003e 0) {\n                 Object value;\n                 if (object instanceof List) {\n                     value \u003d ((List) object).get(0);\n                 } else {\n                     Iterator it \u003d ((Collection) object).iterator();\n                     value \u003d it.next();\n                 }\n                 return convert(value, toType);\n             } else {\n                 return convert(\"\", toType);\n             }\n         }\n     } else if (object instanceof NodeSet) {\n         return convert(((NodeSet) object).getValues(), toType);\n     } else if (object instanceof Pointer) {\n         return convert(((Pointer) object).getValue(), toType);\n     } else if (toType \u003d\u003d String.class) {\n         return object.toString();\n     } else if (object instanceof Boolean) {\n         if (toType \u003d\u003d boolean.class) {\n             return object;\n         }\n         boolean value \u003d ((Boolean) object).booleanValue();\n         return allocateNumber(toType, value ? 1 : 0);\n     } else if (object instanceof Number) {\n         double value \u003d ((Number) object).doubleValue();\n         if (toType \u003d\u003d boolean.class || toType \u003d\u003d Boolean.class) {\n             return value \u003d\u003d 0.0 ? Boolean.FALSE : Boolean.TRUE;\n         }\n         if (toType.isPrimitive() || Number.class.isAssignableFrom(toType)) {\n             return allocateNumber(toType, value);\n         }\n     } else if (object instanceof Character) {\n         if (toType \u003d\u003d char.class) {\n             return object;\n         }\n     } else if (object instanceof String) {\n         Object value \u003d convertStringToPrimitive(object, toType);\n         if (value !\u003d null) {\n             return value;\n         }\n     }\n-    if (ConvertUtils.lookup(toType) !\u003d null) {\n-        return ConvertUtils.convert(object.toString(), toType);\n+    Converter converter \u003d ConvertUtils.lookup(toType);\n+    if (converter !\u003d null) {\n+        return converter.convert(toType, object);\n     }\n     throw new RuntimeException(\"Cannot convert \" + object.getClass() + \" to \" + toType);\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "9871c3f7a3db48cb9d627eb527d2adb58a692287": {
      "type": "Ybodychange",
      "commitMessage": "Integrated with BeanUtils ConverterUtils\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/jakarta/commons/proper/jxpath/trunk@136913 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "6/29/04, 2:50 PM",
      "commitName": "9871c3f7a3db48cb9d627eb527d2adb58a692287",
      "commitAuthor": "Dmitri Plotnikov",
      "commitDateOld": "3/24/04, 9:42 PM",
      "commitNameOld": "e7ecdaf5a2ea7c59b20edfbc92dfc31d6002945a",
      "commitAuthorOld": "Dmitri Plotnikov",
      "daysBetweenCommits": 96.67,
      "commitsBetweenForRepo": 11,
      "commitsBetweenForFile": 1,
      "actualSource": "public Object convert(Object object, Class toType) {\n    if (object \u003d\u003d null) {\n        if (toType.isPrimitive()) {\n            return convertNullToPrimitive(toType);\n        }\n        return null;\n    }\n    if (toType \u003d\u003d Object.class) {\n        if (object instanceof NodeSet) {\n            return convert(((NodeSet) object).getValues(), toType);\n        } else if (object instanceof Pointer) {\n            return convert(((Pointer) object).getValue(), toType);\n        }\n        return object;\n    }\n    Class fromType \u003d object.getClass();\n    if (fromType.equals(toType) || toType.isAssignableFrom(fromType)) {\n        return object;\n    }\n    if (fromType.isArray()) {\n        int length \u003d Array.getLength(object);\n        if (toType.isArray()) {\n            Class cType \u003d toType.getComponentType();\n            Object array \u003d Array.newInstance(cType, length);\n            for (int i \u003d 0; i \u003c length; i++) {\n                Object value \u003d Array.get(object, i);\n                Array.set(array, i, convert(value, cType));\n            }\n            return array;\n        } else if (Collection.class.isAssignableFrom(toType)) {\n            Collection collection \u003d allocateCollection(toType);\n            for (int i \u003d 0; i \u003c length; i++) {\n                collection.add(Array.get(object, i));\n            }\n            return unmodifiableCollection(collection);\n        } else {\n            if (length \u003e 0) {\n                Object value \u003d Array.get(object, 0);\n                return convert(value, toType);\n            } else {\n                return convert(\"\", toType);\n            }\n        }\n    } else if (object instanceof Collection) {\n        int length \u003d ((Collection) object).size();\n        if (toType.isArray()) {\n            Class cType \u003d toType.getComponentType();\n            Object array \u003d Array.newInstance(cType, length);\n            Iterator it \u003d ((Collection) object).iterator();\n            for (int i \u003d 0; i \u003c length; i++) {\n                Object value \u003d it.next();\n                Array.set(array, i, convert(value, cType));\n            }\n            return array;\n        } else if (Collection.class.isAssignableFrom(toType)) {\n            Collection collection \u003d allocateCollection(toType);\n            collection.addAll((Collection) object);\n            return unmodifiableCollection(collection);\n        } else {\n            if (length \u003e 0) {\n                Object value;\n                if (object instanceof List) {\n                    value \u003d ((List) object).get(0);\n                } else {\n                    Iterator it \u003d ((Collection) object).iterator();\n                    value \u003d it.next();\n                }\n                return convert(value, toType);\n            } else {\n                return convert(\"\", toType);\n            }\n        }\n    } else if (object instanceof NodeSet) {\n        return convert(((NodeSet) object).getValues(), toType);\n    } else if (object instanceof Pointer) {\n        return convert(((Pointer) object).getValue(), toType);\n    } else if (toType \u003d\u003d String.class) {\n        return object.toString();\n    } else if (object instanceof Boolean) {\n        if (toType \u003d\u003d boolean.class) {\n            return object;\n        }\n        boolean value \u003d ((Boolean) object).booleanValue();\n        return allocateNumber(toType, value ? 1 : 0);\n    } else if (object instanceof Number) {\n        double value \u003d ((Number) object).doubleValue();\n        if (toType \u003d\u003d boolean.class || toType \u003d\u003d Boolean.class) {\n            return value \u003d\u003d 0.0 ? Boolean.FALSE : Boolean.TRUE;\n        }\n        if (toType.isPrimitive() || Number.class.isAssignableFrom(toType)) {\n            return allocateNumber(toType, value);\n        }\n    } else if (object instanceof Character) {\n        if (toType \u003d\u003d char.class) {\n            return object;\n        }\n    } else if (object instanceof String) {\n        Object value \u003d convertStringToPrimitive(object, toType);\n        if (value !\u003d null) {\n            return value;\n        }\n    }\n    if (ConvertUtils.lookup(toType) !\u003d null) {\n        return ConvertUtils.convert(object.toString(), toType);\n    }\n    throw new RuntimeException(\"Cannot convert \" + object.getClass() + \" to \" + toType);\n}",
      "path": "src/java/org/apache/commons/jxpath/util/BasicTypeConverter.java",
      "functionStartLine": 172,
      "functionName": "convert",
      "functionAnnotation": "",
      "functionDoc": "Converts the supplied object to the specified\ntype. Throws a runtime exception if the conversion is\nnot possible.\n",
      "diff": "@@ -1,104 +1,107 @@\n public Object convert(Object object, Class toType) {\n     if (object \u003d\u003d null) {\n         if (toType.isPrimitive()) {\n             return convertNullToPrimitive(toType);\n         }\n         return null;\n     }\n     if (toType \u003d\u003d Object.class) {\n         if (object instanceof NodeSet) {\n             return convert(((NodeSet) object).getValues(), toType);\n         } else if (object instanceof Pointer) {\n             return convert(((Pointer) object).getValue(), toType);\n         }\n         return object;\n     }\n     Class fromType \u003d object.getClass();\n     if (fromType.equals(toType) || toType.isAssignableFrom(fromType)) {\n         return object;\n     }\n     if (fromType.isArray()) {\n         int length \u003d Array.getLength(object);\n         if (toType.isArray()) {\n             Class cType \u003d toType.getComponentType();\n             Object array \u003d Array.newInstance(cType, length);\n             for (int i \u003d 0; i \u003c length; i++) {\n                 Object value \u003d Array.get(object, i);\n                 Array.set(array, i, convert(value, cType));\n             }\n             return array;\n         } else if (Collection.class.isAssignableFrom(toType)) {\n             Collection collection \u003d allocateCollection(toType);\n             for (int i \u003d 0; i \u003c length; i++) {\n                 collection.add(Array.get(object, i));\n             }\n             return unmodifiableCollection(collection);\n         } else {\n             if (length \u003e 0) {\n                 Object value \u003d Array.get(object, 0);\n                 return convert(value, toType);\n             } else {\n                 return convert(\"\", toType);\n             }\n         }\n     } else if (object instanceof Collection) {\n         int length \u003d ((Collection) object).size();\n         if (toType.isArray()) {\n             Class cType \u003d toType.getComponentType();\n             Object array \u003d Array.newInstance(cType, length);\n             Iterator it \u003d ((Collection) object).iterator();\n             for (int i \u003d 0; i \u003c length; i++) {\n                 Object value \u003d it.next();\n                 Array.set(array, i, convert(value, cType));\n             }\n             return array;\n         } else if (Collection.class.isAssignableFrom(toType)) {\n             Collection collection \u003d allocateCollection(toType);\n             collection.addAll((Collection) object);\n             return unmodifiableCollection(collection);\n         } else {\n             if (length \u003e 0) {\n                 Object value;\n                 if (object instanceof List) {\n                     value \u003d ((List) object).get(0);\n                 } else {\n                     Iterator it \u003d ((Collection) object).iterator();\n                     value \u003d it.next();\n                 }\n                 return convert(value, toType);\n             } else {\n                 return convert(\"\", toType);\n             }\n         }\n     } else if (object instanceof NodeSet) {\n         return convert(((NodeSet) object).getValues(), toType);\n     } else if (object instanceof Pointer) {\n         return convert(((Pointer) object).getValue(), toType);\n     } else if (toType \u003d\u003d String.class) {\n         return object.toString();\n     } else if (object instanceof Boolean) {\n         if (toType \u003d\u003d boolean.class) {\n             return object;\n         }\n         boolean value \u003d ((Boolean) object).booleanValue();\n         return allocateNumber(toType, value ? 1 : 0);\n     } else if (object instanceof Number) {\n         double value \u003d ((Number) object).doubleValue();\n         if (toType \u003d\u003d boolean.class || toType \u003d\u003d Boolean.class) {\n             return value \u003d\u003d 0.0 ? Boolean.FALSE : Boolean.TRUE;\n         }\n         if (toType.isPrimitive() || Number.class.isAssignableFrom(toType)) {\n             return allocateNumber(toType, value);\n         }\n     } else if (object instanceof Character) {\n         if (toType \u003d\u003d char.class) {\n             return object;\n         }\n     } else if (object instanceof String) {\n         Object value \u003d convertStringToPrimitive(object, toType);\n         if (value !\u003d null) {\n             return value;\n         }\n     }\n+    if (ConvertUtils.lookup(toType) !\u003d null) {\n+        return ConvertUtils.convert(object.toString(), toType);\n+    }\n     throw new RuntimeException(\"Cannot convert \" + object.getClass() + \" to \" + toType);\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "e7ecdaf5a2ea7c59b20edfbc92dfc31d6002945a": {
      "type": "Ybodychange",
      "commitMessage": "Improved type conversion for extenstion functions\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/jakarta/commons/proper/jxpath/trunk@136902 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "3/24/04, 9:42 PM",
      "commitName": "e7ecdaf5a2ea7c59b20edfbc92dfc31d6002945a",
      "commitAuthor": "Dmitri Plotnikov",
      "commitDateOld": "2/29/04, 6:17 AM",
      "commitNameOld": "4fc265a938e1e9d13c407d4668ec8c864e85d799",
      "commitAuthorOld": "Stephen Colebourne",
      "daysBetweenCommits": 24.64,
      "commitsBetweenForRepo": 7,
      "commitsBetweenForFile": 1,
      "actualSource": "public Object convert(Object object, Class toType) {\n    if (object \u003d\u003d null) {\n        if (toType.isPrimitive()) {\n            return convertNullToPrimitive(toType);\n        }\n        return null;\n    }\n    if (toType \u003d\u003d Object.class) {\n        if (object instanceof NodeSet) {\n            return convert(((NodeSet) object).getValues(), toType);\n        } else if (object instanceof Pointer) {\n            return convert(((Pointer) object).getValue(), toType);\n        }\n        return object;\n    }\n    Class fromType \u003d object.getClass();\n    if (fromType.equals(toType) || toType.isAssignableFrom(fromType)) {\n        return object;\n    }\n    if (fromType.isArray()) {\n        int length \u003d Array.getLength(object);\n        if (toType.isArray()) {\n            Class cType \u003d toType.getComponentType();\n            Object array \u003d Array.newInstance(cType, length);\n            for (int i \u003d 0; i \u003c length; i++) {\n                Object value \u003d Array.get(object, i);\n                Array.set(array, i, convert(value, cType));\n            }\n            return array;\n        } else if (Collection.class.isAssignableFrom(toType)) {\n            Collection collection \u003d allocateCollection(toType);\n            for (int i \u003d 0; i \u003c length; i++) {\n                collection.add(Array.get(object, i));\n            }\n            return unmodifiableCollection(collection);\n        } else {\n            if (length \u003e 0) {\n                Object value \u003d Array.get(object, 0);\n                return convert(value, toType);\n            } else {\n                return convert(\"\", toType);\n            }\n        }\n    } else if (object instanceof Collection) {\n        int length \u003d ((Collection) object).size();\n        if (toType.isArray()) {\n            Class cType \u003d toType.getComponentType();\n            Object array \u003d Array.newInstance(cType, length);\n            Iterator it \u003d ((Collection) object).iterator();\n            for (int i \u003d 0; i \u003c length; i++) {\n                Object value \u003d it.next();\n                Array.set(array, i, convert(value, cType));\n            }\n            return array;\n        } else if (Collection.class.isAssignableFrom(toType)) {\n            Collection collection \u003d allocateCollection(toType);\n            collection.addAll((Collection) object);\n            return unmodifiableCollection(collection);\n        } else {\n            if (length \u003e 0) {\n                Object value;\n                if (object instanceof List) {\n                    value \u003d ((List) object).get(0);\n                } else {\n                    Iterator it \u003d ((Collection) object).iterator();\n                    value \u003d it.next();\n                }\n                return convert(value, toType);\n            } else {\n                return convert(\"\", toType);\n            }\n        }\n    } else if (object instanceof NodeSet) {\n        return convert(((NodeSet) object).getValues(), toType);\n    } else if (object instanceof Pointer) {\n        return convert(((Pointer) object).getValue(), toType);\n    } else if (toType \u003d\u003d String.class) {\n        return object.toString();\n    } else if (object instanceof Boolean) {\n        if (toType \u003d\u003d boolean.class) {\n            return object;\n        }\n        boolean value \u003d ((Boolean) object).booleanValue();\n        return allocateNumber(toType, value ? 1 : 0);\n    } else if (object instanceof Number) {\n        double value \u003d ((Number) object).doubleValue();\n        if (toType \u003d\u003d boolean.class || toType \u003d\u003d Boolean.class) {\n            return value \u003d\u003d 0.0 ? Boolean.FALSE : Boolean.TRUE;\n        }\n        if (toType.isPrimitive() || Number.class.isAssignableFrom(toType)) {\n            return allocateNumber(toType, value);\n        }\n    } else if (object instanceof Character) {\n        if (toType \u003d\u003d char.class) {\n            return object;\n        }\n    } else if (object instanceof String) {\n        Object value \u003d convertStringToPrimitive(object, toType);\n        if (value !\u003d null) {\n            return value;\n        }\n    }\n    throw new RuntimeException(\"Cannot convert \" + object.getClass() + \" to \" + toType);\n}",
      "path": "src/java/org/apache/commons/jxpath/util/BasicTypeConverter.java",
      "functionStartLine": 171,
      "functionName": "convert",
      "functionAnnotation": "",
      "functionDoc": "Converts the supplied object to the specified\ntype. Throws a runtime exception if the conversion is\nnot possible.\n",
      "diff": "@@ -1,99 +1,104 @@\n public Object convert(Object object, Class toType) {\n     if (object \u003d\u003d null) {\n         if (toType.isPrimitive()) {\n             return convertNullToPrimitive(toType);\n         }\n         return null;\n     }\n     if (toType \u003d\u003d Object.class) {\n+        if (object instanceof NodeSet) {\n+            return convert(((NodeSet) object).getValues(), toType);\n+        } else if (object instanceof Pointer) {\n+            return convert(((Pointer) object).getValue(), toType);\n+        }\n         return object;\n     }\n     Class fromType \u003d object.getClass();\n     if (fromType.equals(toType) || toType.isAssignableFrom(fromType)) {\n         return object;\n     }\n     if (fromType.isArray()) {\n         int length \u003d Array.getLength(object);\n         if (toType.isArray()) {\n             Class cType \u003d toType.getComponentType();\n             Object array \u003d Array.newInstance(cType, length);\n             for (int i \u003d 0; i \u003c length; i++) {\n                 Object value \u003d Array.get(object, i);\n                 Array.set(array, i, convert(value, cType));\n             }\n             return array;\n         } else if (Collection.class.isAssignableFrom(toType)) {\n             Collection collection \u003d allocateCollection(toType);\n             for (int i \u003d 0; i \u003c length; i++) {\n                 collection.add(Array.get(object, i));\n             }\n             return unmodifiableCollection(collection);\n         } else {\n             if (length \u003e 0) {\n                 Object value \u003d Array.get(object, 0);\n                 return convert(value, toType);\n             } else {\n                 return convert(\"\", toType);\n             }\n         }\n     } else if (object instanceof Collection) {\n         int length \u003d ((Collection) object).size();\n         if (toType.isArray()) {\n             Class cType \u003d toType.getComponentType();\n             Object array \u003d Array.newInstance(cType, length);\n             Iterator it \u003d ((Collection) object).iterator();\n             for (int i \u003d 0; i \u003c length; i++) {\n                 Object value \u003d it.next();\n                 Array.set(array, i, convert(value, cType));\n             }\n             return array;\n         } else if (Collection.class.isAssignableFrom(toType)) {\n             Collection collection \u003d allocateCollection(toType);\n             collection.addAll((Collection) object);\n             return unmodifiableCollection(collection);\n         } else {\n             if (length \u003e 0) {\n                 Object value;\n                 if (object instanceof List) {\n                     value \u003d ((List) object).get(0);\n                 } else {\n                     Iterator it \u003d ((Collection) object).iterator();\n                     value \u003d it.next();\n                 }\n                 return convert(value, toType);\n             } else {\n                 return convert(\"\", toType);\n             }\n         }\n     } else if (object instanceof NodeSet) {\n         return convert(((NodeSet) object).getValues(), toType);\n     } else if (object instanceof Pointer) {\n         return convert(((Pointer) object).getValue(), toType);\n     } else if (toType \u003d\u003d String.class) {\n         return object.toString();\n     } else if (object instanceof Boolean) {\n         if (toType \u003d\u003d boolean.class) {\n             return object;\n         }\n         boolean value \u003d ((Boolean) object).booleanValue();\n         return allocateNumber(toType, value ? 1 : 0);\n     } else if (object instanceof Number) {\n         double value \u003d ((Number) object).doubleValue();\n         if (toType \u003d\u003d boolean.class || toType \u003d\u003d Boolean.class) {\n             return value \u003d\u003d 0.0 ? Boolean.FALSE : Boolean.TRUE;\n         }\n         if (toType.isPrimitive() || Number.class.isAssignableFrom(toType)) {\n             return allocateNumber(toType, value);\n         }\n     } else if (object instanceof Character) {\n         if (toType \u003d\u003d char.class) {\n             return object;\n         }\n     } else if (object instanceof String) {\n         Object value \u003d convertStringToPrimitive(object, toType);\n         if (value !\u003d null) {\n             return value;\n         }\n     }\n     throw new RuntimeException(\"Cannot convert \" + object.getClass() + \" to \" + toType);\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "77af585d9f0e629db4ecf8d468ef7b71c9d98e39": {
      "type": "Ybodychange",
      "commitMessage": "Fixed collection as return value of extension function\nReduced the amount of cloning\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/jakarta/commons/proper/jxpath/trunk@136860 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "3/24/03, 6:41 PM",
      "commitName": "77af585d9f0e629db4ecf8d468ef7b71c9d98e39",
      "commitAuthor": "Dmitri Plotnikov",
      "commitDateOld": "3/10/03, 4:59 PM",
      "commitNameOld": "bdf423f27a76d2006ffe1058d6530eebf619c877",
      "commitAuthorOld": "Dmitri Plotnikov",
      "daysBetweenCommits": 14.07,
      "commitsBetweenForRepo": 3,
      "commitsBetweenForFile": 1,
      "actualSource": "public Object convert(Object object, Class toType) {\n    if (object \u003d\u003d null) {\n        if (toType.isPrimitive()) {\n            return convertNullToPrimitive(toType);\n        }\n        return null;\n    }\n    if (toType \u003d\u003d Object.class) {\n        return object;\n    }\n    Class fromType \u003d object.getClass();\n    if (fromType.equals(toType) || toType.isAssignableFrom(fromType)) {\n        return object;\n    }\n    if (fromType.isArray()) {\n        int length \u003d Array.getLength(object);\n        if (toType.isArray()) {\n            Class cType \u003d toType.getComponentType();\n            Object array \u003d Array.newInstance(cType, length);\n            for (int i \u003d 0; i \u003c length; i++) {\n                Object value \u003d Array.get(object, i);\n                Array.set(array, i, convert(value, cType));\n            }\n            return array;\n        } else if (Collection.class.isAssignableFrom(toType)) {\n            Collection collection \u003d allocateCollection(toType);\n            for (int i \u003d 0; i \u003c length; i++) {\n                collection.add(Array.get(object, i));\n            }\n            return unmodifiableCollection(collection);\n        } else {\n            if (length \u003e 0) {\n                Object value \u003d Array.get(object, 0);\n                return convert(value, toType);\n            } else {\n                return convert(\"\", toType);\n            }\n        }\n    } else if (object instanceof Collection) {\n        int length \u003d ((Collection) object).size();\n        if (toType.isArray()) {\n            Class cType \u003d toType.getComponentType();\n            Object array \u003d Array.newInstance(cType, length);\n            Iterator it \u003d ((Collection) object).iterator();\n            for (int i \u003d 0; i \u003c length; i++) {\n                Object value \u003d it.next();\n                Array.set(array, i, convert(value, cType));\n            }\n            return array;\n        } else if (Collection.class.isAssignableFrom(toType)) {\n            Collection collection \u003d allocateCollection(toType);\n            collection.addAll((Collection) object);\n            return unmodifiableCollection(collection);\n        } else {\n            if (length \u003e 0) {\n                Object value;\n                if (object instanceof List) {\n                    value \u003d ((List) object).get(0);\n                } else {\n                    Iterator it \u003d ((Collection) object).iterator();\n                    value \u003d it.next();\n                }\n                return convert(value, toType);\n            } else {\n                return convert(\"\", toType);\n            }\n        }\n    } else if (object instanceof NodeSet) {\n        return convert(((NodeSet) object).getValues(), toType);\n    } else if (object instanceof Pointer) {\n        return convert(((Pointer) object).getValue(), toType);\n    } else if (toType \u003d\u003d String.class) {\n        return object.toString();\n    } else if (object instanceof Boolean) {\n        if (toType \u003d\u003d boolean.class) {\n            return object;\n        }\n        boolean value \u003d ((Boolean) object).booleanValue();\n        return allocateNumber(toType, value ? 1 : 0);\n    } else if (object instanceof Number) {\n        double value \u003d ((Number) object).doubleValue();\n        if (toType \u003d\u003d boolean.class || toType \u003d\u003d Boolean.class) {\n            return value \u003d\u003d 0.0 ? Boolean.FALSE : Boolean.TRUE;\n        }\n        if (toType.isPrimitive() || Number.class.isAssignableFrom(toType)) {\n            return allocateNumber(toType, value);\n        }\n    } else if (object instanceof Character) {\n        if (toType \u003d\u003d char.class) {\n            return object;\n        }\n    } else if (object instanceof String) {\n        Object value \u003d convertStringToPrimitive(object, toType);\n        if (value !\u003d null) {\n            return value;\n        }\n    }\n    throw new RuntimeException(\"Cannot convert \" + object.getClass() + \" to \" + toType);\n}",
      "path": "src/java/org/apache/commons/jxpath/util/BasicTypeConverter.java",
      "functionStartLine": 217,
      "functionName": "convert",
      "functionAnnotation": "",
      "functionDoc": "Converts the supplied object to the specified\ntype. Throws a runtime exception if the conversion is\nnot possible.\n",
      "diff": "@@ -1,94 +1,99 @@\n public Object convert(Object object, Class toType) {\n     if (object \u003d\u003d null) {\n         if (toType.isPrimitive()) {\n             return convertNullToPrimitive(toType);\n         }\n         return null;\n     }\n     if (toType \u003d\u003d Object.class) {\n         return object;\n     }\n     Class fromType \u003d object.getClass();\n     if (fromType.equals(toType) || toType.isAssignableFrom(fromType)) {\n         return object;\n     }\n-    if (toType \u003d\u003d String.class) {\n+    if (fromType.isArray()) {\n+        int length \u003d Array.getLength(object);\n+        if (toType.isArray()) {\n+            Class cType \u003d toType.getComponentType();\n+            Object array \u003d Array.newInstance(cType, length);\n+            for (int i \u003d 0; i \u003c length; i++) {\n+                Object value \u003d Array.get(object, i);\n+                Array.set(array, i, convert(value, cType));\n+            }\n+            return array;\n+        } else if (Collection.class.isAssignableFrom(toType)) {\n+            Collection collection \u003d allocateCollection(toType);\n+            for (int i \u003d 0; i \u003c length; i++) {\n+                collection.add(Array.get(object, i));\n+            }\n+            return unmodifiableCollection(collection);\n+        } else {\n+            if (length \u003e 0) {\n+                Object value \u003d Array.get(object, 0);\n+                return convert(value, toType);\n+            } else {\n+                return convert(\"\", toType);\n+            }\n+        }\n+    } else if (object instanceof Collection) {\n+        int length \u003d ((Collection) object).size();\n+        if (toType.isArray()) {\n+            Class cType \u003d toType.getComponentType();\n+            Object array \u003d Array.newInstance(cType, length);\n+            Iterator it \u003d ((Collection) object).iterator();\n+            for (int i \u003d 0; i \u003c length; i++) {\n+                Object value \u003d it.next();\n+                Array.set(array, i, convert(value, cType));\n+            }\n+            return array;\n+        } else if (Collection.class.isAssignableFrom(toType)) {\n+            Collection collection \u003d allocateCollection(toType);\n+            collection.addAll((Collection) object);\n+            return unmodifiableCollection(collection);\n+        } else {\n+            if (length \u003e 0) {\n+                Object value;\n+                if (object instanceof List) {\n+                    value \u003d ((List) object).get(0);\n+                } else {\n+                    Iterator it \u003d ((Collection) object).iterator();\n+                    value \u003d it.next();\n+                }\n+                return convert(value, toType);\n+            } else {\n+                return convert(\"\", toType);\n+            }\n+        }\n+    } else if (object instanceof NodeSet) {\n+        return convert(((NodeSet) object).getValues(), toType);\n+    } else if (object instanceof Pointer) {\n+        return convert(((Pointer) object).getValue(), toType);\n+    } else if (toType \u003d\u003d String.class) {\n         return object.toString();\n-    }\n-    if (object instanceof Boolean) {\n+    } else if (object instanceof Boolean) {\n         if (toType \u003d\u003d boolean.class) {\n             return object;\n         }\n         boolean value \u003d ((Boolean) object).booleanValue();\n         return allocateNumber(toType, value ? 1 : 0);\n     } else if (object instanceof Number) {\n         double value \u003d ((Number) object).doubleValue();\n         if (toType \u003d\u003d boolean.class || toType \u003d\u003d Boolean.class) {\n             return value \u003d\u003d 0.0 ? Boolean.FALSE : Boolean.TRUE;\n         }\n         if (toType.isPrimitive() || Number.class.isAssignableFrom(toType)) {\n             return allocateNumber(toType, value);\n         }\n     } else if (object instanceof Character) {\n         if (toType \u003d\u003d char.class) {\n             return object;\n         }\n     } else if (object instanceof String) {\n         Object value \u003d convertStringToPrimitive(object, toType);\n         if (value !\u003d null) {\n             return value;\n         }\n-    } else if (fromType.isArray()) {\n-        int length \u003d Array.getLength(object);\n-        if (toType.isArray()) {\n-            Class cType \u003d toType.getComponentType();\n-            Object array \u003d Array.newInstance(cType, length);\n-            for (int i \u003d 0; i \u003c length; i++) {\n-                Object value \u003d Array.get(object, i);\n-                Array.set(array, i, convert(value, cType));\n-            }\n-            return array;\n-        } else if (Collection.class.isAssignableFrom(toType)) {\n-            Collection collection \u003d allocateCollection(toType);\n-            for (int i \u003d 0; i \u003c length; i++) {\n-                collection.add(Array.get(object, i));\n-            }\n-            return unmodifiableCollection(collection);\n-        } else if (length \u003d\u003d 1) {\n-            Object value \u003d Array.get(object, 0);\n-            return convert(value, toType);\n-        }\n-    } else if (object instanceof Collection) {\n-        int length \u003d ((Collection) object).size();\n-        if (toType.isArray()) {\n-            Class cType \u003d toType.getComponentType();\n-            Object array \u003d Array.newInstance(cType, length);\n-            Iterator it \u003d ((Collection) object).iterator();\n-            for (int i \u003d 0; i \u003c length; i++) {\n-                Object value \u003d it.next();\n-                Array.set(array, i, convert(value, cType));\n-            }\n-            return array;\n-        } else if (Collection.class.isAssignableFrom(toType)) {\n-            Collection collection \u003d allocateCollection(toType);\n-            collection.addAll((Collection) object);\n-            return unmodifiableCollection(collection);\n-        } else if (length \u003d\u003d 1) {\n-            Object value;\n-            if (object instanceof List) {\n-                value \u003d ((List) object).get(0);\n-            } else {\n-                Iterator it \u003d ((Collection) object).iterator();\n-                value \u003d it.next();\n-            }\n-            return convert(value, toType);\n-        } else {\n-            throw new RuntimeException(\"Cannot convert collection to \" + toType + \", it contains \" + length + \" elements\");\n-        }\n-    } else if (object instanceof NodeSet) {\n-        return convert(((NodeSet) object).getValues(), toType);\n-    } else if (object instanceof Pointer) {\n-        return convert(((Pointer) object).getValue(), toType);\n     }\n     throw new RuntimeException(\"Cannot convert \" + object.getClass() + \" to \" + toType);\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "4ab5b9e453d0e0ef51fc1d36a5e21aaf21b44c81": {
      "type": "Ybodychange",
      "commitMessage": "Improved handling of collections as arguments of extension functions\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/jakarta/commons/proper/jxpath/trunk@136850 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "2/6/03, 4:51 PM",
      "commitName": "4ab5b9e453d0e0ef51fc1d36a5e21aaf21b44c81",
      "commitAuthor": "Dmitri Plotnikov",
      "commitDateOld": "1/29/03, 9:55 AM",
      "commitNameOld": "348acabaadc57e04f25de5c79c72bc34a4e41723",
      "commitAuthorOld": "Dmitri Plotnikov",
      "daysBetweenCommits": 8.29,
      "commitsBetweenForRepo": 4,
      "commitsBetweenForFile": 1,
      "actualSource": "public Object convert(Object object, Class toType) {\n    if (object \u003d\u003d null) {\n        if (toType.isPrimitive()) {\n            return convertNullToPrimitive(toType);\n        }\n        return null;\n    }\n    if (toType \u003d\u003d Object.class) {\n        return object;\n    }\n    Class fromType \u003d object.getClass();\n    if (fromType.equals(toType) || toType.isAssignableFrom(fromType)) {\n        return object;\n    }\n    if (toType \u003d\u003d String.class) {\n        return object.toString();\n    }\n    if (object instanceof Boolean) {\n        if (toType \u003d\u003d boolean.class) {\n            return object;\n        }\n        boolean value \u003d ((Boolean) object).booleanValue();\n        return allocateNumber(toType, value ? 1 : 0);\n    } else if (object instanceof Number) {\n        double value \u003d ((Number) object).doubleValue();\n        if (toType \u003d\u003d boolean.class || toType \u003d\u003d Boolean.class) {\n            return value \u003d\u003d 0.0 ? Boolean.FALSE : Boolean.TRUE;\n        }\n        if (toType.isPrimitive() || Number.class.isAssignableFrom(toType)) {\n            return allocateNumber(toType, value);\n        }\n    } else if (object instanceof Character) {\n        if (toType \u003d\u003d char.class) {\n            return object;\n        }\n    } else if (object instanceof String) {\n        Object value \u003d convertStringToPrimitive(object, toType);\n        if (value !\u003d null) {\n            return value;\n        }\n    } else if (fromType.isArray()) {\n        int length \u003d Array.getLength(object);\n        if (toType.isArray()) {\n            Class cType \u003d toType.getComponentType();\n            Object array \u003d Array.newInstance(cType, length);\n            for (int i \u003d 0; i \u003c length; i++) {\n                Object value \u003d Array.get(object, i);\n                Array.set(array, i, convert(value, cType));\n            }\n            return array;\n        } else if (Collection.class.isAssignableFrom(toType)) {\n            Collection collection \u003d allocateCollection(toType);\n            for (int i \u003d 0; i \u003c length; i++) {\n                collection.add(Array.get(object, i));\n            }\n            return unmodifiableCollection(collection);\n        } else if (length \u003d\u003d 1) {\n            Object value \u003d Array.get(object, 0);\n            return convert(value, toType);\n        }\n    } else if (object instanceof Collection) {\n        int length \u003d ((Collection) object).size();\n        if (toType.isArray()) {\n            Class cType \u003d toType.getComponentType();\n            Object array \u003d Array.newInstance(cType, length);\n            Iterator it \u003d ((Collection) object).iterator();\n            for (int i \u003d 0; i \u003c length; i++) {\n                Object value \u003d it.next();\n                Array.set(array, i, convert(value, cType));\n            }\n            return array;\n        } else if (Collection.class.isAssignableFrom(toType)) {\n            Collection collection \u003d allocateCollection(toType);\n            collection.addAll((Collection) object);\n            return unmodifiableCollection(collection);\n        } else if (length \u003d\u003d 1) {\n            Object value;\n            if (object instanceof List) {\n                value \u003d ((List) object).get(0);\n            } else {\n                Iterator it \u003d ((Collection) object).iterator();\n                value \u003d it.next();\n            }\n            return convert(value, toType);\n        } else {\n            throw new RuntimeException(\"Cannot convert collection to \" + toType + \", it contains \" + length + \" elements\");\n        }\n    } else if (object instanceof NodeSet) {\n        return convert(((NodeSet) object).getValues(), toType);\n    } else if (object instanceof Pointer) {\n        return convert(((Pointer) object).getValue(), toType);\n    }\n    throw new RuntimeException(\"Cannot convert \" + object.getClass() + \" to \" + toType);\n}",
      "path": "src/java/org/apache/commons/jxpath/util/BasicTypeConverter.java",
      "functionStartLine": 206,
      "functionName": "convert",
      "functionAnnotation": "",
      "functionDoc": "Converts the supplied object to the specified\ntype. Throws a runtime exception if the conversion is\nnot possible.\n",
      "diff": "@@ -1,92 +1,94 @@\n public Object convert(Object object, Class toType) {\n     if (object \u003d\u003d null) {\n         if (toType.isPrimitive()) {\n             return convertNullToPrimitive(toType);\n         }\n         return null;\n     }\n     if (toType \u003d\u003d Object.class) {\n         return object;\n     }\n     Class fromType \u003d object.getClass();\n     if (fromType.equals(toType) || toType.isAssignableFrom(fromType)) {\n         return object;\n     }\n     if (toType \u003d\u003d String.class) {\n         return object.toString();\n     }\n     if (object instanceof Boolean) {\n         if (toType \u003d\u003d boolean.class) {\n             return object;\n         }\n         boolean value \u003d ((Boolean) object).booleanValue();\n         return allocateNumber(toType, value ? 1 : 0);\n     } else if (object instanceof Number) {\n         double value \u003d ((Number) object).doubleValue();\n         if (toType \u003d\u003d boolean.class || toType \u003d\u003d Boolean.class) {\n             return value \u003d\u003d 0.0 ? Boolean.FALSE : Boolean.TRUE;\n         }\n         if (toType.isPrimitive() || Number.class.isAssignableFrom(toType)) {\n             return allocateNumber(toType, value);\n         }\n     } else if (object instanceof Character) {\n         if (toType \u003d\u003d char.class) {\n             return object;\n         }\n     } else if (object instanceof String) {\n         Object value \u003d convertStringToPrimitive(object, toType);\n         if (value !\u003d null) {\n             return value;\n         }\n     } else if (fromType.isArray()) {\n         int length \u003d Array.getLength(object);\n         if (toType.isArray()) {\n             Class cType \u003d toType.getComponentType();\n             Object array \u003d Array.newInstance(cType, length);\n             for (int i \u003d 0; i \u003c length; i++) {\n                 Object value \u003d Array.get(object, i);\n                 Array.set(array, i, convert(value, cType));\n             }\n             return array;\n         } else if (Collection.class.isAssignableFrom(toType)) {\n             Collection collection \u003d allocateCollection(toType);\n             for (int i \u003d 0; i \u003c length; i++) {\n                 collection.add(Array.get(object, i));\n             }\n-            return collection;\n+            return unmodifiableCollection(collection);\n         } else if (length \u003d\u003d 1) {\n             Object value \u003d Array.get(object, 0);\n             return convert(value, toType);\n         }\n     } else if (object instanceof Collection) {\n         int length \u003d ((Collection) object).size();\n         if (toType.isArray()) {\n             Class cType \u003d toType.getComponentType();\n             Object array \u003d Array.newInstance(cType, length);\n             Iterator it \u003d ((Collection) object).iterator();\n             for (int i \u003d 0; i \u003c length; i++) {\n                 Object value \u003d it.next();\n                 Array.set(array, i, convert(value, cType));\n             }\n             return array;\n         } else if (Collection.class.isAssignableFrom(toType)) {\n             Collection collection \u003d allocateCollection(toType);\n             collection.addAll((Collection) object);\n-            return collection;\n+            return unmodifiableCollection(collection);\n         } else if (length \u003d\u003d 1) {\n             Object value;\n             if (object instanceof List) {\n                 value \u003d ((List) object).get(0);\n             } else {\n                 Iterator it \u003d ((Collection) object).iterator();\n                 value \u003d it.next();\n             }\n             return convert(value, toType);\n         } else {\n             throw new RuntimeException(\"Cannot convert collection to \" + toType + \", it contains \" + length + \" elements\");\n         }\n+    } else if (object instanceof NodeSet) {\n+        return convert(((NodeSet) object).getValues(), toType);\n     } else if (object instanceof Pointer) {\n         return convert(((Pointer) object).getValue(), toType);\n     }\n     throw new RuntimeException(\"Cannot convert \" + object.getClass() + \" to \" + toType);\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "348acabaadc57e04f25de5c79c72bc34a4e41723": {
      "type": "Ybodychange",
      "commitMessage": "Fixed type conversion issues with extension functions\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/jakarta/commons/proper/jxpath/trunk@136845 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "1/29/03, 9:55 AM",
      "commitName": "348acabaadc57e04f25de5c79c72bc34a4e41723",
      "commitAuthor": "Dmitri Plotnikov",
      "commitDateOld": "1/10/03, 9:41 PM",
      "commitNameOld": "2327c42440cd4927ac5fc91ed93756cb0c87c96d",
      "commitAuthorOld": "Dmitri Plotnikov",
      "daysBetweenCommits": 18.51,
      "commitsBetweenForRepo": 11,
      "commitsBetweenForFile": 1,
      "actualSource": "public Object convert(Object object, Class toType) {\n    if (object \u003d\u003d null) {\n        if (toType.isPrimitive()) {\n            return convertNullToPrimitive(toType);\n        }\n        return null;\n    }\n    if (toType \u003d\u003d Object.class) {\n        return object;\n    }\n    Class fromType \u003d object.getClass();\n    if (fromType.equals(toType) || toType.isAssignableFrom(fromType)) {\n        return object;\n    }\n    if (toType \u003d\u003d String.class) {\n        return object.toString();\n    }\n    if (object instanceof Boolean) {\n        if (toType \u003d\u003d boolean.class) {\n            return object;\n        }\n        boolean value \u003d ((Boolean) object).booleanValue();\n        return allocateNumber(toType, value ? 1 : 0);\n    } else if (object instanceof Number) {\n        double value \u003d ((Number) object).doubleValue();\n        if (toType \u003d\u003d boolean.class || toType \u003d\u003d Boolean.class) {\n            return value \u003d\u003d 0.0 ? Boolean.FALSE : Boolean.TRUE;\n        }\n        if (toType.isPrimitive() || Number.class.isAssignableFrom(toType)) {\n            return allocateNumber(toType, value);\n        }\n    } else if (object instanceof Character) {\n        if (toType \u003d\u003d char.class) {\n            return object;\n        }\n    } else if (object instanceof String) {\n        Object value \u003d convertStringToPrimitive(object, toType);\n        if (value !\u003d null) {\n            return value;\n        }\n    } else if (fromType.isArray()) {\n        int length \u003d Array.getLength(object);\n        if (toType.isArray()) {\n            Class cType \u003d toType.getComponentType();\n            Object array \u003d Array.newInstance(cType, length);\n            for (int i \u003d 0; i \u003c length; i++) {\n                Object value \u003d Array.get(object, i);\n                Array.set(array, i, convert(value, cType));\n            }\n            return array;\n        } else if (Collection.class.isAssignableFrom(toType)) {\n            Collection collection \u003d allocateCollection(toType);\n            for (int i \u003d 0; i \u003c length; i++) {\n                collection.add(Array.get(object, i));\n            }\n            return collection;\n        } else if (length \u003d\u003d 1) {\n            Object value \u003d Array.get(object, 0);\n            return convert(value, toType);\n        }\n    } else if (object instanceof Collection) {\n        int length \u003d ((Collection) object).size();\n        if (toType.isArray()) {\n            Class cType \u003d toType.getComponentType();\n            Object array \u003d Array.newInstance(cType, length);\n            Iterator it \u003d ((Collection) object).iterator();\n            for (int i \u003d 0; i \u003c length; i++) {\n                Object value \u003d it.next();\n                Array.set(array, i, convert(value, cType));\n            }\n            return array;\n        } else if (Collection.class.isAssignableFrom(toType)) {\n            Collection collection \u003d allocateCollection(toType);\n            collection.addAll((Collection) object);\n            return collection;\n        } else if (length \u003d\u003d 1) {\n            Object value;\n            if (object instanceof List) {\n                value \u003d ((List) object).get(0);\n            } else {\n                Iterator it \u003d ((Collection) object).iterator();\n                value \u003d it.next();\n            }\n            return convert(value, toType);\n        } else {\n            throw new RuntimeException(\"Cannot convert collection to \" + toType + \", it contains \" + length + \" elements\");\n        }\n    } else if (object instanceof Pointer) {\n        return convert(((Pointer) object).getValue(), toType);\n    }\n    throw new RuntimeException(\"Cannot convert \" + object.getClass() + \" to \" + toType);\n}",
      "path": "src/java/org/apache/commons/jxpath/util/BasicTypeConverter.java",
      "functionStartLine": 196,
      "functionName": "convert",
      "functionAnnotation": "",
      "functionDoc": "Converts the supplied object to the specified\ntype. Throws a runtime exception if the conversion is\nnot possible.\n",
      "diff": "@@ -1,110 +1,92 @@\n public Object convert(Object object, Class toType) {\n     if (object \u003d\u003d null) {\n         if (toType.isPrimitive()) {\n             return convertNullToPrimitive(toType);\n         }\n         return null;\n     }\n     if (toType \u003d\u003d Object.class) {\n         return object;\n     }\n-    if (object instanceof ExpressionContext) {\n-        if (Collection.class.isAssignableFrom(toType)) {\n-            List list \u003d ((ExpressionContext) object).getContextNodeList();\n-            Collection result \u003d new ArrayList();\n-            if (toType \u003d\u003d List.class || toType \u003d\u003d ArrayList.class) {\n-                result \u003d new ArrayList();\n-            } else if (toType \u003d\u003d Vector.class) {\n-                result \u003d new Vector();\n-            } else if (toType \u003d\u003d Set.class || toType \u003d\u003d HashSet.class) {\n-                result \u003d new HashSet();\n-            }\n-            int count \u003d list.size();\n-            for (int i \u003d 0; i \u003c count; i++) {\n-                Pointer ptr \u003d (Pointer) list.get(i);\n-                result.add(ptr.getValue());\n-            }\n-            return result;\n-        } else {\n-            Object value \u003d ((ExpressionContext) object).getContextNodePointer().getValue();\n-            return convert(value, toType);\n-        }\n-    }\n     Class fromType \u003d object.getClass();\n     if (fromType.equals(toType) || toType.isAssignableFrom(fromType)) {\n         return object;\n     }\n     if (toType \u003d\u003d String.class) {\n         return object.toString();\n     }\n     if (object instanceof Boolean) {\n         if (toType \u003d\u003d boolean.class) {\n             return object;\n         }\n         boolean value \u003d ((Boolean) object).booleanValue();\n         return allocateNumber(toType, value ? 1 : 0);\n     } else if (object instanceof Number) {\n         double value \u003d ((Number) object).doubleValue();\n         if (toType \u003d\u003d boolean.class || toType \u003d\u003d Boolean.class) {\n             return value \u003d\u003d 0.0 ? Boolean.FALSE : Boolean.TRUE;\n         }\n         if (toType.isPrimitive() || Number.class.isAssignableFrom(toType)) {\n             return allocateNumber(toType, value);\n         }\n     } else if (object instanceof Character) {\n         if (toType \u003d\u003d char.class) {\n             return object;\n         }\n     } else if (object instanceof String) {\n         Object value \u003d convertStringToPrimitive(object, toType);\n         if (value !\u003d null) {\n             return value;\n         }\n     } else if (fromType.isArray()) {\n         int length \u003d Array.getLength(object);\n         if (toType.isArray()) {\n             Class cType \u003d toType.getComponentType();\n             Object array \u003d Array.newInstance(cType, length);\n             for (int i \u003d 0; i \u003c length; i++) {\n                 Object value \u003d Array.get(object, i);\n                 Array.set(array, i, convert(value, cType));\n             }\n             return array;\n         } else if (Collection.class.isAssignableFrom(toType)) {\n             Collection collection \u003d allocateCollection(toType);\n             for (int i \u003d 0; i \u003c length; i++) {\n                 collection.add(Array.get(object, i));\n             }\n             return collection;\n         } else if (length \u003d\u003d 1) {\n             Object value \u003d Array.get(object, 0);\n             return convert(value, toType);\n         }\n     } else if (object instanceof Collection) {\n         int length \u003d ((Collection) object).size();\n         if (toType.isArray()) {\n             Class cType \u003d toType.getComponentType();\n             Object array \u003d Array.newInstance(cType, length);\n             Iterator it \u003d ((Collection) object).iterator();\n             for (int i \u003d 0; i \u003c length; i++) {\n                 Object value \u003d it.next();\n                 Array.set(array, i, convert(value, cType));\n             }\n             return array;\n         } else if (Collection.class.isAssignableFrom(toType)) {\n             Collection collection \u003d allocateCollection(toType);\n             collection.addAll((Collection) object);\n             return collection;\n         } else if (length \u003d\u003d 1) {\n             Object value;\n             if (object instanceof List) {\n                 value \u003d ((List) object).get(0);\n             } else {\n                 Iterator it \u003d ((Collection) object).iterator();\n                 value \u003d it.next();\n             }\n             return convert(value, toType);\n+        } else {\n+            throw new RuntimeException(\"Cannot convert collection to \" + toType + \", it contains \" + length + \" elements\");\n         }\n+    } else if (object instanceof Pointer) {\n+        return convert(((Pointer) object).getValue(), toType);\n     }\n     throw new RuntimeException(\"Cannot convert \" + object.getClass() + \" to \" + toType);\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "2327c42440cd4927ac5fc91ed93756cb0c87c96d": {
      "type": "Ybodychange",
      "commitMessage": "Checkstyle, be happy!\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/jakarta/commons/proper/jxpath/trunk@136834 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "1/10/03, 9:41 PM",
      "commitName": "2327c42440cd4927ac5fc91ed93756cb0c87c96d",
      "commitAuthor": "Dmitri Plotnikov",
      "commitDateOld": "6/15/02, 8:22 PM",
      "commitNameOld": "ab914f400352a3a525ba0a5d189eb2e4e1ade268",
      "commitAuthorOld": "Dmitri Plotnikov",
      "daysBetweenCommits": 209.1,
      "commitsBetweenForRepo": 65,
      "commitsBetweenForFile": 1,
      "actualSource": "public Object convert(Object object, Class toType) {\n    if (object \u003d\u003d null) {\n        if (toType.isPrimitive()) {\n            return convertNullToPrimitive(toType);\n        }\n        return null;\n    }\n    if (toType \u003d\u003d Object.class) {\n        return object;\n    }\n    if (object instanceof ExpressionContext) {\n        if (Collection.class.isAssignableFrom(toType)) {\n            List list \u003d ((ExpressionContext) object).getContextNodeList();\n            Collection result \u003d new ArrayList();\n            if (toType \u003d\u003d List.class || toType \u003d\u003d ArrayList.class) {\n                result \u003d new ArrayList();\n            } else if (toType \u003d\u003d Vector.class) {\n                result \u003d new Vector();\n            } else if (toType \u003d\u003d Set.class || toType \u003d\u003d HashSet.class) {\n                result \u003d new HashSet();\n            }\n            int count \u003d list.size();\n            for (int i \u003d 0; i \u003c count; i++) {\n                Pointer ptr \u003d (Pointer) list.get(i);\n                result.add(ptr.getValue());\n            }\n            return result;\n        } else {\n            Object value \u003d ((ExpressionContext) object).getContextNodePointer().getValue();\n            return convert(value, toType);\n        }\n    }\n    Class fromType \u003d object.getClass();\n    if (fromType.equals(toType) || toType.isAssignableFrom(fromType)) {\n        return object;\n    }\n    if (toType \u003d\u003d String.class) {\n        return object.toString();\n    }\n    if (object instanceof Boolean) {\n        if (toType \u003d\u003d boolean.class) {\n            return object;\n        }\n        boolean value \u003d ((Boolean) object).booleanValue();\n        return allocateNumber(toType, value ? 1 : 0);\n    } else if (object instanceof Number) {\n        double value \u003d ((Number) object).doubleValue();\n        if (toType \u003d\u003d boolean.class || toType \u003d\u003d Boolean.class) {\n            return value \u003d\u003d 0.0 ? Boolean.FALSE : Boolean.TRUE;\n        }\n        if (toType.isPrimitive() || Number.class.isAssignableFrom(toType)) {\n            return allocateNumber(toType, value);\n        }\n    } else if (object instanceof Character) {\n        if (toType \u003d\u003d char.class) {\n            return object;\n        }\n    } else if (object instanceof String) {\n        Object value \u003d convertStringToPrimitive(object, toType);\n        if (value !\u003d null) {\n            return value;\n        }\n    } else if (fromType.isArray()) {\n        int length \u003d Array.getLength(object);\n        if (toType.isArray()) {\n            Class cType \u003d toType.getComponentType();\n            Object array \u003d Array.newInstance(cType, length);\n            for (int i \u003d 0; i \u003c length; i++) {\n                Object value \u003d Array.get(object, i);\n                Array.set(array, i, convert(value, cType));\n            }\n            return array;\n        } else if (Collection.class.isAssignableFrom(toType)) {\n            Collection collection \u003d allocateCollection(toType);\n            for (int i \u003d 0; i \u003c length; i++) {\n                collection.add(Array.get(object, i));\n            }\n            return collection;\n        } else if (length \u003d\u003d 1) {\n            Object value \u003d Array.get(object, 0);\n            return convert(value, toType);\n        }\n    } else if (object instanceof Collection) {\n        int length \u003d ((Collection) object).size();\n        if (toType.isArray()) {\n            Class cType \u003d toType.getComponentType();\n            Object array \u003d Array.newInstance(cType, length);\n            Iterator it \u003d ((Collection) object).iterator();\n            for (int i \u003d 0; i \u003c length; i++) {\n                Object value \u003d it.next();\n                Array.set(array, i, convert(value, cType));\n            }\n            return array;\n        } else if (Collection.class.isAssignableFrom(toType)) {\n            Collection collection \u003d allocateCollection(toType);\n            collection.addAll((Collection) object);\n            return collection;\n        } else if (length \u003d\u003d 1) {\n            Object value;\n            if (object instanceof List) {\n                value \u003d ((List) object).get(0);\n            } else {\n                Iterator it \u003d ((Collection) object).iterator();\n                value \u003d it.next();\n            }\n            return convert(value, toType);\n        }\n    }\n    throw new RuntimeException(\"Cannot convert \" + object.getClass() + \" to \" + toType);\n}",
      "path": "src/java/org/apache/commons/jxpath/util/BasicTypeConverter.java",
      "functionStartLine": 211,
      "functionName": "convert",
      "functionAnnotation": "",
      "functionDoc": "Converts the supplied object to the specified\ntype. Throws a runtime exception if the conversion is\nnot possible.\n",
      "diff": "@@ -1,153 +1,110 @@\n public Object convert(Object object, Class toType) {\n     if (object \u003d\u003d null) {\n         if (toType.isPrimitive()) {\n-            if (toType \u003d\u003d boolean.class) {\n-                return Boolean.FALSE;\n-            }\n-            if (toType \u003d\u003d char.class) {\n-                return new Character(\u0027\\0\u0027);\n-            }\n-            if (toType \u003d\u003d byte.class) {\n-                return new Byte((byte) 0);\n-            }\n-            if (toType \u003d\u003d short.class) {\n-                return new Short((short) 0);\n-            }\n-            if (toType \u003d\u003d int.class) {\n-                return new Integer(0);\n-            }\n-            if (toType \u003d\u003d long.class) {\n-                return new Long(0l);\n-            }\n-            if (toType \u003d\u003d float.class) {\n-                return new Float(0.0f);\n-            }\n-            if (toType \u003d\u003d double.class) {\n-                return new Double(0.0);\n-            }\n+            return convertNullToPrimitive(toType);\n         }\n         return null;\n     }\n     if (toType \u003d\u003d Object.class) {\n         return object;\n     }\n     if (object instanceof ExpressionContext) {\n         if (Collection.class.isAssignableFrom(toType)) {\n             List list \u003d ((ExpressionContext) object).getContextNodeList();\n             Collection result \u003d new ArrayList();\n             if (toType \u003d\u003d List.class || toType \u003d\u003d ArrayList.class) {\n                 result \u003d new ArrayList();\n             } else if (toType \u003d\u003d Vector.class) {\n                 result \u003d new Vector();\n             } else if (toType \u003d\u003d Set.class || toType \u003d\u003d HashSet.class) {\n                 result \u003d new HashSet();\n             }\n             int count \u003d list.size();\n             for (int i \u003d 0; i \u003c count; i++) {\n                 Pointer ptr \u003d (Pointer) list.get(i);\n                 result.add(ptr.getValue());\n             }\n             return result;\n         } else {\n             Object value \u003d ((ExpressionContext) object).getContextNodePointer().getValue();\n             return convert(value, toType);\n         }\n     }\n     Class fromType \u003d object.getClass();\n     if (fromType.equals(toType) || toType.isAssignableFrom(fromType)) {\n         return object;\n     }\n     if (toType \u003d\u003d String.class) {\n         return object.toString();\n     }\n     if (object instanceof Boolean) {\n         if (toType \u003d\u003d boolean.class) {\n             return object;\n         }\n         boolean value \u003d ((Boolean) object).booleanValue();\n         return allocateNumber(toType, value ? 1 : 0);\n     } else if (object instanceof Number) {\n         double value \u003d ((Number) object).doubleValue();\n         if (toType \u003d\u003d boolean.class || toType \u003d\u003d Boolean.class) {\n             return value \u003d\u003d 0.0 ? Boolean.FALSE : Boolean.TRUE;\n         }\n         if (toType.isPrimitive() || Number.class.isAssignableFrom(toType)) {\n             return allocateNumber(toType, value);\n         }\n     } else if (object instanceof Character) {\n         if (toType \u003d\u003d char.class) {\n             return object;\n         }\n     } else if (object instanceof String) {\n-        if (toType \u003d\u003d boolean.class || toType \u003d\u003d Boolean.class) {\n-            return Boolean.valueOf((String) object);\n-        }\n-        if (toType \u003d\u003d char.class || toType \u003d\u003d Character.class) {\n-            return new Character(((String) object).charAt(0));\n-        }\n-        if (toType \u003d\u003d byte.class || toType \u003d\u003d Byte.class) {\n-            return new Byte((String) object);\n-        }\n-        if (toType \u003d\u003d short.class || toType \u003d\u003d Short.class) {\n-            return new Short((String) object);\n-        }\n-        if (toType \u003d\u003d int.class || toType \u003d\u003d Integer.class) {\n-            return new Integer((String) object);\n-        }\n-        if (toType \u003d\u003d long.class || toType \u003d\u003d Long.class) {\n-            return new Long((String) object);\n-        }\n-        if (toType \u003d\u003d float.class || toType \u003d\u003d Float.class) {\n-            return new Float((String) object);\n-        }\n-        if (toType \u003d\u003d double.class || toType \u003d\u003d Double.class) {\n-            return new Double((String) object);\n+        Object value \u003d convertStringToPrimitive(object, toType);\n+        if (value !\u003d null) {\n+            return value;\n         }\n     } else if (fromType.isArray()) {\n         int length \u003d Array.getLength(object);\n         if (toType.isArray()) {\n             Class cType \u003d toType.getComponentType();\n             Object array \u003d Array.newInstance(cType, length);\n             for (int i \u003d 0; i \u003c length; i++) {\n                 Object value \u003d Array.get(object, i);\n                 Array.set(array, i, convert(value, cType));\n             }\n             return array;\n         } else if (Collection.class.isAssignableFrom(toType)) {\n             Collection collection \u003d allocateCollection(toType);\n             for (int i \u003d 0; i \u003c length; i++) {\n                 collection.add(Array.get(object, i));\n             }\n             return collection;\n         } else if (length \u003d\u003d 1) {\n             Object value \u003d Array.get(object, 0);\n             return convert(value, toType);\n         }\n     } else if (object instanceof Collection) {\n         int length \u003d ((Collection) object).size();\n         if (toType.isArray()) {\n             Class cType \u003d toType.getComponentType();\n             Object array \u003d Array.newInstance(cType, length);\n             Iterator it \u003d ((Collection) object).iterator();\n             for (int i \u003d 0; i \u003c length; i++) {\n                 Object value \u003d it.next();\n                 Array.set(array, i, convert(value, cType));\n             }\n             return array;\n         } else if (Collection.class.isAssignableFrom(toType)) {\n             Collection collection \u003d allocateCollection(toType);\n             collection.addAll((Collection) object);\n             return collection;\n         } else if (length \u003d\u003d 1) {\n             Object value;\n             if (object instanceof List) {\n                 value \u003d ((List) object).get(0);\n             } else {\n                 Iterator it \u003d ((Collection) object).iterator();\n                 value \u003d it.next();\n             }\n             return convert(value, toType);\n         }\n     }\n     throw new RuntimeException(\"Cannot convert \" + object.getClass() + \" to \" + toType);\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "73f1fffe48c5f26e2c29280385bf0e8f2b9627ac": {
      "type": "Yintroduced",
      "commitMessage": "Made type converter configurable\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/jakarta/commons/proper/jxpath/trunk@136766 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "6/12/02, 2:02 PM",
      "commitName": "73f1fffe48c5f26e2c29280385bf0e8f2b9627ac",
      "commitAuthor": "Dmitri Plotnikov",
      "diff": "@@ -0,0 +1,153 @@\n+public Object convert(Object object, Class toType) {\n+    if (object \u003d\u003d null) {\n+        if (toType.isPrimitive()) {\n+            if (toType \u003d\u003d boolean.class) {\n+                return Boolean.FALSE;\n+            }\n+            if (toType \u003d\u003d char.class) {\n+                return new Character(\u0027\\0\u0027);\n+            }\n+            if (toType \u003d\u003d byte.class) {\n+                return new Byte((byte) 0);\n+            }\n+            if (toType \u003d\u003d short.class) {\n+                return new Short((short) 0);\n+            }\n+            if (toType \u003d\u003d int.class) {\n+                return new Integer(0);\n+            }\n+            if (toType \u003d\u003d long.class) {\n+                return new Long(0l);\n+            }\n+            if (toType \u003d\u003d float.class) {\n+                return new Float(0.0f);\n+            }\n+            if (toType \u003d\u003d double.class) {\n+                return new Double(0.0);\n+            }\n+        }\n+        return null;\n+    }\n+    if (toType \u003d\u003d Object.class) {\n+        return object;\n+    }\n+    if (object instanceof ExpressionContext) {\n+        if (Collection.class.isAssignableFrom(toType)) {\n+            List list \u003d ((ExpressionContext) object).getContextNodeList();\n+            Collection result \u003d new ArrayList();\n+            if (toType \u003d\u003d List.class || toType \u003d\u003d ArrayList.class) {\n+                result \u003d new ArrayList();\n+            } else if (toType \u003d\u003d Vector.class) {\n+                result \u003d new Vector();\n+            } else if (toType \u003d\u003d Set.class || toType \u003d\u003d HashSet.class) {\n+                result \u003d new HashSet();\n+            }\n+            int count \u003d list.size();\n+            for (int i \u003d 0; i \u003c count; i++) {\n+                Pointer ptr \u003d (Pointer) list.get(i);\n+                result.add(ptr.getValue());\n+            }\n+            return result;\n+        } else {\n+            Object value \u003d ((ExpressionContext) object).getContextNodePointer().getValue();\n+            return convert(value, toType);\n+        }\n+    }\n+    Class fromType \u003d object.getClass();\n+    if (fromType.equals(toType) || toType.isAssignableFrom(fromType)) {\n+        return object;\n+    }\n+    if (toType \u003d\u003d String.class) {\n+        return object.toString();\n+    }\n+    if (object instanceof Boolean) {\n+        if (toType \u003d\u003d boolean.class) {\n+            return object;\n+        }\n+        boolean value \u003d ((Boolean) object).booleanValue();\n+        return allocateNumber(toType, value ? 1 : 0);\n+    } else if (object instanceof Number) {\n+        double value \u003d ((Number) object).doubleValue();\n+        if (toType \u003d\u003d boolean.class || toType \u003d\u003d Boolean.class) {\n+            return value \u003d\u003d 0.0 ? Boolean.FALSE : Boolean.TRUE;\n+        }\n+        if (toType.isPrimitive() || Number.class.isAssignableFrom(toType)) {\n+            return allocateNumber(toType, value);\n+        }\n+    } else if (object instanceof Character) {\n+        if (toType \u003d\u003d char.class) {\n+            return object;\n+        }\n+    } else if (object instanceof String) {\n+        if (toType \u003d\u003d boolean.class || toType \u003d\u003d Boolean.class) {\n+            return Boolean.valueOf((String) object);\n+        }\n+        if (toType \u003d\u003d char.class || toType \u003d\u003d Character.class) {\n+            return new Character(((String) object).charAt(0));\n+        }\n+        if (toType \u003d\u003d byte.class || toType \u003d\u003d Byte.class) {\n+            return new Byte((String) object);\n+        }\n+        if (toType \u003d\u003d short.class || toType \u003d\u003d Short.class) {\n+            return new Short((String) object);\n+        }\n+        if (toType \u003d\u003d int.class || toType \u003d\u003d Integer.class) {\n+            return new Integer((String) object);\n+        }\n+        if (toType \u003d\u003d long.class || toType \u003d\u003d Long.class) {\n+            return new Long((String) object);\n+        }\n+        if (toType \u003d\u003d float.class || toType \u003d\u003d Float.class) {\n+            return new Float((String) object);\n+        }\n+        if (toType \u003d\u003d double.class || toType \u003d\u003d Double.class) {\n+            return new Double((String) object);\n+        }\n+    } else if (fromType.isArray()) {\n+        int length \u003d Array.getLength(object);\n+        if (toType.isArray()) {\n+            Class cType \u003d toType.getComponentType();\n+            Object array \u003d Array.newInstance(cType, length);\n+            for (int i \u003d 0; i \u003c length; i++) {\n+                Object value \u003d Array.get(object, i);\n+                Array.set(array, i, convert(value, cType));\n+            }\n+            return array;\n+        } else if (Collection.class.isAssignableFrom(toType)) {\n+            Collection collection \u003d allocateCollection(toType);\n+            for (int i \u003d 0; i \u003c length; i++) {\n+                collection.add(Array.get(object, i));\n+            }\n+            return collection;\n+        } else if (length \u003d\u003d 1) {\n+            Object value \u003d Array.get(object, 0);\n+            return convert(value, toType);\n+        }\n+    } else if (object instanceof Collection) {\n+        int length \u003d ((Collection) object).size();\n+        if (toType.isArray()) {\n+            Class cType \u003d toType.getComponentType();\n+            Object array \u003d Array.newInstance(cType, length);\n+            Iterator it \u003d ((Collection) object).iterator();\n+            for (int i \u003d 0; i \u003c length; i++) {\n+                Object value \u003d it.next();\n+                Array.set(array, i, convert(value, cType));\n+            }\n+            return array;\n+        } else if (Collection.class.isAssignableFrom(toType)) {\n+            Collection collection \u003d allocateCollection(toType);\n+            collection.addAll((Collection) object);\n+            return collection;\n+        } else if (length \u003d\u003d 1) {\n+            Object value;\n+            if (object instanceof List) {\n+                value \u003d ((List) object).get(0);\n+            } else {\n+                Iterator it \u003d ((Collection) object).iterator();\n+                value \u003d it.next();\n+            }\n+            return convert(value, toType);\n+        }\n+    }\n+    throw new RuntimeException(\"Cannot convert \" + object.getClass() + \" to \" + toType);\n+}\n\\ No newline at end of file\n",
      "actualSource": "public Object convert(Object object, Class toType) {\n    if (object \u003d\u003d null) {\n        if (toType.isPrimitive()) {\n            if (toType \u003d\u003d boolean.class) {\n                return Boolean.FALSE;\n            }\n            if (toType \u003d\u003d char.class) {\n                return new Character(\u0027\\0\u0027);\n            }\n            if (toType \u003d\u003d byte.class) {\n                return new Byte((byte) 0);\n            }\n            if (toType \u003d\u003d short.class) {\n                return new Short((short) 0);\n            }\n            if (toType \u003d\u003d int.class) {\n                return new Integer(0);\n            }\n            if (toType \u003d\u003d long.class) {\n                return new Long(0l);\n            }\n            if (toType \u003d\u003d float.class) {\n                return new Float(0.0f);\n            }\n            if (toType \u003d\u003d double.class) {\n                return new Double(0.0);\n            }\n        }\n        return null;\n    }\n    if (toType \u003d\u003d Object.class) {\n        return object;\n    }\n    if (object instanceof ExpressionContext) {\n        if (Collection.class.isAssignableFrom(toType)) {\n            List list \u003d ((ExpressionContext) object).getContextNodeList();\n            Collection result \u003d new ArrayList();\n            if (toType \u003d\u003d List.class || toType \u003d\u003d ArrayList.class) {\n                result \u003d new ArrayList();\n            } else if (toType \u003d\u003d Vector.class) {\n                result \u003d new Vector();\n            } else if (toType \u003d\u003d Set.class || toType \u003d\u003d HashSet.class) {\n                result \u003d new HashSet();\n            }\n            int count \u003d list.size();\n            for (int i \u003d 0; i \u003c count; i++) {\n                Pointer ptr \u003d (Pointer) list.get(i);\n                result.add(ptr.getValue());\n            }\n            return result;\n        } else {\n            Object value \u003d ((ExpressionContext) object).getContextNodePointer().getValue();\n            return convert(value, toType);\n        }\n    }\n    Class fromType \u003d object.getClass();\n    if (fromType.equals(toType) || toType.isAssignableFrom(fromType)) {\n        return object;\n    }\n    if (toType \u003d\u003d String.class) {\n        return object.toString();\n    }\n    if (object instanceof Boolean) {\n        if (toType \u003d\u003d boolean.class) {\n            return object;\n        }\n        boolean value \u003d ((Boolean) object).booleanValue();\n        return allocateNumber(toType, value ? 1 : 0);\n    } else if (object instanceof Number) {\n        double value \u003d ((Number) object).doubleValue();\n        if (toType \u003d\u003d boolean.class || toType \u003d\u003d Boolean.class) {\n            return value \u003d\u003d 0.0 ? Boolean.FALSE : Boolean.TRUE;\n        }\n        if (toType.isPrimitive() || Number.class.isAssignableFrom(toType)) {\n            return allocateNumber(toType, value);\n        }\n    } else if (object instanceof Character) {\n        if (toType \u003d\u003d char.class) {\n            return object;\n        }\n    } else if (object instanceof String) {\n        if (toType \u003d\u003d boolean.class || toType \u003d\u003d Boolean.class) {\n            return Boolean.valueOf((String) object);\n        }\n        if (toType \u003d\u003d char.class || toType \u003d\u003d Character.class) {\n            return new Character(((String) object).charAt(0));\n        }\n        if (toType \u003d\u003d byte.class || toType \u003d\u003d Byte.class) {\n            return new Byte((String) object);\n        }\n        if (toType \u003d\u003d short.class || toType \u003d\u003d Short.class) {\n            return new Short((String) object);\n        }\n        if (toType \u003d\u003d int.class || toType \u003d\u003d Integer.class) {\n            return new Integer((String) object);\n        }\n        if (toType \u003d\u003d long.class || toType \u003d\u003d Long.class) {\n            return new Long((String) object);\n        }\n        if (toType \u003d\u003d float.class || toType \u003d\u003d Float.class) {\n            return new Float((String) object);\n        }\n        if (toType \u003d\u003d double.class || toType \u003d\u003d Double.class) {\n            return new Double((String) object);\n        }\n    } else if (fromType.isArray()) {\n        int length \u003d Array.getLength(object);\n        if (toType.isArray()) {\n            Class cType \u003d toType.getComponentType();\n            Object array \u003d Array.newInstance(cType, length);\n            for (int i \u003d 0; i \u003c length; i++) {\n                Object value \u003d Array.get(object, i);\n                Array.set(array, i, convert(value, cType));\n            }\n            return array;\n        } else if (Collection.class.isAssignableFrom(toType)) {\n            Collection collection \u003d allocateCollection(toType);\n            for (int i \u003d 0; i \u003c length; i++) {\n                collection.add(Array.get(object, i));\n            }\n            return collection;\n        } else if (length \u003d\u003d 1) {\n            Object value \u003d Array.get(object, 0);\n            return convert(value, toType);\n        }\n    } else if (object instanceof Collection) {\n        int length \u003d ((Collection) object).size();\n        if (toType.isArray()) {\n            Class cType \u003d toType.getComponentType();\n            Object array \u003d Array.newInstance(cType, length);\n            Iterator it \u003d ((Collection) object).iterator();\n            for (int i \u003d 0; i \u003c length; i++) {\n                Object value \u003d it.next();\n                Array.set(array, i, convert(value, cType));\n            }\n            return array;\n        } else if (Collection.class.isAssignableFrom(toType)) {\n            Collection collection \u003d allocateCollection(toType);\n            collection.addAll((Collection) object);\n            return collection;\n        } else if (length \u003d\u003d 1) {\n            Object value;\n            if (object instanceof List) {\n                value \u003d ((List) object).get(0);\n            } else {\n                Iterator it \u003d ((Collection) object).iterator();\n                value \u003d it.next();\n            }\n            return convert(value, toType);\n        }\n    }\n    throw new RuntimeException(\"Cannot convert \" + object.getClass() + \" to \" + toType);\n}",
      "path": "src/java/org/apache/commons/jxpath/util/BasicTypeConverter.java",
      "functionStartLine": 203,
      "functionName": "convert",
      "functionAnnotation": "",
      "functionDoc": "Converts the supplied object to the specified\ntype. Throws a runtime exception if the conversion is\nnot possible.\n"
    }
  }
}