{
  "origin": "codeshovel",
  "repositoryName": "JxPath-10b",
  "repositoryPath": "/tmp/JxPath-10b//.git",
  "startCommitName": "HEAD",
  "sourceFileName": "BasicTypeConverter.java",
  "functionName": "canConvert",
  "functionId": "canConvert___object-Object__toType-Class(modifiers-final)",
  "sourceFilePath": "src/java/org/apache/commons/jxpath/util/BasicTypeConverter.java",
  "functionAnnotation": "",
  "functionDoc": "Returns true if it can convert the supplied\nobject to the specified class.\n",
  "functionStartLine": 51,
  "functionEndLine": 148,
  "numCommitsSeen": 39,
  "timeTaken": 1117,
  "changeHistory": [
    "8778c3cbe1146ece404662cc9f2611a1c819b883",
    "30e4fdde61866403ce8912dfb8afe328502c4d20",
    "9871c3f7a3db48cb9d627eb527d2adb58a692287",
    "77af585d9f0e629db4ecf8d468ef7b71c9d98e39",
    "4ab5b9e453d0e0ef51fc1d36a5e21aaf21b44c81",
    "348acabaadc57e04f25de5c79c72bc34a4e41723",
    "2327c42440cd4927ac5fc91ed93756cb0c87c96d",
    "73f1fffe48c5f26e2c29280385bf0e8f2b9627ac"
  ],
  "changeHistoryShort": {
    "8778c3cbe1146ece404662cc9f2611a1c819b883": "Ymultichange(Ybodychange,Yparametermetachange)",
    "30e4fdde61866403ce8912dfb8afe328502c4d20": "Ybodychange",
    "9871c3f7a3db48cb9d627eb527d2adb58a692287": "Ybodychange",
    "77af585d9f0e629db4ecf8d468ef7b71c9d98e39": "Ybodychange",
    "4ab5b9e453d0e0ef51fc1d36a5e21aaf21b44c81": "Ybodychange",
    "348acabaadc57e04f25de5c79c72bc34a4e41723": "Ybodychange",
    "2327c42440cd4927ac5fc91ed93756cb0c87c96d": "Yformatchange",
    "73f1fffe48c5f26e2c29280385bf0e8f2b9627ac": "Yintroduced"
  },
  "changeHistoryDetails": {
    "8778c3cbe1146ece404662cc9f2611a1c819b883": {
      "type": "Ymultichange(Ybodychange,Yparametermetachange)",
      "commitMessage": "simplify BasicTypeConverter code; add support for untreated Number types + AtomicBoolean\n\ngit-svn-id: https://svn.apache.org/repos/asf/jakarta/commons/proper/jxpath/trunk@552965 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "7/3/07, 1:07 PM",
      "commitName": "8778c3cbe1146ece404662cc9f2611a1c819b883",
      "commitAuthor": "Matthew Jason Benson",
      "subchanges": [
        {
          "type": "Ybodychange",
          "commitMessage": "simplify BasicTypeConverter code; add support for untreated Number types + AtomicBoolean\n\ngit-svn-id: https://svn.apache.org/repos/asf/jakarta/commons/proper/jxpath/trunk@552965 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "7/3/07, 1:07 PM",
          "commitName": "8778c3cbe1146ece404662cc9f2611a1c819b883",
          "commitAuthor": "Matthew Jason Benson",
          "commitDateOld": "2/19/07, 3:24 PM",
          "commitNameOld": "30e4fdde61866403ce8912dfb8afe328502c4d20",
          "commitAuthorOld": "Matthew Jason Benson",
          "daysBetweenCommits": 133.86,
          "commitsBetweenForRepo": 26,
          "commitsBetweenForFile": 1,
          "actualSource": "public boolean canConvert(Object object, final Class toType) {\n    if (object \u003d\u003d null) {\n        return true;\n    }\n    final Class useType \u003d TypeUtils.wrapPrimitive(toType);\n    Class fromType \u003d object.getClass();\n    if (useType.isAssignableFrom(fromType)) {\n        return true;\n    }\n    if (useType \u003d\u003d String.class) {\n        return true;\n    }\n    if (object instanceof Boolean) {\n        if (Number.class.isAssignableFrom(useType) || \"java.util.concurrent.atomic.AtomicBoolean\".equals(useType.getName())) {\n            return true;\n        }\n    }\n    if (object instanceof Number) {\n        if (Number.class.isAssignableFrom(useType) || useType \u003d\u003d Boolean.class) {\n            return true;\n        }\n    }\n    if (object instanceof String) {\n        if (useType \u003d\u003d Boolean.class || useType \u003d\u003d Character.class || useType \u003d\u003d Byte.class || useType \u003d\u003d Short.class || useType \u003d\u003d Integer.class || useType \u003d\u003d Long.class || useType \u003d\u003d Float.class || useType \u003d\u003d Double.class) {\n            return true;\n        }\n    }\n    if (fromType.isArray()) {\n        if (useType.isArray()) {\n            Class cType \u003d useType.getComponentType();\n            int length \u003d Array.getLength(object);\n            for (int i \u003d 0; i \u003c length; i++) {\n                Object value \u003d Array.get(object, i);\n                if (!canConvert(value, cType)) {\n                    return false;\n                }\n            }\n            return true;\n        }\n        if (Collection.class.isAssignableFrom(useType)) {\n            return canCreateCollection(useType);\n        }\n        if (Array.getLength(object) \u003e 0) {\n            Object value \u003d Array.get(object, 0);\n            return canConvert(value, useType);\n        }\n        return canConvert(\"\", useType);\n    }\n    if (object instanceof Collection) {\n        if (useType.isArray()) {\n            Class cType \u003d useType.getComponentType();\n            Iterator it \u003d ((Collection) object).iterator();\n            while (it.hasNext()) {\n                Object value \u003d it.next();\n                if (!canConvert(value, cType)) {\n                    return false;\n                }\n            }\n            return true;\n        }\n        if (Collection.class.isAssignableFrom(useType)) {\n            return canCreateCollection(useType);\n        }\n        if (((Collection) object).size() \u003e 0) {\n            Object value;\n            if (object instanceof List) {\n                value \u003d ((List) object).get(0);\n            } else {\n                Iterator it \u003d ((Collection) object).iterator();\n                value \u003d it.next();\n            }\n            return canConvert(value, useType);\n        }\n        return canConvert(\"\", useType);\n    }\n    if (object instanceof NodeSet) {\n        return canConvert(((NodeSet) object).getValues(), useType);\n    }\n    if (object instanceof Pointer) {\n        return canConvert(((Pointer) object).getValue(), useType);\n    }\n    return ConvertUtils.lookup(useType) !\u003d null;\n}",
          "path": "src/java/org/apache/commons/jxpath/util/BasicTypeConverter.java",
          "functionStartLine": 51,
          "functionName": "canConvert",
          "functionAnnotation": "",
          "functionDoc": "Returns true if it can convert the supplied\nobject to the specified class.\n",
          "diff": "@@ -1,96 +1,83 @@\n-public boolean canConvert(Object object, Class toType) {\n+public boolean canConvert(Object object, final Class toType) {\n     if (object \u003d\u003d null) {\n         return true;\n     }\n-    if (toType \u003d\u003d Object.class) {\n-        return true;\n-    }\n+    final Class useType \u003d TypeUtils.wrapPrimitive(toType);\n     Class fromType \u003d object.getClass();\n-    if (fromType.equals(toType)) {\n+    if (useType.isAssignableFrom(fromType)) {\n         return true;\n     }\n-    if (toType.isAssignableFrom(fromType)) {\n-        return true;\n-    }\n-    if (toType \u003d\u003d String.class) {\n+    if (useType \u003d\u003d String.class) {\n         return true;\n     }\n     if (object instanceof Boolean) {\n-        if (toType \u003d\u003d boolean.class || Number.class.isAssignableFrom(toType)) {\n+        if (Number.class.isAssignableFrom(useType) || \"java.util.concurrent.atomic.AtomicBoolean\".equals(useType.getName())) {\n             return true;\n         }\n     }\n     if (object instanceof Number) {\n-        if (toType.isPrimitive() || Number.class.isAssignableFrom(toType)) {\n-            return true;\n-        }\n-    }\n-    if (object instanceof Character) {\n-        if (toType \u003d\u003d char.class) {\n+        if (Number.class.isAssignableFrom(useType) || useType \u003d\u003d Boolean.class) {\n             return true;\n         }\n     }\n     if (object instanceof String) {\n-        if (toType.isPrimitive()) {\n-            return true;\n-        }\n-        if (toType \u003d\u003d Boolean.class || toType \u003d\u003d Character.class || toType \u003d\u003d Byte.class || toType \u003d\u003d Short.class || toType \u003d\u003d Integer.class || toType \u003d\u003d Long.class || toType \u003d\u003d Float.class || toType \u003d\u003d Double.class) {\n+        if (useType \u003d\u003d Boolean.class || useType \u003d\u003d Character.class || useType \u003d\u003d Byte.class || useType \u003d\u003d Short.class || useType \u003d\u003d Integer.class || useType \u003d\u003d Long.class || useType \u003d\u003d Float.class || useType \u003d\u003d Double.class) {\n             return true;\n         }\n     }\n     if (fromType.isArray()) {\n-        if (toType.isArray()) {\n-            Class cType \u003d toType.getComponentType();\n+        if (useType.isArray()) {\n+            Class cType \u003d useType.getComponentType();\n             int length \u003d Array.getLength(object);\n             for (int i \u003d 0; i \u003c length; i++) {\n                 Object value \u003d Array.get(object, i);\n                 if (!canConvert(value, cType)) {\n                     return false;\n                 }\n             }\n             return true;\n         }\n-        if (Collection.class.isAssignableFrom(toType)) {\n-            return canCreateCollection(toType);\n+        if (Collection.class.isAssignableFrom(useType)) {\n+            return canCreateCollection(useType);\n         }\n         if (Array.getLength(object) \u003e 0) {\n             Object value \u003d Array.get(object, 0);\n-            return canConvert(value, toType);\n+            return canConvert(value, useType);\n         }\n-        return canConvert(\"\", toType);\n+        return canConvert(\"\", useType);\n     }\n     if (object instanceof Collection) {\n-        if (toType.isArray()) {\n-            Class cType \u003d toType.getComponentType();\n+        if (useType.isArray()) {\n+            Class cType \u003d useType.getComponentType();\n             Iterator it \u003d ((Collection) object).iterator();\n             while (it.hasNext()) {\n                 Object value \u003d it.next();\n                 if (!canConvert(value, cType)) {\n                     return false;\n                 }\n             }\n             return true;\n         }\n-        if (Collection.class.isAssignableFrom(toType)) {\n-            return canCreateCollection(toType);\n+        if (Collection.class.isAssignableFrom(useType)) {\n+            return canCreateCollection(useType);\n         }\n         if (((Collection) object).size() \u003e 0) {\n             Object value;\n             if (object instanceof List) {\n                 value \u003d ((List) object).get(0);\n             } else {\n                 Iterator it \u003d ((Collection) object).iterator();\n                 value \u003d it.next();\n             }\n-            return canConvert(value, toType);\n+            return canConvert(value, useType);\n         }\n-        return canConvert(\"\", toType);\n+        return canConvert(\"\", useType);\n     }\n     if (object instanceof NodeSet) {\n-        return canConvert(((NodeSet) object).getValues(), toType);\n+        return canConvert(((NodeSet) object).getValues(), useType);\n     }\n     if (object instanceof Pointer) {\n-        return canConvert(((Pointer) object).getValue(), toType);\n+        return canConvert(((Pointer) object).getValue(), useType);\n     }\n-    return ConvertUtils.lookup(toType) !\u003d null;\n+    return ConvertUtils.lookup(useType) !\u003d null;\n }\n\\ No newline at end of file\n",
          "extendedDetails": {}
        },
        {
          "type": "Yparametermetachange",
          "commitMessage": "simplify BasicTypeConverter code; add support for untreated Number types + AtomicBoolean\n\ngit-svn-id: https://svn.apache.org/repos/asf/jakarta/commons/proper/jxpath/trunk@552965 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "7/3/07, 1:07 PM",
          "commitName": "8778c3cbe1146ece404662cc9f2611a1c819b883",
          "commitAuthor": "Matthew Jason Benson",
          "commitDateOld": "2/19/07, 3:24 PM",
          "commitNameOld": "30e4fdde61866403ce8912dfb8afe328502c4d20",
          "commitAuthorOld": "Matthew Jason Benson",
          "daysBetweenCommits": 133.86,
          "commitsBetweenForRepo": 26,
          "commitsBetweenForFile": 1,
          "actualSource": "public boolean canConvert(Object object, final Class toType) {\n    if (object \u003d\u003d null) {\n        return true;\n    }\n    final Class useType \u003d TypeUtils.wrapPrimitive(toType);\n    Class fromType \u003d object.getClass();\n    if (useType.isAssignableFrom(fromType)) {\n        return true;\n    }\n    if (useType \u003d\u003d String.class) {\n        return true;\n    }\n    if (object instanceof Boolean) {\n        if (Number.class.isAssignableFrom(useType) || \"java.util.concurrent.atomic.AtomicBoolean\".equals(useType.getName())) {\n            return true;\n        }\n    }\n    if (object instanceof Number) {\n        if (Number.class.isAssignableFrom(useType) || useType \u003d\u003d Boolean.class) {\n            return true;\n        }\n    }\n    if (object instanceof String) {\n        if (useType \u003d\u003d Boolean.class || useType \u003d\u003d Character.class || useType \u003d\u003d Byte.class || useType \u003d\u003d Short.class || useType \u003d\u003d Integer.class || useType \u003d\u003d Long.class || useType \u003d\u003d Float.class || useType \u003d\u003d Double.class) {\n            return true;\n        }\n    }\n    if (fromType.isArray()) {\n        if (useType.isArray()) {\n            Class cType \u003d useType.getComponentType();\n            int length \u003d Array.getLength(object);\n            for (int i \u003d 0; i \u003c length; i++) {\n                Object value \u003d Array.get(object, i);\n                if (!canConvert(value, cType)) {\n                    return false;\n                }\n            }\n            return true;\n        }\n        if (Collection.class.isAssignableFrom(useType)) {\n            return canCreateCollection(useType);\n        }\n        if (Array.getLength(object) \u003e 0) {\n            Object value \u003d Array.get(object, 0);\n            return canConvert(value, useType);\n        }\n        return canConvert(\"\", useType);\n    }\n    if (object instanceof Collection) {\n        if (useType.isArray()) {\n            Class cType \u003d useType.getComponentType();\n            Iterator it \u003d ((Collection) object).iterator();\n            while (it.hasNext()) {\n                Object value \u003d it.next();\n                if (!canConvert(value, cType)) {\n                    return false;\n                }\n            }\n            return true;\n        }\n        if (Collection.class.isAssignableFrom(useType)) {\n            return canCreateCollection(useType);\n        }\n        if (((Collection) object).size() \u003e 0) {\n            Object value;\n            if (object instanceof List) {\n                value \u003d ((List) object).get(0);\n            } else {\n                Iterator it \u003d ((Collection) object).iterator();\n                value \u003d it.next();\n            }\n            return canConvert(value, useType);\n        }\n        return canConvert(\"\", useType);\n    }\n    if (object instanceof NodeSet) {\n        return canConvert(((NodeSet) object).getValues(), useType);\n    }\n    if (object instanceof Pointer) {\n        return canConvert(((Pointer) object).getValue(), useType);\n    }\n    return ConvertUtils.lookup(useType) !\u003d null;\n}",
          "path": "src/java/org/apache/commons/jxpath/util/BasicTypeConverter.java",
          "functionStartLine": 51,
          "functionName": "canConvert",
          "functionAnnotation": "",
          "functionDoc": "Returns true if it can convert the supplied\nobject to the specified class.\n",
          "diff": "@@ -1,96 +1,83 @@\n-public boolean canConvert(Object object, Class toType) {\n+public boolean canConvert(Object object, final Class toType) {\n     if (object \u003d\u003d null) {\n         return true;\n     }\n-    if (toType \u003d\u003d Object.class) {\n-        return true;\n-    }\n+    final Class useType \u003d TypeUtils.wrapPrimitive(toType);\n     Class fromType \u003d object.getClass();\n-    if (fromType.equals(toType)) {\n+    if (useType.isAssignableFrom(fromType)) {\n         return true;\n     }\n-    if (toType.isAssignableFrom(fromType)) {\n-        return true;\n-    }\n-    if (toType \u003d\u003d String.class) {\n+    if (useType \u003d\u003d String.class) {\n         return true;\n     }\n     if (object instanceof Boolean) {\n-        if (toType \u003d\u003d boolean.class || Number.class.isAssignableFrom(toType)) {\n+        if (Number.class.isAssignableFrom(useType) || \"java.util.concurrent.atomic.AtomicBoolean\".equals(useType.getName())) {\n             return true;\n         }\n     }\n     if (object instanceof Number) {\n-        if (toType.isPrimitive() || Number.class.isAssignableFrom(toType)) {\n-            return true;\n-        }\n-    }\n-    if (object instanceof Character) {\n-        if (toType \u003d\u003d char.class) {\n+        if (Number.class.isAssignableFrom(useType) || useType \u003d\u003d Boolean.class) {\n             return true;\n         }\n     }\n     if (object instanceof String) {\n-        if (toType.isPrimitive()) {\n-            return true;\n-        }\n-        if (toType \u003d\u003d Boolean.class || toType \u003d\u003d Character.class || toType \u003d\u003d Byte.class || toType \u003d\u003d Short.class || toType \u003d\u003d Integer.class || toType \u003d\u003d Long.class || toType \u003d\u003d Float.class || toType \u003d\u003d Double.class) {\n+        if (useType \u003d\u003d Boolean.class || useType \u003d\u003d Character.class || useType \u003d\u003d Byte.class || useType \u003d\u003d Short.class || useType \u003d\u003d Integer.class || useType \u003d\u003d Long.class || useType \u003d\u003d Float.class || useType \u003d\u003d Double.class) {\n             return true;\n         }\n     }\n     if (fromType.isArray()) {\n-        if (toType.isArray()) {\n-            Class cType \u003d toType.getComponentType();\n+        if (useType.isArray()) {\n+            Class cType \u003d useType.getComponentType();\n             int length \u003d Array.getLength(object);\n             for (int i \u003d 0; i \u003c length; i++) {\n                 Object value \u003d Array.get(object, i);\n                 if (!canConvert(value, cType)) {\n                     return false;\n                 }\n             }\n             return true;\n         }\n-        if (Collection.class.isAssignableFrom(toType)) {\n-            return canCreateCollection(toType);\n+        if (Collection.class.isAssignableFrom(useType)) {\n+            return canCreateCollection(useType);\n         }\n         if (Array.getLength(object) \u003e 0) {\n             Object value \u003d Array.get(object, 0);\n-            return canConvert(value, toType);\n+            return canConvert(value, useType);\n         }\n-        return canConvert(\"\", toType);\n+        return canConvert(\"\", useType);\n     }\n     if (object instanceof Collection) {\n-        if (toType.isArray()) {\n-            Class cType \u003d toType.getComponentType();\n+        if (useType.isArray()) {\n+            Class cType \u003d useType.getComponentType();\n             Iterator it \u003d ((Collection) object).iterator();\n             while (it.hasNext()) {\n                 Object value \u003d it.next();\n                 if (!canConvert(value, cType)) {\n                     return false;\n                 }\n             }\n             return true;\n         }\n-        if (Collection.class.isAssignableFrom(toType)) {\n-            return canCreateCollection(toType);\n+        if (Collection.class.isAssignableFrom(useType)) {\n+            return canCreateCollection(useType);\n         }\n         if (((Collection) object).size() \u003e 0) {\n             Object value;\n             if (object instanceof List) {\n                 value \u003d ((List) object).get(0);\n             } else {\n                 Iterator it \u003d ((Collection) object).iterator();\n                 value \u003d it.next();\n             }\n-            return canConvert(value, toType);\n+            return canConvert(value, useType);\n         }\n-        return canConvert(\"\", toType);\n+        return canConvert(\"\", useType);\n     }\n     if (object instanceof NodeSet) {\n-        return canConvert(((NodeSet) object).getValues(), toType);\n+        return canConvert(((NodeSet) object).getValues(), useType);\n     }\n     if (object instanceof Pointer) {\n-        return canConvert(((Pointer) object).getValue(), toType);\n+        return canConvert(((Pointer) object).getValue(), useType);\n     }\n-    return ConvertUtils.lookup(toType) !\u003d null;\n+    return ConvertUtils.lookup(useType) !\u003d null;\n }\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldValue": "[object-Object, toType-Class]",
            "newValue": "[object-Object, toType-Class(modifiers-final)]"
          }
        }
      ]
    },
    "30e4fdde61866403ce8912dfb8afe328502c4d20": {
      "type": "Ybodychange",
      "commitMessage": "bulled through JXPath codebase to get a little better familiarity; tiny refactorings and removals of unnecessary elses, etc. along the way\n\ngit-svn-id: https://svn.apache.org/repos/asf/jakarta/commons/proper/jxpath/trunk@509378 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "2/19/07, 3:24 PM",
      "commitName": "30e4fdde61866403ce8912dfb8afe328502c4d20",
      "commitAuthor": "Matthew Jason Benson",
      "commitDateOld": "11/28/06, 9:37 PM",
      "commitNameOld": "a78dc45a3795e3b9666daed8c13ccc7f4ff48806",
      "commitAuthorOld": "Henri Yandell",
      "daysBetweenCommits": 82.74,
      "commitsBetweenForRepo": 26,
      "commitsBetweenForFile": 1,
      "actualSource": "public boolean canConvert(Object object, Class toType) {\n    if (object \u003d\u003d null) {\n        return true;\n    }\n    if (toType \u003d\u003d Object.class) {\n        return true;\n    }\n    Class fromType \u003d object.getClass();\n    if (fromType.equals(toType)) {\n        return true;\n    }\n    if (toType.isAssignableFrom(fromType)) {\n        return true;\n    }\n    if (toType \u003d\u003d String.class) {\n        return true;\n    }\n    if (object instanceof Boolean) {\n        if (toType \u003d\u003d boolean.class || Number.class.isAssignableFrom(toType)) {\n            return true;\n        }\n    }\n    if (object instanceof Number) {\n        if (toType.isPrimitive() || Number.class.isAssignableFrom(toType)) {\n            return true;\n        }\n    }\n    if (object instanceof Character) {\n        if (toType \u003d\u003d char.class) {\n            return true;\n        }\n    }\n    if (object instanceof String) {\n        if (toType.isPrimitive()) {\n            return true;\n        }\n        if (toType \u003d\u003d Boolean.class || toType \u003d\u003d Character.class || toType \u003d\u003d Byte.class || toType \u003d\u003d Short.class || toType \u003d\u003d Integer.class || toType \u003d\u003d Long.class || toType \u003d\u003d Float.class || toType \u003d\u003d Double.class) {\n            return true;\n        }\n    }\n    if (fromType.isArray()) {\n        if (toType.isArray()) {\n            Class cType \u003d toType.getComponentType();\n            int length \u003d Array.getLength(object);\n            for (int i \u003d 0; i \u003c length; i++) {\n                Object value \u003d Array.get(object, i);\n                if (!canConvert(value, cType)) {\n                    return false;\n                }\n            }\n            return true;\n        }\n        if (Collection.class.isAssignableFrom(toType)) {\n            return canCreateCollection(toType);\n        }\n        if (Array.getLength(object) \u003e 0) {\n            Object value \u003d Array.get(object, 0);\n            return canConvert(value, toType);\n        }\n        return canConvert(\"\", toType);\n    }\n    if (object instanceof Collection) {\n        if (toType.isArray()) {\n            Class cType \u003d toType.getComponentType();\n            Iterator it \u003d ((Collection) object).iterator();\n            while (it.hasNext()) {\n                Object value \u003d it.next();\n                if (!canConvert(value, cType)) {\n                    return false;\n                }\n            }\n            return true;\n        }\n        if (Collection.class.isAssignableFrom(toType)) {\n            return canCreateCollection(toType);\n        }\n        if (((Collection) object).size() \u003e 0) {\n            Object value;\n            if (object instanceof List) {\n                value \u003d ((List) object).get(0);\n            } else {\n                Iterator it \u003d ((Collection) object).iterator();\n                value \u003d it.next();\n            }\n            return canConvert(value, toType);\n        }\n        return canConvert(\"\", toType);\n    }\n    if (object instanceof NodeSet) {\n        return canConvert(((NodeSet) object).getValues(), toType);\n    }\n    if (object instanceof Pointer) {\n        return canConvert(((Pointer) object).getValue(), toType);\n    }\n    return ConvertUtils.lookup(toType) !\u003d null;\n}",
      "path": "src/java/org/apache/commons/jxpath/util/BasicTypeConverter.java",
      "functionStartLine": 49,
      "functionName": "canConvert",
      "functionAnnotation": "",
      "functionDoc": "Returns true if it can convert the supplied\nobject to the specified class.\n",
      "diff": "@@ -1,91 +1,96 @@\n public boolean canConvert(Object object, Class toType) {\n     if (object \u003d\u003d null) {\n         return true;\n     }\n     if (toType \u003d\u003d Object.class) {\n         return true;\n     }\n     Class fromType \u003d object.getClass();\n     if (fromType.equals(toType)) {\n         return true;\n     }\n     if (toType.isAssignableFrom(fromType)) {\n         return true;\n     }\n     if (toType \u003d\u003d String.class) {\n         return true;\n     }\n     if (object instanceof Boolean) {\n         if (toType \u003d\u003d boolean.class || Number.class.isAssignableFrom(toType)) {\n             return true;\n         }\n-    } else if (object instanceof Number) {\n+    }\n+    if (object instanceof Number) {\n         if (toType.isPrimitive() || Number.class.isAssignableFrom(toType)) {\n             return true;\n         }\n-    } else if (object instanceof Character) {\n+    }\n+    if (object instanceof Character) {\n         if (toType \u003d\u003d char.class) {\n             return true;\n         }\n-    } else if (object instanceof String) {\n+    }\n+    if (object instanceof String) {\n         if (toType.isPrimitive()) {\n             return true;\n         }\n         if (toType \u003d\u003d Boolean.class || toType \u003d\u003d Character.class || toType \u003d\u003d Byte.class || toType \u003d\u003d Short.class || toType \u003d\u003d Integer.class || toType \u003d\u003d Long.class || toType \u003d\u003d Float.class || toType \u003d\u003d Double.class) {\n             return true;\n         }\n-    } else if (fromType.isArray()) {\n+    }\n+    if (fromType.isArray()) {\n         if (toType.isArray()) {\n             Class cType \u003d toType.getComponentType();\n             int length \u003d Array.getLength(object);\n             for (int i \u003d 0; i \u003c length; i++) {\n                 Object value \u003d Array.get(object, i);\n                 if (!canConvert(value, cType)) {\n                     return false;\n                 }\n             }\n             return true;\n-        } else if (Collection.class.isAssignableFrom(toType)) {\n-            return canCreateCollection(toType);\n-        } else {\n-            if (Array.getLength(object) \u003e 0) {\n-                Object value \u003d Array.get(object, 0);\n-                return canConvert(value, toType);\n-            } else {\n-                return canConvert(\"\", toType);\n-            }\n         }\n-    } else if (object instanceof Collection) {\n+        if (Collection.class.isAssignableFrom(toType)) {\n+            return canCreateCollection(toType);\n+        }\n+        if (Array.getLength(object) \u003e 0) {\n+            Object value \u003d Array.get(object, 0);\n+            return canConvert(value, toType);\n+        }\n+        return canConvert(\"\", toType);\n+    }\n+    if (object instanceof Collection) {\n         if (toType.isArray()) {\n             Class cType \u003d toType.getComponentType();\n             Iterator it \u003d ((Collection) object).iterator();\n             while (it.hasNext()) {\n                 Object value \u003d it.next();\n                 if (!canConvert(value, cType)) {\n                     return false;\n                 }\n             }\n             return true;\n-        } else if (Collection.class.isAssignableFrom(toType)) {\n-            return canCreateCollection(toType);\n-        } else {\n-            if (((Collection) object).size() \u003e 0) {\n-                Object value;\n-                if (object instanceof List) {\n-                    value \u003d ((List) object).get(0);\n-                } else {\n-                    Iterator it \u003d ((Collection) object).iterator();\n-                    value \u003d it.next();\n-                }\n-                return canConvert(value, toType);\n-            } else {\n-                return canConvert(\"\", toType);\n-            }\n         }\n-    } else if (object instanceof NodeSet) {\n+        if (Collection.class.isAssignableFrom(toType)) {\n+            return canCreateCollection(toType);\n+        }\n+        if (((Collection) object).size() \u003e 0) {\n+            Object value;\n+            if (object instanceof List) {\n+                value \u003d ((List) object).get(0);\n+            } else {\n+                Iterator it \u003d ((Collection) object).iterator();\n+                value \u003d it.next();\n+            }\n+            return canConvert(value, toType);\n+        }\n+        return canConvert(\"\", toType);\n+    }\n+    if (object instanceof NodeSet) {\n         return canConvert(((NodeSet) object).getValues(), toType);\n-    } else if (object instanceof Pointer) {\n+    }\n+    if (object instanceof Pointer) {\n         return canConvert(((Pointer) object).getValue(), toType);\n     }\n     return ConvertUtils.lookup(toType) !\u003d null;\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "9871c3f7a3db48cb9d627eb527d2adb58a692287": {
      "type": "Ybodychange",
      "commitMessage": "Integrated with BeanUtils ConverterUtils\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/jakarta/commons/proper/jxpath/trunk@136913 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "6/29/04, 2:50 PM",
      "commitName": "9871c3f7a3db48cb9d627eb527d2adb58a692287",
      "commitAuthor": "Dmitri Plotnikov",
      "commitDateOld": "3/24/04, 9:42 PM",
      "commitNameOld": "e7ecdaf5a2ea7c59b20edfbc92dfc31d6002945a",
      "commitAuthorOld": "Dmitri Plotnikov",
      "daysBetweenCommits": 96.67,
      "commitsBetweenForRepo": 11,
      "commitsBetweenForFile": 1,
      "actualSource": "public boolean canConvert(Object object, Class toType) {\n    if (object \u003d\u003d null) {\n        return true;\n    }\n    if (toType \u003d\u003d Object.class) {\n        return true;\n    }\n    Class fromType \u003d object.getClass();\n    if (fromType.equals(toType)) {\n        return true;\n    }\n    if (toType.isAssignableFrom(fromType)) {\n        return true;\n    }\n    if (toType \u003d\u003d String.class) {\n        return true;\n    }\n    if (object instanceof Boolean) {\n        if (toType \u003d\u003d boolean.class || Number.class.isAssignableFrom(toType)) {\n            return true;\n        }\n    } else if (object instanceof Number) {\n        if (toType.isPrimitive() || Number.class.isAssignableFrom(toType)) {\n            return true;\n        }\n    } else if (object instanceof Character) {\n        if (toType \u003d\u003d char.class) {\n            return true;\n        }\n    } else if (object instanceof String) {\n        if (toType.isPrimitive()) {\n            return true;\n        }\n        if (toType \u003d\u003d Boolean.class || toType \u003d\u003d Character.class || toType \u003d\u003d Byte.class || toType \u003d\u003d Short.class || toType \u003d\u003d Integer.class || toType \u003d\u003d Long.class || toType \u003d\u003d Float.class || toType \u003d\u003d Double.class) {\n            return true;\n        }\n    } else if (fromType.isArray()) {\n        if (toType.isArray()) {\n            Class cType \u003d toType.getComponentType();\n            int length \u003d Array.getLength(object);\n            for (int i \u003d 0; i \u003c length; i++) {\n                Object value \u003d Array.get(object, i);\n                if (!canConvert(value, cType)) {\n                    return false;\n                }\n            }\n            return true;\n        } else if (Collection.class.isAssignableFrom(toType)) {\n            return canCreateCollection(toType);\n        } else {\n            if (Array.getLength(object) \u003e 0) {\n                Object value \u003d Array.get(object, 0);\n                return canConvert(value, toType);\n            } else {\n                return canConvert(\"\", toType);\n            }\n        }\n    } else if (object instanceof Collection) {\n        if (toType.isArray()) {\n            Class cType \u003d toType.getComponentType();\n            Iterator it \u003d ((Collection) object).iterator();\n            while (it.hasNext()) {\n                Object value \u003d it.next();\n                if (!canConvert(value, cType)) {\n                    return false;\n                }\n            }\n            return true;\n        } else if (Collection.class.isAssignableFrom(toType)) {\n            return canCreateCollection(toType);\n        } else {\n            if (((Collection) object).size() \u003e 0) {\n                Object value;\n                if (object instanceof List) {\n                    value \u003d ((List) object).get(0);\n                } else {\n                    Iterator it \u003d ((Collection) object).iterator();\n                    value \u003d it.next();\n                }\n                return canConvert(value, toType);\n            } else {\n                return canConvert(\"\", toType);\n            }\n        }\n    } else if (object instanceof NodeSet) {\n        return canConvert(((NodeSet) object).getValues(), toType);\n    } else if (object instanceof Pointer) {\n        return canConvert(((Pointer) object).getValue(), toType);\n    }\n    return ConvertUtils.lookup(toType) !\u003d null;\n}",
      "path": "src/java/org/apache/commons/jxpath/util/BasicTypeConverter.java",
      "functionStartLine": 45,
      "functionName": "canConvert",
      "functionAnnotation": "",
      "functionDoc": "Returns true if it can convert the supplied\nobject to the specified class.\n",
      "diff": "@@ -1,91 +1,91 @@\n public boolean canConvert(Object object, Class toType) {\n     if (object \u003d\u003d null) {\n         return true;\n     }\n     if (toType \u003d\u003d Object.class) {\n         return true;\n     }\n     Class fromType \u003d object.getClass();\n     if (fromType.equals(toType)) {\n         return true;\n     }\n     if (toType.isAssignableFrom(fromType)) {\n         return true;\n     }\n     if (toType \u003d\u003d String.class) {\n         return true;\n     }\n     if (object instanceof Boolean) {\n         if (toType \u003d\u003d boolean.class || Number.class.isAssignableFrom(toType)) {\n             return true;\n         }\n     } else if (object instanceof Number) {\n         if (toType.isPrimitive() || Number.class.isAssignableFrom(toType)) {\n             return true;\n         }\n     } else if (object instanceof Character) {\n         if (toType \u003d\u003d char.class) {\n             return true;\n         }\n     } else if (object instanceof String) {\n         if (toType.isPrimitive()) {\n             return true;\n         }\n         if (toType \u003d\u003d Boolean.class || toType \u003d\u003d Character.class || toType \u003d\u003d Byte.class || toType \u003d\u003d Short.class || toType \u003d\u003d Integer.class || toType \u003d\u003d Long.class || toType \u003d\u003d Float.class || toType \u003d\u003d Double.class) {\n             return true;\n         }\n     } else if (fromType.isArray()) {\n         if (toType.isArray()) {\n             Class cType \u003d toType.getComponentType();\n             int length \u003d Array.getLength(object);\n             for (int i \u003d 0; i \u003c length; i++) {\n                 Object value \u003d Array.get(object, i);\n                 if (!canConvert(value, cType)) {\n                     return false;\n                 }\n             }\n             return true;\n         } else if (Collection.class.isAssignableFrom(toType)) {\n             return canCreateCollection(toType);\n         } else {\n             if (Array.getLength(object) \u003e 0) {\n                 Object value \u003d Array.get(object, 0);\n                 return canConvert(value, toType);\n             } else {\n                 return canConvert(\"\", toType);\n             }\n         }\n     } else if (object instanceof Collection) {\n         if (toType.isArray()) {\n             Class cType \u003d toType.getComponentType();\n             Iterator it \u003d ((Collection) object).iterator();\n             while (it.hasNext()) {\n                 Object value \u003d it.next();\n                 if (!canConvert(value, cType)) {\n                     return false;\n                 }\n             }\n             return true;\n         } else if (Collection.class.isAssignableFrom(toType)) {\n             return canCreateCollection(toType);\n         } else {\n             if (((Collection) object).size() \u003e 0) {\n                 Object value;\n                 if (object instanceof List) {\n                     value \u003d ((List) object).get(0);\n                 } else {\n                     Iterator it \u003d ((Collection) object).iterator();\n                     value \u003d it.next();\n                 }\n                 return canConvert(value, toType);\n             } else {\n                 return canConvert(\"\", toType);\n             }\n         }\n     } else if (object instanceof NodeSet) {\n         return canConvert(((NodeSet) object).getValues(), toType);\n     } else if (object instanceof Pointer) {\n         return canConvert(((Pointer) object).getValue(), toType);\n     }\n-    return false;\n+    return ConvertUtils.lookup(toType) !\u003d null;\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "77af585d9f0e629db4ecf8d468ef7b71c9d98e39": {
      "type": "Ybodychange",
      "commitMessage": "Fixed collection as return value of extension function\nReduced the amount of cloning\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/jakarta/commons/proper/jxpath/trunk@136860 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "3/24/03, 6:41 PM",
      "commitName": "77af585d9f0e629db4ecf8d468ef7b71c9d98e39",
      "commitAuthor": "Dmitri Plotnikov",
      "commitDateOld": "3/10/03, 4:59 PM",
      "commitNameOld": "bdf423f27a76d2006ffe1058d6530eebf619c877",
      "commitAuthorOld": "Dmitri Plotnikov",
      "daysBetweenCommits": 14.07,
      "commitsBetweenForRepo": 3,
      "commitsBetweenForFile": 1,
      "actualSource": "public boolean canConvert(Object object, Class toType) {\n    if (object \u003d\u003d null) {\n        return true;\n    }\n    if (toType \u003d\u003d Object.class) {\n        return true;\n    }\n    Class fromType \u003d object.getClass();\n    if (fromType.equals(toType)) {\n        return true;\n    }\n    if (toType.isAssignableFrom(fromType)) {\n        return true;\n    }\n    if (toType \u003d\u003d String.class) {\n        return true;\n    }\n    if (object instanceof Boolean) {\n        if (toType \u003d\u003d boolean.class || Number.class.isAssignableFrom(toType)) {\n            return true;\n        }\n    } else if (object instanceof Number) {\n        if (toType.isPrimitive() || Number.class.isAssignableFrom(toType)) {\n            return true;\n        }\n    } else if (object instanceof Character) {\n        if (toType \u003d\u003d char.class) {\n            return true;\n        }\n    } else if (object instanceof String) {\n        if (toType.isPrimitive()) {\n            return true;\n        }\n        if (toType \u003d\u003d Boolean.class || toType \u003d\u003d Character.class || toType \u003d\u003d Byte.class || toType \u003d\u003d Short.class || toType \u003d\u003d Integer.class || toType \u003d\u003d Long.class || toType \u003d\u003d Float.class || toType \u003d\u003d Double.class) {\n            return true;\n        }\n    } else if (fromType.isArray()) {\n        if (toType.isArray()) {\n            Class cType \u003d toType.getComponentType();\n            int length \u003d Array.getLength(object);\n            for (int i \u003d 0; i \u003c length; i++) {\n                Object value \u003d Array.get(object, i);\n                if (!canConvert(value, cType)) {\n                    return false;\n                }\n            }\n            return true;\n        } else if (Collection.class.isAssignableFrom(toType)) {\n            return canCreateCollection(toType);\n        } else {\n            if (Array.getLength(object) \u003e 0) {\n                Object value \u003d Array.get(object, 0);\n                return canConvert(value, toType);\n            } else {\n                return canConvert(\"\", toType);\n            }\n        }\n    } else if (object instanceof Collection) {\n        if (toType.isArray()) {\n            Class cType \u003d toType.getComponentType();\n            Iterator it \u003d ((Collection) object).iterator();\n            while (it.hasNext()) {\n                Object value \u003d it.next();\n                if (!canConvert(value, cType)) {\n                    return false;\n                }\n            }\n            return true;\n        } else if (Collection.class.isAssignableFrom(toType)) {\n            return canCreateCollection(toType);\n        } else {\n            if (((Collection) object).size() \u003e 0) {\n                Object value;\n                if (object instanceof List) {\n                    value \u003d ((List) object).get(0);\n                } else {\n                    Iterator it \u003d ((Collection) object).iterator();\n                    value \u003d it.next();\n                }\n                return canConvert(value, toType);\n            } else {\n                return canConvert(\"\", toType);\n            }\n        }\n    } else if (object instanceof NodeSet) {\n        return canConvert(((NodeSet) object).getValues(), toType);\n    } else if (object instanceof Pointer) {\n        return canConvert(((Pointer) object).getValue(), toType);\n    }\n    return false;\n}",
      "path": "src/java/org/apache/commons/jxpath/util/BasicTypeConverter.java",
      "functionStartLine": 90,
      "functionName": "canConvert",
      "functionAnnotation": "",
      "functionDoc": "Returns true if it can convert the supplied\nobject to the specified class.\n",
      "diff": "@@ -1,83 +1,91 @@\n public boolean canConvert(Object object, Class toType) {\n     if (object \u003d\u003d null) {\n         return true;\n     }\n     if (toType \u003d\u003d Object.class) {\n         return true;\n     }\n     Class fromType \u003d object.getClass();\n     if (fromType.equals(toType)) {\n         return true;\n     }\n     if (toType.isAssignableFrom(fromType)) {\n         return true;\n     }\n     if (toType \u003d\u003d String.class) {\n         return true;\n     }\n     if (object instanceof Boolean) {\n         if (toType \u003d\u003d boolean.class || Number.class.isAssignableFrom(toType)) {\n             return true;\n         }\n     } else if (object instanceof Number) {\n         if (toType.isPrimitive() || Number.class.isAssignableFrom(toType)) {\n             return true;\n         }\n     } else if (object instanceof Character) {\n         if (toType \u003d\u003d char.class) {\n             return true;\n         }\n     } else if (object instanceof String) {\n         if (toType.isPrimitive()) {\n             return true;\n         }\n         if (toType \u003d\u003d Boolean.class || toType \u003d\u003d Character.class || toType \u003d\u003d Byte.class || toType \u003d\u003d Short.class || toType \u003d\u003d Integer.class || toType \u003d\u003d Long.class || toType \u003d\u003d Float.class || toType \u003d\u003d Double.class) {\n             return true;\n         }\n     } else if (fromType.isArray()) {\n         if (toType.isArray()) {\n             Class cType \u003d toType.getComponentType();\n             int length \u003d Array.getLength(object);\n             for (int i \u003d 0; i \u003c length; i++) {\n                 Object value \u003d Array.get(object, i);\n                 if (!canConvert(value, cType)) {\n                     return false;\n                 }\n             }\n             return true;\n         } else if (Collection.class.isAssignableFrom(toType)) {\n             return canCreateCollection(toType);\n-        } else if (Array.getLength(object) \u003d\u003d 1) {\n-            Object value \u003d Array.get(object, 0);\n-            return canConvert(value, toType);\n+        } else {\n+            if (Array.getLength(object) \u003e 0) {\n+                Object value \u003d Array.get(object, 0);\n+                return canConvert(value, toType);\n+            } else {\n+                return canConvert(\"\", toType);\n+            }\n         }\n     } else if (object instanceof Collection) {\n         if (toType.isArray()) {\n             Class cType \u003d toType.getComponentType();\n             Iterator it \u003d ((Collection) object).iterator();\n             while (it.hasNext()) {\n                 Object value \u003d it.next();\n                 if (!canConvert(value, cType)) {\n                     return false;\n                 }\n             }\n             return true;\n         } else if (Collection.class.isAssignableFrom(toType)) {\n             return canCreateCollection(toType);\n-        } else if (((Collection) object).size() \u003d\u003d 1) {\n-            Object value;\n-            if (object instanceof List) {\n-                value \u003d ((List) object).get(0);\n+        } else {\n+            if (((Collection) object).size() \u003e 0) {\n+                Object value;\n+                if (object instanceof List) {\n+                    value \u003d ((List) object).get(0);\n+                } else {\n+                    Iterator it \u003d ((Collection) object).iterator();\n+                    value \u003d it.next();\n+                }\n+                return canConvert(value, toType);\n             } else {\n-                Iterator it \u003d ((Collection) object).iterator();\n-                value \u003d it.next();\n+                return canConvert(\"\", toType);\n             }\n-            return canConvert(value, toType);\n         }\n     } else if (object instanceof NodeSet) {\n         return canConvert(((NodeSet) object).getValues(), toType);\n     } else if (object instanceof Pointer) {\n         return canConvert(((Pointer) object).getValue(), toType);\n     }\n     return false;\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "4ab5b9e453d0e0ef51fc1d36a5e21aaf21b44c81": {
      "type": "Ybodychange",
      "commitMessage": "Improved handling of collections as arguments of extension functions\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/jakarta/commons/proper/jxpath/trunk@136850 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "2/6/03, 4:51 PM",
      "commitName": "4ab5b9e453d0e0ef51fc1d36a5e21aaf21b44c81",
      "commitAuthor": "Dmitri Plotnikov",
      "commitDateOld": "1/29/03, 9:55 AM",
      "commitNameOld": "348acabaadc57e04f25de5c79c72bc34a4e41723",
      "commitAuthorOld": "Dmitri Plotnikov",
      "daysBetweenCommits": 8.29,
      "commitsBetweenForRepo": 4,
      "commitsBetweenForFile": 1,
      "actualSource": "public boolean canConvert(Object object, Class toType) {\n    if (object \u003d\u003d null) {\n        return true;\n    }\n    if (toType \u003d\u003d Object.class) {\n        return true;\n    }\n    Class fromType \u003d object.getClass();\n    if (fromType.equals(toType)) {\n        return true;\n    }\n    if (toType.isAssignableFrom(fromType)) {\n        return true;\n    }\n    if (toType \u003d\u003d String.class) {\n        return true;\n    }\n    if (object instanceof Boolean) {\n        if (toType \u003d\u003d boolean.class || Number.class.isAssignableFrom(toType)) {\n            return true;\n        }\n    } else if (object instanceof Number) {\n        if (toType.isPrimitive() || Number.class.isAssignableFrom(toType)) {\n            return true;\n        }\n    } else if (object instanceof Character) {\n        if (toType \u003d\u003d char.class) {\n            return true;\n        }\n    } else if (object instanceof String) {\n        if (toType.isPrimitive()) {\n            return true;\n        }\n        if (toType \u003d\u003d Boolean.class || toType \u003d\u003d Character.class || toType \u003d\u003d Byte.class || toType \u003d\u003d Short.class || toType \u003d\u003d Integer.class || toType \u003d\u003d Long.class || toType \u003d\u003d Float.class || toType \u003d\u003d Double.class) {\n            return true;\n        }\n    } else if (fromType.isArray()) {\n        if (toType.isArray()) {\n            Class cType \u003d toType.getComponentType();\n            int length \u003d Array.getLength(object);\n            for (int i \u003d 0; i \u003c length; i++) {\n                Object value \u003d Array.get(object, i);\n                if (!canConvert(value, cType)) {\n                    return false;\n                }\n            }\n            return true;\n        } else if (Collection.class.isAssignableFrom(toType)) {\n            return canCreateCollection(toType);\n        } else if (Array.getLength(object) \u003d\u003d 1) {\n            Object value \u003d Array.get(object, 0);\n            return canConvert(value, toType);\n        }\n    } else if (object instanceof Collection) {\n        if (toType.isArray()) {\n            Class cType \u003d toType.getComponentType();\n            Iterator it \u003d ((Collection) object).iterator();\n            while (it.hasNext()) {\n                Object value \u003d it.next();\n                if (!canConvert(value, cType)) {\n                    return false;\n                }\n            }\n            return true;\n        } else if (Collection.class.isAssignableFrom(toType)) {\n            return canCreateCollection(toType);\n        } else if (((Collection) object).size() \u003d\u003d 1) {\n            Object value;\n            if (object instanceof List) {\n                value \u003d ((List) object).get(0);\n            } else {\n                Iterator it \u003d ((Collection) object).iterator();\n                value \u003d it.next();\n            }\n            return canConvert(value, toType);\n        }\n    } else if (object instanceof NodeSet) {\n        return canConvert(((NodeSet) object).getValues(), toType);\n    } else if (object instanceof Pointer) {\n        return canConvert(((Pointer) object).getValue(), toType);\n    }\n    return false;\n}",
      "path": "src/java/org/apache/commons/jxpath/util/BasicTypeConverter.java",
      "functionStartLine": 90,
      "functionName": "canConvert",
      "functionAnnotation": "",
      "functionDoc": "Returns true if it can convert the supplied\nobject to the specified class.\n",
      "diff": "@@ -1,81 +1,83 @@\n public boolean canConvert(Object object, Class toType) {\n     if (object \u003d\u003d null) {\n         return true;\n     }\n     if (toType \u003d\u003d Object.class) {\n         return true;\n     }\n     Class fromType \u003d object.getClass();\n     if (fromType.equals(toType)) {\n         return true;\n     }\n     if (toType.isAssignableFrom(fromType)) {\n         return true;\n     }\n     if (toType \u003d\u003d String.class) {\n         return true;\n     }\n     if (object instanceof Boolean) {\n         if (toType \u003d\u003d boolean.class || Number.class.isAssignableFrom(toType)) {\n             return true;\n         }\n     } else if (object instanceof Number) {\n         if (toType.isPrimitive() || Number.class.isAssignableFrom(toType)) {\n             return true;\n         }\n     } else if (object instanceof Character) {\n         if (toType \u003d\u003d char.class) {\n             return true;\n         }\n     } else if (object instanceof String) {\n         if (toType.isPrimitive()) {\n             return true;\n         }\n         if (toType \u003d\u003d Boolean.class || toType \u003d\u003d Character.class || toType \u003d\u003d Byte.class || toType \u003d\u003d Short.class || toType \u003d\u003d Integer.class || toType \u003d\u003d Long.class || toType \u003d\u003d Float.class || toType \u003d\u003d Double.class) {\n             return true;\n         }\n     } else if (fromType.isArray()) {\n         if (toType.isArray()) {\n             Class cType \u003d toType.getComponentType();\n             int length \u003d Array.getLength(object);\n             for (int i \u003d 0; i \u003c length; i++) {\n                 Object value \u003d Array.get(object, i);\n                 if (!canConvert(value, cType)) {\n                     return false;\n                 }\n             }\n             return true;\n         } else if (Collection.class.isAssignableFrom(toType)) {\n             return canCreateCollection(toType);\n         } else if (Array.getLength(object) \u003d\u003d 1) {\n             Object value \u003d Array.get(object, 0);\n             return canConvert(value, toType);\n         }\n     } else if (object instanceof Collection) {\n         if (toType.isArray()) {\n             Class cType \u003d toType.getComponentType();\n             Iterator it \u003d ((Collection) object).iterator();\n             while (it.hasNext()) {\n                 Object value \u003d it.next();\n                 if (!canConvert(value, cType)) {\n                     return false;\n                 }\n             }\n             return true;\n         } else if (Collection.class.isAssignableFrom(toType)) {\n             return canCreateCollection(toType);\n         } else if (((Collection) object).size() \u003d\u003d 1) {\n             Object value;\n             if (object instanceof List) {\n                 value \u003d ((List) object).get(0);\n             } else {\n                 Iterator it \u003d ((Collection) object).iterator();\n                 value \u003d it.next();\n             }\n             return canConvert(value, toType);\n         }\n+    } else if (object instanceof NodeSet) {\n+        return canConvert(((NodeSet) object).getValues(), toType);\n     } else if (object instanceof Pointer) {\n         return canConvert(((Pointer) object).getValue(), toType);\n     }\n     return false;\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "348acabaadc57e04f25de5c79c72bc34a4e41723": {
      "type": "Ybodychange",
      "commitMessage": "Fixed type conversion issues with extension functions\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/jakarta/commons/proper/jxpath/trunk@136845 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "1/29/03, 9:55 AM",
      "commitName": "348acabaadc57e04f25de5c79c72bc34a4e41723",
      "commitAuthor": "Dmitri Plotnikov",
      "commitDateOld": "1/10/03, 9:41 PM",
      "commitNameOld": "2327c42440cd4927ac5fc91ed93756cb0c87c96d",
      "commitAuthorOld": "Dmitri Plotnikov",
      "daysBetweenCommits": 18.51,
      "commitsBetweenForRepo": 11,
      "commitsBetweenForFile": 1,
      "actualSource": "public boolean canConvert(Object object, Class toType) {\n    if (object \u003d\u003d null) {\n        return true;\n    }\n    if (toType \u003d\u003d Object.class) {\n        return true;\n    }\n    Class fromType \u003d object.getClass();\n    if (fromType.equals(toType)) {\n        return true;\n    }\n    if (toType.isAssignableFrom(fromType)) {\n        return true;\n    }\n    if (toType \u003d\u003d String.class) {\n        return true;\n    }\n    if (object instanceof Boolean) {\n        if (toType \u003d\u003d boolean.class || Number.class.isAssignableFrom(toType)) {\n            return true;\n        }\n    } else if (object instanceof Number) {\n        if (toType.isPrimitive() || Number.class.isAssignableFrom(toType)) {\n            return true;\n        }\n    } else if (object instanceof Character) {\n        if (toType \u003d\u003d char.class) {\n            return true;\n        }\n    } else if (object instanceof String) {\n        if (toType.isPrimitive()) {\n            return true;\n        }\n        if (toType \u003d\u003d Boolean.class || toType \u003d\u003d Character.class || toType \u003d\u003d Byte.class || toType \u003d\u003d Short.class || toType \u003d\u003d Integer.class || toType \u003d\u003d Long.class || toType \u003d\u003d Float.class || toType \u003d\u003d Double.class) {\n            return true;\n        }\n    } else if (fromType.isArray()) {\n        if (toType.isArray()) {\n            Class cType \u003d toType.getComponentType();\n            int length \u003d Array.getLength(object);\n            for (int i \u003d 0; i \u003c length; i++) {\n                Object value \u003d Array.get(object, i);\n                if (!canConvert(value, cType)) {\n                    return false;\n                }\n            }\n            return true;\n        } else if (Collection.class.isAssignableFrom(toType)) {\n            return canCreateCollection(toType);\n        } else if (Array.getLength(object) \u003d\u003d 1) {\n            Object value \u003d Array.get(object, 0);\n            return canConvert(value, toType);\n        }\n    } else if (object instanceof Collection) {\n        if (toType.isArray()) {\n            Class cType \u003d toType.getComponentType();\n            Iterator it \u003d ((Collection) object).iterator();\n            while (it.hasNext()) {\n                Object value \u003d it.next();\n                if (!canConvert(value, cType)) {\n                    return false;\n                }\n            }\n            return true;\n        } else if (Collection.class.isAssignableFrom(toType)) {\n            return canCreateCollection(toType);\n        } else if (((Collection) object).size() \u003d\u003d 1) {\n            Object value;\n            if (object instanceof List) {\n                value \u003d ((List) object).get(0);\n            } else {\n                Iterator it \u003d ((Collection) object).iterator();\n                value \u003d it.next();\n            }\n            return canConvert(value, toType);\n        }\n    } else if (object instanceof Pointer) {\n        return canConvert(((Pointer) object).getValue(), toType);\n    }\n    return false;\n}",
      "path": "src/java/org/apache/commons/jxpath/util/BasicTypeConverter.java",
      "functionStartLine": 83,
      "functionName": "canConvert",
      "functionAnnotation": "",
      "functionDoc": "Returns true if it can convert the supplied\nobject to the specified class.\n",
      "diff": "@@ -1,88 +1,81 @@\n public boolean canConvert(Object object, Class toType) {\n     if (object \u003d\u003d null) {\n         return true;\n     }\n     if (toType \u003d\u003d Object.class) {\n         return true;\n     }\n     Class fromType \u003d object.getClass();\n     if (fromType.equals(toType)) {\n         return true;\n     }\n     if (toType.isAssignableFrom(fromType)) {\n         return true;\n     }\n     if (toType \u003d\u003d String.class) {\n         return true;\n     }\n     if (object instanceof Boolean) {\n         if (toType \u003d\u003d boolean.class || Number.class.isAssignableFrom(toType)) {\n             return true;\n         }\n     } else if (object instanceof Number) {\n         if (toType.isPrimitive() || Number.class.isAssignableFrom(toType)) {\n             return true;\n         }\n     } else if (object instanceof Character) {\n         if (toType \u003d\u003d char.class) {\n             return true;\n         }\n     } else if (object instanceof String) {\n         if (toType.isPrimitive()) {\n             return true;\n         }\n         if (toType \u003d\u003d Boolean.class || toType \u003d\u003d Character.class || toType \u003d\u003d Byte.class || toType \u003d\u003d Short.class || toType \u003d\u003d Integer.class || toType \u003d\u003d Long.class || toType \u003d\u003d Float.class || toType \u003d\u003d Double.class) {\n             return true;\n         }\n-    } else if (object instanceof ExpressionContext) {\n-        if (Collection.class.isAssignableFrom(toType)) {\n-            return true;\n-        }\n-        Pointer pointer \u003d ((ExpressionContext) object).getContextNodePointer();\n-        if (pointer !\u003d null) {\n-            Object value \u003d pointer.getValue();\n-            return canConvert(value, toType);\n-        }\n     } else if (fromType.isArray()) {\n         if (toType.isArray()) {\n             Class cType \u003d toType.getComponentType();\n             int length \u003d Array.getLength(object);\n             for (int i \u003d 0; i \u003c length; i++) {\n                 Object value \u003d Array.get(object, i);\n                 if (!canConvert(value, cType)) {\n                     return false;\n                 }\n             }\n             return true;\n         } else if (Collection.class.isAssignableFrom(toType)) {\n             return canCreateCollection(toType);\n         } else if (Array.getLength(object) \u003d\u003d 1) {\n             Object value \u003d Array.get(object, 0);\n             return canConvert(value, toType);\n         }\n     } else if (object instanceof Collection) {\n         if (toType.isArray()) {\n             Class cType \u003d toType.getComponentType();\n             Iterator it \u003d ((Collection) object).iterator();\n             while (it.hasNext()) {\n                 Object value \u003d it.next();\n                 if (!canConvert(value, cType)) {\n                     return false;\n                 }\n             }\n             return true;\n         } else if (Collection.class.isAssignableFrom(toType)) {\n             return canCreateCollection(toType);\n         } else if (((Collection) object).size() \u003d\u003d 1) {\n             Object value;\n             if (object instanceof List) {\n                 value \u003d ((List) object).get(0);\n             } else {\n                 Iterator it \u003d ((Collection) object).iterator();\n                 value \u003d it.next();\n             }\n             return canConvert(value, toType);\n         }\n+    } else if (object instanceof Pointer) {\n+        return canConvert(((Pointer) object).getValue(), toType);\n     }\n     return false;\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "2327c42440cd4927ac5fc91ed93756cb0c87c96d": {
      "type": "Yformatchange",
      "commitMessage": "Checkstyle, be happy!\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/jakarta/commons/proper/jxpath/trunk@136834 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "1/10/03, 9:41 PM",
      "commitName": "2327c42440cd4927ac5fc91ed93756cb0c87c96d",
      "commitAuthor": "Dmitri Plotnikov",
      "commitDateOld": "6/15/02, 8:22 PM",
      "commitNameOld": "ab914f400352a3a525ba0a5d189eb2e4e1ade268",
      "commitAuthorOld": "Dmitri Plotnikov",
      "daysBetweenCommits": 209.1,
      "commitsBetweenForRepo": 65,
      "commitsBetweenForFile": 1,
      "actualSource": "public boolean canConvert(Object object, Class toType) {\n    if (object \u003d\u003d null) {\n        return true;\n    }\n    if (toType \u003d\u003d Object.class) {\n        return true;\n    }\n    Class fromType \u003d object.getClass();\n    if (fromType.equals(toType)) {\n        return true;\n    }\n    if (toType.isAssignableFrom(fromType)) {\n        return true;\n    }\n    if (toType \u003d\u003d String.class) {\n        return true;\n    }\n    if (object instanceof Boolean) {\n        if (toType \u003d\u003d boolean.class || Number.class.isAssignableFrom(toType)) {\n            return true;\n        }\n    } else if (object instanceof Number) {\n        if (toType.isPrimitive() || Number.class.isAssignableFrom(toType)) {\n            return true;\n        }\n    } else if (object instanceof Character) {\n        if (toType \u003d\u003d char.class) {\n            return true;\n        }\n    } else if (object instanceof String) {\n        if (toType.isPrimitive()) {\n            return true;\n        }\n        if (toType \u003d\u003d Boolean.class || toType \u003d\u003d Character.class || toType \u003d\u003d Byte.class || toType \u003d\u003d Short.class || toType \u003d\u003d Integer.class || toType \u003d\u003d Long.class || toType \u003d\u003d Float.class || toType \u003d\u003d Double.class) {\n            return true;\n        }\n    } else if (object instanceof ExpressionContext) {\n        if (Collection.class.isAssignableFrom(toType)) {\n            return true;\n        }\n        Pointer pointer \u003d ((ExpressionContext) object).getContextNodePointer();\n        if (pointer !\u003d null) {\n            Object value \u003d pointer.getValue();\n            return canConvert(value, toType);\n        }\n    } else if (fromType.isArray()) {\n        if (toType.isArray()) {\n            Class cType \u003d toType.getComponentType();\n            int length \u003d Array.getLength(object);\n            for (int i \u003d 0; i \u003c length; i++) {\n                Object value \u003d Array.get(object, i);\n                if (!canConvert(value, cType)) {\n                    return false;\n                }\n            }\n            return true;\n        } else if (Collection.class.isAssignableFrom(toType)) {\n            return canCreateCollection(toType);\n        } else if (Array.getLength(object) \u003d\u003d 1) {\n            Object value \u003d Array.get(object, 0);\n            return canConvert(value, toType);\n        }\n    } else if (object instanceof Collection) {\n        if (toType.isArray()) {\n            Class cType \u003d toType.getComponentType();\n            Iterator it \u003d ((Collection) object).iterator();\n            while (it.hasNext()) {\n                Object value \u003d it.next();\n                if (!canConvert(value, cType)) {\n                    return false;\n                }\n            }\n            return true;\n        } else if (Collection.class.isAssignableFrom(toType)) {\n            return canCreateCollection(toType);\n        } else if (((Collection) object).size() \u003d\u003d 1) {\n            Object value;\n            if (object instanceof List) {\n                value \u003d ((List) object).get(0);\n            } else {\n                Iterator it \u003d ((Collection) object).iterator();\n                value \u003d it.next();\n            }\n            return canConvert(value, toType);\n        }\n    }\n    return false;\n}",
      "path": "src/java/org/apache/commons/jxpath/util/BasicTypeConverter.java",
      "functionStartLine": 90,
      "functionName": "canConvert",
      "functionAnnotation": "",
      "functionDoc": "Returns true if it can convert the supplied\nobject to the specified class.\n",
      "diff": "",
      "extendedDetails": {}
    },
    "73f1fffe48c5f26e2c29280385bf0e8f2b9627ac": {
      "type": "Yintroduced",
      "commitMessage": "Made type converter configurable\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/jakarta/commons/proper/jxpath/trunk@136766 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "6/12/02, 2:02 PM",
      "commitName": "73f1fffe48c5f26e2c29280385bf0e8f2b9627ac",
      "commitAuthor": "Dmitri Plotnikov",
      "diff": "@@ -0,0 +1,88 @@\n+public boolean canConvert(Object object, Class toType) {\n+    if (object \u003d\u003d null) {\n+        return true;\n+    }\n+    if (toType \u003d\u003d Object.class) {\n+        return true;\n+    }\n+    Class fromType \u003d object.getClass();\n+    if (fromType.equals(toType)) {\n+        return true;\n+    }\n+    if (toType.isAssignableFrom(fromType)) {\n+        return true;\n+    }\n+    if (toType \u003d\u003d String.class) {\n+        return true;\n+    }\n+    if (object instanceof Boolean) {\n+        if (toType \u003d\u003d boolean.class || Number.class.isAssignableFrom(toType)) {\n+            return true;\n+        }\n+    } else if (object instanceof Number) {\n+        if (toType.isPrimitive() || Number.class.isAssignableFrom(toType)) {\n+            return true;\n+        }\n+    } else if (object instanceof Character) {\n+        if (toType \u003d\u003d char.class) {\n+            return true;\n+        }\n+    } else if (object instanceof String) {\n+        if (toType.isPrimitive()) {\n+            return true;\n+        }\n+        if (toType \u003d\u003d Boolean.class || toType \u003d\u003d Character.class || toType \u003d\u003d Byte.class || toType \u003d\u003d Short.class || toType \u003d\u003d Integer.class || toType \u003d\u003d Long.class || toType \u003d\u003d Float.class || toType \u003d\u003d Double.class) {\n+            return true;\n+        }\n+    } else if (object instanceof ExpressionContext) {\n+        if (Collection.class.isAssignableFrom(toType)) {\n+            return true;\n+        }\n+        Pointer pointer \u003d ((ExpressionContext) object).getContextNodePointer();\n+        if (pointer !\u003d null) {\n+            Object value \u003d pointer.getValue();\n+            return canConvert(value, toType);\n+        }\n+    } else if (fromType.isArray()) {\n+        if (toType.isArray()) {\n+            Class cType \u003d toType.getComponentType();\n+            int length \u003d Array.getLength(object);\n+            for (int i \u003d 0; i \u003c length; i++) {\n+                Object value \u003d Array.get(object, i);\n+                if (!canConvert(value, cType)) {\n+                    return false;\n+                }\n+            }\n+            return true;\n+        } else if (Collection.class.isAssignableFrom(toType)) {\n+            return canCreateCollection(toType);\n+        } else if (Array.getLength(object) \u003d\u003d 1) {\n+            Object value \u003d Array.get(object, 0);\n+            return canConvert(value, toType);\n+        }\n+    } else if (object instanceof Collection) {\n+        if (toType.isArray()) {\n+            Class cType \u003d toType.getComponentType();\n+            Iterator it \u003d ((Collection) object).iterator();\n+            while (it.hasNext()) {\n+                Object value \u003d it.next();\n+                if (!canConvert(value, cType)) {\n+                    return false;\n+                }\n+            }\n+            return true;\n+        } else if (Collection.class.isAssignableFrom(toType)) {\n+            return canCreateCollection(toType);\n+        } else if (((Collection) object).size() \u003d\u003d 1) {\n+            Object value;\n+            if (object instanceof List) {\n+                value \u003d ((List) object).get(0);\n+            } else {\n+                Iterator it \u003d ((Collection) object).iterator();\n+                value \u003d it.next();\n+            }\n+            return canConvert(value, toType);\n+        }\n+    }\n+    return false;\n+}\n\\ No newline at end of file\n",
      "actualSource": "public boolean canConvert(Object object, Class toType) {\n    if (object \u003d\u003d null) {\n        return true;\n    }\n    if (toType \u003d\u003d Object.class) {\n        return true;\n    }\n    Class fromType \u003d object.getClass();\n    if (fromType.equals(toType)) {\n        return true;\n    }\n    if (toType.isAssignableFrom(fromType)) {\n        return true;\n    }\n    if (toType \u003d\u003d String.class) {\n        return true;\n    }\n    if (object instanceof Boolean) {\n        if (toType \u003d\u003d boolean.class || Number.class.isAssignableFrom(toType)) {\n            return true;\n        }\n    } else if (object instanceof Number) {\n        if (toType.isPrimitive() || Number.class.isAssignableFrom(toType)) {\n            return true;\n        }\n    } else if (object instanceof Character) {\n        if (toType \u003d\u003d char.class) {\n            return true;\n        }\n    } else if (object instanceof String) {\n        if (toType.isPrimitive()) {\n            return true;\n        }\n        if (toType \u003d\u003d Boolean.class || toType \u003d\u003d Character.class || toType \u003d\u003d Byte.class || toType \u003d\u003d Short.class || toType \u003d\u003d Integer.class || toType \u003d\u003d Long.class || toType \u003d\u003d Float.class || toType \u003d\u003d Double.class) {\n            return true;\n        }\n    } else if (object instanceof ExpressionContext) {\n        if (Collection.class.isAssignableFrom(toType)) {\n            return true;\n        }\n        Pointer pointer \u003d ((ExpressionContext) object).getContextNodePointer();\n        if (pointer !\u003d null) {\n            Object value \u003d pointer.getValue();\n            return canConvert(value, toType);\n        }\n    } else if (fromType.isArray()) {\n        if (toType.isArray()) {\n            Class cType \u003d toType.getComponentType();\n            int length \u003d Array.getLength(object);\n            for (int i \u003d 0; i \u003c length; i++) {\n                Object value \u003d Array.get(object, i);\n                if (!canConvert(value, cType)) {\n                    return false;\n                }\n            }\n            return true;\n        } else if (Collection.class.isAssignableFrom(toType)) {\n            return canCreateCollection(toType);\n        } else if (Array.getLength(object) \u003d\u003d 1) {\n            Object value \u003d Array.get(object, 0);\n            return canConvert(value, toType);\n        }\n    } else if (object instanceof Collection) {\n        if (toType.isArray()) {\n            Class cType \u003d toType.getComponentType();\n            Iterator it \u003d ((Collection) object).iterator();\n            while (it.hasNext()) {\n                Object value \u003d it.next();\n                if (!canConvert(value, cType)) {\n                    return false;\n                }\n            }\n            return true;\n        } else if (Collection.class.isAssignableFrom(toType)) {\n            return canCreateCollection(toType);\n        } else if (((Collection) object).size() \u003d\u003d 1) {\n            Object value;\n            if (object instanceof List) {\n                value \u003d ((List) object).get(0);\n            } else {\n                Iterator it \u003d ((Collection) object).iterator();\n                value \u003d it.next();\n            }\n            return canConvert(value, toType);\n        }\n    }\n    return false;\n}",
      "path": "src/java/org/apache/commons/jxpath/util/BasicTypeConverter.java",
      "functionStartLine": 82,
      "functionName": "canConvert",
      "functionAnnotation": "",
      "functionDoc": "Returns true if it can convert the supplied\nobject to the specified class.\n"
    }
  }
}