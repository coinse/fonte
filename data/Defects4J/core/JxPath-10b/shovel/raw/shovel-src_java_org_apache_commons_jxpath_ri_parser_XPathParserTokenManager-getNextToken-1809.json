{
  "origin": "codeshovel",
  "repositoryName": "JxPath-10b",
  "repositoryPath": "/tmp/JxPath-10b//.git",
  "startCommitName": "HEAD",
  "sourceFileName": "XPathParserTokenManager.java",
  "functionName": "getNextToken",
  "functionId": "getNextToken",
  "sourceFilePath": "src/java/org/apache/commons/jxpath/ri/parser/XPathParserTokenManager.java",
  "functionAnnotation": "",
  "functionDoc": "",
  "functionStartLine": 1809,
  "functionEndLine": 1873,
  "numCommitsSeen": 6,
  "timeTaken": 946,
  "changeHistory": [
    "6b424e974f9e68987125d1d489731366bee87031",
    "5bbe586b1063ebafc02e20ca0b6b47465c9b9f06",
    "bc53a66311b9b22e471dd74860c7df75eebe9837"
  ],
  "changeHistoryShort": {
    "6b424e974f9e68987125d1d489731366bee87031": "Ymodifierchange",
    "5bbe586b1063ebafc02e20ca0b6b47465c9b9f06": "Ybodychange",
    "bc53a66311b9b22e471dd74860c7df75eebe9837": "Yintroduced"
  },
  "changeHistoryDetails": {
    "6b424e974f9e68987125d1d489731366bee87031": {
      "type": "Ymodifierchange",
      "commitMessage": "Upgraded to JavaCC 3.0, enabled optimizations\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/jakarta/commons/proper/jxpath/trunk@136861 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "5/4/03, 4:48 PM",
      "commitName": "6b424e974f9e68987125d1d489731366bee87031",
      "commitAuthor": "Dmitri Plotnikov",
      "commitDateOld": "3/24/03, 6:28 PM",
      "commitNameOld": "5bbe586b1063ebafc02e20ca0b6b47465c9b9f06",
      "commitAuthorOld": "Dmitri Plotnikov",
      "daysBetweenCommits": 40.89,
      "commitsBetweenForRepo": 2,
      "commitsBetweenForFile": 1,
      "actualSource": "public Token getNextToken() {\n    int kind;\n    Token specialToken \u003d null;\n    Token matchedToken;\n    int curPos \u003d 0;\n    EOFLoop: for (; ; ) {\n        try {\n            curChar \u003d input_stream.BeginToken();\n        } catch (java.io.IOException e) {\n            jjmatchedKind \u003d 0;\n            matchedToken \u003d jjFillToken();\n            return matchedToken;\n        }\n        try {\n            input_stream.backup(0);\n            while (curChar \u003c\u003d 32 \u0026\u0026 (0x100003600L \u0026 (1L \u003c\u003c curChar)) !\u003d 0L) curChar \u003d input_stream.BeginToken();\n        } catch (java.io.IOException e1) {\n            continue EOFLoop;\n        }\n        jjmatchedKind \u003d 0x7fffffff;\n        jjmatchedPos \u003d 0;\n        curPos \u003d jjMoveStringLiteralDfa0_0();\n        if (jjmatchedKind !\u003d 0x7fffffff) {\n            if (jjmatchedPos + 1 \u003c curPos)\n                input_stream.backup(curPos - jjmatchedPos - 1);\n            if ((jjtoToken[jjmatchedKind \u003e\u003e 6] \u0026 (1L \u003c\u003c (jjmatchedKind \u0026 077))) !\u003d 0L) {\n                matchedToken \u003d jjFillToken();\n                return matchedToken;\n            } else {\n                continue EOFLoop;\n            }\n        }\n        int error_line \u003d input_stream.getEndLine();\n        int error_column \u003d input_stream.getEndColumn();\n        String error_after \u003d null;\n        boolean EOFSeen \u003d false;\n        try {\n            input_stream.readChar();\n            input_stream.backup(1);\n        } catch (java.io.IOException e1) {\n            EOFSeen \u003d true;\n            error_after \u003d curPos \u003c\u003d 1 ? \"\" : input_stream.GetImage();\n            if (curChar \u003d\u003d \u0027\\n\u0027 || curChar \u003d\u003d \u0027\\r\u0027) {\n                error_line++;\n                error_column \u003d 0;\n            } else\n                error_column++;\n        }\n        if (!EOFSeen) {\n            input_stream.backup(1);\n            error_after \u003d curPos \u003c\u003d 1 ? \"\" : input_stream.GetImage();\n        }\n        throw new TokenMgrError(EOFSeen, curLexState, error_line, error_column, error_after, curChar, TokenMgrError.LEXICAL_ERROR);\n    }\n}",
      "path": "src/java/org/apache/commons/jxpath/ri/parser/XPathParserTokenManager.java",
      "functionStartLine": 1809,
      "functionName": "getNextToken",
      "functionAnnotation": "",
      "functionDoc": "",
      "diff": "@@ -1,55 +1,55 @@\n-public final Token getNextToken() {\n+public Token getNextToken() {\n     int kind;\n     Token specialToken \u003d null;\n     Token matchedToken;\n     int curPos \u003d 0;\n     EOFLoop: for (; ; ) {\n         try {\n             curChar \u003d input_stream.BeginToken();\n         } catch (java.io.IOException e) {\n             jjmatchedKind \u003d 0;\n             matchedToken \u003d jjFillToken();\n             return matchedToken;\n         }\n         try {\n             input_stream.backup(0);\n             while (curChar \u003c\u003d 32 \u0026\u0026 (0x100003600L \u0026 (1L \u003c\u003c curChar)) !\u003d 0L) curChar \u003d input_stream.BeginToken();\n         } catch (java.io.IOException e1) {\n             continue EOFLoop;\n         }\n         jjmatchedKind \u003d 0x7fffffff;\n         jjmatchedPos \u003d 0;\n         curPos \u003d jjMoveStringLiteralDfa0_0();\n         if (jjmatchedKind !\u003d 0x7fffffff) {\n             if (jjmatchedPos + 1 \u003c curPos)\n                 input_stream.backup(curPos - jjmatchedPos - 1);\n             if ((jjtoToken[jjmatchedKind \u003e\u003e 6] \u0026 (1L \u003c\u003c (jjmatchedKind \u0026 077))) !\u003d 0L) {\n                 matchedToken \u003d jjFillToken();\n                 return matchedToken;\n             } else {\n                 continue EOFLoop;\n             }\n         }\n         int error_line \u003d input_stream.getEndLine();\n         int error_column \u003d input_stream.getEndColumn();\n         String error_after \u003d null;\n         boolean EOFSeen \u003d false;\n         try {\n             input_stream.readChar();\n             input_stream.backup(1);\n         } catch (java.io.IOException e1) {\n             EOFSeen \u003d true;\n             error_after \u003d curPos \u003c\u003d 1 ? \"\" : input_stream.GetImage();\n             if (curChar \u003d\u003d \u0027\\n\u0027 || curChar \u003d\u003d \u0027\\r\u0027) {\n                 error_line++;\n                 error_column \u003d 0;\n             } else\n                 error_column++;\n         }\n         if (!EOFSeen) {\n             input_stream.backup(1);\n             error_after \u003d curPos \u003c\u003d 1 ? \"\" : input_stream.GetImage();\n         }\n         throw new TokenMgrError(EOFSeen, curLexState, error_line, error_column, error_after, curChar, TokenMgrError.LEXICAL_ERROR);\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {
        "oldValue": "[public, final]",
        "newValue": "[public]"
      }
    },
    "5bbe586b1063ebafc02e20ca0b6b47465c9b9f06": {
      "type": "Ybodychange",
      "commitMessage": "Optimized parser by using SKIP instead of SPECIAL_CHARACTER\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/jakarta/commons/proper/jxpath/trunk@136859 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "3/24/03, 6:28 PM",
      "commitName": "5bbe586b1063ebafc02e20ca0b6b47465c9b9f06",
      "commitAuthor": "Dmitri Plotnikov",
      "commitDateOld": "1/24/03, 5:49 PM",
      "commitNameOld": "e5a284c0486a8b2a4289605939074cc6ddf9df44",
      "commitAuthorOld": "Dmitri Plotnikov",
      "daysBetweenCommits": 59.03,
      "commitsBetweenForRepo": 13,
      "commitsBetweenForFile": 1,
      "actualSource": "public final Token getNextToken() {\n    int kind;\n    Token specialToken \u003d null;\n    Token matchedToken;\n    int curPos \u003d 0;\n    EOFLoop: for (; ; ) {\n        try {\n            curChar \u003d input_stream.BeginToken();\n        } catch (java.io.IOException e) {\n            jjmatchedKind \u003d 0;\n            matchedToken \u003d jjFillToken();\n            return matchedToken;\n        }\n        try {\n            input_stream.backup(0);\n            while (curChar \u003c\u003d 32 \u0026\u0026 (0x100003600L \u0026 (1L \u003c\u003c curChar)) !\u003d 0L) curChar \u003d input_stream.BeginToken();\n        } catch (java.io.IOException e1) {\n            continue EOFLoop;\n        }\n        jjmatchedKind \u003d 0x7fffffff;\n        jjmatchedPos \u003d 0;\n        curPos \u003d jjMoveStringLiteralDfa0_0();\n        if (jjmatchedKind !\u003d 0x7fffffff) {\n            if (jjmatchedPos + 1 \u003c curPos)\n                input_stream.backup(curPos - jjmatchedPos - 1);\n            if ((jjtoToken[jjmatchedKind \u003e\u003e 6] \u0026 (1L \u003c\u003c (jjmatchedKind \u0026 077))) !\u003d 0L) {\n                matchedToken \u003d jjFillToken();\n                return matchedToken;\n            } else {\n                continue EOFLoop;\n            }\n        }\n        int error_line \u003d input_stream.getEndLine();\n        int error_column \u003d input_stream.getEndColumn();\n        String error_after \u003d null;\n        boolean EOFSeen \u003d false;\n        try {\n            input_stream.readChar();\n            input_stream.backup(1);\n        } catch (java.io.IOException e1) {\n            EOFSeen \u003d true;\n            error_after \u003d curPos \u003c\u003d 1 ? \"\" : input_stream.GetImage();\n            if (curChar \u003d\u003d \u0027\\n\u0027 || curChar \u003d\u003d \u0027\\r\u0027) {\n                error_line++;\n                error_column \u003d 0;\n            } else\n                error_column++;\n        }\n        if (!EOFSeen) {\n            input_stream.backup(1);\n            error_after \u003d curPos \u003c\u003d 1 ? \"\" : input_stream.GetImage();\n        }\n        throw new TokenMgrError(EOFSeen, curLexState, error_line, error_column, error_after, curChar, TokenMgrError.LEXICAL_ERROR);\n    }\n}",
      "path": "src/java/org/apache/commons/jxpath/ri/parser/XPathParserTokenManager.java",
      "functionStartLine": 1809,
      "functionName": "getNextToken",
      "functionAnnotation": "",
      "functionDoc": "",
      "diff": "@@ -1,60 +1,55 @@\n public final Token getNextToken() {\n     int kind;\n     Token specialToken \u003d null;\n     Token matchedToken;\n     int curPos \u003d 0;\n     EOFLoop: for (; ; ) {\n         try {\n             curChar \u003d input_stream.BeginToken();\n         } catch (java.io.IOException e) {\n             jjmatchedKind \u003d 0;\n             matchedToken \u003d jjFillToken();\n-            matchedToken.specialToken \u003d specialToken;\n             return matchedToken;\n         }\n+        try {\n+            input_stream.backup(0);\n+            while (curChar \u003c\u003d 32 \u0026\u0026 (0x100003600L \u0026 (1L \u003c\u003c curChar)) !\u003d 0L) curChar \u003d input_stream.BeginToken();\n+        } catch (java.io.IOException e1) {\n+            continue EOFLoop;\n+        }\n         jjmatchedKind \u003d 0x7fffffff;\n         jjmatchedPos \u003d 0;\n         curPos \u003d jjMoveStringLiteralDfa0_0();\n         if (jjmatchedKind !\u003d 0x7fffffff) {\n             if (jjmatchedPos + 1 \u003c curPos)\n                 input_stream.backup(curPos - jjmatchedPos - 1);\n             if ((jjtoToken[jjmatchedKind \u003e\u003e 6] \u0026 (1L \u003c\u003c (jjmatchedKind \u0026 077))) !\u003d 0L) {\n                 matchedToken \u003d jjFillToken();\n-                matchedToken.specialToken \u003d specialToken;\n                 return matchedToken;\n             } else {\n-                if ((jjtoSpecial[jjmatchedKind \u003e\u003e 6] \u0026 (1L \u003c\u003c (jjmatchedKind \u0026 077))) !\u003d 0L) {\n-                    matchedToken \u003d jjFillToken();\n-                    if (specialToken \u003d\u003d null)\n-                        specialToken \u003d matchedToken;\n-                    else {\n-                        matchedToken.specialToken \u003d specialToken;\n-                        specialToken \u003d (specialToken.next \u003d matchedToken);\n-                    }\n-                }\n                 continue EOFLoop;\n             }\n         }\n         int error_line \u003d input_stream.getEndLine();\n         int error_column \u003d input_stream.getEndColumn();\n         String error_after \u003d null;\n         boolean EOFSeen \u003d false;\n         try {\n             input_stream.readChar();\n             input_stream.backup(1);\n         } catch (java.io.IOException e1) {\n             EOFSeen \u003d true;\n             error_after \u003d curPos \u003c\u003d 1 ? \"\" : input_stream.GetImage();\n             if (curChar \u003d\u003d \u0027\\n\u0027 || curChar \u003d\u003d \u0027\\r\u0027) {\n                 error_line++;\n                 error_column \u003d 0;\n             } else\n                 error_column++;\n         }\n         if (!EOFSeen) {\n             input_stream.backup(1);\n             error_after \u003d curPos \u003c\u003d 1 ? \"\" : input_stream.GetImage();\n         }\n         throw new TokenMgrError(EOFSeen, curLexState, error_line, error_column, error_after, curChar, TokenMgrError.LEXICAL_ERROR);\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "bc53a66311b9b22e471dd74860c7df75eebe9837": {
      "type": "Yintroduced",
      "commitMessage": "Initial submission\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/jakarta/commons/proper/jxpath/trunk@136698 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "8/22/01, 5:47 PM",
      "commitName": "bc53a66311b9b22e471dd74860c7df75eebe9837",
      "commitAuthor": "Dmitri Plotnikov",
      "diff": "@@ -0,0 +1,60 @@\n+public final Token getNextToken() {\n+    int kind;\n+    Token specialToken \u003d null;\n+    Token matchedToken;\n+    int curPos \u003d 0;\n+    EOFLoop: for (; ; ) {\n+        try {\n+            curChar \u003d input_stream.BeginToken();\n+        } catch (java.io.IOException e) {\n+            jjmatchedKind \u003d 0;\n+            matchedToken \u003d jjFillToken();\n+            matchedToken.specialToken \u003d specialToken;\n+            return matchedToken;\n+        }\n+        jjmatchedKind \u003d 0x7fffffff;\n+        jjmatchedPos \u003d 0;\n+        curPos \u003d jjMoveStringLiteralDfa0_0();\n+        if (jjmatchedKind !\u003d 0x7fffffff) {\n+            if (jjmatchedPos + 1 \u003c curPos)\n+                input_stream.backup(curPos - jjmatchedPos - 1);\n+            if ((jjtoToken[jjmatchedKind \u003e\u003e 6] \u0026 (1L \u003c\u003c (jjmatchedKind \u0026 077))) !\u003d 0L) {\n+                matchedToken \u003d jjFillToken();\n+                matchedToken.specialToken \u003d specialToken;\n+                return matchedToken;\n+            } else {\n+                if ((jjtoSpecial[jjmatchedKind \u003e\u003e 6] \u0026 (1L \u003c\u003c (jjmatchedKind \u0026 077))) !\u003d 0L) {\n+                    matchedToken \u003d jjFillToken();\n+                    if (specialToken \u003d\u003d null)\n+                        specialToken \u003d matchedToken;\n+                    else {\n+                        matchedToken.specialToken \u003d specialToken;\n+                        specialToken \u003d (specialToken.next \u003d matchedToken);\n+                    }\n+                }\n+                continue EOFLoop;\n+            }\n+        }\n+        int error_line \u003d input_stream.getEndLine();\n+        int error_column \u003d input_stream.getEndColumn();\n+        String error_after \u003d null;\n+        boolean EOFSeen \u003d false;\n+        try {\n+            input_stream.readChar();\n+            input_stream.backup(1);\n+        } catch (java.io.IOException e1) {\n+            EOFSeen \u003d true;\n+            error_after \u003d curPos \u003c\u003d 1 ? \"\" : input_stream.GetImage();\n+            if (curChar \u003d\u003d \u0027\\n\u0027 || curChar \u003d\u003d \u0027\\r\u0027) {\n+                error_line++;\n+                error_column \u003d 0;\n+            } else\n+                error_column++;\n+        }\n+        if (!EOFSeen) {\n+            input_stream.backup(1);\n+            error_after \u003d curPos \u003c\u003d 1 ? \"\" : input_stream.GetImage();\n+        }\n+        throw new TokenMgrError(EOFSeen, curLexState, error_line, error_column, error_after, curChar, TokenMgrError.LEXICAL_ERROR);\n+    }\n+}\n\\ No newline at end of file\n",
      "actualSource": "public final Token getNextToken() {\n    int kind;\n    Token specialToken \u003d null;\n    Token matchedToken;\n    int curPos \u003d 0;\n    EOFLoop: for (; ; ) {\n        try {\n            curChar \u003d input_stream.BeginToken();\n        } catch (java.io.IOException e) {\n            jjmatchedKind \u003d 0;\n            matchedToken \u003d jjFillToken();\n            matchedToken.specialToken \u003d specialToken;\n            return matchedToken;\n        }\n        jjmatchedKind \u003d 0x7fffffff;\n        jjmatchedPos \u003d 0;\n        curPos \u003d jjMoveStringLiteralDfa0_0();\n        if (jjmatchedKind !\u003d 0x7fffffff) {\n            if (jjmatchedPos + 1 \u003c curPos)\n                input_stream.backup(curPos - jjmatchedPos - 1);\n            if ((jjtoToken[jjmatchedKind \u003e\u003e 6] \u0026 (1L \u003c\u003c (jjmatchedKind \u0026 077))) !\u003d 0L) {\n                matchedToken \u003d jjFillToken();\n                matchedToken.specialToken \u003d specialToken;\n                return matchedToken;\n            } else {\n                if ((jjtoSpecial[jjmatchedKind \u003e\u003e 6] \u0026 (1L \u003c\u003c (jjmatchedKind \u0026 077))) !\u003d 0L) {\n                    matchedToken \u003d jjFillToken();\n                    if (specialToken \u003d\u003d null)\n                        specialToken \u003d matchedToken;\n                    else {\n                        matchedToken.specialToken \u003d specialToken;\n                        specialToken \u003d (specialToken.next \u003d matchedToken);\n                    }\n                }\n                continue EOFLoop;\n            }\n        }\n        int error_line \u003d input_stream.getEndLine();\n        int error_column \u003d input_stream.getEndColumn();\n        String error_after \u003d null;\n        boolean EOFSeen \u003d false;\n        try {\n            input_stream.readChar();\n            input_stream.backup(1);\n        } catch (java.io.IOException e1) {\n            EOFSeen \u003d true;\n            error_after \u003d curPos \u003c\u003d 1 ? \"\" : input_stream.GetImage();\n            if (curChar \u003d\u003d \u0027\\n\u0027 || curChar \u003d\u003d \u0027\\r\u0027) {\n                error_line++;\n                error_column \u003d 0;\n            } else\n                error_column++;\n        }\n        if (!EOFSeen) {\n            input_stream.backup(1);\n            error_after \u003d curPos \u003c\u003d 1 ? \"\" : input_stream.GetImage();\n        }\n        throw new TokenMgrError(EOFSeen, curLexState, error_line, error_column, error_after, curChar, TokenMgrError.LEXICAL_ERROR);\n    }\n}",
      "path": "src/java/org/apache/commons/jxpath/ri/parser/XPathParserTokenManager.java",
      "functionStartLine": 1809,
      "functionName": "getNextToken",
      "functionAnnotation": "",
      "functionDoc": ""
    }
  }
}