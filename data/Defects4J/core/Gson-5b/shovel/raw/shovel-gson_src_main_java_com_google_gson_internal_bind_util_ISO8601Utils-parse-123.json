{
  "origin": "codeshovel",
  "repositoryName": "Gson-5b",
  "repositoryPath": "/tmp/Gson-5b//.git",
  "startCommitName": "HEAD",
  "sourceFileName": "ISO8601Utils.java",
  "functionName": "parse",
  "functionId": "parse___date-String__pos-ParsePosition",
  "sourceFilePath": "gson/src/main/java/com/google/gson/internal/bind/util/ISO8601Utils.java",
  "functionAnnotation": "",
  "functionDoc": "Parse a date from ISO-8601 formatted string. It expects a format\n[yyyy-MM-dd|yyyyMMdd][T(hh:mm[:ss[.sss]]|hhmm[ss[.sss]])]?[Z|[+-]hh:mm]]\n\n@param date ISO string to parse in the appropriate format.\n@param pos The position to start parsing from, updated to where parsing stopped.\n@return the parsed date\n@throws ParseException if the date is not in the appropriate format\n",
  "functionStartLine": 123,
  "functionEndLine": 273,
  "numCommitsSeen": 2,
  "timeTaken": 234,
  "changeHistory": [
    "bcd52a1fdc4883731ee25b79e2c3f6a7d578bf92"
  ],
  "changeHistoryShort": {
    "bcd52a1fdc4883731ee25b79e2c3f6a7d578bf92": "Yintroduced"
  },
  "changeHistoryDetails": {
    "bcd52a1fdc4883731ee25b79e2c3f6a7d578bf92": {
      "type": "Yintroduced",
      "commitMessage": "Added ISO8601 complete support for date deserialization\n",
      "commitDate": "11/22/15, 10:11 PM",
      "commitName": "bcd52a1fdc4883731ee25b79e2c3f6a7d578bf92",
      "commitAuthor": "Gorik",
      "diff": "@@ -0,0 +1,112 @@\n+public static Date parse(String date, ParsePosition pos) throws ParseException {\n+    Exception fail \u003d null;\n+    try {\n+        int offset \u003d pos.getIndex();\n+        int year \u003d parseInt(date, offset, offset +\u003d 4);\n+        if (checkOffset(date, offset, \u0027-\u0027)) {\n+            offset +\u003d 1;\n+        }\n+        int month \u003d parseInt(date, offset, offset +\u003d 2);\n+        if (checkOffset(date, offset, \u0027-\u0027)) {\n+            offset +\u003d 1;\n+        }\n+        int day \u003d parseInt(date, offset, offset +\u003d 2);\n+        int hour \u003d 0;\n+        int minutes \u003d 0;\n+        int seconds \u003d 0;\n+        int milliseconds \u003d 0;\n+        boolean hasT \u003d checkOffset(date, offset, \u0027T\u0027);\n+        if (!hasT \u0026\u0026 (date.length() \u003c\u003d offset)) {\n+            Calendar calendar \u003d new GregorianCalendar(year, month - 1, day);\n+            pos.setIndex(offset);\n+            return calendar.getTime();\n+        }\n+        if (hasT) {\n+            hour \u003d parseInt(date, offset +\u003d 1, offset +\u003d 2);\n+            if (checkOffset(date, offset, \u0027:\u0027)) {\n+                offset +\u003d 1;\n+            }\n+            minutes \u003d parseInt(date, offset, offset +\u003d 2);\n+            if (checkOffset(date, offset, \u0027:\u0027)) {\n+                offset +\u003d 1;\n+            }\n+            if (date.length() \u003e offset) {\n+                char c \u003d date.charAt(offset);\n+                if (c !\u003d \u0027Z\u0027 \u0026\u0026 c !\u003d \u0027+\u0027 \u0026\u0026 c !\u003d \u0027-\u0027) {\n+                    seconds \u003d parseInt(date, offset, offset +\u003d 2);\n+                    if (seconds \u003e 59 \u0026\u0026 seconds \u003c 63)\n+                        seconds \u003d 59;\n+                    if (checkOffset(date, offset, \u0027.\u0027)) {\n+                        offset +\u003d 1;\n+                        int endOffset \u003d indexOfNonDigit(date, offset + 1);\n+                        int parseEndOffset \u003d Math.min(endOffset, offset + 3);\n+                        int fraction \u003d parseInt(date, offset, parseEndOffset);\n+                        switch(parseEndOffset - offset) {\n+                            case 2:\n+                                milliseconds \u003d fraction * 10;\n+                                break;\n+                            case 1:\n+                                milliseconds \u003d fraction * 100;\n+                                break;\n+                            default:\n+                                milliseconds \u003d fraction;\n+                        }\n+                        offset \u003d endOffset;\n+                    }\n+                }\n+            }\n+        }\n+        if (date.length() \u003c\u003d offset) {\n+            throw new IllegalArgumentException(\"No time zone indicator\");\n+        }\n+        TimeZone timezone \u003d null;\n+        char timezoneIndicator \u003d date.charAt(offset);\n+        if (timezoneIndicator \u003d\u003d \u0027Z\u0027) {\n+            timezone \u003d TIMEZONE_UTC;\n+            offset +\u003d 1;\n+        } else if (timezoneIndicator \u003d\u003d \u0027+\u0027 || timezoneIndicator \u003d\u003d \u0027-\u0027) {\n+            String timezoneOffset \u003d date.substring(offset);\n+            offset +\u003d timezoneOffset.length();\n+            if (\"+0000\".equals(timezoneOffset) || \"+00:00\".equals(timezoneOffset)) {\n+                timezone \u003d TIMEZONE_UTC;\n+            } else {\n+                String timezoneId \u003d \"GMT\" + timezoneOffset;\n+                timezone \u003d TimeZone.getTimeZone(timezoneId);\n+                String act \u003d timezone.getID();\n+                if (!act.equals(timezoneId)) {\n+                    String cleaned \u003d act.replace(\":\", \"\");\n+                    if (!cleaned.equals(timezoneId)) {\n+                        throw new IndexOutOfBoundsException(\"Mismatching time zone indicator: \" + timezoneId + \" given, resolves to \" + timezone.getID());\n+                    }\n+                }\n+            }\n+        } else {\n+            throw new IndexOutOfBoundsException(\"Invalid time zone indicator \u0027\" + timezoneIndicator + \"\u0027\");\n+        }\n+        Calendar calendar \u003d new GregorianCalendar(timezone);\n+        calendar.setLenient(false);\n+        calendar.set(Calendar.YEAR, year);\n+        calendar.set(Calendar.MONTH, month - 1);\n+        calendar.set(Calendar.DAY_OF_MONTH, day);\n+        calendar.set(Calendar.HOUR_OF_DAY, hour);\n+        calendar.set(Calendar.MINUTE, minutes);\n+        calendar.set(Calendar.SECOND, seconds);\n+        calendar.set(Calendar.MILLISECOND, milliseconds);\n+        pos.setIndex(offset);\n+        return calendar.getTime();\n+    } catch (IndexOutOfBoundsException e) {\n+        fail \u003d e;\n+    } catch (NumberFormatException e) {\n+        fail \u003d e;\n+    } catch (IllegalArgumentException e) {\n+        fail \u003d e;\n+    }\n+    String input \u003d (date \u003d\u003d null) ? null : (\u0027\"\u0027 + date + \"\u0027\");\n+    String msg \u003d fail.getMessage();\n+    if (msg \u003d\u003d null || msg.isEmpty()) {\n+        msg \u003d \"(\" + fail.getClass().getName() + \")\";\n+    }\n+    ParseException ex \u003d new ParseException(\"Failed to parse date [\" + input + \"]: \" + msg, pos.getIndex());\n+    ex.initCause(fail);\n+    throw ex;\n+}\n\\ No newline at end of file\n",
      "actualSource": "public static Date parse(String date, ParsePosition pos) throws ParseException {\n    Exception fail \u003d null;\n    try {\n        int offset \u003d pos.getIndex();\n        int year \u003d parseInt(date, offset, offset +\u003d 4);\n        if (checkOffset(date, offset, \u0027-\u0027)) {\n            offset +\u003d 1;\n        }\n        int month \u003d parseInt(date, offset, offset +\u003d 2);\n        if (checkOffset(date, offset, \u0027-\u0027)) {\n            offset +\u003d 1;\n        }\n        int day \u003d parseInt(date, offset, offset +\u003d 2);\n        int hour \u003d 0;\n        int minutes \u003d 0;\n        int seconds \u003d 0;\n        int milliseconds \u003d 0;\n        boolean hasT \u003d checkOffset(date, offset, \u0027T\u0027);\n        if (!hasT \u0026\u0026 (date.length() \u003c\u003d offset)) {\n            Calendar calendar \u003d new GregorianCalendar(year, month - 1, day);\n            pos.setIndex(offset);\n            return calendar.getTime();\n        }\n        if (hasT) {\n            hour \u003d parseInt(date, offset +\u003d 1, offset +\u003d 2);\n            if (checkOffset(date, offset, \u0027:\u0027)) {\n                offset +\u003d 1;\n            }\n            minutes \u003d parseInt(date, offset, offset +\u003d 2);\n            if (checkOffset(date, offset, \u0027:\u0027)) {\n                offset +\u003d 1;\n            }\n            if (date.length() \u003e offset) {\n                char c \u003d date.charAt(offset);\n                if (c !\u003d \u0027Z\u0027 \u0026\u0026 c !\u003d \u0027+\u0027 \u0026\u0026 c !\u003d \u0027-\u0027) {\n                    seconds \u003d parseInt(date, offset, offset +\u003d 2);\n                    if (seconds \u003e 59 \u0026\u0026 seconds \u003c 63)\n                        seconds \u003d 59;\n                    if (checkOffset(date, offset, \u0027.\u0027)) {\n                        offset +\u003d 1;\n                        int endOffset \u003d indexOfNonDigit(date, offset + 1);\n                        int parseEndOffset \u003d Math.min(endOffset, offset + 3);\n                        int fraction \u003d parseInt(date, offset, parseEndOffset);\n                        switch(parseEndOffset - offset) {\n                            case 2:\n                                milliseconds \u003d fraction * 10;\n                                break;\n                            case 1:\n                                milliseconds \u003d fraction * 100;\n                                break;\n                            default:\n                                milliseconds \u003d fraction;\n                        }\n                        offset \u003d endOffset;\n                    }\n                }\n            }\n        }\n        if (date.length() \u003c\u003d offset) {\n            throw new IllegalArgumentException(\"No time zone indicator\");\n        }\n        TimeZone timezone \u003d null;\n        char timezoneIndicator \u003d date.charAt(offset);\n        if (timezoneIndicator \u003d\u003d \u0027Z\u0027) {\n            timezone \u003d TIMEZONE_UTC;\n            offset +\u003d 1;\n        } else if (timezoneIndicator \u003d\u003d \u0027+\u0027 || timezoneIndicator \u003d\u003d \u0027-\u0027) {\n            String timezoneOffset \u003d date.substring(offset);\n            offset +\u003d timezoneOffset.length();\n            if (\"+0000\".equals(timezoneOffset) || \"+00:00\".equals(timezoneOffset)) {\n                timezone \u003d TIMEZONE_UTC;\n            } else {\n                String timezoneId \u003d \"GMT\" + timezoneOffset;\n                timezone \u003d TimeZone.getTimeZone(timezoneId);\n                String act \u003d timezone.getID();\n                if (!act.equals(timezoneId)) {\n                    String cleaned \u003d act.replace(\":\", \"\");\n                    if (!cleaned.equals(timezoneId)) {\n                        throw new IndexOutOfBoundsException(\"Mismatching time zone indicator: \" + timezoneId + \" given, resolves to \" + timezone.getID());\n                    }\n                }\n            }\n        } else {\n            throw new IndexOutOfBoundsException(\"Invalid time zone indicator \u0027\" + timezoneIndicator + \"\u0027\");\n        }\n        Calendar calendar \u003d new GregorianCalendar(timezone);\n        calendar.setLenient(false);\n        calendar.set(Calendar.YEAR, year);\n        calendar.set(Calendar.MONTH, month - 1);\n        calendar.set(Calendar.DAY_OF_MONTH, day);\n        calendar.set(Calendar.HOUR_OF_DAY, hour);\n        calendar.set(Calendar.MINUTE, minutes);\n        calendar.set(Calendar.SECOND, seconds);\n        calendar.set(Calendar.MILLISECOND, milliseconds);\n        pos.setIndex(offset);\n        return calendar.getTime();\n    } catch (IndexOutOfBoundsException e) {\n        fail \u003d e;\n    } catch (NumberFormatException e) {\n        fail \u003d e;\n    } catch (IllegalArgumentException e) {\n        fail \u003d e;\n    }\n    String input \u003d (date \u003d\u003d null) ? null : (\u0027\"\u0027 + date + \"\u0027\");\n    String msg \u003d fail.getMessage();\n    if (msg \u003d\u003d null || msg.isEmpty()) {\n        msg \u003d \"(\" + fail.getClass().getName() + \")\";\n    }\n    ParseException ex \u003d new ParseException(\"Failed to parse date [\" + input + \"]: \" + msg, pos.getIndex());\n    ex.initCause(fail);\n    throw ex;\n}",
      "path": "gson/src/main/java/com/google/gson/internal/bind/util/ISO8601Utils.java",
      "functionStartLine": 123,
      "functionName": "parse",
      "functionAnnotation": "",
      "functionDoc": "Parse a date from ISO-8601 formatted string. It expects a format\n[yyyy-MM-dd|yyyyMMdd][T(hh:mm[:ss[.sss]]|hhmm[ss[.sss]])]?[Z|[+-]hh:mm]]\n\n@param date ISO string to parse in the appropriate format.\n@param pos The position to start parsing from, updated to where parsing stopped.\n@return the parsed date\n@throws ParseException if the date is not in the appropriate format\n"
    }
  }
}