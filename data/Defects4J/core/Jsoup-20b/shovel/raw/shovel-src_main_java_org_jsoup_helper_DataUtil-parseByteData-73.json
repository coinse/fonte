{
  "origin": "codeshovel",
  "repositoryName": "Jsoup-20b",
  "repositoryPath": "/tmp/Jsoup-20b//.git",
  "startCommitName": "HEAD",
  "sourceFileName": "DataUtil.java",
  "functionName": "parseByteData",
  "functionId": "parseByteData___byteData-ByteBuffer__charsetName-String__baseUri-String__parser-Parser",
  "sourceFilePath": "src/main/java/org/jsoup/helper/DataUtil.java",
  "functionAnnotation": "",
  "functionDoc": "",
  "functionStartLine": 73,
  "functionEndLine": 99,
  "numCommitsSeen": 21,
  "timeTaken": 453,
  "changeHistory": [
    "433d2f180058b8b73e1951c6cfbb986714e68b0f",
    "a14fb16d6430d8de4bf31c898d119ab713840c2d",
    "78d40f41b9567d7e8a0c891f31b7deee2b1f3f19",
    "ce843ec83988e3e3318fa7db38133b06be741a1f"
  ],
  "changeHistoryShort": {
    "433d2f180058b8b73e1951c6cfbb986714e68b0f": "Ymultichange(Yparameterchange,Ybodychange)",
    "a14fb16d6430d8de4bf31c898d119ab713840c2d": "Ybodychange",
    "78d40f41b9567d7e8a0c891f31b7deee2b1f3f19": "Ybodychange",
    "ce843ec83988e3e3318fa7db38133b06be741a1f": "Yintroduced"
  },
  "changeHistoryDetails": {
    "433d2f180058b8b73e1951c6cfbb986714e68b0f": {
      "type": "Ymultichange(Yparameterchange,Ybodychange)",
      "commitMessage": "Allow an alternate parser to be supplied for core use cases.\n",
      "commitDate": "2/27/12, 8:55 PM",
      "commitName": "433d2f180058b8b73e1951c6cfbb986714e68b0f",
      "commitAuthor": "Jonathan Hedley",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "Allow an alternate parser to be supplied for core use cases.\n",
          "commitDate": "2/27/12, 8:55 PM",
          "commitName": "433d2f180058b8b73e1951c6cfbb986714e68b0f",
          "commitAuthor": "Jonathan Hedley",
          "commitDateOld": "7/2/11, 4:12 AM",
          "commitNameOld": "912d3c14f98af2b3a77eeabf536617ebc9c6f665",
          "commitAuthorOld": "Jonathan Hedley",
          "daysBetweenCommits": 240.74,
          "commitsBetweenForRepo": 26,
          "commitsBetweenForFile": 1,
          "actualSource": "static Document parseByteData(ByteBuffer byteData, String charsetName, String baseUri, Parser parser) {\n    String docData;\n    Document doc \u003d null;\n    if (charsetName \u003d\u003d null) {\n        docData \u003d Charset.forName(defaultCharset).decode(byteData).toString();\n        doc \u003d parser.parseInput(docData, baseUri);\n        Element meta \u003d doc.select(\"meta[http-equiv\u003dcontent-type], meta[charset]\").first();\n        if (meta !\u003d null) {\n            String foundCharset \u003d meta.hasAttr(\"http-equiv\") ? getCharsetFromContentType(meta.attr(\"content\")) : meta.attr(\"charset\");\n            if (foundCharset !\u003d null \u0026\u0026 foundCharset.length() !\u003d 0 \u0026\u0026 !foundCharset.equals(defaultCharset)) {\n                charsetName \u003d foundCharset;\n                byteData.rewind();\n                docData \u003d Charset.forName(foundCharset).decode(byteData).toString();\n                doc \u003d null;\n            }\n        }\n    } else {\n        Validate.notEmpty(charsetName, \"Must set charset arg to character set of file to parse. Set to null to attempt to detect from HTML\");\n        docData \u003d Charset.forName(charsetName).decode(byteData).toString();\n    }\n    if (doc \u003d\u003d null) {\n        doc \u003d parser.parseInput(docData, baseUri);\n        doc.outputSettings().charset(charsetName);\n    }\n    return doc;\n}",
          "path": "src/main/java/org/jsoup/helper/DataUtil.java",
          "functionStartLine": 73,
          "functionName": "parseByteData",
          "functionAnnotation": "",
          "functionDoc": "",
          "diff": "@@ -1,26 +1,26 @@\n-static Document parseByteData(ByteBuffer byteData, String charsetName, String baseUri) {\n+static Document parseByteData(ByteBuffer byteData, String charsetName, String baseUri, Parser parser) {\n     String docData;\n     Document doc \u003d null;\n     if (charsetName \u003d\u003d null) {\n         docData \u003d Charset.forName(defaultCharset).decode(byteData).toString();\n-        doc \u003d Jsoup.parse(docData, baseUri);\n+        doc \u003d parser.parseInput(docData, baseUri);\n         Element meta \u003d doc.select(\"meta[http-equiv\u003dcontent-type], meta[charset]\").first();\n         if (meta !\u003d null) {\n             String foundCharset \u003d meta.hasAttr(\"http-equiv\") ? getCharsetFromContentType(meta.attr(\"content\")) : meta.attr(\"charset\");\n             if (foundCharset !\u003d null \u0026\u0026 foundCharset.length() !\u003d 0 \u0026\u0026 !foundCharset.equals(defaultCharset)) {\n                 charsetName \u003d foundCharset;\n                 byteData.rewind();\n                 docData \u003d Charset.forName(foundCharset).decode(byteData).toString();\n                 doc \u003d null;\n             }\n         }\n     } else {\n         Validate.notEmpty(charsetName, \"Must set charset arg to character set of file to parse. Set to null to attempt to detect from HTML\");\n         docData \u003d Charset.forName(charsetName).decode(byteData).toString();\n     }\n     if (doc \u003d\u003d null) {\n-        doc \u003d Jsoup.parse(docData, baseUri);\n+        doc \u003d parser.parseInput(docData, baseUri);\n         doc.outputSettings().charset(charsetName);\n     }\n     return doc;\n }\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldValue": "[byteData-ByteBuffer, charsetName-String, baseUri-String]",
            "newValue": "[byteData-ByteBuffer, charsetName-String, baseUri-String, parser-Parser]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "Allow an alternate parser to be supplied for core use cases.\n",
          "commitDate": "2/27/12, 8:55 PM",
          "commitName": "433d2f180058b8b73e1951c6cfbb986714e68b0f",
          "commitAuthor": "Jonathan Hedley",
          "commitDateOld": "7/2/11, 4:12 AM",
          "commitNameOld": "912d3c14f98af2b3a77eeabf536617ebc9c6f665",
          "commitAuthorOld": "Jonathan Hedley",
          "daysBetweenCommits": 240.74,
          "commitsBetweenForRepo": 26,
          "commitsBetweenForFile": 1,
          "actualSource": "static Document parseByteData(ByteBuffer byteData, String charsetName, String baseUri, Parser parser) {\n    String docData;\n    Document doc \u003d null;\n    if (charsetName \u003d\u003d null) {\n        docData \u003d Charset.forName(defaultCharset).decode(byteData).toString();\n        doc \u003d parser.parseInput(docData, baseUri);\n        Element meta \u003d doc.select(\"meta[http-equiv\u003dcontent-type], meta[charset]\").first();\n        if (meta !\u003d null) {\n            String foundCharset \u003d meta.hasAttr(\"http-equiv\") ? getCharsetFromContentType(meta.attr(\"content\")) : meta.attr(\"charset\");\n            if (foundCharset !\u003d null \u0026\u0026 foundCharset.length() !\u003d 0 \u0026\u0026 !foundCharset.equals(defaultCharset)) {\n                charsetName \u003d foundCharset;\n                byteData.rewind();\n                docData \u003d Charset.forName(foundCharset).decode(byteData).toString();\n                doc \u003d null;\n            }\n        }\n    } else {\n        Validate.notEmpty(charsetName, \"Must set charset arg to character set of file to parse. Set to null to attempt to detect from HTML\");\n        docData \u003d Charset.forName(charsetName).decode(byteData).toString();\n    }\n    if (doc \u003d\u003d null) {\n        doc \u003d parser.parseInput(docData, baseUri);\n        doc.outputSettings().charset(charsetName);\n    }\n    return doc;\n}",
          "path": "src/main/java/org/jsoup/helper/DataUtil.java",
          "functionStartLine": 73,
          "functionName": "parseByteData",
          "functionAnnotation": "",
          "functionDoc": "",
          "diff": "@@ -1,26 +1,26 @@\n-static Document parseByteData(ByteBuffer byteData, String charsetName, String baseUri) {\n+static Document parseByteData(ByteBuffer byteData, String charsetName, String baseUri, Parser parser) {\n     String docData;\n     Document doc \u003d null;\n     if (charsetName \u003d\u003d null) {\n         docData \u003d Charset.forName(defaultCharset).decode(byteData).toString();\n-        doc \u003d Jsoup.parse(docData, baseUri);\n+        doc \u003d parser.parseInput(docData, baseUri);\n         Element meta \u003d doc.select(\"meta[http-equiv\u003dcontent-type], meta[charset]\").first();\n         if (meta !\u003d null) {\n             String foundCharset \u003d meta.hasAttr(\"http-equiv\") ? getCharsetFromContentType(meta.attr(\"content\")) : meta.attr(\"charset\");\n             if (foundCharset !\u003d null \u0026\u0026 foundCharset.length() !\u003d 0 \u0026\u0026 !foundCharset.equals(defaultCharset)) {\n                 charsetName \u003d foundCharset;\n                 byteData.rewind();\n                 docData \u003d Charset.forName(foundCharset).decode(byteData).toString();\n                 doc \u003d null;\n             }\n         }\n     } else {\n         Validate.notEmpty(charsetName, \"Must set charset arg to character set of file to parse. Set to null to attempt to detect from HTML\");\n         docData \u003d Charset.forName(charsetName).decode(byteData).toString();\n     }\n     if (doc \u003d\u003d null) {\n-        doc \u003d Jsoup.parse(docData, baseUri);\n+        doc \u003d parser.parseInput(docData, baseUri);\n         doc.outputSettings().charset(charsetName);\n     }\n     return doc;\n }\n\\ No newline at end of file\n",
          "extendedDetails": {}
        }
      ]
    },
    "a14fb16d6430d8de4bf31c898d119ab713840c2d": {
      "type": "Ybodychange",
      "commitMessage": "Fixed issue with selector parser where some boolean AND + OR combined queries (e.g. \"meta[http-equiv], meta[content]\") were being parsed incorrectly as OR only queries (e.g. former as \"meta, [http-equiv], meta[content]\")\n\nFixed issue where a content-tye specified in a meta tag may not be reliably detected, due to the above issue.\n",
      "commitDate": "7/2/11, 4:12 AM",
      "commitName": "a14fb16d6430d8de4bf31c898d119ab713840c2d",
      "commitAuthor": "Jonathan Hedley",
      "commitDateOld": "7/2/11, 4:12 AM",
      "commitNameOld": "cacbbfb9604fc5ce565b3547f4a7de77c037013f",
      "commitAuthorOld": "Jonathan Hedley",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 76,
      "commitsBetweenForFile": 1,
      "actualSource": "static Document parseByteData(ByteBuffer byteData, String charsetName, String baseUri) {\n    String docData;\n    Document doc \u003d null;\n    if (charsetName \u003d\u003d null) {\n        docData \u003d Charset.forName(defaultCharset).decode(byteData).toString();\n        doc \u003d Jsoup.parse(docData, baseUri);\n        Element meta \u003d doc.select(\"meta[http-equiv\u003dcontent-type], meta[charset]\").first();\n        if (meta !\u003d null) {\n            String foundCharset \u003d meta.hasAttr(\"http-equiv\") ? getCharsetFromContentType(meta.attr(\"content\")) : meta.attr(\"charset\");\n            if (foundCharset !\u003d null \u0026\u0026 foundCharset.length() !\u003d 0 \u0026\u0026 !foundCharset.equals(defaultCharset)) {\n                charsetName \u003d foundCharset;\n                byteData.rewind();\n                docData \u003d Charset.forName(foundCharset).decode(byteData).toString();\n                doc \u003d null;\n            }\n        }\n    } else {\n        Validate.notEmpty(charsetName, \"Must set charset arg to character set of file to parse. Set to null to attempt to detect from HTML\");\n        docData \u003d Charset.forName(charsetName).decode(byteData).toString();\n    }\n    if (doc \u003d\u003d null) {\n        doc \u003d Jsoup.parse(docData, baseUri);\n        doc.outputSettings().charset(charsetName);\n    }\n    return doc;\n}",
      "path": "src/main/java/org/jsoup/helper/DataUtil.java",
      "functionStartLine": 58,
      "functionName": "parseByteData",
      "functionAnnotation": "",
      "functionDoc": "",
      "diff": "@@ -1,26 +1,26 @@\n static Document parseByteData(ByteBuffer byteData, String charsetName, String baseUri) {\n     String docData;\n     Document doc \u003d null;\n     if (charsetName \u003d\u003d null) {\n         docData \u003d Charset.forName(defaultCharset).decode(byteData).toString();\n         doc \u003d Jsoup.parse(docData, baseUri);\n         Element meta \u003d doc.select(\"meta[http-equiv\u003dcontent-type], meta[charset]\").first();\n         if (meta !\u003d null) {\n             String foundCharset \u003d meta.hasAttr(\"http-equiv\") ? getCharsetFromContentType(meta.attr(\"content\")) : meta.attr(\"charset\");\n-            if (foundCharset !\u003d null \u0026\u0026 !foundCharset.equals(defaultCharset)) {\n+            if (foundCharset !\u003d null \u0026\u0026 foundCharset.length() !\u003d 0 \u0026\u0026 !foundCharset.equals(defaultCharset)) {\n                 charsetName \u003d foundCharset;\n                 byteData.rewind();\n                 docData \u003d Charset.forName(foundCharset).decode(byteData).toString();\n                 doc \u003d null;\n             }\n         }\n     } else {\n         Validate.notEmpty(charsetName, \"Must set charset arg to character set of file to parse. Set to null to attempt to detect from HTML\");\n         docData \u003d Charset.forName(charsetName).decode(byteData).toString();\n     }\n     if (doc \u003d\u003d null) {\n         doc \u003d Jsoup.parse(docData, baseUri);\n         doc.outputSettings().charset(charsetName);\n     }\n     return doc;\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "78d40f41b9567d7e8a0c891f31b7deee2b1f3f19": {
      "type": "Ybodychange",
      "commitMessage": "Improved malformed table parsing by implementing ignorable end tags.\n",
      "commitDate": "7/2/11, 4:12 AM",
      "commitName": "78d40f41b9567d7e8a0c891f31b7deee2b1f3f19",
      "commitAuthor": "Jonathan Hedley",
      "commitDateOld": "7/2/11, 4:12 AM",
      "commitNameOld": "b57bab46e4241cd3cacce52cb6ff310bbf69eb7b",
      "commitAuthorOld": "Jonathan Hedley",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "static Document parseByteData(ByteBuffer byteData, String charsetName, String baseUri) {\n    String docData;\n    Document doc \u003d null;\n    if (charsetName \u003d\u003d null) {\n        docData \u003d Charset.forName(defaultCharset).decode(byteData).toString();\n        doc \u003d Jsoup.parse(docData, baseUri);\n        Element meta \u003d doc.select(\"meta[http-equiv\u003dcontent-type], meta[charset]\").first();\n        if (meta !\u003d null) {\n            String foundCharset \u003d meta.hasAttr(\"http-equiv\") ? getCharsetFromContentType(meta.attr(\"content\")) : meta.attr(\"charset\");\n            if (foundCharset !\u003d null \u0026\u0026 !foundCharset.equals(defaultCharset)) {\n                charsetName \u003d foundCharset;\n                byteData.rewind();\n                docData \u003d Charset.forName(foundCharset).decode(byteData).toString();\n                doc \u003d null;\n            }\n        }\n    } else {\n        Validate.notEmpty(charsetName, \"Must set charset arg to character set of file to parse. Set to null to attempt to detect from HTML\");\n        docData \u003d Charset.forName(charsetName).decode(byteData).toString();\n    }\n    if (doc \u003d\u003d null) {\n        doc \u003d Jsoup.parse(docData, baseUri);\n        doc.outputSettings().charset(charsetName);\n    }\n    return doc;\n}",
      "path": "src/main/java/org/jsoup/helper/DataUtil.java",
      "functionStartLine": 41,
      "functionName": "parseByteData",
      "functionAnnotation": "",
      "functionDoc": "",
      "diff": "@@ -1,25 +1,26 @@\n static Document parseByteData(ByteBuffer byteData, String charsetName, String baseUri) {\n     String docData;\n     Document doc \u003d null;\n     if (charsetName \u003d\u003d null) {\n         docData \u003d Charset.forName(defaultCharset).decode(byteData).toString();\n         doc \u003d Jsoup.parse(docData, baseUri);\n         Element meta \u003d doc.select(\"meta[http-equiv\u003dcontent-type], meta[charset]\").first();\n         if (meta !\u003d null) {\n             String foundCharset \u003d meta.hasAttr(\"http-equiv\") ? getCharsetFromContentType(meta.attr(\"content\")) : meta.attr(\"charset\");\n             if (foundCharset !\u003d null \u0026\u0026 !foundCharset.equals(defaultCharset)) {\n                 charsetName \u003d foundCharset;\n                 byteData.rewind();\n                 docData \u003d Charset.forName(foundCharset).decode(byteData).toString();\n                 doc \u003d null;\n             }\n         }\n     } else {\n+        Validate.notEmpty(charsetName, \"Must set charset arg to character set of file to parse. Set to null to attempt to detect from HTML\");\n         docData \u003d Charset.forName(charsetName).decode(byteData).toString();\n     }\n     if (doc \u003d\u003d null) {\n         doc \u003d Jsoup.parse(docData, baseUri);\n         doc.outputSettings().charset(charsetName);\n     }\n     return doc;\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "ce843ec83988e3e3318fa7db38133b06be741a1f": {
      "type": "Yintroduced",
      "commitMessage": "Initial implementation of Connection\n",
      "commitDate": "7/2/11, 4:11 AM",
      "commitName": "ce843ec83988e3e3318fa7db38133b06be741a1f",
      "commitAuthor": "Jonathan Hedley",
      "diff": "@@ -0,0 +1,25 @@\n+static Document parseByteData(ByteBuffer byteData, String charsetName, String baseUri) {\n+    String docData;\n+    Document doc \u003d null;\n+    if (charsetName \u003d\u003d null) {\n+        docData \u003d Charset.forName(defaultCharset).decode(byteData).toString();\n+        doc \u003d Jsoup.parse(docData, baseUri);\n+        Element meta \u003d doc.select(\"meta[http-equiv\u003dcontent-type], meta[charset]\").first();\n+        if (meta !\u003d null) {\n+            String foundCharset \u003d meta.hasAttr(\"http-equiv\") ? getCharsetFromContentType(meta.attr(\"content\")) : meta.attr(\"charset\");\n+            if (foundCharset !\u003d null \u0026\u0026 !foundCharset.equals(defaultCharset)) {\n+                charsetName \u003d foundCharset;\n+                byteData.rewind();\n+                docData \u003d Charset.forName(foundCharset).decode(byteData).toString();\n+                doc \u003d null;\n+            }\n+        }\n+    } else {\n+        docData \u003d Charset.forName(charsetName).decode(byteData).toString();\n+    }\n+    if (doc \u003d\u003d null) {\n+        doc \u003d Jsoup.parse(docData, baseUri);\n+        doc.outputSettings().charset(charsetName);\n+    }\n+    return doc;\n+}\n\\ No newline at end of file\n",
      "actualSource": "static Document parseByteData(ByteBuffer byteData, String charsetName, String baseUri) {\n    String docData;\n    Document doc \u003d null;\n    if (charsetName \u003d\u003d null) {\n        docData \u003d Charset.forName(defaultCharset).decode(byteData).toString();\n        doc \u003d Jsoup.parse(docData, baseUri);\n        Element meta \u003d doc.select(\"meta[http-equiv\u003dcontent-type], meta[charset]\").first();\n        if (meta !\u003d null) {\n            String foundCharset \u003d meta.hasAttr(\"http-equiv\") ? getCharsetFromContentType(meta.attr(\"content\")) : meta.attr(\"charset\");\n            if (foundCharset !\u003d null \u0026\u0026 !foundCharset.equals(defaultCharset)) {\n                charsetName \u003d foundCharset;\n                byteData.rewind();\n                docData \u003d Charset.forName(foundCharset).decode(byteData).toString();\n                doc \u003d null;\n            }\n        }\n    } else {\n        docData \u003d Charset.forName(charsetName).decode(byteData).toString();\n    }\n    if (doc \u003d\u003d null) {\n        doc \u003d Jsoup.parse(docData, baseUri);\n        doc.outputSettings().charset(charsetName);\n    }\n    return doc;\n}",
      "path": "src/main/java/org/jsoup/helper/DataUtil.java",
      "functionStartLine": 39,
      "functionName": "parseByteData",
      "functionAnnotation": "",
      "functionDoc": ""
    }
  }
}