{
  "origin": "codeshovel",
  "repositoryName": "Gson-6b",
  "repositoryPath": "/tmp/Gson-6b//.git",
  "startCommitName": "HEAD",
  "sourceFileName": "Gson.java",
  "functionName": "getDelegateAdapter",
  "functionId": "getDelegateAdapter___skipPast-TypeAdapterFactory__type-TypeToken__T__",
  "sourceFilePath": "gson/src/main/java/com/google/gson/Gson.java",
  "functionAnnotation": "",
  "functionDoc": "This method is used to get an alternate type adapter for the specified type. This is used\nto access a type adapter that is overridden by a {@link TypeAdapterFactory} that you\nmay have registered. This features is typically used when you want to register a type\nadapter that does a little bit of work but then delegates further processing to the Gson\ndefault type adapter. Here is an example:\n\u003cp\u003eLet\u0027s say we want to write a type adapter that counts the number of objects being read\n from or written to JSON. We can achieve this by writing a type adapter factory that uses\n the \u003ccode\u003egetDelegateAdapter\u003c/code\u003e method:\n \u003cpre\u003e {@code\n class StatsTypeAdapterFactory implements TypeAdapterFactory {\n   public int numReads \u003d 0;\n   public int numWrites \u003d 0;\n   public \u0026lt;T\u0026gt; TypeAdapter\u0026lt;T\u0026gt; create(Gson gson, TypeToken\u0026lt;T\u0026gt; type) {\n     final TypeAdapter\u0026lt;T\u0026gt; delegate \u003d gson.getDelegateAdapter(this, type);\n     return new TypeAdapter\u0026lt;T\u0026gt;() {\n       public void write(JsonWriter out, T value) throws IOException {\n         ++numWrites;\n         delegate.write(out, value);\n       }\n       public T read(JsonReader in) throws IOException {\n         ++numReads;\n         return delegate.read(in);\n       }\n     };\n   }\n }\n } \u003c/pre\u003e\n This factory can now be used like this:\n \u003cpre\u003e {@code\n StatsTypeAdapterFactory stats \u003d new StatsTypeAdapterFactory();\n Gson gson \u003d new GsonBuilder().registerTypeAdapterFactory(stats).create();\n // Call gson.toJson() and fromJson methods on objects\n System.out.println(\"Num JSON reads\" + stats.numReads);\n System.out.println(\"Num JSON writes\" + stats.numWrites);\n }\u003c/pre\u003e\n Note that this call will skip all factories registered before {@code skipPast}. In case of\n multiple TypeAdapterFactories registered it is up to the caller of this function to insure\n that the order of registration does not prevent this method from reaching a factory they\n would expect to reply from this call.\n Note that since you can not override type adapter factories for String and Java primitive\n types, our stats factory will not count the number of String or primitives that will be\n read or written.\n\n@param skipPast The type adapter factory that needs to be skipped while searching for\n  a matching type adapter. In most cases, you should just pass \u003ci\u003ethis\u003c/i\u003e (the type adapter\n  factory from where {@link #getDelegateAdapter} method is being invoked).\n@param type Type for which the delegate adapter is being searched for.\n@since 2.2\n",
  "functionStartLine": 483,
  "functionEndLine": 504,
  "numCommitsSeen": 711,
  "timeTaken": 3865,
  "changeHistory": [
    "7a1c94f9863bfc6915eaa56236dcef46876d4674",
    "618343fd1bae998ac9ebfde37a56eb4f498a59d7",
    "f2591b666419e06017b2327f7729440c122bf675",
    "4816941f0d76f2dc5d5b0b7b5fb3206d6fef641d",
    "83e5a4937cf13ab9b94a7bb12ce2fefa168752ed",
    "6c78bf5247828219d4383c1b5dd13d494fa65cec",
    "ecdf9150f6cc820dafddea5b545f456fed47472f",
    "d7fbac03844aa86dbb1c65a8ba50ac364c4b2050",
    "8f8e69a36444022da48d40966549fa9eb78f5751",
    "7e760143fdc8b689daeebdee33ad6ea7d0a62a56",
    "25c6ae177b1ca56db7f3c29eb574bdd032a06165"
  ],
  "changeHistoryShort": {
    "7a1c94f9863bfc6915eaa56236dcef46876d4674": "Ydocchange",
    "618343fd1bae998ac9ebfde37a56eb4f498a59d7": "Ydocchange",
    "f2591b666419e06017b2327f7729440c122bf675": "Ybodychange",
    "4816941f0d76f2dc5d5b0b7b5fb3206d6fef641d": "Ydocchange",
    "83e5a4937cf13ab9b94a7bb12ce2fefa168752ed": "Ymultichange(Yrename,Ydocchange)",
    "6c78bf5247828219d4383c1b5dd13d494fa65cec": "Ymultichange(Yparameterchange,Ybodychange,Yannotationchange,Ydocchange)",
    "ecdf9150f6cc820dafddea5b545f456fed47472f": "Ymultichange(Yparameterchange,Ybodychange,Yannotationchange,Ydocchange)",
    "d7fbac03844aa86dbb1c65a8ba50ac364c4b2050": "Ymultichange(Yparameterchange,Ybodychange)",
    "8f8e69a36444022da48d40966549fa9eb78f5751": "Ydocchange",
    "7e760143fdc8b689daeebdee33ad6ea7d0a62a56": "Ymultichange(Ymovefromfile,Ybodychange)",
    "25c6ae177b1ca56db7f3c29eb574bdd032a06165": "Yintroduced"
  },
  "changeHistoryDetails": {
    "7a1c94f9863bfc6915eaa56236dcef46876d4674": {
      "type": "Ydocchange",
      "commitMessage": "Remove synthetic accessors from being generated.\n",
      "commitDate": "12/26/15, 10:39 PM",
      "commitName": "7a1c94f9863bfc6915eaa56236dcef46876d4674",
      "commitAuthor": "Jake Wharton",
      "commitDateOld": "11/6/15, 3:41 PM",
      "commitNameOld": "47cc34548d2ede1f294ff72ae02c05e2b0eae404",
      "commitAuthorOld": "Inderjeet Singh",
      "daysBetweenCommits": 50.29,
      "commitsBetweenForRepo": 5,
      "commitsBetweenForFile": 1,
      "actualSource": "public \u003cT\u003e TypeAdapter\u003cT\u003e getDelegateAdapter(TypeAdapterFactory skipPast, TypeToken\u003cT\u003e type) {\n    boolean skipPastFound \u003d false;\n    if (!factories.contains(skipPast))\n        skipPastFound \u003d true;\n    for (TypeAdapterFactory factory : factories) {\n        if (!skipPastFound) {\n            if (factory \u003d\u003d skipPast) {\n                skipPastFound \u003d true;\n            }\n            continue;\n        }\n        TypeAdapter\u003cT\u003e candidate \u003d factory.create(this, type);\n        if (candidate !\u003d null) {\n            return candidate;\n        }\n    }\n    throw new IllegalArgumentException(\"GSON cannot serialize \" + type);\n}",
      "path": "gson/src/main/java/com/google/gson/Gson.java",
      "functionStartLine": 474,
      "functionName": "getDelegateAdapter",
      "functionAnnotation": "",
      "functionDoc": "This method is used to get an alternate type adapter for the specified type. This is used\nto access a type adapter that is overridden by a {@link TypeAdapterFactory} that you\nmay have registered. This features is typically used when you want to register a type\nadapter that does a little bit of work but then delegates further processing to the Gson\ndefault type adapter. Here is an example:\n\u003cp\u003eLet\u0027s say we want to write a type adapter that counts the number of objects being read\n from or written to JSON. We can achieve this by writing a type adapter factory that uses\n the \u003ccode\u003egetDelegateAdapter\u003c/code\u003e method:\n \u003cpre\u003e {@code\n class StatsTypeAdapterFactory implements TypeAdapterFactory {\n   public int numReads \u003d 0;\n   public int numWrites \u003d 0;\n   public \u0026lt;T\u0026gt; TypeAdapter\u0026lt;T\u0026gt; create(Gson gson, TypeToken\u0026lt;T\u0026gt; type) {\n     final TypeAdapter\u0026lt;T\u0026gt; delegate \u003d gson.getDelegateAdapter(this, type);\n     return new TypeAdapter\u0026lt;T\u0026gt;() {\n       public void write(JsonWriter out, T value) throws IOException {\n         ++numWrites;\n         delegate.write(out, value);\n       }\n       public T read(JsonReader in) throws IOException {\n         ++numReads;\n         return delegate.read(in);\n       }\n     };\n   }\n }\n } \u003c/pre\u003e\n This factory can now be used like this:\n \u003cpre\u003e {@code\n StatsTypeAdapterFactory stats \u003d new StatsTypeAdapterFactory();\n Gson gson \u003d new GsonBuilder().registerTypeAdapterFactory(stats).create();\n // Call gson.toJson() and fromJson methods on objects\n System.out.println(\"Num JSON reads\" + stats.numReads);\n System.out.println(\"Num JSON writes\" + stats.numWrites);\n }\u003c/pre\u003e\n Note that this call will skip all factories registered before {@code skipPast}. In case of\n multiple TypeAdapterFactories registered it is up to the caller of this function to insure\n that the order of registration does not prevent this method from reaching a factory they\n would expect to reply from this call.\n Note that since you can not override type adapter factories for String and Java primitive\n types, our stats factory will not count the number of String or primitives that will be\n read or written.\n\n@param skipPast The type adapter factory that needs to be skipped while searching for\n  a matching type adapter. In most cases, you should just pass \u003ci\u003ethis\u003c/i\u003e (the type adapter\n  factory from where {@link #getDelegateAdapter} method is being invoked).\n@param type Type for which the delegate adapter is being searched for.\n@since 2.2\n",
      "diff": "",
      "extendedDetails": {
        "oldValue": "This method is used to get an alternate type adapter for the specified type. This is used\nto access a type adapter that is overridden by a {@link TypeAdapterFactory} that you\nmay have registered. This features is typically used when you want to register a type\nadapter that does a little bit of work but then delegates further processing to the Gson\ndefault type adapter. Here is an example:\n\u003cp\u003eLet\u0027s say we want to write a type adapter that counts the number of objects being read\n from or written to JSON. We can achieve this by writing a type adapter factory that uses\n the \u003ccode\u003egetDelegateAdapter\u003c/code\u003e method:\n \u003cpre\u003e {@code\n class StatsTypeAdapterFactory implements TypeAdapterFactory {\n   public int numReads \u003d 0;\n   public int numWrites \u003d 0;\n   public \u0026lt;T\u0026gt; TypeAdapter\u0026lt;T\u0026gt; create(Gson gson, TypeToken\u0026lt;T\u0026gt; type) {\n     final TypeAdapter\u0026lt;T\u0026gt; delegate \u003d gson.getDelegateAdapter(this, type);\n     return new TypeAdapter\u0026lt;T\u0026gt;() {\n       public void write(JsonWriter out, T value) throws IOException {\n         ++numWrites;\n         delegate.write(out, value);\n       }\n       public T read(JsonReader in) throws IOException {\n         ++numReads;\n         return delegate.read(in);\n       }\n     };\n   }\n }\n } \u003c/pre\u003e\n This factory can now be used like this:\n \u003cpre\u003e {@code\n StatsTypeAdapterFactory stats \u003d new StatsTypeAdapterFactory();\n Gson gson \u003d new GsonBuilder().registerTypeAdapterFactory(stats).create();\n // Call gson.toJson() and fromJson methods on objects\n System.out.println(\"Num JSON reads\" + stats.numReads);\n System.out.println(\"Num JSON writes\" + stats.numWrites);\n }\u003c/pre\u003e\n Note that this call will skip all factories registered before {@code skipPast}. In case of\n multiple TypeAdapterFactories registered it is up to the caller of this function to insure\n that the order of registration does not prevent this method from reaching a factory they \n would expect to reply from this call.\n Note that since you can not override type adapter factories for String and Java primitive\n types, our stats factory will not count the number of String or primitives that will be\n read or written.\n\n@param skipPast The type adapter factory that needs to be skipped while searching for\n  a matching type adapter. In most cases, you should just pass \u003ci\u003ethis\u003c/i\u003e (the type adapter\n  factory from where {@link #getDelegateAdapter} method is being invoked).\n@param type Type for which the delegate adapter is being searched for.\n@since 2.2\n",
        "newValue": "This method is used to get an alternate type adapter for the specified type. This is used\nto access a type adapter that is overridden by a {@link TypeAdapterFactory} that you\nmay have registered. This features is typically used when you want to register a type\nadapter that does a little bit of work but then delegates further processing to the Gson\ndefault type adapter. Here is an example:\n\u003cp\u003eLet\u0027s say we want to write a type adapter that counts the number of objects being read\n from or written to JSON. We can achieve this by writing a type adapter factory that uses\n the \u003ccode\u003egetDelegateAdapter\u003c/code\u003e method:\n \u003cpre\u003e {@code\n class StatsTypeAdapterFactory implements TypeAdapterFactory {\n   public int numReads \u003d 0;\n   public int numWrites \u003d 0;\n   public \u0026lt;T\u0026gt; TypeAdapter\u0026lt;T\u0026gt; create(Gson gson, TypeToken\u0026lt;T\u0026gt; type) {\n     final TypeAdapter\u0026lt;T\u0026gt; delegate \u003d gson.getDelegateAdapter(this, type);\n     return new TypeAdapter\u0026lt;T\u0026gt;() {\n       public void write(JsonWriter out, T value) throws IOException {\n         ++numWrites;\n         delegate.write(out, value);\n       }\n       public T read(JsonReader in) throws IOException {\n         ++numReads;\n         return delegate.read(in);\n       }\n     };\n   }\n }\n } \u003c/pre\u003e\n This factory can now be used like this:\n \u003cpre\u003e {@code\n StatsTypeAdapterFactory stats \u003d new StatsTypeAdapterFactory();\n Gson gson \u003d new GsonBuilder().registerTypeAdapterFactory(stats).create();\n // Call gson.toJson() and fromJson methods on objects\n System.out.println(\"Num JSON reads\" + stats.numReads);\n System.out.println(\"Num JSON writes\" + stats.numWrites);\n }\u003c/pre\u003e\n Note that this call will skip all factories registered before {@code skipPast}. In case of\n multiple TypeAdapterFactories registered it is up to the caller of this function to insure\n that the order of registration does not prevent this method from reaching a factory they\n would expect to reply from this call.\n Note that since you can not override type adapter factories for String and Java primitive\n types, our stats factory will not count the number of String or primitives that will be\n read or written.\n\n@param skipPast The type adapter factory that needs to be skipped while searching for\n  a matching type adapter. In most cases, you should just pass \u003ci\u003ethis\u003c/i\u003e (the type adapter\n  factory from where {@link #getDelegateAdapter} method is being invoked).\n@param type Type for which the delegate adapter is being searched for.\n@since 2.2\n"
      }
    },
    "618343fd1bae998ac9ebfde37a56eb4f498a59d7": {
      "type": "Ydocchange",
      "commitMessage": "Clarify the fact that the behaviour of getDelegateAdapter depends on registration order.\n",
      "commitDate": "9/3/15, 10:15 AM",
      "commitName": "618343fd1bae998ac9ebfde37a56eb4f498a59d7",
      "commitAuthor": "Dorvaryn",
      "commitDateOld": "8/10/15, 7:04 AM",
      "commitNameOld": "0c4ae018361d4756123c82c2f67ad04385caec5b",
      "commitAuthorOld": "Inderjeet Singh",
      "daysBetweenCommits": 24.13,
      "commitsBetweenForRepo": 4,
      "commitsBetweenForFile": 1,
      "actualSource": "public \u003cT\u003e TypeAdapter\u003cT\u003e getDelegateAdapter(TypeAdapterFactory skipPast, TypeToken\u003cT\u003e type) {\n    boolean skipPastFound \u003d false;\n    if (!factories.contains(skipPast))\n        skipPastFound \u003d true;\n    for (TypeAdapterFactory factory : factories) {\n        if (!skipPastFound) {\n            if (factory \u003d\u003d skipPast) {\n                skipPastFound \u003d true;\n            }\n            continue;\n        }\n        TypeAdapter\u003cT\u003e candidate \u003d factory.create(this, type);\n        if (candidate !\u003d null) {\n            return candidate;\n        }\n    }\n    throw new IllegalArgumentException(\"GSON cannot serialize \" + type);\n}",
      "path": "gson/src/main/java/com/google/gson/Gson.java",
      "functionStartLine": 427,
      "functionName": "getDelegateAdapter",
      "functionAnnotation": "",
      "functionDoc": "This method is used to get an alternate type adapter for the specified type. This is used\nto access a type adapter that is overridden by a {@link TypeAdapterFactory} that you\nmay have registered. This features is typically used when you want to register a type\nadapter that does a little bit of work but then delegates further processing to the Gson\ndefault type adapter. Here is an example:\n\u003cp\u003eLet\u0027s say we want to write a type adapter that counts the number of objects being read\n from or written to JSON. We can achieve this by writing a type adapter factory that uses\n the \u003ccode\u003egetDelegateAdapter\u003c/code\u003e method:\n \u003cpre\u003e {@code\n class StatsTypeAdapterFactory implements TypeAdapterFactory {\n   public int numReads \u003d 0;\n   public int numWrites \u003d 0;\n   public \u0026lt;T\u0026gt; TypeAdapter\u0026lt;T\u0026gt; create(Gson gson, TypeToken\u0026lt;T\u0026gt; type) {\n     final TypeAdapter\u0026lt;T\u0026gt; delegate \u003d gson.getDelegateAdapter(this, type);\n     return new TypeAdapter\u0026lt;T\u0026gt;() {\n       public void write(JsonWriter out, T value) throws IOException {\n         ++numWrites;\n         delegate.write(out, value);\n       }\n       public T read(JsonReader in) throws IOException {\n         ++numReads;\n         return delegate.read(in);\n       }\n     };\n   }\n }\n } \u003c/pre\u003e\n This factory can now be used like this:\n \u003cpre\u003e {@code\n StatsTypeAdapterFactory stats \u003d new StatsTypeAdapterFactory();\n Gson gson \u003d new GsonBuilder().registerTypeAdapterFactory(stats).create();\n // Call gson.toJson() and fromJson methods on objects\n System.out.println(\"Num JSON reads\" + stats.numReads);\n System.out.println(\"Num JSON writes\" + stats.numWrites);\n }\u003c/pre\u003e\n Note that this call will skip all factories registered before {@code skipPast}. In case of\n multiple TypeAdapterFactories registered it is up to the caller of this function to insure\n that the order of registration does not prevent this method from reaching a factory they \n would expect to reply from this call.\n Note that since you can not override type adapter factories for String and Java primitive\n types, our stats factory will not count the number of String or primitives that will be\n read or written.\n\n@param skipPast The type adapter factory that needs to be skipped while searching for\n  a matching type adapter. In most cases, you should just pass \u003ci\u003ethis\u003c/i\u003e (the type adapter\n  factory from where {@link #getDelegateAdapter} method is being invoked).\n@param type Type for which the delegate adapter is being searched for.\n@since 2.2\n",
      "diff": "",
      "extendedDetails": {
        "oldValue": "This method is used to get an alternate type adapter for the specified type. This is used\nto access a type adapter that is overridden by a {@link TypeAdapterFactory} that you\nmay have registered. This features is typically used when you want to register a type\nadapter that does a little bit of work but then delegates further processing to the Gson\ndefault type adapter. Here is an example:\n\u003cp\u003eLet\u0027s say we want to write a type adapter that counts the number of objects being read\n from or written to JSON. We can achieve this by writing a type adapter factory that uses\n the \u003ccode\u003egetDelegateAdapter\u003c/code\u003e method:\n \u003cpre\u003e {@code\n class StatsTypeAdapterFactory implements TypeAdapterFactory {\n   public int numReads \u003d 0;\n   public int numWrites \u003d 0;\n   public \u0026lt;T\u0026gt; TypeAdapter\u0026lt;T\u0026gt; create(Gson gson, TypeToken\u0026lt;T\u0026gt; type) {\n     final TypeAdapter\u0026lt;T\u0026gt; delegate \u003d gson.getDelegateAdapter(this, type);\n     return new TypeAdapter\u0026lt;T\u0026gt;() {\n       public void write(JsonWriter out, T value) throws IOException {\n         ++numWrites;\n         delegate.write(out, value);\n       }\n       public T read(JsonReader in) throws IOException {\n         ++numReads;\n         return delegate.read(in);\n       }\n     };\n   }\n }\n } \u003c/pre\u003e\n This factory can now be used like this:\n \u003cpre\u003e {@code\n StatsTypeAdapterFactory stats \u003d new StatsTypeAdapterFactory();\n Gson gson \u003d new GsonBuilder().registerTypeAdapterFactory(stats).create();\n // Call gson.toJson() and fromJson methods on objects\n System.out.println(\"Num JSON reads\" + stats.numReads);\n System.out.println(\"Num JSON writes\" + stats.numWrites);\n }\u003c/pre\u003e\n Note that since you can not override type adapter factories for String and Java primitive\n types, our stats factory will not count the number of String or primitives that will be\n read or written.\n\n@param skipPast The type adapter factory that needs to be skipped while searching for\n  a matching type adapter. In most cases, you should just pass \u003ci\u003ethis\u003c/i\u003e (the type adapter\n  factory from where {@link #getDelegateAdapter} method is being invoked).\n@param type Type for which the delegate adapter is being searched for.\n@since 2.2\n",
        "newValue": "This method is used to get an alternate type adapter for the specified type. This is used\nto access a type adapter that is overridden by a {@link TypeAdapterFactory} that you\nmay have registered. This features is typically used when you want to register a type\nadapter that does a little bit of work but then delegates further processing to the Gson\ndefault type adapter. Here is an example:\n\u003cp\u003eLet\u0027s say we want to write a type adapter that counts the number of objects being read\n from or written to JSON. We can achieve this by writing a type adapter factory that uses\n the \u003ccode\u003egetDelegateAdapter\u003c/code\u003e method:\n \u003cpre\u003e {@code\n class StatsTypeAdapterFactory implements TypeAdapterFactory {\n   public int numReads \u003d 0;\n   public int numWrites \u003d 0;\n   public \u0026lt;T\u0026gt; TypeAdapter\u0026lt;T\u0026gt; create(Gson gson, TypeToken\u0026lt;T\u0026gt; type) {\n     final TypeAdapter\u0026lt;T\u0026gt; delegate \u003d gson.getDelegateAdapter(this, type);\n     return new TypeAdapter\u0026lt;T\u0026gt;() {\n       public void write(JsonWriter out, T value) throws IOException {\n         ++numWrites;\n         delegate.write(out, value);\n       }\n       public T read(JsonReader in) throws IOException {\n         ++numReads;\n         return delegate.read(in);\n       }\n     };\n   }\n }\n } \u003c/pre\u003e\n This factory can now be used like this:\n \u003cpre\u003e {@code\n StatsTypeAdapterFactory stats \u003d new StatsTypeAdapterFactory();\n Gson gson \u003d new GsonBuilder().registerTypeAdapterFactory(stats).create();\n // Call gson.toJson() and fromJson methods on objects\n System.out.println(\"Num JSON reads\" + stats.numReads);\n System.out.println(\"Num JSON writes\" + stats.numWrites);\n }\u003c/pre\u003e\n Note that this call will skip all factories registered before {@code skipPast}. In case of\n multiple TypeAdapterFactories registered it is up to the caller of this function to insure\n that the order of registration does not prevent this method from reaching a factory they \n would expect to reply from this call.\n Note that since you can not override type adapter factories for String and Java primitive\n types, our stats factory will not count the number of String or primitives that will be\n read or written.\n\n@param skipPast The type adapter factory that needs to be skipped while searching for\n  a matching type adapter. In most cases, you should just pass \u003ci\u003ethis\u003c/i\u003e (the type adapter\n  factory from where {@link #getDelegateAdapter} method is being invoked).\n@param type Type for which the delegate adapter is being searched for.\n@since 2.2\n"
      }
    },
    "f2591b666419e06017b2327f7729440c122bf675": {
      "type": "Ybodychange",
      "commitMessage": "adjusted factory finding code to take into account non-present factories\n",
      "commitDate": "11/10/14, 3:15 PM",
      "commitName": "f2591b666419e06017b2327f7729440c122bf675",
      "commitAuthor": "Inderjeet Singh",
      "commitDateOld": "11/3/14, 4:59 PM",
      "commitNameOld": "7f8f490fdc95fb087e735dc582a2af07cee46078",
      "commitAuthorOld": "Jake Wharton",
      "daysBetweenCommits": 6.93,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "public \u003cT\u003e TypeAdapter\u003cT\u003e getDelegateAdapter(TypeAdapterFactory skipPast, TypeToken\u003cT\u003e type) {\n    boolean skipPastFound \u003d false;\n    if (!factories.contains(skipPast))\n        skipPastFound \u003d true;\n    for (TypeAdapterFactory factory : factories) {\n        if (!skipPastFound) {\n            if (factory \u003d\u003d skipPast) {\n                skipPastFound \u003d true;\n            }\n            continue;\n        }\n        TypeAdapter\u003cT\u003e candidate \u003d factory.create(this, type);\n        if (candidate !\u003d null) {\n            return candidate;\n        }\n    }\n    throw new IllegalArgumentException(\"GSON cannot serialize \" + type);\n}",
      "path": "gson/src/main/java/com/google/gson/Gson.java",
      "functionStartLine": 421,
      "functionName": "getDelegateAdapter",
      "functionAnnotation": "",
      "functionDoc": "This method is used to get an alternate type adapter for the specified type. This is used\nto access a type adapter that is overridden by a {@link TypeAdapterFactory} that you\nmay have registered. This features is typically used when you want to register a type\nadapter that does a little bit of work but then delegates further processing to the Gson\ndefault type adapter. Here is an example:\n\u003cp\u003eLet\u0027s say we want to write a type adapter that counts the number of objects being read\n from or written to JSON. We can achieve this by writing a type adapter factory that uses\n the \u003ccode\u003egetDelegateAdapter\u003c/code\u003e method:\n \u003cpre\u003e {@code\n class StatsTypeAdapterFactory implements TypeAdapterFactory {\n   public int numReads \u003d 0;\n   public int numWrites \u003d 0;\n   public \u0026lt;T\u0026gt; TypeAdapter\u0026lt;T\u0026gt; create(Gson gson, TypeToken\u0026lt;T\u0026gt; type) {\n     final TypeAdapter\u0026lt;T\u0026gt; delegate \u003d gson.getDelegateAdapter(this, type);\n     return new TypeAdapter\u0026lt;T\u0026gt;() {\n       public void write(JsonWriter out, T value) throws IOException {\n         ++numWrites;\n         delegate.write(out, value);\n       }\n       public T read(JsonReader in) throws IOException {\n         ++numReads;\n         return delegate.read(in);\n       }\n     };\n   }\n }\n } \u003c/pre\u003e\n This factory can now be used like this:\n \u003cpre\u003e {@code\n StatsTypeAdapterFactory stats \u003d new StatsTypeAdapterFactory();\n Gson gson \u003d new GsonBuilder().registerTypeAdapterFactory(stats).create();\n // Call gson.toJson() and fromJson methods on objects\n System.out.println(\"Num JSON reads\" + stats.numReads);\n System.out.println(\"Num JSON writes\" + stats.numWrites);\n }\u003c/pre\u003e\n Note that since you can not override type adapter factories for String and Java primitive\n types, our stats factory will not count the number of String or primitives that will be\n read or written.\n\n@param skipPast The type adapter factory that needs to be skipped while searching for\n  a matching type adapter. In most cases, you should just pass \u003ci\u003ethis\u003c/i\u003e (the type adapter\n  factory from where {@link #getDelegateAdapter} method is being invoked).\n@param type Type for which the delegate adapter is being searched for.\n@since 2.2\n",
      "diff": "@@ -1,16 +1,18 @@\n public \u003cT\u003e TypeAdapter\u003cT\u003e getDelegateAdapter(TypeAdapterFactory skipPast, TypeToken\u003cT\u003e type) {\n     boolean skipPastFound \u003d false;\n+    if (!factories.contains(skipPast))\n+        skipPastFound \u003d true;\n     for (TypeAdapterFactory factory : factories) {\n         if (!skipPastFound) {\n             if (factory \u003d\u003d skipPast) {\n                 skipPastFound \u003d true;\n             }\n             continue;\n         }\n         TypeAdapter\u003cT\u003e candidate \u003d factory.create(this, type);\n         if (candidate !\u003d null) {\n             return candidate;\n         }\n     }\n     throw new IllegalArgumentException(\"GSON cannot serialize \" + type);\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "4816941f0d76f2dc5d5b0b7b5fb3206d6fef641d": {
      "type": "Ydocchange",
      "commitMessage": "Address code review comments on r1154\n",
      "commitDate": "7/2/12, 1:32 PM",
      "commitName": "4816941f0d76f2dc5d5b0b7b5fb3206d6fef641d",
      "commitAuthor": "Jesse Wilson",
      "commitDateOld": "6/29/12, 7:37 PM",
      "commitNameOld": "dc4e43bb237c3878d12902e562ac352cbf463333",
      "commitAuthorOld": "Jesse Wilson",
      "daysBetweenCommits": 2.75,
      "commitsBetweenForRepo": 6,
      "commitsBetweenForFile": 1,
      "actualSource": "public \u003cT\u003e TypeAdapter\u003cT\u003e getDelegateAdapter(TypeAdapterFactory skipPast, TypeToken\u003cT\u003e type) {\n    boolean skipPastFound \u003d false;\n    for (TypeAdapterFactory factory : factories) {\n        if (!skipPastFound) {\n            if (factory \u003d\u003d skipPast) {\n                skipPastFound \u003d true;\n            }\n            continue;\n        }\n        TypeAdapter\u003cT\u003e candidate \u003d factory.create(this, type);\n        if (candidate !\u003d null) {\n            return candidate;\n        }\n    }\n    throw new IllegalArgumentException(\"GSON cannot serialize \" + type);\n}",
      "path": "gson/src/main/java/com/google/gson/Gson.java",
      "functionStartLine": 414,
      "functionName": "getDelegateAdapter",
      "functionAnnotation": "",
      "functionDoc": "This method is used to get an alternate type adapter for the specified type. This is used\nto access a type adapter that is overridden by a {@link TypeAdapterFactory} that you\nmay have registered. This features is typically used when you want to register a type\nadapter that does a little bit of work but then delegates further processing to the Gson\ndefault type adapter. Here is an example:\n\u003cp\u003eLet\u0027s say we want to write a type adapter that counts the number of objects being read\n from or written to JSON. We can achieve this by writing a type adapter factory that uses\n the \u003ccode\u003egetDelegateAdapter\u003c/code\u003e method:\n \u003cpre\u003e {@code\n class StatsTypeAdapterFactory implements TypeAdapterFactory {\n   public int numReads \u003d 0;\n   public int numWrites \u003d 0;\n   public \u0026lt;T\u0026gt; TypeAdapter\u0026lt;T\u0026gt; create(Gson gson, TypeToken\u0026lt;T\u0026gt; type) {\n     final TypeAdapter\u0026lt;T\u0026gt; delegate \u003d gson.getDelegateAdapter(this, type);\n     return new TypeAdapter\u0026lt;T\u0026gt;() {\n       public void write(JsonWriter out, T value) throws IOException {\n         ++numWrites;\n         delegate.write(out, value);\n       }\n       public T read(JsonReader in) throws IOException {\n         ++numReads;\n         return delegate.read(in);\n       }\n     };\n   }\n }\n } \u003c/pre\u003e\n This factory can now be used like this:\n \u003cpre\u003e {@code\n StatsTypeAdapterFactory stats \u003d new StatsTypeAdapterFactory();\n Gson gson \u003d new GsonBuilder().registerTypeAdapterFactory(stats).create();\n // Call gson.toJson() and fromJson methods on objects\n System.out.println(\"Num JSON reads\" + stats.numReads);\n System.out.println(\"Num JSON writes\" + stats.numWrites);\n }\u003c/pre\u003e\n Note that since you can not override type adapter factories for String and Java primitive\n types, our stats factory will not count the number of String or primitives that will be\n read or written.\n\n@param skipPast The type adapter factory that needs to be skipped while searching for\n  a matching type adapter. In most cases, you should just pass \u003ci\u003ethis\u003c/i\u003e (the type adapter\n  factory from where {@link #getDelegateAdapter} method is being invoked).\n@param type Type for which the delegate adapter is being searched for.\n@since 2.2\n",
      "diff": "",
      "extendedDetails": {
        "oldValue": "This method is used to get an alternate type adapter for the specified type. This is used\nto access a type adapter that is overridden by a {@link TypeAdapterFactory} that you\nmay have registered. This features is typically used when you want to register a type\nadapter that does a little bit of work but then delegates further processing to the Gson\ndefault type adapter. Here is an example:\n\u003cp\u003eLet\u0027s say we want to write a type adapter that counts the number of objects being read\n from or written to JSON. We can achieve this by writing a type adapter factory that uses\n the \u003ccode\u003egetDelegateAdapter\u003c/code\u003e method:\n \u003cpre\u003e {@code\n class StatsTypeAdapterFactory implements TypeAdapterFactory {\n   public int numReads \u003d 0;\n   public int numWrites \u003d 0;\n   public \u0026lt;T\u0026gt; TypeAdapter\u0026lt;T\u0026gt; create(Gson gson, TypeToken\u0026lt;T\u0026gt; type) {\n     final TypeAdapter\u0026lt;T\u0026gt; delegate \u003d gson.getDelegateAdapter(this, type);\n     return new TypeAdapter\u0026lt;T\u0026gt;() {\n       public void write(JsonWriter out, T value) throws IOException {\n         ++numWrites;\n         delegate.write(out, value);\n       }\n       public T read(JsonReader in) throws IOException {\n         ++numReads;\n         return delegate.read(in);\n       }\n     };\n   }\n }\n } \u003c/pre\u003e\n This factory can now be used like this:\n \u003cpre\u003e {@code\n StatsTypeAdapterFactory stats \u003d new StatsTypeAdapterFactory();\n Gson gson \u003d new GsonBuilder().registerTypeAdapterFactory(stats).create();\n // Call gson.toJson() and fromJson methods on objects\n System.out.println(\"Num JSON reads\" + stats.numReads);\n System.out.println(\"Num JSON writes\" + stats.numWrites);\n }\u003c/pre\u003e\n Note that since you can not override type adapter factories for String and Java primitive\n types, our stats factory will not count the number of String or primitives that will be\n read or written.\n\n@param skipPast The type adapter factory that needs to be skipped while searching for\n  a matching type adapter. In most cases, you should just pass \u003ci\u003ethis\u003c/i\u003e (the type adapter\n  factory from where {@link getDelegateAdapter} method is being invoked).\n@param type Type for which the delegate adapter is being searched for.\n@since 2.2\n",
        "newValue": "This method is used to get an alternate type adapter for the specified type. This is used\nto access a type adapter that is overridden by a {@link TypeAdapterFactory} that you\nmay have registered. This features is typically used when you want to register a type\nadapter that does a little bit of work but then delegates further processing to the Gson\ndefault type adapter. Here is an example:\n\u003cp\u003eLet\u0027s say we want to write a type adapter that counts the number of objects being read\n from or written to JSON. We can achieve this by writing a type adapter factory that uses\n the \u003ccode\u003egetDelegateAdapter\u003c/code\u003e method:\n \u003cpre\u003e {@code\n class StatsTypeAdapterFactory implements TypeAdapterFactory {\n   public int numReads \u003d 0;\n   public int numWrites \u003d 0;\n   public \u0026lt;T\u0026gt; TypeAdapter\u0026lt;T\u0026gt; create(Gson gson, TypeToken\u0026lt;T\u0026gt; type) {\n     final TypeAdapter\u0026lt;T\u0026gt; delegate \u003d gson.getDelegateAdapter(this, type);\n     return new TypeAdapter\u0026lt;T\u0026gt;() {\n       public void write(JsonWriter out, T value) throws IOException {\n         ++numWrites;\n         delegate.write(out, value);\n       }\n       public T read(JsonReader in) throws IOException {\n         ++numReads;\n         return delegate.read(in);\n       }\n     };\n   }\n }\n } \u003c/pre\u003e\n This factory can now be used like this:\n \u003cpre\u003e {@code\n StatsTypeAdapterFactory stats \u003d new StatsTypeAdapterFactory();\n Gson gson \u003d new GsonBuilder().registerTypeAdapterFactory(stats).create();\n // Call gson.toJson() and fromJson methods on objects\n System.out.println(\"Num JSON reads\" + stats.numReads);\n System.out.println(\"Num JSON writes\" + stats.numWrites);\n }\u003c/pre\u003e\n Note that since you can not override type adapter factories for String and Java primitive\n types, our stats factory will not count the number of String or primitives that will be\n read or written.\n\n@param skipPast The type adapter factory that needs to be skipped while searching for\n  a matching type adapter. In most cases, you should just pass \u003ci\u003ethis\u003c/i\u003e (the type adapter\n  factory from where {@link #getDelegateAdapter} method is being invoked).\n@param type Type for which the delegate adapter is being searched for.\n@since 2.2\n"
      }
    },
    "83e5a4937cf13ab9b94a7bb12ce2fefa168752ed": {
      "type": "Ymultichange(Yrename,Ydocchange)",
      "commitMessage": "Renamed Gson.getNextAdapter to getDelegateAdapter.\nDeleted testParameterizedMapSubclassDeserialization which we decided to not fix.\nAdded simple tests for getDelegateAdapter\n",
      "commitDate": "4/12/12, 11:49 AM",
      "commitName": "83e5a4937cf13ab9b94a7bb12ce2fefa168752ed",
      "commitAuthor": "Inderjeet Singh",
      "subchanges": [
        {
          "type": "Yrename",
          "commitMessage": "Renamed Gson.getNextAdapter to getDelegateAdapter.\nDeleted testParameterizedMapSubclassDeserialization which we decided to not fix.\nAdded simple tests for getDelegateAdapter\n",
          "commitDate": "4/12/12, 11:49 AM",
          "commitName": "83e5a4937cf13ab9b94a7bb12ce2fefa168752ed",
          "commitAuthor": "Inderjeet Singh",
          "commitDateOld": "3/18/12, 10:55 AM",
          "commitNameOld": "9be0fd9ecc91ba0eacf885faeec5f3d1d82fa99f",
          "commitAuthorOld": "Jesse Wilson",
          "daysBetweenCommits": 25.04,
          "commitsBetweenForRepo": 8,
          "commitsBetweenForFile": 1,
          "actualSource": "public \u003cT\u003e TypeAdapter\u003cT\u003e getDelegateAdapter(TypeAdapterFactory skipPast, TypeToken\u003cT\u003e type) {\n    boolean skipPastFound \u003d false;\n    for (TypeAdapterFactory factory : factories) {\n        if (!skipPastFound) {\n            if (factory \u003d\u003d skipPast) {\n                skipPastFound \u003d true;\n            }\n            continue;\n        }\n        TypeAdapter\u003cT\u003e candidate \u003d factory.create(this, type);\n        if (candidate !\u003d null) {\n            return candidate;\n        }\n    }\n    throw new IllegalArgumentException(\"GSON cannot serialize \" + type);\n}",
          "path": "gson/src/main/java/com/google/gson/Gson.java",
          "functionStartLine": 408,
          "functionName": "getDelegateAdapter",
          "functionAnnotation": "",
          "functionDoc": "This method is used to get an alternate type adapter for the specified type. This is used\nto access a type adapter that is overridden by a {@link TypeAdapterFactory} that you\nmay have registered. This features is typically used when you want to register a type\nadapter that does a little bit of work but then delegates further processing to the Gson\ndefault type adapter. Here is an example:\n\u003cp\u003eLet\u0027s say we want to write a type adapter that counts the number of objects being read\n from or written to JSON. We can achieve this by writing a type adapter factory that uses\n the \u003ccode\u003egetDelegateAdapter\u003c/code\u003e method:\n \u003cpre\u003e {@code\n class StatsTypeAdapterFactory implements TypeAdapterFactory {\n   public int numReads \u003d 0;\n   public int numWrites \u003d 0;\n   public \u0026lt;T\u0026gt; TypeAdapter\u0026lt;T\u0026gt; create(Gson gson, TypeToken\u0026lt;T\u0026gt; type) {\n     final TypeAdapter\u0026lt;T\u0026gt; delegate \u003d gson.getDelegateAdapter(this, type);\n     return new TypeAdapter\u0026lt;T\u0026gt;() {\n       public void write(JsonWriter out, T value) throws IOException {\n         ++numWrites;\n         delegate.write(out, value);\n       }\n       public T read(JsonReader in) throws IOException {\n         ++numReads;\n         return delegate.read(in);\n       }\n     };\n   }\n }\n } \u003c/pre\u003e\n This factory can now be used like this:\n \u003cpre\u003e {@code\n StatsTypeAdapterFactory stats \u003d new StatsTypeAdapterFactory();\n Gson gson \u003d new GsonBuilder().registerTypeAdapterFactory(stats).create();\n // Call gson.toJson() and fromJson methods on objects\n System.out.println(\"Num JSON reads\" + stats.numReads);\n System.out.println(\"Num JSON writes\" + stats.numWrites);\n }\u003c/pre\u003e\n Note that since you can not override type adapter factories for String and Java primitive\n types, our stats factory will not count the number of String or primitives that will be\n read or written.\n\n@param skipPast The type adapter factory that needs to be skipped while searching for\n  a matching type adapter. In most cases, you should just pass \u003ci\u003ethis\u003c/i\u003e (the type adapter\n  factory from where {@link getDelegateAdapter} method is being invoked).\n@param type Type for which the delegate adapter is being searched for.\n@since 2.2\n",
          "diff": "@@ -1,16 +1,16 @@\n-public \u003cT\u003e TypeAdapter\u003cT\u003e getNextAdapter(TypeAdapterFactory skipPast, TypeToken\u003cT\u003e type) {\n+public \u003cT\u003e TypeAdapter\u003cT\u003e getDelegateAdapter(TypeAdapterFactory skipPast, TypeToken\u003cT\u003e type) {\n     boolean skipPastFound \u003d false;\n     for (TypeAdapterFactory factory : factories) {\n         if (!skipPastFound) {\n             if (factory \u003d\u003d skipPast) {\n                 skipPastFound \u003d true;\n             }\n             continue;\n         }\n         TypeAdapter\u003cT\u003e candidate \u003d factory.create(this, type);\n         if (candidate !\u003d null) {\n             return candidate;\n         }\n     }\n     throw new IllegalArgumentException(\"GSON cannot serialize \" + type);\n }\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldValue": "getNextAdapter",
            "newValue": "getDelegateAdapter"
          }
        },
        {
          "type": "Ydocchange",
          "commitMessage": "Renamed Gson.getNextAdapter to getDelegateAdapter.\nDeleted testParameterizedMapSubclassDeserialization which we decided to not fix.\nAdded simple tests for getDelegateAdapter\n",
          "commitDate": "4/12/12, 11:49 AM",
          "commitName": "83e5a4937cf13ab9b94a7bb12ce2fefa168752ed",
          "commitAuthor": "Inderjeet Singh",
          "commitDateOld": "3/18/12, 10:55 AM",
          "commitNameOld": "9be0fd9ecc91ba0eacf885faeec5f3d1d82fa99f",
          "commitAuthorOld": "Jesse Wilson",
          "daysBetweenCommits": 25.04,
          "commitsBetweenForRepo": 8,
          "commitsBetweenForFile": 1,
          "actualSource": "public \u003cT\u003e TypeAdapter\u003cT\u003e getDelegateAdapter(TypeAdapterFactory skipPast, TypeToken\u003cT\u003e type) {\n    boolean skipPastFound \u003d false;\n    for (TypeAdapterFactory factory : factories) {\n        if (!skipPastFound) {\n            if (factory \u003d\u003d skipPast) {\n                skipPastFound \u003d true;\n            }\n            continue;\n        }\n        TypeAdapter\u003cT\u003e candidate \u003d factory.create(this, type);\n        if (candidate !\u003d null) {\n            return candidate;\n        }\n    }\n    throw new IllegalArgumentException(\"GSON cannot serialize \" + type);\n}",
          "path": "gson/src/main/java/com/google/gson/Gson.java",
          "functionStartLine": 408,
          "functionName": "getDelegateAdapter",
          "functionAnnotation": "",
          "functionDoc": "This method is used to get an alternate type adapter for the specified type. This is used\nto access a type adapter that is overridden by a {@link TypeAdapterFactory} that you\nmay have registered. This features is typically used when you want to register a type\nadapter that does a little bit of work but then delegates further processing to the Gson\ndefault type adapter. Here is an example:\n\u003cp\u003eLet\u0027s say we want to write a type adapter that counts the number of objects being read\n from or written to JSON. We can achieve this by writing a type adapter factory that uses\n the \u003ccode\u003egetDelegateAdapter\u003c/code\u003e method:\n \u003cpre\u003e {@code\n class StatsTypeAdapterFactory implements TypeAdapterFactory {\n   public int numReads \u003d 0;\n   public int numWrites \u003d 0;\n   public \u0026lt;T\u0026gt; TypeAdapter\u0026lt;T\u0026gt; create(Gson gson, TypeToken\u0026lt;T\u0026gt; type) {\n     final TypeAdapter\u0026lt;T\u0026gt; delegate \u003d gson.getDelegateAdapter(this, type);\n     return new TypeAdapter\u0026lt;T\u0026gt;() {\n       public void write(JsonWriter out, T value) throws IOException {\n         ++numWrites;\n         delegate.write(out, value);\n       }\n       public T read(JsonReader in) throws IOException {\n         ++numReads;\n         return delegate.read(in);\n       }\n     };\n   }\n }\n } \u003c/pre\u003e\n This factory can now be used like this:\n \u003cpre\u003e {@code\n StatsTypeAdapterFactory stats \u003d new StatsTypeAdapterFactory();\n Gson gson \u003d new GsonBuilder().registerTypeAdapterFactory(stats).create();\n // Call gson.toJson() and fromJson methods on objects\n System.out.println(\"Num JSON reads\" + stats.numReads);\n System.out.println(\"Num JSON writes\" + stats.numWrites);\n }\u003c/pre\u003e\n Note that since you can not override type adapter factories for String and Java primitive\n types, our stats factory will not count the number of String or primitives that will be\n read or written.\n\n@param skipPast The type adapter factory that needs to be skipped while searching for\n  a matching type adapter. In most cases, you should just pass \u003ci\u003ethis\u003c/i\u003e (the type adapter\n  factory from where {@link getDelegateAdapter} method is being invoked).\n@param type Type for which the delegate adapter is being searched for.\n@since 2.2\n",
          "diff": "@@ -1,16 +1,16 @@\n-public \u003cT\u003e TypeAdapter\u003cT\u003e getNextAdapter(TypeAdapterFactory skipPast, TypeToken\u003cT\u003e type) {\n+public \u003cT\u003e TypeAdapter\u003cT\u003e getDelegateAdapter(TypeAdapterFactory skipPast, TypeToken\u003cT\u003e type) {\n     boolean skipPastFound \u003d false;\n     for (TypeAdapterFactory factory : factories) {\n         if (!skipPastFound) {\n             if (factory \u003d\u003d skipPast) {\n                 skipPastFound \u003d true;\n             }\n             continue;\n         }\n         TypeAdapter\u003cT\u003e candidate \u003d factory.create(this, type);\n         if (candidate !\u003d null) {\n             return candidate;\n         }\n     }\n     throw new IllegalArgumentException(\"GSON cannot serialize \" + type);\n }\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldValue": "TODO: needs documentation\n\n@since 2.2\n",
            "newValue": "This method is used to get an alternate type adapter for the specified type. This is used\nto access a type adapter that is overridden by a {@link TypeAdapterFactory} that you\nmay have registered. This features is typically used when you want to register a type\nadapter that does a little bit of work but then delegates further processing to the Gson\ndefault type adapter. Here is an example:\n\u003cp\u003eLet\u0027s say we want to write a type adapter that counts the number of objects being read\n from or written to JSON. We can achieve this by writing a type adapter factory that uses\n the \u003ccode\u003egetDelegateAdapter\u003c/code\u003e method:\n \u003cpre\u003e {@code\n class StatsTypeAdapterFactory implements TypeAdapterFactory {\n   public int numReads \u003d 0;\n   public int numWrites \u003d 0;\n   public \u0026lt;T\u0026gt; TypeAdapter\u0026lt;T\u0026gt; create(Gson gson, TypeToken\u0026lt;T\u0026gt; type) {\n     final TypeAdapter\u0026lt;T\u0026gt; delegate \u003d gson.getDelegateAdapter(this, type);\n     return new TypeAdapter\u0026lt;T\u0026gt;() {\n       public void write(JsonWriter out, T value) throws IOException {\n         ++numWrites;\n         delegate.write(out, value);\n       }\n       public T read(JsonReader in) throws IOException {\n         ++numReads;\n         return delegate.read(in);\n       }\n     };\n   }\n }\n } \u003c/pre\u003e\n This factory can now be used like this:\n \u003cpre\u003e {@code\n StatsTypeAdapterFactory stats \u003d new StatsTypeAdapterFactory();\n Gson gson \u003d new GsonBuilder().registerTypeAdapterFactory(stats).create();\n // Call gson.toJson() and fromJson methods on objects\n System.out.println(\"Num JSON reads\" + stats.numReads);\n System.out.println(\"Num JSON writes\" + stats.numWrites);\n }\u003c/pre\u003e\n Note that since you can not override type adapter factories for String and Java primitive\n types, our stats factory will not count the number of String or primitives that will be\n read or written.\n\n@param skipPast The type adapter factory that needs to be skipped while searching for\n  a matching type adapter. In most cases, you should just pass \u003ci\u003ethis\u003c/i\u003e (the type adapter\n  factory from where {@link getDelegateAdapter} method is being invoked).\n@param type Type for which the delegate adapter is being searched for.\n@since 2.2\n"
          }
        }
      ]
    },
    "6c78bf5247828219d4383c1b5dd13d494fa65cec": {
      "type": "Ymultichange(Yparameterchange,Ybodychange,Yannotationchange,Ydocchange)",
      "commitMessage": "made toJson/fromJson/toJsonTree methods public in TypeAdapter.\nmade Gson.getNextAdapter method public.\n",
      "commitDate": "12/31/11, 12:52 AM",
      "commitName": "6c78bf5247828219d4383c1b5dd13d494fa65cec",
      "commitAuthor": "Inderjeet Singh",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "made toJson/fromJson/toJsonTree methods public in TypeAdapter.\nmade Gson.getNextAdapter method public.\n",
          "commitDate": "12/31/11, 12:52 AM",
          "commitName": "6c78bf5247828219d4383c1b5dd13d494fa65cec",
          "commitAuthor": "Inderjeet Singh",
          "commitDateOld": "12/30/11, 9:30 PM",
          "commitNameOld": "ecdf9150f6cc820dafddea5b545f456fed47472f",
          "commitAuthorOld": "Jesse Wilson",
          "daysBetweenCommits": 0.14,
          "commitsBetweenForRepo": 6,
          "commitsBetweenForFile": 1,
          "actualSource": "public \u003cT\u003e TypeAdapter\u003cT\u003e getNextAdapter(TypeAdapterFactory skipPast, TypeToken\u003cT\u003e type) {\n    boolean skipPastFound \u003d false;\n    for (TypeAdapterFactory factory : factories) {\n        if (!skipPastFound) {\n            if (factory \u003d\u003d skipPast) {\n                skipPastFound \u003d true;\n            }\n            continue;\n        }\n        TypeAdapter\u003cT\u003e candidate \u003d factory.create(this, type);\n        if (candidate !\u003d null) {\n            return candidate;\n        }\n    }\n    throw new IllegalArgumentException(\"GSON cannot serialize \" + type);\n}",
          "path": "gson/src/main/java/com/google/gson/Gson.java",
          "functionStartLine": 370,
          "functionName": "getNextAdapter",
          "functionAnnotation": "",
          "functionDoc": "TODO: needs documentation\n\n@since 2.2\n",
          "diff": "@@ -1,17 +1,16 @@\n-@Override\n-public \u003cT\u003e TypeAdapter\u003cT\u003e getNextAdapter(Gson gson, TypeAdapterFactory skipPast, TypeToken\u003cT\u003e type) {\n+public \u003cT\u003e TypeAdapter\u003cT\u003e getNextAdapter(TypeAdapterFactory skipPast, TypeToken\u003cT\u003e type) {\n     boolean skipPastFound \u003d false;\n-    for (TypeAdapterFactory factory : gson.factories) {\n+    for (TypeAdapterFactory factory : factories) {\n         if (!skipPastFound) {\n             if (factory \u003d\u003d skipPast) {\n                 skipPastFound \u003d true;\n             }\n             continue;\n         }\n-        TypeAdapter\u003cT\u003e candidate \u003d factory.create(gson, type);\n+        TypeAdapter\u003cT\u003e candidate \u003d factory.create(this, type);\n         if (candidate !\u003d null) {\n             return candidate;\n         }\n     }\n     throw new IllegalArgumentException(\"GSON cannot serialize \" + type);\n }\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldValue": "[gson-Gson, skipPast-TypeAdapterFactory, type-TypeToken\u003cT\u003e]",
            "newValue": "[skipPast-TypeAdapterFactory, type-TypeToken\u003cT\u003e]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "made toJson/fromJson/toJsonTree methods public in TypeAdapter.\nmade Gson.getNextAdapter method public.\n",
          "commitDate": "12/31/11, 12:52 AM",
          "commitName": "6c78bf5247828219d4383c1b5dd13d494fa65cec",
          "commitAuthor": "Inderjeet Singh",
          "commitDateOld": "12/30/11, 9:30 PM",
          "commitNameOld": "ecdf9150f6cc820dafddea5b545f456fed47472f",
          "commitAuthorOld": "Jesse Wilson",
          "daysBetweenCommits": 0.14,
          "commitsBetweenForRepo": 6,
          "commitsBetweenForFile": 1,
          "actualSource": "public \u003cT\u003e TypeAdapter\u003cT\u003e getNextAdapter(TypeAdapterFactory skipPast, TypeToken\u003cT\u003e type) {\n    boolean skipPastFound \u003d false;\n    for (TypeAdapterFactory factory : factories) {\n        if (!skipPastFound) {\n            if (factory \u003d\u003d skipPast) {\n                skipPastFound \u003d true;\n            }\n            continue;\n        }\n        TypeAdapter\u003cT\u003e candidate \u003d factory.create(this, type);\n        if (candidate !\u003d null) {\n            return candidate;\n        }\n    }\n    throw new IllegalArgumentException(\"GSON cannot serialize \" + type);\n}",
          "path": "gson/src/main/java/com/google/gson/Gson.java",
          "functionStartLine": 370,
          "functionName": "getNextAdapter",
          "functionAnnotation": "",
          "functionDoc": "TODO: needs documentation\n\n@since 2.2\n",
          "diff": "@@ -1,17 +1,16 @@\n-@Override\n-public \u003cT\u003e TypeAdapter\u003cT\u003e getNextAdapter(Gson gson, TypeAdapterFactory skipPast, TypeToken\u003cT\u003e type) {\n+public \u003cT\u003e TypeAdapter\u003cT\u003e getNextAdapter(TypeAdapterFactory skipPast, TypeToken\u003cT\u003e type) {\n     boolean skipPastFound \u003d false;\n-    for (TypeAdapterFactory factory : gson.factories) {\n+    for (TypeAdapterFactory factory : factories) {\n         if (!skipPastFound) {\n             if (factory \u003d\u003d skipPast) {\n                 skipPastFound \u003d true;\n             }\n             continue;\n         }\n-        TypeAdapter\u003cT\u003e candidate \u003d factory.create(gson, type);\n+        TypeAdapter\u003cT\u003e candidate \u003d factory.create(this, type);\n         if (candidate !\u003d null) {\n             return candidate;\n         }\n     }\n     throw new IllegalArgumentException(\"GSON cannot serialize \" + type);\n }\n\\ No newline at end of file\n",
          "extendedDetails": {}
        },
        {
          "type": "Yannotationchange",
          "commitMessage": "made toJson/fromJson/toJsonTree methods public in TypeAdapter.\nmade Gson.getNextAdapter method public.\n",
          "commitDate": "12/31/11, 12:52 AM",
          "commitName": "6c78bf5247828219d4383c1b5dd13d494fa65cec",
          "commitAuthor": "Inderjeet Singh",
          "commitDateOld": "12/30/11, 9:30 PM",
          "commitNameOld": "ecdf9150f6cc820dafddea5b545f456fed47472f",
          "commitAuthorOld": "Jesse Wilson",
          "daysBetweenCommits": 0.14,
          "commitsBetweenForRepo": 6,
          "commitsBetweenForFile": 1,
          "actualSource": "public \u003cT\u003e TypeAdapter\u003cT\u003e getNextAdapter(TypeAdapterFactory skipPast, TypeToken\u003cT\u003e type) {\n    boolean skipPastFound \u003d false;\n    for (TypeAdapterFactory factory : factories) {\n        if (!skipPastFound) {\n            if (factory \u003d\u003d skipPast) {\n                skipPastFound \u003d true;\n            }\n            continue;\n        }\n        TypeAdapter\u003cT\u003e candidate \u003d factory.create(this, type);\n        if (candidate !\u003d null) {\n            return candidate;\n        }\n    }\n    throw new IllegalArgumentException(\"GSON cannot serialize \" + type);\n}",
          "path": "gson/src/main/java/com/google/gson/Gson.java",
          "functionStartLine": 370,
          "functionName": "getNextAdapter",
          "functionAnnotation": "",
          "functionDoc": "TODO: needs documentation\n\n@since 2.2\n",
          "diff": "@@ -1,17 +1,16 @@\n-@Override\n-public \u003cT\u003e TypeAdapter\u003cT\u003e getNextAdapter(Gson gson, TypeAdapterFactory skipPast, TypeToken\u003cT\u003e type) {\n+public \u003cT\u003e TypeAdapter\u003cT\u003e getNextAdapter(TypeAdapterFactory skipPast, TypeToken\u003cT\u003e type) {\n     boolean skipPastFound \u003d false;\n-    for (TypeAdapterFactory factory : gson.factories) {\n+    for (TypeAdapterFactory factory : factories) {\n         if (!skipPastFound) {\n             if (factory \u003d\u003d skipPast) {\n                 skipPastFound \u003d true;\n             }\n             continue;\n         }\n-        TypeAdapter\u003cT\u003e candidate \u003d factory.create(gson, type);\n+        TypeAdapter\u003cT\u003e candidate \u003d factory.create(this, type);\n         if (candidate !\u003d null) {\n             return candidate;\n         }\n     }\n     throw new IllegalArgumentException(\"GSON cannot serialize \" + type);\n }\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldValue": "@Override",
            "newValue": ""
          }
        },
        {
          "type": "Ydocchange",
          "commitMessage": "made toJson/fromJson/toJsonTree methods public in TypeAdapter.\nmade Gson.getNextAdapter method public.\n",
          "commitDate": "12/31/11, 12:52 AM",
          "commitName": "6c78bf5247828219d4383c1b5dd13d494fa65cec",
          "commitAuthor": "Inderjeet Singh",
          "commitDateOld": "12/30/11, 9:30 PM",
          "commitNameOld": "ecdf9150f6cc820dafddea5b545f456fed47472f",
          "commitAuthorOld": "Jesse Wilson",
          "daysBetweenCommits": 0.14,
          "commitsBetweenForRepo": 6,
          "commitsBetweenForFile": 1,
          "actualSource": "public \u003cT\u003e TypeAdapter\u003cT\u003e getNextAdapter(TypeAdapterFactory skipPast, TypeToken\u003cT\u003e type) {\n    boolean skipPastFound \u003d false;\n    for (TypeAdapterFactory factory : factories) {\n        if (!skipPastFound) {\n            if (factory \u003d\u003d skipPast) {\n                skipPastFound \u003d true;\n            }\n            continue;\n        }\n        TypeAdapter\u003cT\u003e candidate \u003d factory.create(this, type);\n        if (candidate !\u003d null) {\n            return candidate;\n        }\n    }\n    throw new IllegalArgumentException(\"GSON cannot serialize \" + type);\n}",
          "path": "gson/src/main/java/com/google/gson/Gson.java",
          "functionStartLine": 370,
          "functionName": "getNextAdapter",
          "functionAnnotation": "",
          "functionDoc": "TODO: needs documentation\n\n@since 2.2\n",
          "diff": "@@ -1,17 +1,16 @@\n-@Override\n-public \u003cT\u003e TypeAdapter\u003cT\u003e getNextAdapter(Gson gson, TypeAdapterFactory skipPast, TypeToken\u003cT\u003e type) {\n+public \u003cT\u003e TypeAdapter\u003cT\u003e getNextAdapter(TypeAdapterFactory skipPast, TypeToken\u003cT\u003e type) {\n     boolean skipPastFound \u003d false;\n-    for (TypeAdapterFactory factory : gson.factories) {\n+    for (TypeAdapterFactory factory : factories) {\n         if (!skipPastFound) {\n             if (factory \u003d\u003d skipPast) {\n                 skipPastFound \u003d true;\n             }\n             continue;\n         }\n-        TypeAdapter\u003cT\u003e candidate \u003d factory.create(gson, type);\n+        TypeAdapter\u003cT\u003e candidate \u003d factory.create(this, type);\n         if (candidate !\u003d null) {\n             return candidate;\n         }\n     }\n     throw new IllegalArgumentException(\"GSON cannot serialize \" + type);\n }\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldValue": "",
            "newValue": "TODO: needs documentation\n\n@since 2.2\n"
          }
        }
      ]
    },
    "ecdf9150f6cc820dafddea5b545f456fed47472f": {
      "type": "Ymultichange(Yparameterchange,Ybodychange,Yannotationchange,Ydocchange)",
      "commitMessage": "Hide Gson.getNextAdapter() for the current release.\n",
      "commitDate": "12/30/11, 9:30 PM",
      "commitName": "ecdf9150f6cc820dafddea5b545f456fed47472f",
      "commitAuthor": "Jesse Wilson",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "Hide Gson.getNextAdapter() for the current release.\n",
          "commitDate": "12/30/11, 9:30 PM",
          "commitName": "ecdf9150f6cc820dafddea5b545f456fed47472f",
          "commitAuthor": "Jesse Wilson",
          "commitDateOld": "12/30/11, 12:27 AM",
          "commitNameOld": "4057b98babf5ecb7ad1583d23a90abe7b7fede12",
          "commitAuthorOld": "Jesse Wilson",
          "daysBetweenCommits": 0.88,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "actualSource": "@Override\npublic \u003cT\u003e TypeAdapter\u003cT\u003e getNextAdapter(Gson gson, TypeAdapterFactory skipPast, TypeToken\u003cT\u003e type) {\n    boolean skipPastFound \u003d false;\n    for (TypeAdapterFactory factory : gson.factories) {\n        if (!skipPastFound) {\n            if (factory \u003d\u003d skipPast) {\n                skipPastFound \u003d true;\n            }\n            continue;\n        }\n        TypeAdapter\u003cT\u003e candidate \u003d factory.create(gson, type);\n        if (candidate !\u003d null) {\n            return candidate;\n        }\n    }\n    throw new IllegalArgumentException(\"GSON cannot serialize \" + type);\n}",
          "path": "gson/src/main/java/com/google/gson/Gson.java",
          "functionStartLine": 368,
          "functionName": "getNextAdapter",
          "functionAnnotation": "@Override",
          "functionDoc": "",
          "diff": "@@ -1,16 +1,17 @@\n-public \u003cT\u003e TypeAdapter\u003cT\u003e getNextAdapter(TypeAdapterFactory skipPast, TypeToken\u003cT\u003e type) {\n+@Override\n+public \u003cT\u003e TypeAdapter\u003cT\u003e getNextAdapter(Gson gson, TypeAdapterFactory skipPast, TypeToken\u003cT\u003e type) {\n     boolean skipPastFound \u003d false;\n-    for (TypeAdapterFactory factory : factories) {\n+    for (TypeAdapterFactory factory : gson.factories) {\n         if (!skipPastFound) {\n             if (factory \u003d\u003d skipPast) {\n                 skipPastFound \u003d true;\n             }\n             continue;\n         }\n-        TypeAdapter\u003cT\u003e candidate \u003d factory.create(this, type);\n+        TypeAdapter\u003cT\u003e candidate \u003d factory.create(gson, type);\n         if (candidate !\u003d null) {\n             return candidate;\n         }\n     }\n     throw new IllegalArgumentException(\"GSON cannot serialize \" + type);\n }\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldValue": "[skipPast-TypeAdapterFactory, type-TypeToken\u003cT\u003e]",
            "newValue": "[gson-Gson, skipPast-TypeAdapterFactory, type-TypeToken\u003cT\u003e]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "Hide Gson.getNextAdapter() for the current release.\n",
          "commitDate": "12/30/11, 9:30 PM",
          "commitName": "ecdf9150f6cc820dafddea5b545f456fed47472f",
          "commitAuthor": "Jesse Wilson",
          "commitDateOld": "12/30/11, 12:27 AM",
          "commitNameOld": "4057b98babf5ecb7ad1583d23a90abe7b7fede12",
          "commitAuthorOld": "Jesse Wilson",
          "daysBetweenCommits": 0.88,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "actualSource": "@Override\npublic \u003cT\u003e TypeAdapter\u003cT\u003e getNextAdapter(Gson gson, TypeAdapterFactory skipPast, TypeToken\u003cT\u003e type) {\n    boolean skipPastFound \u003d false;\n    for (TypeAdapterFactory factory : gson.factories) {\n        if (!skipPastFound) {\n            if (factory \u003d\u003d skipPast) {\n                skipPastFound \u003d true;\n            }\n            continue;\n        }\n        TypeAdapter\u003cT\u003e candidate \u003d factory.create(gson, type);\n        if (candidate !\u003d null) {\n            return candidate;\n        }\n    }\n    throw new IllegalArgumentException(\"GSON cannot serialize \" + type);\n}",
          "path": "gson/src/main/java/com/google/gson/Gson.java",
          "functionStartLine": 368,
          "functionName": "getNextAdapter",
          "functionAnnotation": "@Override",
          "functionDoc": "",
          "diff": "@@ -1,16 +1,17 @@\n-public \u003cT\u003e TypeAdapter\u003cT\u003e getNextAdapter(TypeAdapterFactory skipPast, TypeToken\u003cT\u003e type) {\n+@Override\n+public \u003cT\u003e TypeAdapter\u003cT\u003e getNextAdapter(Gson gson, TypeAdapterFactory skipPast, TypeToken\u003cT\u003e type) {\n     boolean skipPastFound \u003d false;\n-    for (TypeAdapterFactory factory : factories) {\n+    for (TypeAdapterFactory factory : gson.factories) {\n         if (!skipPastFound) {\n             if (factory \u003d\u003d skipPast) {\n                 skipPastFound \u003d true;\n             }\n             continue;\n         }\n-        TypeAdapter\u003cT\u003e candidate \u003d factory.create(this, type);\n+        TypeAdapter\u003cT\u003e candidate \u003d factory.create(gson, type);\n         if (candidate !\u003d null) {\n             return candidate;\n         }\n     }\n     throw new IllegalArgumentException(\"GSON cannot serialize \" + type);\n }\n\\ No newline at end of file\n",
          "extendedDetails": {}
        },
        {
          "type": "Yannotationchange",
          "commitMessage": "Hide Gson.getNextAdapter() for the current release.\n",
          "commitDate": "12/30/11, 9:30 PM",
          "commitName": "ecdf9150f6cc820dafddea5b545f456fed47472f",
          "commitAuthor": "Jesse Wilson",
          "commitDateOld": "12/30/11, 12:27 AM",
          "commitNameOld": "4057b98babf5ecb7ad1583d23a90abe7b7fede12",
          "commitAuthorOld": "Jesse Wilson",
          "daysBetweenCommits": 0.88,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "actualSource": "@Override\npublic \u003cT\u003e TypeAdapter\u003cT\u003e getNextAdapter(Gson gson, TypeAdapterFactory skipPast, TypeToken\u003cT\u003e type) {\n    boolean skipPastFound \u003d false;\n    for (TypeAdapterFactory factory : gson.factories) {\n        if (!skipPastFound) {\n            if (factory \u003d\u003d skipPast) {\n                skipPastFound \u003d true;\n            }\n            continue;\n        }\n        TypeAdapter\u003cT\u003e candidate \u003d factory.create(gson, type);\n        if (candidate !\u003d null) {\n            return candidate;\n        }\n    }\n    throw new IllegalArgumentException(\"GSON cannot serialize \" + type);\n}",
          "path": "gson/src/main/java/com/google/gson/Gson.java",
          "functionStartLine": 368,
          "functionName": "getNextAdapter",
          "functionAnnotation": "@Override",
          "functionDoc": "",
          "diff": "@@ -1,16 +1,17 @@\n-public \u003cT\u003e TypeAdapter\u003cT\u003e getNextAdapter(TypeAdapterFactory skipPast, TypeToken\u003cT\u003e type) {\n+@Override\n+public \u003cT\u003e TypeAdapter\u003cT\u003e getNextAdapter(Gson gson, TypeAdapterFactory skipPast, TypeToken\u003cT\u003e type) {\n     boolean skipPastFound \u003d false;\n-    for (TypeAdapterFactory factory : factories) {\n+    for (TypeAdapterFactory factory : gson.factories) {\n         if (!skipPastFound) {\n             if (factory \u003d\u003d skipPast) {\n                 skipPastFound \u003d true;\n             }\n             continue;\n         }\n-        TypeAdapter\u003cT\u003e candidate \u003d factory.create(this, type);\n+        TypeAdapter\u003cT\u003e candidate \u003d factory.create(gson, type);\n         if (candidate !\u003d null) {\n             return candidate;\n         }\n     }\n     throw new IllegalArgumentException(\"GSON cannot serialize \" + type);\n }\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldValue": "",
            "newValue": "@Override"
          }
        },
        {
          "type": "Ydocchange",
          "commitMessage": "Hide Gson.getNextAdapter() for the current release.\n",
          "commitDate": "12/30/11, 9:30 PM",
          "commitName": "ecdf9150f6cc820dafddea5b545f456fed47472f",
          "commitAuthor": "Jesse Wilson",
          "commitDateOld": "12/30/11, 12:27 AM",
          "commitNameOld": "4057b98babf5ecb7ad1583d23a90abe7b7fede12",
          "commitAuthorOld": "Jesse Wilson",
          "daysBetweenCommits": 0.88,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "actualSource": "@Override\npublic \u003cT\u003e TypeAdapter\u003cT\u003e getNextAdapter(Gson gson, TypeAdapterFactory skipPast, TypeToken\u003cT\u003e type) {\n    boolean skipPastFound \u003d false;\n    for (TypeAdapterFactory factory : gson.factories) {\n        if (!skipPastFound) {\n            if (factory \u003d\u003d skipPast) {\n                skipPastFound \u003d true;\n            }\n            continue;\n        }\n        TypeAdapter\u003cT\u003e candidate \u003d factory.create(gson, type);\n        if (candidate !\u003d null) {\n            return candidate;\n        }\n    }\n    throw new IllegalArgumentException(\"GSON cannot serialize \" + type);\n}",
          "path": "gson/src/main/java/com/google/gson/Gson.java",
          "functionStartLine": 368,
          "functionName": "getNextAdapter",
          "functionAnnotation": "@Override",
          "functionDoc": "",
          "diff": "@@ -1,16 +1,17 @@\n-public \u003cT\u003e TypeAdapter\u003cT\u003e getNextAdapter(TypeAdapterFactory skipPast, TypeToken\u003cT\u003e type) {\n+@Override\n+public \u003cT\u003e TypeAdapter\u003cT\u003e getNextAdapter(Gson gson, TypeAdapterFactory skipPast, TypeToken\u003cT\u003e type) {\n     boolean skipPastFound \u003d false;\n-    for (TypeAdapterFactory factory : factories) {\n+    for (TypeAdapterFactory factory : gson.factories) {\n         if (!skipPastFound) {\n             if (factory \u003d\u003d skipPast) {\n                 skipPastFound \u003d true;\n             }\n             continue;\n         }\n-        TypeAdapter\u003cT\u003e candidate \u003d factory.create(this, type);\n+        TypeAdapter\u003cT\u003e candidate \u003d factory.create(gson, type);\n         if (candidate !\u003d null) {\n             return candidate;\n         }\n     }\n     throw new IllegalArgumentException(\"GSON cannot serialize \" + type);\n }\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldValue": "Returns a type adapter for {@code} type that isn\u0027t {@code skipPast}. This\ncan be used for type adapters to compose other, simpler type adapters.\n\n@throws IllegalArgumentException if this GSON cannot serialize and\n    deserialize {@code type}.\n@since 2.1\n",
            "newValue": ""
          }
        }
      ]
    },
    "d7fbac03844aa86dbb1c65a8ba50ac364c4b2050": {
      "type": "Ymultichange(Yparameterchange,Ybodychange)",
      "commitMessage": "Rename TypeAdapter.Factory to TypeAdapterFactory.\n",
      "commitDate": "12/23/11, 10:27 AM",
      "commitName": "d7fbac03844aa86dbb1c65a8ba50ac364c4b2050",
      "commitAuthor": "Jesse Wilson",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "Rename TypeAdapter.Factory to TypeAdapterFactory.\n",
          "commitDate": "12/23/11, 10:27 AM",
          "commitName": "d7fbac03844aa86dbb1c65a8ba50ac364c4b2050",
          "commitAuthor": "Jesse Wilson",
          "commitDateOld": "12/22/11, 2:31 PM",
          "commitNameOld": "bd937fe7b54392d7c9c7bac591bd813f510f5bfa",
          "commitAuthorOld": "Inderjeet Singh",
          "daysBetweenCommits": 0.83,
          "commitsBetweenForRepo": 3,
          "commitsBetweenForFile": 1,
          "actualSource": "public \u003cT\u003e TypeAdapter\u003cT\u003e getNextAdapter(TypeAdapterFactory skipPast, TypeToken\u003cT\u003e type) {\n    boolean skipPastFound \u003d false;\n    for (TypeAdapterFactory factory : factories) {\n        if (!skipPastFound) {\n            if (factory \u003d\u003d skipPast) {\n                skipPastFound \u003d true;\n            }\n            continue;\n        }\n        TypeAdapter\u003cT\u003e candidate \u003d factory.create(this, type);\n        if (candidate !\u003d null) {\n            return candidate;\n        }\n    }\n    throw new IllegalArgumentException(\"GSON cannot serialize \" + type);\n}",
          "path": "gson/src/main/java/com/google/gson/Gson.java",
          "functionStartLine": 373,
          "functionName": "getNextAdapter",
          "functionAnnotation": "",
          "functionDoc": "Returns a type adapter for {@code} type that isn\u0027t {@code skipPast}. This\ncan be used for type adapters to compose other, simpler type adapters.\n\n@throws IllegalArgumentException if this GSON cannot serialize and\n    deserialize {@code type}.\n@since 2.1\n",
          "diff": "@@ -1,16 +1,16 @@\n-public \u003cT\u003e TypeAdapter\u003cT\u003e getNextAdapter(TypeAdapter.Factory skipPast, TypeToken\u003cT\u003e type) {\n+public \u003cT\u003e TypeAdapter\u003cT\u003e getNextAdapter(TypeAdapterFactory skipPast, TypeToken\u003cT\u003e type) {\n     boolean skipPastFound \u003d false;\n-    for (TypeAdapter.Factory factory : factories) {\n+    for (TypeAdapterFactory factory : factories) {\n         if (!skipPastFound) {\n             if (factory \u003d\u003d skipPast) {\n                 skipPastFound \u003d true;\n             }\n             continue;\n         }\n         TypeAdapter\u003cT\u003e candidate \u003d factory.create(this, type);\n         if (candidate !\u003d null) {\n             return candidate;\n         }\n     }\n     throw new IllegalArgumentException(\"GSON cannot serialize \" + type);\n }\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldValue": "[skipPast-TypeAdapter.Factory, type-TypeToken\u003cT\u003e]",
            "newValue": "[skipPast-TypeAdapterFactory, type-TypeToken\u003cT\u003e]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "Rename TypeAdapter.Factory to TypeAdapterFactory.\n",
          "commitDate": "12/23/11, 10:27 AM",
          "commitName": "d7fbac03844aa86dbb1c65a8ba50ac364c4b2050",
          "commitAuthor": "Jesse Wilson",
          "commitDateOld": "12/22/11, 2:31 PM",
          "commitNameOld": "bd937fe7b54392d7c9c7bac591bd813f510f5bfa",
          "commitAuthorOld": "Inderjeet Singh",
          "daysBetweenCommits": 0.83,
          "commitsBetweenForRepo": 3,
          "commitsBetweenForFile": 1,
          "actualSource": "public \u003cT\u003e TypeAdapter\u003cT\u003e getNextAdapter(TypeAdapterFactory skipPast, TypeToken\u003cT\u003e type) {\n    boolean skipPastFound \u003d false;\n    for (TypeAdapterFactory factory : factories) {\n        if (!skipPastFound) {\n            if (factory \u003d\u003d skipPast) {\n                skipPastFound \u003d true;\n            }\n            continue;\n        }\n        TypeAdapter\u003cT\u003e candidate \u003d factory.create(this, type);\n        if (candidate !\u003d null) {\n            return candidate;\n        }\n    }\n    throw new IllegalArgumentException(\"GSON cannot serialize \" + type);\n}",
          "path": "gson/src/main/java/com/google/gson/Gson.java",
          "functionStartLine": 373,
          "functionName": "getNextAdapter",
          "functionAnnotation": "",
          "functionDoc": "Returns a type adapter for {@code} type that isn\u0027t {@code skipPast}. This\ncan be used for type adapters to compose other, simpler type adapters.\n\n@throws IllegalArgumentException if this GSON cannot serialize and\n    deserialize {@code type}.\n@since 2.1\n",
          "diff": "@@ -1,16 +1,16 @@\n-public \u003cT\u003e TypeAdapter\u003cT\u003e getNextAdapter(TypeAdapter.Factory skipPast, TypeToken\u003cT\u003e type) {\n+public \u003cT\u003e TypeAdapter\u003cT\u003e getNextAdapter(TypeAdapterFactory skipPast, TypeToken\u003cT\u003e type) {\n     boolean skipPastFound \u003d false;\n-    for (TypeAdapter.Factory factory : factories) {\n+    for (TypeAdapterFactory factory : factories) {\n         if (!skipPastFound) {\n             if (factory \u003d\u003d skipPast) {\n                 skipPastFound \u003d true;\n             }\n             continue;\n         }\n         TypeAdapter\u003cT\u003e candidate \u003d factory.create(this, type);\n         if (candidate !\u003d null) {\n             return candidate;\n         }\n     }\n     throw new IllegalArgumentException(\"GSON cannot serialize \" + type);\n }\n\\ No newline at end of file\n",
          "extendedDetails": {}
        }
      ]
    },
    "8f8e69a36444022da48d40966549fa9eb78f5751": {
      "type": "Ydocchange",
      "commitMessage": "Add @since tags.\n",
      "commitDate": "12/2/11, 3:11 PM",
      "commitName": "8f8e69a36444022da48d40966549fa9eb78f5751",
      "commitAuthor": "Jesse Wilson",
      "commitDateOld": "11/26/11, 7:30 AM",
      "commitNameOld": "4c06b013697d06b327f3c537e23181887aeab774",
      "commitAuthorOld": "Jesse Wilson",
      "daysBetweenCommits": 6.32,
      "commitsBetweenForRepo": 5,
      "commitsBetweenForFile": 1,
      "actualSource": "public \u003cT\u003e TypeAdapter\u003cT\u003e getNextAdapter(TypeAdapter.Factory skipPast, TypeToken\u003cT\u003e type) {\n    boolean skipPastFound \u003d false;\n    for (TypeAdapter.Factory factory : factories) {\n        if (!skipPastFound) {\n            if (factory \u003d\u003d skipPast) {\n                skipPastFound \u003d true;\n            }\n            continue;\n        }\n        TypeAdapter\u003cT\u003e candidate \u003d factory.create(this, type);\n        if (candidate !\u003d null) {\n            return candidate;\n        }\n    }\n    throw new IllegalArgumentException(\"GSON cannot serialize \" + type);\n}",
      "path": "gson/src/main/java/com/google/gson/Gson.java",
      "functionStartLine": 371,
      "functionName": "getNextAdapter",
      "functionAnnotation": "",
      "functionDoc": "Returns a type adapter for {@code} type that isn\u0027t {@code skipPast}. This\ncan be used for type adapters to compose other, simpler type adapters.\n\n@throws IllegalArgumentException if this GSON cannot serialize and\n    deserialize {@code type}.\n@since 2.1\n",
      "diff": "",
      "extendedDetails": {
        "oldValue": "Returns a type adapter for {@code} type that isn\u0027t {@code skipPast}. This\ncan be used for type adapters to compose other, simpler type adapters.\n\n@throws IllegalArgumentException if this GSON cannot serialize and\n    deserialize {@code type}.\n",
        "newValue": "Returns a type adapter for {@code} type that isn\u0027t {@code skipPast}. This\ncan be used for type adapters to compose other, simpler type adapters.\n\n@throws IllegalArgumentException if this GSON cannot serialize and\n    deserialize {@code type}.\n@since 2.1\n"
      }
    },
    "7e760143fdc8b689daeebdee33ad6ea7d0a62a56": {
      "type": "Ymultichange(Ymovefromfile,Ybodychange)",
      "commitMessage": "Smash together MiniGson and Gson. This changes Gson to be the MiniGson rather than delegating to the MiniGson. It means that the MiniGson objects passed into streaming type adapters are now fully-capable \u0027Gson\u0027 objects. \n\nThe most notable impact of this change is that it adds several new public APIs:\n - The TypeAdapter abstract class\n - The TypeAdapter.Factory interface\n - Four new methods on GsonBuilder to register streaming TypeAdapters (via Factory, via Class, via TypeToken, and as a type hierarchy)\n - Three new methods on Gson to lookup streaming TypeAdapters (by type, by class, and to get the next type adapter) \n\nStill outstanding:\n - Write beautiful prose to document the new APIs above\n - Change GsonBuilder\u0027s precedence so that both old and new-style type adapters are registered in one lot\n",
      "commitDate": "11/20/11, 7:23 AM",
      "commitName": "7e760143fdc8b689daeebdee33ad6ea7d0a62a56",
      "commitAuthor": "Jesse Wilson",
      "subchanges": [
        {
          "type": "Ymovefromfile",
          "commitMessage": "Smash together MiniGson and Gson. This changes Gson to be the MiniGson rather than delegating to the MiniGson. It means that the MiniGson objects passed into streaming type adapters are now fully-capable \u0027Gson\u0027 objects. \n\nThe most notable impact of this change is that it adds several new public APIs:\n - The TypeAdapter abstract class\n - The TypeAdapter.Factory interface\n - Four new methods on GsonBuilder to register streaming TypeAdapters (via Factory, via Class, via TypeToken, and as a type hierarchy)\n - Three new methods on Gson to lookup streaming TypeAdapters (by type, by class, and to get the next type adapter) \n\nStill outstanding:\n - Write beautiful prose to document the new APIs above\n - Change GsonBuilder\u0027s precedence so that both old and new-style type adapters are registered in one lot\n",
          "commitDate": "11/20/11, 7:23 AM",
          "commitName": "7e760143fdc8b689daeebdee33ad6ea7d0a62a56",
          "commitAuthor": "Jesse Wilson",
          "commitDateOld": "11/18/11, 8:07 AM",
          "commitNameOld": "df31d2db16fe9ef85b7152d002880d5546070fb2",
          "commitAuthorOld": "Jesse Wilson",
          "daysBetweenCommits": 1.97,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "actualSource": "public \u003cT\u003e TypeAdapter\u003cT\u003e getNextAdapter(TypeAdapter.Factory skipPast, TypeToken\u003cT\u003e type) {\n    boolean skipPastFound \u003d false;\n    for (TypeAdapter.Factory factory : factories) {\n        if (!skipPastFound) {\n            if (factory \u003d\u003d skipPast) {\n                skipPastFound \u003d true;\n            }\n            continue;\n        }\n        TypeAdapter\u003cT\u003e candidate \u003d factory.create(this, type);\n        if (candidate !\u003d null) {\n            return candidate;\n        }\n    }\n    throw new IllegalArgumentException(\"GSON cannot serialize \" + type);\n}",
          "path": "gson/src/main/java/com/google/gson/Gson.java",
          "functionStartLine": 417,
          "functionName": "getNextAdapter",
          "functionAnnotation": "",
          "functionDoc": "Returns a type adapter for {@code} type that isn\u0027t {@code skipPast}. This\ncan be used for type adapters to compose other, simpler type adapters.\n\n@throws IllegalArgumentException if this GSON cannot serialize and\n    deserialize {@code type}.\n",
          "diff": "@@ -1,16 +1,16 @@\n public \u003cT\u003e TypeAdapter\u003cT\u003e getNextAdapter(TypeAdapter.Factory skipPast, TypeToken\u003cT\u003e type) {\n     boolean skipPastFound \u003d false;\n     for (TypeAdapter.Factory factory : factories) {\n         if (!skipPastFound) {\n             if (factory \u003d\u003d skipPast) {\n                 skipPastFound \u003d true;\n             }\n             continue;\n         }\n         TypeAdapter\u003cT\u003e candidate \u003d factory.create(this, type);\n         if (candidate !\u003d null) {\n             return candidate;\n         }\n     }\n-    throw new IllegalArgumentException(\"This MiniGSON cannot serialize \" + type);\n+    throw new IllegalArgumentException(\"GSON cannot serialize \" + type);\n }\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldPath": "gson/src/main/java/com/google/gson/internal/bind/MiniGson.java",
            "newPath": "gson/src/main/java/com/google/gson/Gson.java",
            "oldMethodName": "getNextAdapter",
            "newMethodName": "getNextAdapter"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "Smash together MiniGson and Gson. This changes Gson to be the MiniGson rather than delegating to the MiniGson. It means that the MiniGson objects passed into streaming type adapters are now fully-capable \u0027Gson\u0027 objects. \n\nThe most notable impact of this change is that it adds several new public APIs:\n - The TypeAdapter abstract class\n - The TypeAdapter.Factory interface\n - Four new methods on GsonBuilder to register streaming TypeAdapters (via Factory, via Class, via TypeToken, and as a type hierarchy)\n - Three new methods on Gson to lookup streaming TypeAdapters (by type, by class, and to get the next type adapter) \n\nStill outstanding:\n - Write beautiful prose to document the new APIs above\n - Change GsonBuilder\u0027s precedence so that both old and new-style type adapters are registered in one lot\n",
          "commitDate": "11/20/11, 7:23 AM",
          "commitName": "7e760143fdc8b689daeebdee33ad6ea7d0a62a56",
          "commitAuthor": "Jesse Wilson",
          "commitDateOld": "11/18/11, 8:07 AM",
          "commitNameOld": "df31d2db16fe9ef85b7152d002880d5546070fb2",
          "commitAuthorOld": "Jesse Wilson",
          "daysBetweenCommits": 1.97,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "actualSource": "public \u003cT\u003e TypeAdapter\u003cT\u003e getNextAdapter(TypeAdapter.Factory skipPast, TypeToken\u003cT\u003e type) {\n    boolean skipPastFound \u003d false;\n    for (TypeAdapter.Factory factory : factories) {\n        if (!skipPastFound) {\n            if (factory \u003d\u003d skipPast) {\n                skipPastFound \u003d true;\n            }\n            continue;\n        }\n        TypeAdapter\u003cT\u003e candidate \u003d factory.create(this, type);\n        if (candidate !\u003d null) {\n            return candidate;\n        }\n    }\n    throw new IllegalArgumentException(\"GSON cannot serialize \" + type);\n}",
          "path": "gson/src/main/java/com/google/gson/Gson.java",
          "functionStartLine": 417,
          "functionName": "getNextAdapter",
          "functionAnnotation": "",
          "functionDoc": "Returns a type adapter for {@code} type that isn\u0027t {@code skipPast}. This\ncan be used for type adapters to compose other, simpler type adapters.\n\n@throws IllegalArgumentException if this GSON cannot serialize and\n    deserialize {@code type}.\n",
          "diff": "@@ -1,16 +1,16 @@\n public \u003cT\u003e TypeAdapter\u003cT\u003e getNextAdapter(TypeAdapter.Factory skipPast, TypeToken\u003cT\u003e type) {\n     boolean skipPastFound \u003d false;\n     for (TypeAdapter.Factory factory : factories) {\n         if (!skipPastFound) {\n             if (factory \u003d\u003d skipPast) {\n                 skipPastFound \u003d true;\n             }\n             continue;\n         }\n         TypeAdapter\u003cT\u003e candidate \u003d factory.create(this, type);\n         if (candidate !\u003d null) {\n             return candidate;\n         }\n     }\n-    throw new IllegalArgumentException(\"This MiniGSON cannot serialize \" + type);\n+    throw new IllegalArgumentException(\"GSON cannot serialize \" + type);\n }\n\\ No newline at end of file\n",
          "extendedDetails": {}
        }
      ]
    },
    "25c6ae177b1ca56db7f3c29eb574bdd032a06165": {
      "type": "Yintroduced",
      "commitMessage": "Down to 22 failing tests.\n\nConsolidated all of the different code paths that we use to construct instances. We now have an ObjectConstructor class that knows what type it constructs; this means that we don\u0027t need to ever do reflection to lookup a constructor at construction time.\n\nCleaned up some buggy type adapters, particularly around handling of null.\n\nRemoved dead code for object graph navigation.\n\nMoved some classes into \u0027internal\u0027 so they are visible to the \u0027bind\u0027 subpackage.\n\nTurned some TypeAdapterFactory/TypeAdapter pairs inside out so that the TypeAdapter is now the inner class. This is necessary so that the factories can take parameters.\n\nAdded an API to request the \u0027next\u0027 type adapter for a type. This allows type adapters to compose other type adapters. We\u0027re using this in two places:\n - where the user has excluded a type from serialization but not deserialization, we need to use the \"default\" deserialization but interpose null on serialization. We create a type adapter that delegates for one and returns null for the other.\n - similarly when a DOM type serializer is registered but no deserializer, or vice versa.\nThis is the biggest change to the MiniGson core.\n\nFor backwards compatibility, return null for the empty string.\n\nSimplify JsonSerializationContext/JsonDeserializationContext to simply call through to GSON. SerializeDefault is currently unsupported.\n\nMore useful error messages when calling getAsBoolean on a JsonNull.\n\nRemove currently unused MemoryRefStack. We might need this back again, though wiring it back in will be much more difficult because we don\u0027t interject ourselves between the users\u0027 various type adapters.\n",
      "commitDate": "9/11/11, 12:04 AM",
      "commitName": "25c6ae177b1ca56db7f3c29eb574bdd032a06165",
      "commitAuthor": "Jesse Wilson",
      "diff": "@@ -0,0 +1,16 @@\n+public \u003cT\u003e TypeAdapter\u003cT\u003e getNextAdapter(TypeAdapter.Factory skipPast, TypeToken\u003cT\u003e type) {\n+    boolean skipPastFound \u003d false;\n+    for (TypeAdapter.Factory factory : factories) {\n+        if (!skipPastFound) {\n+            if (factory \u003d\u003d skipPast) {\n+                skipPastFound \u003d true;\n+            }\n+            continue;\n+        }\n+        TypeAdapter\u003cT\u003e candidate \u003d factory.create(this, type);\n+        if (candidate !\u003d null) {\n+            return candidate;\n+        }\n+    }\n+    throw new IllegalArgumentException(\"This MiniGSON cannot serialize \" + type);\n+}\n\\ No newline at end of file\n",
      "actualSource": "public \u003cT\u003e TypeAdapter\u003cT\u003e getNextAdapter(TypeAdapter.Factory skipPast, TypeToken\u003cT\u003e type) {\n    boolean skipPastFound \u003d false;\n    for (TypeAdapter.Factory factory : factories) {\n        if (!skipPastFound) {\n            if (factory \u003d\u003d skipPast) {\n                skipPastFound \u003d true;\n            }\n            continue;\n        }\n        TypeAdapter\u003cT\u003e candidate \u003d factory.create(this, type);\n        if (candidate !\u003d null) {\n            return candidate;\n        }\n    }\n    throw new IllegalArgumentException(\"This MiniGSON cannot serialize \" + type);\n}",
      "path": "gson/src/main/java/com/google/gson/internal/bind/MiniGson.java",
      "functionStartLine": 111,
      "functionName": "getNextAdapter",
      "functionAnnotation": "",
      "functionDoc": "Returns a type adapter for {@code} type that isn\u0027t {@code skipPast}. This\ncan be used for type adapters to compose other, simpler type adapters.\n\n@throws IllegalArgumentException if this GSON cannot serialize and\n    deserialize {@code type}.\n"
    }
  }
}