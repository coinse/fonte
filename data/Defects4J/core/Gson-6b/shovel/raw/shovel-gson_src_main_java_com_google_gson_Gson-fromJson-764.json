{
  "origin": "codeshovel",
  "repositoryName": "Gson-6b",
  "repositoryPath": "/tmp/Gson-6b//.git",
  "startCommitName": "HEAD",
  "sourceFileName": "Gson.java",
  "functionName": "fromJson",
  "functionId": "fromJson___json-String__classOfT-Class__T__",
  "sourceFilePath": "gson/src/main/java/com/google/gson/Gson.java",
  "functionAnnotation": "",
  "functionDoc": "This method deserializes the specified Json into an object of the specified class. It is not\nsuitable to use if the specified class is a generic type since it will not have the generic\ntype information because of the Type Erasure feature of Java. Therefore, this method should not\nbe used if the desired type is a generic type. Note that this method works fine if the any of\nthe fields of the specified object are generics, just the object itself should not be a\ngeneric type. For the cases when the object is of generic type, invoke\n{@link #fromJson(String, Type)}. If you have the Json in a {@link Reader} instead of\na String, use {@link #fromJson(Reader, Class)} instead.\n\n@param \u003cT\u003e the type of the desired object\n@param json the string from which the object is to be deserialized\n@param classOfT the class of T\n@return an object of type T from the string. Returns {@code null} if {@code json} is {@code null}.\n@throws JsonSyntaxException if json is not a valid representation for an object of type\nclassOfT\n",
  "functionStartLine": 764,
  "functionEndLine": 767,
  "numCommitsSeen": 177,
  "timeTaken": 3859,
  "changeHistory": [
    "b373c20136eae1a821b173d106ed6c222f87fb13",
    "5bc80cd6937faae894c5b578b78ed071c7c8d61d",
    "4efb133b4a6cc93708dda782d948b9c88c3b5ff0",
    "10db917e9380ca4d741e06152fd1ee506666c1c3",
    "83539c534c3cade5a05e633944420615b0b478ed",
    "c8c3a6965c5a1a01951452a25291e5a5944fa59a",
    "20d895ff95414d4da23d07115c57920f5813a95d",
    "57d1f32de5bf3a7dd54613384cc7e979fba2660b"
  ],
  "changeHistoryShort": {
    "b373c20136eae1a821b173d106ed6c222f87fb13": "Ydocchange",
    "5bc80cd6937faae894c5b578b78ed071c7c8d61d": "Ybodychange",
    "4efb133b4a6cc93708dda782d948b9c88c3b5ff0": "Ybodychange",
    "10db917e9380ca4d741e06152fd1ee506666c1c3": "Ymultichange(Yexceptionschange,Ydocchange)",
    "83539c534c3cade5a05e633944420615b0b478ed": "Yannotationchange",
    "c8c3a6965c5a1a01951452a25291e5a5944fa59a": "Ybodychange",
    "20d895ff95414d4da23d07115c57920f5813a95d": "Ybodychange",
    "57d1f32de5bf3a7dd54613384cc7e979fba2660b": "Yintroduced"
  },
  "changeHistoryDetails": {
    "b373c20136eae1a821b173d106ed6c222f87fb13": {
      "type": "Ydocchange",
      "commitMessage": "Fixed issue 552 by documenting when fromJson returns null.\n",
      "commitDate": "3/29/14, 4:28 PM",
      "commitName": "b373c20136eae1a821b173d106ed6c222f87fb13",
      "commitAuthor": "Inderjeet Singh",
      "commitDateOld": "3/26/14, 11:07 AM",
      "commitNameOld": "c53e2551058b445b6adf5bc588456c2b33548e28",
      "commitAuthorOld": "Inderjeet Singh",
      "daysBetweenCommits": 3.22,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "public \u003cT\u003e T fromJson(String json, Class\u003cT\u003e classOfT) throws JsonSyntaxException {\n    Object object \u003d fromJson(json, (Type) classOfT);\n    return Primitives.wrap(classOfT).cast(object);\n}",
      "path": "gson/src/main/java/com/google/gson/Gson.java",
      "functionStartLine": 703,
      "functionName": "fromJson",
      "functionAnnotation": "",
      "functionDoc": "This method deserializes the specified Json into an object of the specified class. It is not\nsuitable to use if the specified class is a generic type since it will not have the generic\ntype information because of the Type Erasure feature of Java. Therefore, this method should not\nbe used if the desired type is a generic type. Note that this method works fine if the any of\nthe fields of the specified object are generics, just the object itself should not be a\ngeneric type. For the cases when the object is of generic type, invoke\n{@link #fromJson(String, Type)}. If you have the Json in a {@link Reader} instead of\na String, use {@link #fromJson(Reader, Class)} instead.\n\n@param \u003cT\u003e the type of the desired object\n@param json the string from which the object is to be deserialized\n@param classOfT the class of T\n@return an object of type T from the string. Returns {@code null} if {@code json} is {@code null}.\n@throws JsonSyntaxException if json is not a valid representation for an object of type\nclassOfT\n",
      "diff": "",
      "extendedDetails": {
        "oldValue": "This method deserializes the specified Json into an object of the specified class. It is not\nsuitable to use if the specified class is a generic type since it will not have the generic\ntype information because of the Type Erasure feature of Java. Therefore, this method should not\nbe used if the desired type is a generic type. Note that this method works fine if the any of\nthe fields of the specified object are generics, just the object itself should not be a\ngeneric type. For the cases when the object is of generic type, invoke\n{@link #fromJson(String, Type)}. If you have the Json in a {@link Reader} instead of\na String, use {@link #fromJson(Reader, Class)} instead.\n\n@param \u003cT\u003e the type of the desired object\n@param json the string from which the object is to be deserialized\n@param classOfT the class of T\n@return an object of type T from the string\n@throws JsonSyntaxException if json is not a valid representation for an object of type\nclassOfT\n",
        "newValue": "This method deserializes the specified Json into an object of the specified class. It is not\nsuitable to use if the specified class is a generic type since it will not have the generic\ntype information because of the Type Erasure feature of Java. Therefore, this method should not\nbe used if the desired type is a generic type. Note that this method works fine if the any of\nthe fields of the specified object are generics, just the object itself should not be a\ngeneric type. For the cases when the object is of generic type, invoke\n{@link #fromJson(String, Type)}. If you have the Json in a {@link Reader} instead of\na String, use {@link #fromJson(Reader, Class)} instead.\n\n@param \u003cT\u003e the type of the desired object\n@param json the string from which the object is to be deserialized\n@param classOfT the class of T\n@return an object of type T from the string. Returns {@code null} if {@code json} is {@code null}.\n@throws JsonSyntaxException if json is not a valid representation for an object of type\nclassOfT\n"
      }
    },
    "5bc80cd6937faae894c5b578b78ed071c7c8d61d": {
      "type": "Ybodychange",
      "commitMessage": "Moved Cache, LruCache, Pair, Primitives and UnsafeAllocator to com.google.gson and made them package private.\n",
      "commitDate": "3/30/11, 6:59 AM",
      "commitName": "5bc80cd6937faae894c5b578b78ed071c7c8d61d",
      "commitAuthor": "Inderjeet Singh",
      "commitDateOld": "3/29/11, 2:24 PM",
      "commitNameOld": "4efb133b4a6cc93708dda782d948b9c88c3b5ff0",
      "commitAuthorOld": "Jesse Wilson",
      "daysBetweenCommits": 0.69,
      "commitsBetweenForRepo": 4,
      "commitsBetweenForFile": 1,
      "actualSource": "public \u003cT\u003e T fromJson(String json, Class\u003cT\u003e classOfT) throws JsonSyntaxException {\n    Object object \u003d fromJson(json, (Type) classOfT);\n    return Primitives.wrap(classOfT).cast(object);\n}",
      "path": "gson/src/main/java/com/google/gson/Gson.java",
      "functionStartLine": 388,
      "functionName": "fromJson",
      "functionAnnotation": "",
      "functionDoc": "This method deserializes the specified Json into an object of the specified class. It is not\nsuitable to use if the specified class is a generic type since it will not have the generic\ntype information because of the Type Erasure feature of Java. Therefore, this method should not\nbe used if the desired type is a generic type. Note that this method works fine if the any of\nthe fields of the specified object are generics, just the object itself should not be a\ngeneric type. For the cases when the object is of generic type, invoke\n{@link #fromJson(String, Type)}. If you have the Json in a {@link Reader} instead of\na String, use {@link #fromJson(Reader, Class)} instead.\n\n@param \u003cT\u003e the type of the desired object\n@param json the string from which the object is to be deserialized\n@param classOfT the class of T\n@return an object of type T from the string\n@throws JsonSyntaxException if json is not a valid representation for an object of type\nclassOfT\n",
      "diff": "@@ -1,4 +1,4 @@\n public \u003cT\u003e T fromJson(String json, Class\u003cT\u003e classOfT) throws JsonSyntaxException {\n     Object object \u003d fromJson(json, (Type) classOfT);\n-    return $Primitives.wrap(classOfT).cast(object);\n+    return Primitives.wrap(classOfT).cast(object);\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "4efb133b4a6cc93708dda782d948b9c88c3b5ff0": {
      "type": "Ybodychange",
      "commitMessage": "bling bling\n\nPrefix internal classes with $ to prevent them from interfering with IDE\u0027s auto import functionality.\n",
      "commitDate": "3/29/11, 2:24 PM",
      "commitName": "4efb133b4a6cc93708dda782d948b9c88c3b5ff0",
      "commitAuthor": "Jesse Wilson",
      "commitDateOld": "3/24/11, 1:19 PM",
      "commitNameOld": "337d89cf3feec17918ea7739fc00edb52ed5527e",
      "commitAuthorOld": "Inderjeet Singh",
      "daysBetweenCommits": 5.04,
      "commitsBetweenForRepo": 8,
      "commitsBetweenForFile": 1,
      "actualSource": "public \u003cT\u003e T fromJson(String json, Class\u003cT\u003e classOfT) throws JsonSyntaxException {\n    Object object \u003d fromJson(json, (Type) classOfT);\n    return $Primitives.wrap(classOfT).cast(object);\n}",
      "path": "gson/src/main/java/com/google/gson/Gson.java",
      "functionStartLine": 389,
      "functionName": "fromJson",
      "functionAnnotation": "",
      "functionDoc": "This method deserializes the specified Json into an object of the specified class. It is not\nsuitable to use if the specified class is a generic type since it will not have the generic\ntype information because of the Type Erasure feature of Java. Therefore, this method should not\nbe used if the desired type is a generic type. Note that this method works fine if the any of\nthe fields of the specified object are generics, just the object itself should not be a\ngeneric type. For the cases when the object is of generic type, invoke\n{@link #fromJson(String, Type)}. If you have the Json in a {@link Reader} instead of\na String, use {@link #fromJson(Reader, Class)} instead.\n\n@param \u003cT\u003e the type of the desired object\n@param json the string from which the object is to be deserialized\n@param classOfT the class of T\n@return an object of type T from the string\n@throws JsonSyntaxException if json is not a valid representation for an object of type\nclassOfT\n",
      "diff": "@@ -1,4 +1,4 @@\n public \u003cT\u003e T fromJson(String json, Class\u003cT\u003e classOfT) throws JsonSyntaxException {\n     Object object \u003d fromJson(json, (Type) classOfT);\n-    return Primitives.wrap(classOfT).cast(object);\n+    return $Primitives.wrap(classOfT).cast(object);\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "10db917e9380ca4d741e06152fd1ee506666c1c3": {
      "type": "Ymultichange(Yexceptionschange,Ydocchange)",
      "commitMessage": "Updated fromJson and toJson signatures to indicate the kind of exceptions (JsonIOException, JsonSyntaxException) that can be thrown.\n",
      "commitDate": "11/3/10, 12:46 PM",
      "commitName": "10db917e9380ca4d741e06152fd1ee506666c1c3",
      "commitAuthor": "Inderjeet Singh",
      "subchanges": [
        {
          "type": "Yexceptionschange",
          "commitMessage": "Updated fromJson and toJson signatures to indicate the kind of exceptions (JsonIOException, JsonSyntaxException) that can be thrown.\n",
          "commitDate": "11/3/10, 12:46 PM",
          "commitName": "10db917e9380ca4d741e06152fd1ee506666c1c3",
          "commitAuthor": "Inderjeet Singh",
          "commitDateOld": "11/3/10, 6:28 AM",
          "commitNameOld": "83539c534c3cade5a05e633944420615b0b478ed",
          "commitAuthorOld": "Inderjeet Singh",
          "daysBetweenCommits": 0.26,
          "commitsBetweenForRepo": 2,
          "commitsBetweenForFile": 1,
          "actualSource": "public \u003cT\u003e T fromJson(String json, Class\u003cT\u003e classOfT) throws JsonSyntaxException {\n    Object object \u003d fromJson(json, (Type) classOfT);\n    return Primitives.wrap(classOfT).cast(object);\n}",
          "path": "gson/src/main/java/com/google/gson/Gson.java",
          "functionStartLine": 403,
          "functionName": "fromJson",
          "functionAnnotation": "",
          "functionDoc": "This method deserializes the specified Json into an object of the specified class. It is not\nsuitable to use if the specified class is a generic type since it will not have the generic\ntype information because of the Type Erasure feature of Java. Therefore, this method should not\nbe used if the desired type is a generic type. Note that this method works fine if the any of\nthe fields of the specified object are generics, just the object itself should not be a\ngeneric type. For the cases when the object is of generic type, invoke\n{@link #fromJson(String, Type)}. If you have the Json in a {@link Reader} instead of\na String, use {@link #fromJson(Reader, Class)} instead.\n\n@param \u003cT\u003e the type of the desired object\n@param json the string from which the object is to be deserialized\n@param classOfT the class of T\n@return an object of type T from the string\n@throws JsonSyntaxException if json is not a valid representation for an object of type\nclassOfT\n",
          "diff": "@@ -1,4 +1,4 @@\n-public \u003cT\u003e T fromJson(String json, Class\u003cT\u003e classOfT) throws JsonParseException {\n+public \u003cT\u003e T fromJson(String json, Class\u003cT\u003e classOfT) throws JsonSyntaxException {\n     Object object \u003d fromJson(json, (Type) classOfT);\n     return Primitives.wrap(classOfT).cast(object);\n }\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldValue": "[JsonParseException]",
            "newValue": "[JsonSyntaxException]"
          }
        },
        {
          "type": "Ydocchange",
          "commitMessage": "Updated fromJson and toJson signatures to indicate the kind of exceptions (JsonIOException, JsonSyntaxException) that can be thrown.\n",
          "commitDate": "11/3/10, 12:46 PM",
          "commitName": "10db917e9380ca4d741e06152fd1ee506666c1c3",
          "commitAuthor": "Inderjeet Singh",
          "commitDateOld": "11/3/10, 6:28 AM",
          "commitNameOld": "83539c534c3cade5a05e633944420615b0b478ed",
          "commitAuthorOld": "Inderjeet Singh",
          "daysBetweenCommits": 0.26,
          "commitsBetweenForRepo": 2,
          "commitsBetweenForFile": 1,
          "actualSource": "public \u003cT\u003e T fromJson(String json, Class\u003cT\u003e classOfT) throws JsonSyntaxException {\n    Object object \u003d fromJson(json, (Type) classOfT);\n    return Primitives.wrap(classOfT).cast(object);\n}",
          "path": "gson/src/main/java/com/google/gson/Gson.java",
          "functionStartLine": 403,
          "functionName": "fromJson",
          "functionAnnotation": "",
          "functionDoc": "This method deserializes the specified Json into an object of the specified class. It is not\nsuitable to use if the specified class is a generic type since it will not have the generic\ntype information because of the Type Erasure feature of Java. Therefore, this method should not\nbe used if the desired type is a generic type. Note that this method works fine if the any of\nthe fields of the specified object are generics, just the object itself should not be a\ngeneric type. For the cases when the object is of generic type, invoke\n{@link #fromJson(String, Type)}. If you have the Json in a {@link Reader} instead of\na String, use {@link #fromJson(Reader, Class)} instead.\n\n@param \u003cT\u003e the type of the desired object\n@param json the string from which the object is to be deserialized\n@param classOfT the class of T\n@return an object of type T from the string\n@throws JsonSyntaxException if json is not a valid representation for an object of type\nclassOfT\n",
          "diff": "@@ -1,4 +1,4 @@\n-public \u003cT\u003e T fromJson(String json, Class\u003cT\u003e classOfT) throws JsonParseException {\n+public \u003cT\u003e T fromJson(String json, Class\u003cT\u003e classOfT) throws JsonSyntaxException {\n     Object object \u003d fromJson(json, (Type) classOfT);\n     return Primitives.wrap(classOfT).cast(object);\n }\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldValue": "This method deserializes the specified Json into an object of the specified class. It is not\nsuitable to use if the specified class is a generic type since it will not have the generic\ntype information because of the Type Erasure feature of Java. Therefore, this method should not\nbe used if the desired type is a generic type. Note that this method works fine if the any of\nthe fields of the specified object are generics, just the object itself should not be a\ngeneric type. For the cases when the object is of generic type, invoke\n{@link #fromJson(String, Type)}. If you have the Json in a {@link Reader} instead of\na String, use {@link #fromJson(Reader, Class)} instead.\n\n@param \u003cT\u003e the type of the desired object\n@param json the string from which the object is to be deserialized\n@param classOfT the class of T\n@return an object of type T from the string\n@throws JsonParseException if json is not a valid representation for an object of type\nclassOfT\n",
            "newValue": "This method deserializes the specified Json into an object of the specified class. It is not\nsuitable to use if the specified class is a generic type since it will not have the generic\ntype information because of the Type Erasure feature of Java. Therefore, this method should not\nbe used if the desired type is a generic type. Note that this method works fine if the any of\nthe fields of the specified object are generics, just the object itself should not be a\ngeneric type. For the cases when the object is of generic type, invoke\n{@link #fromJson(String, Type)}. If you have the Json in a {@link Reader} instead of\na String, use {@link #fromJson(Reader, Class)} instead.\n\n@param \u003cT\u003e the type of the desired object\n@param json the string from which the object is to be deserialized\n@param classOfT the class of T\n@return an object of type T from the string\n@throws JsonSyntaxException if json is not a valid representation for an object of type\nclassOfT\n"
          }
        }
      ]
    },
    "83539c534c3cade5a05e633944420615b0b478ed": {
      "type": "Yannotationchange",
      "commitMessage": "removed compiler warnings.\nAdded default serial version id for MalformedJsonException.\n",
      "commitDate": "11/3/10, 6:28 AM",
      "commitName": "83539c534c3cade5a05e633944420615b0b478ed",
      "commitAuthor": "Inderjeet Singh",
      "commitDateOld": "11/1/10, 4:03 PM",
      "commitNameOld": "dea7ab89fe3e4c5b71c41a9733b102ccdc30b902",
      "commitAuthorOld": "Jesse Wilson",
      "daysBetweenCommits": 1.6,
      "commitsBetweenForRepo": 13,
      "commitsBetweenForFile": 1,
      "actualSource": "public \u003cT\u003e T fromJson(String json, Class\u003cT\u003e classOfT) throws JsonParseException {\n    Object object \u003d fromJson(json, (Type) classOfT);\n    return Primitives.wrap(classOfT).cast(object);\n}",
      "path": "gson/src/main/java/com/google/gson/Gson.java",
      "functionStartLine": 398,
      "functionName": "fromJson",
      "functionAnnotation": "",
      "functionDoc": "This method deserializes the specified Json into an object of the specified class. It is not\nsuitable to use if the specified class is a generic type since it will not have the generic\ntype information because of the Type Erasure feature of Java. Therefore, this method should not\nbe used if the desired type is a generic type. Note that this method works fine if the any of\nthe fields of the specified object are generics, just the object itself should not be a\ngeneric type. For the cases when the object is of generic type, invoke\n{@link #fromJson(String, Type)}. If you have the Json in a {@link Reader} instead of\na String, use {@link #fromJson(Reader, Class)} instead.\n\n@param \u003cT\u003e the type of the desired object\n@param json the string from which the object is to be deserialized\n@param classOfT the class of T\n@return an object of type T from the string\n@throws JsonParseException if json is not a valid representation for an object of type\nclassOfT\n",
      "diff": "@@ -1,5 +1,4 @@\n-@SuppressWarnings(\"unchecked\")\n public \u003cT\u003e T fromJson(String json, Class\u003cT\u003e classOfT) throws JsonParseException {\n     Object object \u003d fromJson(json, (Type) classOfT);\n     return Primitives.wrap(classOfT).cast(object);\n }\n\\ No newline at end of file\n",
      "extendedDetails": {
        "oldValue": "@SuppressWarnings(\"unchecked\")",
        "newValue": ""
      }
    },
    "c8c3a6965c5a1a01951452a25291e5a5944fa59a": {
      "type": "Ybodychange",
      "commitMessage": "Fix a regression that expects different type adapters for long.class and Long.class. This is a temporary fix; later we may want to always use the canonical wrapped class.\n",
      "commitDate": "11/1/10, 3:46 PM",
      "commitName": "c8c3a6965c5a1a01951452a25291e5a5944fa59a",
      "commitAuthor": "Jesse Wilson",
      "commitDateOld": "11/1/10, 3:36 PM",
      "commitNameOld": "20d895ff95414d4da23d07115c57920f5813a95d",
      "commitAuthorOld": "Jesse Wilson",
      "daysBetweenCommits": 0.01,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "@SuppressWarnings(\"unchecked\")\npublic \u003cT\u003e T fromJson(String json, Class\u003cT\u003e classOfT) throws JsonParseException {\n    Object object \u003d fromJson(json, (Type) classOfT);\n    return Primitives.wrap(classOfT).cast(object);\n}",
      "path": "gson/src/main/java/com/google/gson/Gson.java",
      "functionStartLine": 394,
      "functionName": "fromJson",
      "functionAnnotation": "@SuppressWarnings(\"unchecked\")",
      "functionDoc": "This method deserializes the specified Json into an object of the specified class. It is not\nsuitable to use if the specified class is a generic type since it will not have the generic\ntype information because of the Type Erasure feature of Java. Therefore, this method should not\nbe used if the desired type is a generic type. Note that this method works fine if the any of\nthe fields of the specified object are generics, just the object itself should not be a\ngeneric type. For the cases when the object is of generic type, invoke\n{@link #fromJson(String, Type)}. If you have the Json in a {@link Reader} instead of\na String, use {@link #fromJson(Reader, Class)} instead.\n\n@param \u003cT\u003e the type of the desired object\n@param json the string from which the object is to be deserialized\n@param classOfT the class of T\n@return an object of type T from the string\n@throws JsonParseException if json is not a valid representation for an object of type\nclassOfT\n",
      "diff": "@@ -1,6 +1,5 @@\n @SuppressWarnings(\"unchecked\")\n public \u003cT\u003e T fromJson(String json, Class\u003cT\u003e classOfT) throws JsonParseException {\n-    Class\u003cT\u003e wrapped \u003d Primitives.wrap(classOfT);\n-    Object object \u003d fromJson(json, (Type) wrapped);\n-    return wrapped.cast(object);\n+    Object object \u003d fromJson(json, (Type) classOfT);\n+    return Primitives.wrap(classOfT).cast(object);\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "20d895ff95414d4da23d07115c57920f5813a95d": {
      "type": "Ybodychange",
      "commitMessage": "Fix primitive wrapping and casting.\n\nIssue: 235\n",
      "commitDate": "11/1/10, 3:36 PM",
      "commitName": "20d895ff95414d4da23d07115c57920f5813a95d",
      "commitAuthor": "Jesse Wilson",
      "commitDateOld": "10/22/10, 9:06 AM",
      "commitNameOld": "d3eda04f33ed9386140bb8c3066716916e2de831",
      "commitAuthorOld": "Inderjeet Singh",
      "daysBetweenCommits": 10.27,
      "commitsBetweenForRepo": 15,
      "commitsBetweenForFile": 1,
      "actualSource": "@SuppressWarnings(\"unchecked\")\npublic \u003cT\u003e T fromJson(String json, Class\u003cT\u003e classOfT) throws JsonParseException {\n    Class\u003cT\u003e wrapped \u003d Primitives.wrap(classOfT);\n    Object object \u003d fromJson(json, (Type) wrapped);\n    return wrapped.cast(object);\n}",
      "path": "gson/src/main/java/com/google/gson/Gson.java",
      "functionStartLine": 394,
      "functionName": "fromJson",
      "functionAnnotation": "@SuppressWarnings(\"unchecked\")",
      "functionDoc": "This method deserializes the specified Json into an object of the specified class. It is not\nsuitable to use if the specified class is a generic type since it will not have the generic\ntype information because of the Type Erasure feature of Java. Therefore, this method should not\nbe used if the desired type is a generic type. Note that this method works fine if the any of\nthe fields of the specified object are generics, just the object itself should not be a\ngeneric type. For the cases when the object is of generic type, invoke\n{@link #fromJson(String, Type)}. If you have the Json in a {@link Reader} instead of\na String, use {@link #fromJson(Reader, Class)} instead.\n\n@param \u003cT\u003e the type of the desired object\n@param json the string from which the object is to be deserialized\n@param classOfT the class of T\n@return an object of type T from the string\n@throws JsonParseException if json is not a valid representation for an object of type\nclassOfT\n",
      "diff": "@@ -1,5 +1,6 @@\n @SuppressWarnings(\"unchecked\")\n public \u003cT\u003e T fromJson(String json, Class\u003cT\u003e classOfT) throws JsonParseException {\n-    T target \u003d (T) fromJson(json, (Type) classOfT);\n-    return target;\n+    Class\u003cT\u003e wrapped \u003d Primitives.wrap(classOfT);\n+    Object object \u003d fromJson(json, (Type) wrapped);\n+    return wrapped.cast(object);\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "57d1f32de5bf3a7dd54613384cc7e979fba2660b": {
      "type": "Yintroduced",
      "commitMessage": "moved gson as a project under trunk\n",
      "commitDate": "8/31/08, 8:13 PM",
      "commitName": "57d1f32de5bf3a7dd54613384cc7e979fba2660b",
      "commitAuthor": "Inderjeet Singh",
      "diff": "@@ -0,0 +1,5 @@\n+@SuppressWarnings(\"unchecked\")\n+public \u003cT\u003e T fromJson(String json, Class\u003cT\u003e classOfT) throws JsonParseException {\n+    T target \u003d (T) fromJson(json, (Type) classOfT);\n+    return target;\n+}\n\\ No newline at end of file\n",
      "actualSource": "@SuppressWarnings(\"unchecked\")\npublic \u003cT\u003e T fromJson(String json, Class\u003cT\u003e classOfT) throws JsonParseException {\n    T target \u003d (T) fromJson(json, (Type) classOfT);\n    return target;\n}",
      "path": "gson/src/main/java/com/google/gson/Gson.java",
      "functionStartLine": 301,
      "functionName": "fromJson",
      "functionAnnotation": "@SuppressWarnings(\"unchecked\")",
      "functionDoc": "This method deserializes the specified Json into an object of the specified class. It is not\nsuitable to use if the specified class is a generic type since it will not have the generic\ntype information because of the Type Erasure feature of Java. Therefore, this method should not\nbe used if the desired type is a generic type. Note that this method works fine if the any of\nthe fields of the specified object are generics, just the object itself should not be a\ngeneric type. For the cases when the object is of generic type, invoke\n{@link #fromJson(String, Type)}. If you have the Json in a {@link Reader} instead of\na String, use {@link #fromJson(Reader, Class)} instead.\n\n@param \u003cT\u003e the type of the desired object\n@param json the string from which the object is to be deserialized\n@param classOfT the class of T\n@return an object of type T from the string\n@throws JsonParseException if json is not a valid representation for an object of type\nclassOfT\n"
    }
  }
}