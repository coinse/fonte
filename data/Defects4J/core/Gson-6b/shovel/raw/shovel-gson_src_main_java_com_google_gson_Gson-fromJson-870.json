{
  "origin": "codeshovel",
  "repositoryName": "Gson-6b",
  "repositoryPath": "/tmp/Gson-6b//.git",
  "startCommitName": "HEAD",
  "sourceFileName": "Gson.java",
  "functionName": "fromJson",
  "functionId": "fromJson___reader-JsonReader__typeOfT-Type",
  "sourceFilePath": "gson/src/main/java/com/google/gson/Gson.java",
  "functionAnnotation": "@SuppressWarnings(\"unchecked\")",
  "functionDoc": "Reads the next JSON value from {@code reader} and convert it to an object\nof type {@code typeOfT}. Returns {@code null}, if the {@code reader} is at EOF.\nSince Type is not parameterized by T, this method is type unsafe and should be used carefully\n\n@throws JsonIOException if there was a problem writing to the Reader\n@throws JsonSyntaxException if json is not a valid representation for an object of type\n",
  "functionStartLine": 870,
  "functionEndLine": 898,
  "numCommitsSeen": 211,
  "timeTaken": 4031,
  "changeHistory": [
    "b373c20136eae1a821b173d106ed6c222f87fb13",
    "af4879dbb782bb13fd95e3b406a55d80272ddff3",
    "22c835f2bcd5ee39fd58556e01324f334c5f0cb7",
    "fd4fbe41322c39329245b6a1311ae42bd10827ad",
    "c25278b4d6036a0e0ae758b13194813936d9e911",
    "7e760143fdc8b689daeebdee33ad6ea7d0a62a56",
    "016261d9cfdcab859a674f90c1b53858dee44f36",
    "25c6ae177b1ca56db7f3c29eb574bdd032a06165",
    "99801915aa324c4d07b852e23debfbcefb1a3007",
    "bafc43afae04d33bf50f112c05661bf4a402aa69",
    "84c71409da812c1ccc62196ac2ff71f761bbf31b",
    "10db917e9380ca4d741e06152fd1ee506666c1c3",
    "747e3c3051153779954e49b7dbc475daa678e1f4",
    "fa40b4c63a57e92e87b3fb6079b01fd5304a01c1",
    "7a7bbf754cfabbcb56d090b982bf4b128e15938d",
    "29ab864b2fda09ddee46554751f22f875c0ab736",
    "abf4ab2d78b2a7f3108fd7560145f45886f6b301",
    "6e59e502c2461c11d0e6099f10f65c666acabc45",
    "5c6d5a0d119481e7ca61b0884c881c6811d7af86",
    "2034090b15cfef51d81e860b1d49340147378618",
    "2c7cc620d4975521dc5d1c54ea1c0b2247b4fdad",
    "cf2a457af7b0422e7728e0d55a4e794048af5a6b",
    "9dfa454f6da6e88b51dba7840881feb874dbbdef",
    "57d1f32de5bf3a7dd54613384cc7e979fba2660b"
  ],
  "changeHistoryShort": {
    "b373c20136eae1a821b173d106ed6c222f87fb13": "Ydocchange",
    "af4879dbb782bb13fd95e3b406a55d80272ddff3": "Ybodychange",
    "22c835f2bcd5ee39fd58556e01324f334c5f0cb7": "Ybodychange",
    "fd4fbe41322c39329245b6a1311ae42bd10827ad": "Ybodychange",
    "c25278b4d6036a0e0ae758b13194813936d9e911": "Ybodychange",
    "7e760143fdc8b689daeebdee33ad6ea7d0a62a56": "Ybodychange",
    "016261d9cfdcab859a674f90c1b53858dee44f36": "Ybodychange",
    "25c6ae177b1ca56db7f3c29eb574bdd032a06165": "Ybodychange",
    "99801915aa324c4d07b852e23debfbcefb1a3007": "Ybodychange",
    "bafc43afae04d33bf50f112c05661bf4a402aa69": "Ybodychange",
    "84c71409da812c1ccc62196ac2ff71f761bbf31b": "Ybodychange",
    "10db917e9380ca4d741e06152fd1ee506666c1c3": "Ymultichange(Yexceptionschange,Yannotationchange,Ydocchange)",
    "747e3c3051153779954e49b7dbc475daa678e1f4": "Ymultichange(Yparameterchange,Ybodychange,Yannotationchange,Ydocchange)",
    "fa40b4c63a57e92e87b3fb6079b01fd5304a01c1": "Ybodychange",
    "7a7bbf754cfabbcb56d090b982bf4b128e15938d": "Ybodychange",
    "29ab864b2fda09ddee46554751f22f875c0ab736": "Ymultichange(Ybodychange,Yannotationchange)",
    "abf4ab2d78b2a7f3108fd7560145f45886f6b301": "Ymultichange(Ybodychange,Yannotationchange)",
    "6e59e502c2461c11d0e6099f10f65c666acabc45": "Ybodychange",
    "5c6d5a0d119481e7ca61b0884c881c6811d7af86": "Ybodychange",
    "2034090b15cfef51d81e860b1d49340147378618": "Ybodychange",
    "2c7cc620d4975521dc5d1c54ea1c0b2247b4fdad": "Ybodychange",
    "cf2a457af7b0422e7728e0d55a4e794048af5a6b": "Ybodychange",
    "9dfa454f6da6e88b51dba7840881feb874dbbdef": "Ybodychange",
    "57d1f32de5bf3a7dd54613384cc7e979fba2660b": "Yintroduced"
  },
  "changeHistoryDetails": {
    "b373c20136eae1a821b173d106ed6c222f87fb13": {
      "type": "Ydocchange",
      "commitMessage": "Fixed issue 552 by documenting when fromJson returns null.\n",
      "commitDate": "3/29/14, 4:28 PM",
      "commitName": "b373c20136eae1a821b173d106ed6c222f87fb13",
      "commitAuthor": "Inderjeet Singh",
      "commitDateOld": "3/26/14, 11:07 AM",
      "commitNameOld": "c53e2551058b445b6adf5bc588456c2b33548e28",
      "commitAuthorOld": "Inderjeet Singh",
      "daysBetweenCommits": 3.22,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "@SuppressWarnings(\"unchecked\")\npublic \u003cT\u003e T fromJson(JsonReader reader, Type typeOfT) throws JsonIOException, JsonSyntaxException {\n    boolean isEmpty \u003d true;\n    boolean oldLenient \u003d reader.isLenient();\n    reader.setLenient(true);\n    try {\n        reader.peek();\n        isEmpty \u003d false;\n        TypeToken\u003cT\u003e typeToken \u003d (TypeToken\u003cT\u003e) TypeToken.get(typeOfT);\n        TypeAdapter\u003cT\u003e typeAdapter \u003d getAdapter(typeToken);\n        T object \u003d typeAdapter.read(reader);\n        return object;\n    } catch (EOFException e) {\n        if (isEmpty) {\n            return null;\n        }\n        throw new JsonSyntaxException(e);\n    } catch (IllegalStateException e) {\n        throw new JsonSyntaxException(e);\n    } catch (IOException e) {\n        throw new JsonSyntaxException(e);\n    } finally {\n        reader.setLenient(oldLenient);\n    }\n}",
      "path": "gson/src/main/java/com/google/gson/Gson.java",
      "functionStartLine": 809,
      "functionName": "fromJson",
      "functionAnnotation": "@SuppressWarnings(\"unchecked\")",
      "functionDoc": "Reads the next JSON value from {@code reader} and convert it to an object\nof type {@code typeOfT}. Returns {@code null}, if the {@code reader} is at EOF.\nSince Type is not parameterized by T, this method is type unsafe and should be used carefully\n\n@throws JsonIOException if there was a problem writing to the Reader\n@throws JsonSyntaxException if json is not a valid representation for an object of type\n",
      "diff": "",
      "extendedDetails": {
        "oldValue": "Reads the next JSON value from {@code reader} and convert it to an object\nof type {@code typeOfT}.\nSince Type is not parameterized by T, this method is type unsafe and should be used carefully\n\n@throws JsonIOException if there was a problem writing to the Reader\n@throws JsonSyntaxException if json is not a valid representation for an object of type\n",
        "newValue": "Reads the next JSON value from {@code reader} and convert it to an object\nof type {@code typeOfT}. Returns {@code null}, if the {@code reader} is at EOF.\nSince Type is not parameterized by T, this method is type unsafe and should be used carefully\n\n@throws JsonIOException if there was a problem writing to the Reader\n@throws JsonSyntaxException if json is not a valid representation for an object of type\n"
      }
    },
    "af4879dbb782bb13fd95e3b406a55d80272ddff3": {
      "type": "Ybodychange",
      "commitMessage": "Move interceptors from \u0027alpha\u0027 to \u0027extras\u0027.\n\nThis makes the feature less risky to use! It now uses our\nTypeAdapterFactory infrastructure rather than relying on\nparallel infrastructure.\n\n",
      "commitDate": "10/23/12, 10:36 AM",
      "commitName": "af4879dbb782bb13fd95e3b406a55d80272ddff3",
      "commitAuthor": "Jesse Wilson",
      "commitDateOld": "10/22/12, 7:41 PM",
      "commitNameOld": "1e18dce002158992bbda1d3a19952fdf07f308f4",
      "commitAuthorOld": "Jesse Wilson",
      "daysBetweenCommits": 0.62,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "@SuppressWarnings(\"unchecked\")\npublic \u003cT\u003e T fromJson(JsonReader reader, Type typeOfT) throws JsonIOException, JsonSyntaxException {\n    boolean isEmpty \u003d true;\n    boolean oldLenient \u003d reader.isLenient();\n    reader.setLenient(true);\n    try {\n        reader.peek();\n        isEmpty \u003d false;\n        TypeToken\u003cT\u003e typeToken \u003d (TypeToken\u003cT\u003e) TypeToken.get(typeOfT);\n        TypeAdapter\u003cT\u003e typeAdapter \u003d getAdapter(typeToken);\n        T object \u003d typeAdapter.read(reader);\n        return object;\n    } catch (EOFException e) {\n        if (isEmpty) {\n            return null;\n        }\n        throw new JsonSyntaxException(e);\n    } catch (IllegalStateException e) {\n        throw new JsonSyntaxException(e);\n    } catch (IOException e) {\n        throw new JsonSyntaxException(e);\n    } finally {\n        reader.setLenient(oldLenient);\n    }\n}",
      "path": "gson/src/main/java/com/google/gson/Gson.java",
      "functionStartLine": 787,
      "functionName": "fromJson",
      "functionAnnotation": "@SuppressWarnings(\"unchecked\")",
      "functionDoc": "Reads the next JSON value from {@code reader} and convert it to an object\nof type {@code typeOfT}.\nSince Type is not parameterized by T, this method is type unsafe and should be used carefully\n\n@throws JsonIOException if there was a problem writing to the Reader\n@throws JsonSyntaxException if json is not a valid representation for an object of type\n",
      "diff": "@@ -1,26 +1,25 @@\n @SuppressWarnings(\"unchecked\")\n public \u003cT\u003e T fromJson(JsonReader reader, Type typeOfT) throws JsonIOException, JsonSyntaxException {\n     boolean isEmpty \u003d true;\n     boolean oldLenient \u003d reader.isLenient();\n     reader.setLenient(true);\n     try {\n         reader.peek();\n         isEmpty \u003d false;\n         TypeToken\u003cT\u003e typeToken \u003d (TypeToken\u003cT\u003e) TypeToken.get(typeOfT);\n         TypeAdapter\u003cT\u003e typeAdapter \u003d getAdapter(typeToken);\n         T object \u003d typeAdapter.read(reader);\n-        invokeInterceptorIfNeeded(object, (Class\u003cT\u003e) typeToken.getRawType());\n         return object;\n     } catch (EOFException e) {\n         if (isEmpty) {\n             return null;\n         }\n         throw new JsonSyntaxException(e);\n     } catch (IllegalStateException e) {\n         throw new JsonSyntaxException(e);\n     } catch (IOException e) {\n         throw new JsonSyntaxException(e);\n     } finally {\n         reader.setLenient(oldLenient);\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "22c835f2bcd5ee39fd58556e01324f334c5f0cb7": {
      "type": "Ybodychange",
      "commitMessage": "Fix compile warnings\n",
      "commitDate": "10/22/12, 7:40 PM",
      "commitName": "22c835f2bcd5ee39fd58556e01324f334c5f0cb7",
      "commitAuthor": "Jesse Wilson",
      "commitDateOld": "10/17/12, 7:37 PM",
      "commitNameOld": "fd4fbe41322c39329245b6a1311ae42bd10827ad",
      "commitAuthorOld": "Inderjeet Singh",
      "daysBetweenCommits": 5.0,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "@SuppressWarnings(\"unchecked\")\npublic \u003cT\u003e T fromJson(JsonReader reader, Type typeOfT) throws JsonIOException, JsonSyntaxException {\n    boolean isEmpty \u003d true;\n    boolean oldLenient \u003d reader.isLenient();\n    reader.setLenient(true);\n    try {\n        reader.peek();\n        isEmpty \u003d false;\n        TypeToken\u003cT\u003e typeToken \u003d (TypeToken\u003cT\u003e) TypeToken.get(typeOfT);\n        TypeAdapter\u003cT\u003e typeAdapter \u003d getAdapter(typeToken);\n        T object \u003d typeAdapter.read(reader);\n        invokeInterceptorIfNeeded(object, (Class\u003cT\u003e) typeToken.getRawType());\n        return object;\n    } catch (EOFException e) {\n        if (isEmpty) {\n            return null;\n        }\n        throw new JsonSyntaxException(e);\n    } catch (IllegalStateException e) {\n        throw new JsonSyntaxException(e);\n    } catch (IOException e) {\n        throw new JsonSyntaxException(e);\n    } finally {\n        reader.setLenient(oldLenient);\n    }\n}",
      "path": "gson/src/main/java/com/google/gson/Gson.java",
      "functionStartLine": 790,
      "functionName": "fromJson",
      "functionAnnotation": "@SuppressWarnings(\"unchecked\")",
      "functionDoc": "Reads the next JSON value from {@code reader} and convert it to an object\nof type {@code typeOfT}.\nSince Type is not parameterized by T, this method is type unsafe and should be used carefully\n\n@throws JsonIOException if there was a problem writing to the Reader\n@throws JsonSyntaxException if json is not a valid representation for an object of type\n",
      "diff": "@@ -1,26 +1,26 @@\n @SuppressWarnings(\"unchecked\")\n public \u003cT\u003e T fromJson(JsonReader reader, Type typeOfT) throws JsonIOException, JsonSyntaxException {\n     boolean isEmpty \u003d true;\n     boolean oldLenient \u003d reader.isLenient();\n     reader.setLenient(true);\n     try {\n         reader.peek();\n         isEmpty \u003d false;\n         TypeToken\u003cT\u003e typeToken \u003d (TypeToken\u003cT\u003e) TypeToken.get(typeOfT);\n-        TypeAdapter\u003cT\u003e typeAdapter \u003d (TypeAdapter\u003cT\u003e) getAdapter(typeToken);\n+        TypeAdapter\u003cT\u003e typeAdapter \u003d getAdapter(typeToken);\n         T object \u003d typeAdapter.read(reader);\n-        invokeInterceptorIfNeeded(object, typeToken.getRawType());\n+        invokeInterceptorIfNeeded(object, (Class\u003cT\u003e) typeToken.getRawType());\n         return object;\n     } catch (EOFException e) {\n         if (isEmpty) {\n             return null;\n         }\n         throw new JsonSyntaxException(e);\n     } catch (IllegalStateException e) {\n         throw new JsonSyntaxException(e);\n     } catch (IOException e) {\n         throw new JsonSyntaxException(e);\n     } finally {\n         reader.setLenient(oldLenient);\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "fd4fbe41322c39329245b6a1311ae42bd10827ad": {
      "type": "Ybodychange",
      "commitMessage": "Added support for collections, maps, and arbitrary depth of type adapters for Intercept annotation.\nAdded more tests for the features.\n",
      "commitDate": "10/17/12, 7:37 PM",
      "commitName": "fd4fbe41322c39329245b6a1311ae42bd10827ad",
      "commitAuthor": "Inderjeet Singh",
      "commitDateOld": "10/10/12, 8:20 PM",
      "commitNameOld": "c25278b4d6036a0e0ae758b13194813936d9e911",
      "commitAuthorOld": "Inderjeet Singh",
      "daysBetweenCommits": 6.97,
      "commitsBetweenForRepo": 2,
      "commitsBetweenForFile": 1,
      "actualSource": "@SuppressWarnings(\"unchecked\")\npublic \u003cT\u003e T fromJson(JsonReader reader, Type typeOfT) throws JsonIOException, JsonSyntaxException {\n    boolean isEmpty \u003d true;\n    boolean oldLenient \u003d reader.isLenient();\n    reader.setLenient(true);\n    try {\n        reader.peek();\n        isEmpty \u003d false;\n        TypeToken\u003cT\u003e typeToken \u003d (TypeToken\u003cT\u003e) TypeToken.get(typeOfT);\n        TypeAdapter\u003cT\u003e typeAdapter \u003d (TypeAdapter\u003cT\u003e) getAdapter(typeToken);\n        T object \u003d typeAdapter.read(reader);\n        invokeInterceptorIfNeeded(object, typeToken.getRawType());\n        return object;\n    } catch (EOFException e) {\n        if (isEmpty) {\n            return null;\n        }\n        throw new JsonSyntaxException(e);\n    } catch (IllegalStateException e) {\n        throw new JsonSyntaxException(e);\n    } catch (IOException e) {\n        throw new JsonSyntaxException(e);\n    } finally {\n        reader.setLenient(oldLenient);\n    }\n}",
      "path": "gson/src/main/java/com/google/gson/Gson.java",
      "functionStartLine": 790,
      "functionName": "fromJson",
      "functionAnnotation": "@SuppressWarnings(\"unchecked\")",
      "functionDoc": "Reads the next JSON value from {@code reader} and convert it to an object\nof type {@code typeOfT}.\nSince Type is not parameterized by T, this method is type unsafe and should be used carefully\n\n@throws JsonIOException if there was a problem writing to the Reader\n@throws JsonSyntaxException if json is not a valid representation for an object of type\n",
      "diff": "@@ -1,26 +1,26 @@\n @SuppressWarnings(\"unchecked\")\n public \u003cT\u003e T fromJson(JsonReader reader, Type typeOfT) throws JsonIOException, JsonSyntaxException {\n     boolean isEmpty \u003d true;\n     boolean oldLenient \u003d reader.isLenient();\n     reader.setLenient(true);\n     try {\n         reader.peek();\n         isEmpty \u003d false;\n         TypeToken\u003cT\u003e typeToken \u003d (TypeToken\u003cT\u003e) TypeToken.get(typeOfT);\n         TypeAdapter\u003cT\u003e typeAdapter \u003d (TypeAdapter\u003cT\u003e) getAdapter(typeToken);\n         T object \u003d typeAdapter.read(reader);\n-        invokeInterceptorIfNeeded(object, typeToken);\n+        invokeInterceptorIfNeeded(object, typeToken.getRawType());\n         return object;\n     } catch (EOFException e) {\n         if (isEmpty) {\n             return null;\n         }\n         throw new JsonSyntaxException(e);\n     } catch (IllegalStateException e) {\n         throw new JsonSyntaxException(e);\n     } catch (IOException e) {\n         throw new JsonSyntaxException(e);\n     } finally {\n         reader.setLenient(oldLenient);\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "c25278b4d6036a0e0ae758b13194813936d9e911": {
      "type": "Ybodychange",
      "commitMessage": "Created an alpha package that holds experimental feature.\nAdded support for JsonPostDeserializer that allows you to invoke postDeserialize methods on an Gson deserialized object.\n",
      "commitDate": "10/10/12, 8:20 PM",
      "commitName": "c25278b4d6036a0e0ae758b13194813936d9e911",
      "commitAuthor": "Inderjeet Singh",
      "commitDateOld": "7/2/12, 5:28 PM",
      "commitNameOld": "b946a229b615d7a8d5cec9ce11e4abf249c548bd",
      "commitAuthorOld": "Inderjeet Singh",
      "daysBetweenCommits": 100.12,
      "commitsBetweenForRepo": 47,
      "commitsBetweenForFile": 1,
      "actualSource": "@SuppressWarnings(\"unchecked\")\npublic \u003cT\u003e T fromJson(JsonReader reader, Type typeOfT) throws JsonIOException, JsonSyntaxException {\n    boolean isEmpty \u003d true;\n    boolean oldLenient \u003d reader.isLenient();\n    reader.setLenient(true);\n    try {\n        reader.peek();\n        isEmpty \u003d false;\n        TypeToken\u003cT\u003e typeToken \u003d (TypeToken\u003cT\u003e) TypeToken.get(typeOfT);\n        TypeAdapter\u003cT\u003e typeAdapter \u003d (TypeAdapter\u003cT\u003e) getAdapter(typeToken);\n        T object \u003d typeAdapter.read(reader);\n        invokeInterceptorIfNeeded(object, typeToken);\n        return object;\n    } catch (EOFException e) {\n        if (isEmpty) {\n            return null;\n        }\n        throw new JsonSyntaxException(e);\n    } catch (IllegalStateException e) {\n        throw new JsonSyntaxException(e);\n    } catch (IOException e) {\n        throw new JsonSyntaxException(e);\n    } finally {\n        reader.setLenient(oldLenient);\n    }\n}",
      "path": "gson/src/main/java/com/google/gson/Gson.java",
      "functionStartLine": 790,
      "functionName": "fromJson",
      "functionAnnotation": "@SuppressWarnings(\"unchecked\")",
      "functionDoc": "Reads the next JSON value from {@code reader} and convert it to an object\nof type {@code typeOfT}.\nSince Type is not parameterized by T, this method is type unsafe and should be used carefully\n\n@throws JsonIOException if there was a problem writing to the Reader\n@throws JsonSyntaxException if json is not a valid representation for an object of type\n",
      "diff": "@@ -1,23 +1,26 @@\n @SuppressWarnings(\"unchecked\")\n public \u003cT\u003e T fromJson(JsonReader reader, Type typeOfT) throws JsonIOException, JsonSyntaxException {\n     boolean isEmpty \u003d true;\n     boolean oldLenient \u003d reader.isLenient();\n     reader.setLenient(true);\n     try {\n         reader.peek();\n         isEmpty \u003d false;\n-        TypeAdapter\u003cT\u003e typeAdapter \u003d (TypeAdapter\u003cT\u003e) getAdapter(TypeToken.get(typeOfT));\n-        return typeAdapter.read(reader);\n+        TypeToken\u003cT\u003e typeToken \u003d (TypeToken\u003cT\u003e) TypeToken.get(typeOfT);\n+        TypeAdapter\u003cT\u003e typeAdapter \u003d (TypeAdapter\u003cT\u003e) getAdapter(typeToken);\n+        T object \u003d typeAdapter.read(reader);\n+        invokeInterceptorIfNeeded(object, typeToken);\n+        return object;\n     } catch (EOFException e) {\n         if (isEmpty) {\n             return null;\n         }\n         throw new JsonSyntaxException(e);\n     } catch (IllegalStateException e) {\n         throw new JsonSyntaxException(e);\n     } catch (IOException e) {\n         throw new JsonSyntaxException(e);\n     } finally {\n         reader.setLenient(oldLenient);\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "7e760143fdc8b689daeebdee33ad6ea7d0a62a56": {
      "type": "Ybodychange",
      "commitMessage": "Smash together MiniGson and Gson. This changes Gson to be the MiniGson rather than delegating to the MiniGson. It means that the MiniGson objects passed into streaming type adapters are now fully-capable \u0027Gson\u0027 objects. \n\nThe most notable impact of this change is that it adds several new public APIs:\n - The TypeAdapter abstract class\n - The TypeAdapter.Factory interface\n - Four new methods on GsonBuilder to register streaming TypeAdapters (via Factory, via Class, via TypeToken, and as a type hierarchy)\n - Three new methods on Gson to lookup streaming TypeAdapters (by type, by class, and to get the next type adapter) \n\nStill outstanding:\n - Write beautiful prose to document the new APIs above\n - Change GsonBuilder\u0027s precedence so that both old and new-style type adapters are registered in one lot\n",
      "commitDate": "11/20/11, 7:23 AM",
      "commitName": "7e760143fdc8b689daeebdee33ad6ea7d0a62a56",
      "commitAuthor": "Jesse Wilson",
      "commitDateOld": "11/13/11, 12:04 PM",
      "commitNameOld": "a92cf394e827089f8a10853ca5d5f0da6c23654c",
      "commitAuthorOld": "Joel Leitch",
      "daysBetweenCommits": 6.8,
      "commitsBetweenForRepo": 8,
      "commitsBetweenForFile": 1,
      "actualSource": "@SuppressWarnings(\"unchecked\")\npublic \u003cT\u003e T fromJson(JsonReader reader, Type typeOfT) throws JsonIOException, JsonSyntaxException {\n    boolean isEmpty \u003d true;\n    boolean oldLenient \u003d reader.isLenient();\n    reader.setLenient(true);\n    try {\n        reader.peek();\n        isEmpty \u003d false;\n        TypeAdapter\u003cT\u003e typeAdapter \u003d (TypeAdapter\u003cT\u003e) getAdapter(TypeToken.get(typeOfT));\n        return typeAdapter.read(reader);\n    } catch (EOFException e) {\n        if (isEmpty) {\n            return null;\n        }\n        throw new JsonSyntaxException(e);\n    } catch (IllegalStateException e) {\n        throw new JsonSyntaxException(e);\n    } catch (IOException e) {\n        throw new JsonSyntaxException(e);\n    } finally {\n        reader.setLenient(oldLenient);\n    }\n}",
      "path": "gson/src/main/java/com/google/gson/Gson.java",
      "functionStartLine": 793,
      "functionName": "fromJson",
      "functionAnnotation": "@SuppressWarnings(\"unchecked\")",
      "functionDoc": "Reads the next JSON value from {@code reader} and convert it to an object\nof type {@code typeOfT}.\nSince Type is not parameterized by T, this method is type unsafe and should be used carefully\n\n@throws JsonIOException if there was a problem writing to the Reader\n@throws JsonSyntaxException if json is not a valid representation for an object of type\n",
      "diff": "@@ -1,23 +1,23 @@\n @SuppressWarnings(\"unchecked\")\n public \u003cT\u003e T fromJson(JsonReader reader, Type typeOfT) throws JsonIOException, JsonSyntaxException {\n     boolean isEmpty \u003d true;\n     boolean oldLenient \u003d reader.isLenient();\n     reader.setLenient(true);\n     try {\n         reader.peek();\n         isEmpty \u003d false;\n-        TypeAdapter\u003cT\u003e typeAdapter \u003d (TypeAdapter\u003cT\u003e) miniGson.getAdapter(TypeToken.get(typeOfT));\n+        TypeAdapter\u003cT\u003e typeAdapter \u003d (TypeAdapter\u003cT\u003e) getAdapter(TypeToken.get(typeOfT));\n         return typeAdapter.read(reader);\n     } catch (EOFException e) {\n         if (isEmpty) {\n             return null;\n         }\n         throw new JsonSyntaxException(e);\n     } catch (IllegalStateException e) {\n         throw new JsonSyntaxException(e);\n     } catch (IOException e) {\n         throw new JsonSyntaxException(e);\n     } finally {\n         reader.setLenient(oldLenient);\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "016261d9cfdcab859a674f90c1b53858dee44f36": {
      "type": "Ybodychange",
      "commitMessage": "Throw JsonParseException in event of binding failures like type mismatches.\n",
      "commitDate": "10/23/11, 6:32 PM",
      "commitName": "016261d9cfdcab859a674f90c1b53858dee44f36",
      "commitAuthor": "Jesse Wilson",
      "commitDateOld": "10/23/11, 1:28 PM",
      "commitNameOld": "052c9ce0ce7dc0e9c8c98e1902d0fdac97f6af52",
      "commitAuthorOld": "Jesse Wilson",
      "daysBetweenCommits": 0.21,
      "commitsBetweenForRepo": 3,
      "commitsBetweenForFile": 1,
      "actualSource": "@SuppressWarnings(\"unchecked\")\npublic \u003cT\u003e T fromJson(JsonReader reader, Type typeOfT) throws JsonIOException, JsonSyntaxException {\n    boolean isEmpty \u003d true;\n    boolean oldLenient \u003d reader.isLenient();\n    reader.setLenient(true);\n    try {\n        reader.peek();\n        isEmpty \u003d false;\n        TypeAdapter\u003cT\u003e typeAdapter \u003d (TypeAdapter\u003cT\u003e) miniGson.getAdapter(TypeToken.get(typeOfT));\n        return typeAdapter.read(reader);\n    } catch (EOFException e) {\n        if (isEmpty) {\n            return null;\n        }\n        throw new JsonSyntaxException(e);\n    } catch (IllegalStateException e) {\n        throw new JsonSyntaxException(e);\n    } catch (IOException e) {\n        throw new JsonSyntaxException(e);\n    } finally {\n        reader.setLenient(oldLenient);\n    }\n}",
      "path": "gson/src/main/java/com/google/gson/Gson.java",
      "functionStartLine": 716,
      "functionName": "fromJson",
      "functionAnnotation": "@SuppressWarnings(\"unchecked\")",
      "functionDoc": "Reads the next JSON value from {@code reader} and convert it to an object\nof type {@code typeOfT}.\nSince Type is not parameterized by T, this method is type unsafe and should be used carefully\n\n@throws JsonIOException if there was a problem writing to the Reader\n@throws JsonSyntaxException if json is not a valid representation for an object of type\n",
      "diff": "@@ -1,21 +1,23 @@\n @SuppressWarnings(\"unchecked\")\n public \u003cT\u003e T fromJson(JsonReader reader, Type typeOfT) throws JsonIOException, JsonSyntaxException {\n     boolean isEmpty \u003d true;\n     boolean oldLenient \u003d reader.isLenient();\n     reader.setLenient(true);\n     try {\n         reader.peek();\n         isEmpty \u003d false;\n         TypeAdapter\u003cT\u003e typeAdapter \u003d (TypeAdapter\u003cT\u003e) miniGson.getAdapter(TypeToken.get(typeOfT));\n         return typeAdapter.read(reader);\n     } catch (EOFException e) {\n         if (isEmpty) {\n             return null;\n         }\n         throw new JsonSyntaxException(e);\n+    } catch (IllegalStateException e) {\n+        throw new JsonSyntaxException(e);\n     } catch (IOException e) {\n         throw new JsonSyntaxException(e);\n     } finally {\n         reader.setLenient(oldLenient);\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "25c6ae177b1ca56db7f3c29eb574bdd032a06165": {
      "type": "Ybodychange",
      "commitMessage": "Down to 22 failing tests.\n\nConsolidated all of the different code paths that we use to construct instances. We now have an ObjectConstructor class that knows what type it constructs; this means that we don\u0027t need to ever do reflection to lookup a constructor at construction time.\n\nCleaned up some buggy type adapters, particularly around handling of null.\n\nRemoved dead code for object graph navigation.\n\nMoved some classes into \u0027internal\u0027 so they are visible to the \u0027bind\u0027 subpackage.\n\nTurned some TypeAdapterFactory/TypeAdapter pairs inside out so that the TypeAdapter is now the inner class. This is necessary so that the factories can take parameters.\n\nAdded an API to request the \u0027next\u0027 type adapter for a type. This allows type adapters to compose other type adapters. We\u0027re using this in two places:\n - where the user has excluded a type from serialization but not deserialization, we need to use the \"default\" deserialization but interpose null on serialization. We create a type adapter that delegates for one and returns null for the other.\n - similarly when a DOM type serializer is registered but no deserializer, or vice versa.\nThis is the biggest change to the MiniGson core.\n\nFor backwards compatibility, return null for the empty string.\n\nSimplify JsonSerializationContext/JsonDeserializationContext to simply call through to GSON. SerializeDefault is currently unsupported.\n\nMore useful error messages when calling getAsBoolean on a JsonNull.\n\nRemove currently unused MemoryRefStack. We might need this back again, though wiring it back in will be much more difficult because we don\u0027t interject ourselves between the users\u0027 various type adapters.\n",
      "commitDate": "9/11/11, 12:04 AM",
      "commitName": "25c6ae177b1ca56db7f3c29eb574bdd032a06165",
      "commitAuthor": "Jesse Wilson",
      "commitDateOld": "9/9/11, 1:04 AM",
      "commitNameOld": "d22e11b1846d43efef5179851a131f6ebb9cf1a9",
      "commitAuthorOld": "Jesse Wilson",
      "daysBetweenCommits": 1.96,
      "commitsBetweenForRepo": 5,
      "commitsBetweenForFile": 1,
      "actualSource": "@SuppressWarnings(\"unchecked\")\npublic \u003cT\u003e T fromJson(JsonReader reader, Type typeOfT) throws JsonIOException, JsonSyntaxException {\n    boolean isEmpty \u003d true;\n    boolean oldLenient \u003d reader.isLenient();\n    reader.setLenient(true);\n    try {\n        reader.peek();\n        isEmpty \u003d false;\n        TypeAdapter\u003cT\u003e typeAdapter \u003d (TypeAdapter\u003cT\u003e) miniGson.getAdapter(TypeToken.get(typeOfT));\n        return typeAdapter.read(reader);\n    } catch (EOFException e) {\n        if (isEmpty) {\n            return null;\n        }\n        throw new JsonSyntaxException(e);\n    } catch (IOException e) {\n        throw new JsonSyntaxException(e);\n    } finally {\n        reader.setLenient(oldLenient);\n    }\n}",
      "path": "gson/src/main/java/com/google/gson/Gson.java",
      "functionStartLine": 664,
      "functionName": "fromJson",
      "functionAnnotation": "@SuppressWarnings(\"unchecked\")",
      "functionDoc": "Reads the next JSON value from {@code reader} and convert it to an object\nof type {@code typeOfT}.\nSince Type is not parameterized by T, this method is type unsafe and should be used carefully\n\n@throws JsonIOException if there was a problem writing to the Reader\n@throws JsonSyntaxException if json is not a valid representation for an object of type\n",
      "diff": "@@ -1,13 +1,21 @@\n @SuppressWarnings(\"unchecked\")\n public \u003cT\u003e T fromJson(JsonReader reader, Type typeOfT) throws JsonIOException, JsonSyntaxException {\n+    boolean isEmpty \u003d true;\n     boolean oldLenient \u003d reader.isLenient();\n     reader.setLenient(true);\n     try {\n+        reader.peek();\n+        isEmpty \u003d false;\n         TypeAdapter\u003cT\u003e typeAdapter \u003d (TypeAdapter\u003cT\u003e) miniGson.getAdapter(TypeToken.get(typeOfT));\n         return typeAdapter.read(reader);\n+    } catch (EOFException e) {\n+        if (isEmpty) {\n+            return null;\n+        }\n+        throw new JsonSyntaxException(e);\n     } catch (IOException e) {\n         throw new JsonSyntaxException(e);\n     } finally {\n         reader.setLenient(oldLenient);\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "99801915aa324c4d07b852e23debfbcefb1a3007": {
      "type": "Ybodychange",
      "commitMessage": "More code through the same fromJson path\n",
      "commitDate": "9/8/11, 10:40 PM",
      "commitName": "99801915aa324c4d07b852e23debfbcefb1a3007",
      "commitAuthor": "Jesse Wilson",
      "commitDateOld": "9/8/11, 9:39 PM",
      "commitNameOld": "9db0c5321710f1cebb6ae297b2d7c35ef15b56ce",
      "commitAuthorOld": "Jesse Wilson",
      "daysBetweenCommits": 0.04,
      "commitsBetweenForRepo": 5,
      "commitsBetweenForFile": 1,
      "actualSource": "@SuppressWarnings(\"unchecked\")\npublic \u003cT\u003e T fromJson(JsonReader reader, Type typeOfT) throws JsonIOException, JsonSyntaxException {\n    boolean oldLenient \u003d reader.isLenient();\n    reader.setLenient(true);\n    try {\n        TypeAdapter\u003cT\u003e typeAdapter \u003d (TypeAdapter\u003cT\u003e) miniGson.getAdapter(TypeToken.get(typeOfT));\n        return typeAdapter.read(reader);\n    } catch (IOException e) {\n        throw new JsonSyntaxException(e);\n    } finally {\n        reader.setLenient(oldLenient);\n    }\n}",
      "path": "gson/src/main/java/com/google/gson/Gson.java",
      "functionStartLine": 642,
      "functionName": "fromJson",
      "functionAnnotation": "@SuppressWarnings(\"unchecked\")",
      "functionDoc": "Reads the next JSON value from {@code reader} and convert it to an object\nof type {@code typeOfT}.\nSince Type is not parameterized by T, this method is type unsafe and should be used carefully\n\n@throws JsonIOException if there was a problem writing to the Reader\n@throws JsonSyntaxException if json is not a valid representation for an object of type\n",
      "diff": "@@ -1,16 +1,13 @@\n @SuppressWarnings(\"unchecked\")\n public \u003cT\u003e T fromJson(JsonReader reader, Type typeOfT) throws JsonIOException, JsonSyntaxException {\n-    if (reader \u003d\u003d null) {\n-        return null;\n-    }\n     boolean oldLenient \u003d reader.isLenient();\n     reader.setLenient(true);\n     try {\n         TypeAdapter\u003cT\u003e typeAdapter \u003d (TypeAdapter\u003cT\u003e) miniGson.getAdapter(TypeToken.get(typeOfT));\n         return typeAdapter.read(reader);\n     } catch (IOException e) {\n         throw new JsonSyntaxException(e);\n     } finally {\n         reader.setLenient(oldLenient);\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "bafc43afae04d33bf50f112c05661bf4a402aa69": {
      "type": "Ybodychange",
      "commitMessage": "removed unneeded exception catch clause.\n",
      "commitDate": "8/18/11, 8:16 PM",
      "commitName": "bafc43afae04d33bf50f112c05661bf4a402aa69",
      "commitAuthor": "Inderjeet Singh",
      "commitDateOld": "8/18/11, 8:13 PM",
      "commitNameOld": "84c71409da812c1ccc62196ac2ff71f761bbf31b",
      "commitAuthorOld": "Inderjeet Singh",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "@SuppressWarnings(\"unchecked\")\npublic \u003cT\u003e T fromJson(JsonReader reader, Type typeOfT) throws JsonIOException, JsonSyntaxException {\n    if (reader \u003d\u003d null) {\n        return null;\n    }\n    boolean oldLenient \u003d reader.isLenient();\n    reader.setLenient(true);\n    try {\n        TypeAdapter\u003cT\u003e typeAdapter \u003d (TypeAdapter\u003cT\u003e) miniGson.getAdapter(TypeToken.get(typeOfT));\n        return typeAdapter.read(reader);\n    } catch (IOException e) {\n        throw new JsonSyntaxException(e);\n    } finally {\n        reader.setLenient(oldLenient);\n    }\n}",
      "path": "gson/src/main/java/com/google/gson/Gson.java",
      "functionStartLine": 631,
      "functionName": "fromJson",
      "functionAnnotation": "@SuppressWarnings(\"unchecked\")",
      "functionDoc": "Reads the next JSON value from {@code reader} and convert it to an object\nof type {@code typeOfT}.\nSince Type is not parameterized by T, this method is type unsafe and should be used carefully\n\n@throws JsonIOException if there was a problem writing to the Reader\n@throws JsonSyntaxException if json is not a valid representation for an object of type\n",
      "diff": "@@ -1,18 +1,16 @@\n @SuppressWarnings(\"unchecked\")\n public \u003cT\u003e T fromJson(JsonReader reader, Type typeOfT) throws JsonIOException, JsonSyntaxException {\n     if (reader \u003d\u003d null) {\n         return null;\n     }\n     boolean oldLenient \u003d reader.isLenient();\n     reader.setLenient(true);\n     try {\n         TypeAdapter\u003cT\u003e typeAdapter \u003d (TypeAdapter\u003cT\u003e) miniGson.getAdapter(TypeToken.get(typeOfT));\n         return typeAdapter.read(reader);\n-    } catch (IllegalStateException e) {\n-        throw new JsonSyntaxException(e);\n     } catch (IOException e) {\n         throw new JsonSyntaxException(e);\n     } finally {\n         reader.setLenient(oldLenient);\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "84c71409da812c1ccc62196ac2ff71f761bbf31b": {
      "type": "Ybodychange",
      "commitMessage": "Removed Gson type adapters for boolean, integer, float, double, String, BigDecimal and BigInteger.\nSwitched Gson.fromJson() methods to use miniGson directly instead of using a DOM.\n",
      "commitDate": "8/18/11, 8:13 PM",
      "commitName": "84c71409da812c1ccc62196ac2ff71f761bbf31b",
      "commitAuthor": "Inderjeet Singh",
      "commitDateOld": "8/12/11, 11:24 AM",
      "commitNameOld": "ff88ac32f22e3edf7652f1c491277f996cb56024",
      "commitAuthorOld": "Jesse Wilson",
      "daysBetweenCommits": 6.37,
      "commitsBetweenForRepo": 2,
      "commitsBetweenForFile": 1,
      "actualSource": "@SuppressWarnings(\"unchecked\")\npublic \u003cT\u003e T fromJson(JsonReader reader, Type typeOfT) throws JsonIOException, JsonSyntaxException {\n    if (reader \u003d\u003d null) {\n        return null;\n    }\n    boolean oldLenient \u003d reader.isLenient();\n    reader.setLenient(true);\n    try {\n        TypeAdapter\u003cT\u003e typeAdapter \u003d (TypeAdapter\u003cT\u003e) miniGson.getAdapter(TypeToken.get(typeOfT));\n        return typeAdapter.read(reader);\n    } catch (IllegalStateException e) {\n        throw new JsonSyntaxException(e);\n    } catch (IOException e) {\n        throw new JsonSyntaxException(e);\n    } finally {\n        reader.setLenient(oldLenient);\n    }\n}",
      "path": "gson/src/main/java/com/google/gson/Gson.java",
      "functionStartLine": 631,
      "functionName": "fromJson",
      "functionAnnotation": "@SuppressWarnings(\"unchecked\")",
      "functionDoc": "Reads the next JSON value from {@code reader} and convert it to an object\nof type {@code typeOfT}.\nSince Type is not parameterized by T, this method is type unsafe and should be used carefully\n\n@throws JsonIOException if there was a problem writing to the Reader\n@throws JsonSyntaxException if json is not a valid representation for an object of type\n",
      "diff": "@@ -1,11 +1,18 @@\n @SuppressWarnings(\"unchecked\")\n public \u003cT\u003e T fromJson(JsonReader reader, Type typeOfT) throws JsonIOException, JsonSyntaxException {\n+    if (reader \u003d\u003d null) {\n+        return null;\n+    }\n     boolean oldLenient \u003d reader.isLenient();\n     reader.setLenient(true);\n     try {\n-        JsonElement root \u003d Streams.parse(reader);\n-        return (T) fromJson(root, typeOfT);\n+        TypeAdapter\u003cT\u003e typeAdapter \u003d (TypeAdapter\u003cT\u003e) miniGson.getAdapter(TypeToken.get(typeOfT));\n+        return typeAdapter.read(reader);\n+    } catch (IllegalStateException e) {\n+        throw new JsonSyntaxException(e);\n+    } catch (IOException e) {\n+        throw new JsonSyntaxException(e);\n     } finally {\n         reader.setLenient(oldLenient);\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "10db917e9380ca4d741e06152fd1ee506666c1c3": {
      "type": "Ymultichange(Yexceptionschange,Yannotationchange,Ydocchange)",
      "commitMessage": "Updated fromJson and toJson signatures to indicate the kind of exceptions (JsonIOException, JsonSyntaxException) that can be thrown.\n",
      "commitDate": "11/3/10, 12:46 PM",
      "commitName": "10db917e9380ca4d741e06152fd1ee506666c1c3",
      "commitAuthor": "Inderjeet Singh",
      "subchanges": [
        {
          "type": "Yexceptionschange",
          "commitMessage": "Updated fromJson and toJson signatures to indicate the kind of exceptions (JsonIOException, JsonSyntaxException) that can be thrown.\n",
          "commitDate": "11/3/10, 12:46 PM",
          "commitName": "10db917e9380ca4d741e06152fd1ee506666c1c3",
          "commitAuthor": "Inderjeet Singh",
          "commitDateOld": "11/3/10, 6:28 AM",
          "commitNameOld": "83539c534c3cade5a05e633944420615b0b478ed",
          "commitAuthorOld": "Inderjeet Singh",
          "daysBetweenCommits": 0.26,
          "commitsBetweenForRepo": 2,
          "commitsBetweenForFile": 1,
          "actualSource": "@SuppressWarnings(\"unchecked\")\npublic \u003cT\u003e T fromJson(JsonReader reader, Type typeOfT) throws JsonIOException, JsonSyntaxException {\n    boolean oldLenient \u003d reader.isLenient();\n    reader.setLenient(true);\n    try {\n        JsonElement root \u003d Streams.parse(reader);\n        return (T) fromJson(root, typeOfT);\n    } finally {\n        reader.setLenient(oldLenient);\n    }\n}",
          "path": "gson/src/main/java/com/google/gson/Gson.java",
          "functionStartLine": 491,
          "functionName": "fromJson",
          "functionAnnotation": "@SuppressWarnings(\"unchecked\")",
          "functionDoc": "Reads the next JSON value from {@code reader} and convert it to an object\nof type {@code typeOfT}.\nSince Type is not parameterized by T, this method is type unsafe and should be used carefully\n\n@throws JsonIOException if there was a problem writing to the Reader\n@throws JsonSyntaxException if json is not a valid representation for an object of type\n",
          "diff": "@@ -1,11 +1,11 @@\n @SuppressWarnings(\"unchecked\")\n-public \u003cT\u003e T fromJson(JsonReader reader, Type typeOfT) throws JsonParseException {\n+public \u003cT\u003e T fromJson(JsonReader reader, Type typeOfT) throws JsonIOException, JsonSyntaxException {\n     boolean oldLenient \u003d reader.isLenient();\n     reader.setLenient(true);\n     try {\n         JsonElement root \u003d Streams.parse(reader);\n         return (T) fromJson(root, typeOfT);\n     } finally {\n         reader.setLenient(oldLenient);\n     }\n }\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldValue": "[JsonParseException]",
            "newValue": "[JsonIOException, JsonSyntaxException]"
          }
        },
        {
          "type": "Yannotationchange",
          "commitMessage": "Updated fromJson and toJson signatures to indicate the kind of exceptions (JsonIOException, JsonSyntaxException) that can be thrown.\n",
          "commitDate": "11/3/10, 12:46 PM",
          "commitName": "10db917e9380ca4d741e06152fd1ee506666c1c3",
          "commitAuthor": "Inderjeet Singh",
          "commitDateOld": "11/3/10, 6:28 AM",
          "commitNameOld": "83539c534c3cade5a05e633944420615b0b478ed",
          "commitAuthorOld": "Inderjeet Singh",
          "daysBetweenCommits": 0.26,
          "commitsBetweenForRepo": 2,
          "commitsBetweenForFile": 1,
          "actualSource": "@SuppressWarnings(\"unchecked\")\npublic \u003cT\u003e T fromJson(JsonReader reader, Type typeOfT) throws JsonIOException, JsonSyntaxException {\n    boolean oldLenient \u003d reader.isLenient();\n    reader.setLenient(true);\n    try {\n        JsonElement root \u003d Streams.parse(reader);\n        return (T) fromJson(root, typeOfT);\n    } finally {\n        reader.setLenient(oldLenient);\n    }\n}",
          "path": "gson/src/main/java/com/google/gson/Gson.java",
          "functionStartLine": 491,
          "functionName": "fromJson",
          "functionAnnotation": "@SuppressWarnings(\"unchecked\")",
          "functionDoc": "Reads the next JSON value from {@code reader} and convert it to an object\nof type {@code typeOfT}.\nSince Type is not parameterized by T, this method is type unsafe and should be used carefully\n\n@throws JsonIOException if there was a problem writing to the Reader\n@throws JsonSyntaxException if json is not a valid representation for an object of type\n",
          "diff": "@@ -1,11 +1,11 @@\n @SuppressWarnings(\"unchecked\")\n-public \u003cT\u003e T fromJson(JsonReader reader, Type typeOfT) throws JsonParseException {\n+public \u003cT\u003e T fromJson(JsonReader reader, Type typeOfT) throws JsonIOException, JsonSyntaxException {\n     boolean oldLenient \u003d reader.isLenient();\n     reader.setLenient(true);\n     try {\n         JsonElement root \u003d Streams.parse(reader);\n         return (T) fromJson(root, typeOfT);\n     } finally {\n         reader.setLenient(oldLenient);\n     }\n }\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldValue": "// this method is unsafe and should be used very carefully\n@SuppressWarnings(\"unchecked\")",
            "newValue": "@SuppressWarnings(\"unchecked\")"
          }
        },
        {
          "type": "Ydocchange",
          "commitMessage": "Updated fromJson and toJson signatures to indicate the kind of exceptions (JsonIOException, JsonSyntaxException) that can be thrown.\n",
          "commitDate": "11/3/10, 12:46 PM",
          "commitName": "10db917e9380ca4d741e06152fd1ee506666c1c3",
          "commitAuthor": "Inderjeet Singh",
          "commitDateOld": "11/3/10, 6:28 AM",
          "commitNameOld": "83539c534c3cade5a05e633944420615b0b478ed",
          "commitAuthorOld": "Inderjeet Singh",
          "daysBetweenCommits": 0.26,
          "commitsBetweenForRepo": 2,
          "commitsBetweenForFile": 1,
          "actualSource": "@SuppressWarnings(\"unchecked\")\npublic \u003cT\u003e T fromJson(JsonReader reader, Type typeOfT) throws JsonIOException, JsonSyntaxException {\n    boolean oldLenient \u003d reader.isLenient();\n    reader.setLenient(true);\n    try {\n        JsonElement root \u003d Streams.parse(reader);\n        return (T) fromJson(root, typeOfT);\n    } finally {\n        reader.setLenient(oldLenient);\n    }\n}",
          "path": "gson/src/main/java/com/google/gson/Gson.java",
          "functionStartLine": 491,
          "functionName": "fromJson",
          "functionAnnotation": "@SuppressWarnings(\"unchecked\")",
          "functionDoc": "Reads the next JSON value from {@code reader} and convert it to an object\nof type {@code typeOfT}.\nSince Type is not parameterized by T, this method is type unsafe and should be used carefully\n\n@throws JsonIOException if there was a problem writing to the Reader\n@throws JsonSyntaxException if json is not a valid representation for an object of type\n",
          "diff": "@@ -1,11 +1,11 @@\n @SuppressWarnings(\"unchecked\")\n-public \u003cT\u003e T fromJson(JsonReader reader, Type typeOfT) throws JsonParseException {\n+public \u003cT\u003e T fromJson(JsonReader reader, Type typeOfT) throws JsonIOException, JsonSyntaxException {\n     boolean oldLenient \u003d reader.isLenient();\n     reader.setLenient(true);\n     try {\n         JsonElement root \u003d Streams.parse(reader);\n         return (T) fromJson(root, typeOfT);\n     } finally {\n         reader.setLenient(oldLenient);\n     }\n }\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldValue": "Reads the next JSON value from {@code reader} and convert it to an object\nof type {@code typeOfT}.\n",
            "newValue": "Reads the next JSON value from {@code reader} and convert it to an object\nof type {@code typeOfT}.\nSince Type is not parameterized by T, this method is type unsafe and should be used carefully\n\n@throws JsonIOException if there was a problem writing to the Reader\n@throws JsonSyntaxException if json is not a valid representation for an object of type\n"
          }
        }
      ]
    },
    "747e3c3051153779954e49b7dbc475daa678e1f4": {
      "type": "Ymultichange(Yparameterchange,Ybodychange,Yannotationchange,Ydocchange)",
      "commitMessage": "Support mixed streaming and databinding with new APIs.\n",
      "commitDate": "9/1/10, 5:15 PM",
      "commitName": "747e3c3051153779954e49b7dbc475daa678e1f4",
      "commitAuthor": "Jesse Wilson",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "Support mixed streaming and databinding with new APIs.\n",
          "commitDate": "9/1/10, 5:15 PM",
          "commitName": "747e3c3051153779954e49b7dbc475daa678e1f4",
          "commitAuthor": "Jesse Wilson",
          "commitDateOld": "9/1/10, 5:10 PM",
          "commitNameOld": "fa40b4c63a57e92e87b3fb6079b01fd5304a01c1",
          "commitAuthorOld": "Jesse Wilson",
          "daysBetweenCommits": 0.0,
          "commitsBetweenForRepo": 2,
          "commitsBetweenForFile": 1,
          "actualSource": "@SuppressWarnings(\"unchecked\")\npublic \u003cT\u003e T fromJson(JsonReader reader, Type typeOfT) throws JsonParseException {\n    boolean oldLenient \u003d reader.isLenient();\n    reader.setLenient(true);\n    try {\n        JsonElement root \u003d Streams.parse(reader);\n        return (T) fromJson(root, typeOfT);\n    } finally {\n        reader.setLenient(oldLenient);\n    }\n}",
          "path": "gson/src/main/java/com/google/gson/Gson.java",
          "functionStartLine": 477,
          "functionName": "fromJson",
          "functionAnnotation": "// this method is unsafe and should be used very carefully\n@SuppressWarnings(\"unchecked\")",
          "functionDoc": "Reads the next JSON value from {@code reader} and convert it to an object\nof type {@code typeOfT}.\n",
          "diff": "@@ -1,7 +1,11 @@\n @SuppressWarnings(\"unchecked\")\n-public \u003cT\u003e T fromJson(Reader json, Type typeOfT) throws JsonParseException {\n-    JsonReader jsonReader \u003d new JsonReader(json);\n-    jsonReader.setLenient(true);\n-    JsonElement root \u003d Streams.parse(jsonReader);\n-    return (T) fromJson(root, typeOfT);\n+public \u003cT\u003e T fromJson(JsonReader reader, Type typeOfT) throws JsonParseException {\n+    boolean oldLenient \u003d reader.isLenient();\n+    reader.setLenient(true);\n+    try {\n+        JsonElement root \u003d Streams.parse(reader);\n+        return (T) fromJson(root, typeOfT);\n+    } finally {\n+        reader.setLenient(oldLenient);\n+    }\n }\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldValue": "[json-Reader, typeOfT-Type]",
            "newValue": "[reader-JsonReader, typeOfT-Type]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "Support mixed streaming and databinding with new APIs.\n",
          "commitDate": "9/1/10, 5:15 PM",
          "commitName": "747e3c3051153779954e49b7dbc475daa678e1f4",
          "commitAuthor": "Jesse Wilson",
          "commitDateOld": "9/1/10, 5:10 PM",
          "commitNameOld": "fa40b4c63a57e92e87b3fb6079b01fd5304a01c1",
          "commitAuthorOld": "Jesse Wilson",
          "daysBetweenCommits": 0.0,
          "commitsBetweenForRepo": 2,
          "commitsBetweenForFile": 1,
          "actualSource": "@SuppressWarnings(\"unchecked\")\npublic \u003cT\u003e T fromJson(JsonReader reader, Type typeOfT) throws JsonParseException {\n    boolean oldLenient \u003d reader.isLenient();\n    reader.setLenient(true);\n    try {\n        JsonElement root \u003d Streams.parse(reader);\n        return (T) fromJson(root, typeOfT);\n    } finally {\n        reader.setLenient(oldLenient);\n    }\n}",
          "path": "gson/src/main/java/com/google/gson/Gson.java",
          "functionStartLine": 477,
          "functionName": "fromJson",
          "functionAnnotation": "// this method is unsafe and should be used very carefully\n@SuppressWarnings(\"unchecked\")",
          "functionDoc": "Reads the next JSON value from {@code reader} and convert it to an object\nof type {@code typeOfT}.\n",
          "diff": "@@ -1,7 +1,11 @@\n @SuppressWarnings(\"unchecked\")\n-public \u003cT\u003e T fromJson(Reader json, Type typeOfT) throws JsonParseException {\n-    JsonReader jsonReader \u003d new JsonReader(json);\n-    jsonReader.setLenient(true);\n-    JsonElement root \u003d Streams.parse(jsonReader);\n-    return (T) fromJson(root, typeOfT);\n+public \u003cT\u003e T fromJson(JsonReader reader, Type typeOfT) throws JsonParseException {\n+    boolean oldLenient \u003d reader.isLenient();\n+    reader.setLenient(true);\n+    try {\n+        JsonElement root \u003d Streams.parse(reader);\n+        return (T) fromJson(root, typeOfT);\n+    } finally {\n+        reader.setLenient(oldLenient);\n+    }\n }\n\\ No newline at end of file\n",
          "extendedDetails": {}
        },
        {
          "type": "Yannotationchange",
          "commitMessage": "Support mixed streaming and databinding with new APIs.\n",
          "commitDate": "9/1/10, 5:15 PM",
          "commitName": "747e3c3051153779954e49b7dbc475daa678e1f4",
          "commitAuthor": "Jesse Wilson",
          "commitDateOld": "9/1/10, 5:10 PM",
          "commitNameOld": "fa40b4c63a57e92e87b3fb6079b01fd5304a01c1",
          "commitAuthorOld": "Jesse Wilson",
          "daysBetweenCommits": 0.0,
          "commitsBetweenForRepo": 2,
          "commitsBetweenForFile": 1,
          "actualSource": "@SuppressWarnings(\"unchecked\")\npublic \u003cT\u003e T fromJson(JsonReader reader, Type typeOfT) throws JsonParseException {\n    boolean oldLenient \u003d reader.isLenient();\n    reader.setLenient(true);\n    try {\n        JsonElement root \u003d Streams.parse(reader);\n        return (T) fromJson(root, typeOfT);\n    } finally {\n        reader.setLenient(oldLenient);\n    }\n}",
          "path": "gson/src/main/java/com/google/gson/Gson.java",
          "functionStartLine": 477,
          "functionName": "fromJson",
          "functionAnnotation": "// this method is unsafe and should be used very carefully\n@SuppressWarnings(\"unchecked\")",
          "functionDoc": "Reads the next JSON value from {@code reader} and convert it to an object\nof type {@code typeOfT}.\n",
          "diff": "@@ -1,7 +1,11 @@\n @SuppressWarnings(\"unchecked\")\n-public \u003cT\u003e T fromJson(Reader json, Type typeOfT) throws JsonParseException {\n-    JsonReader jsonReader \u003d new JsonReader(json);\n-    jsonReader.setLenient(true);\n-    JsonElement root \u003d Streams.parse(jsonReader);\n-    return (T) fromJson(root, typeOfT);\n+public \u003cT\u003e T fromJson(JsonReader reader, Type typeOfT) throws JsonParseException {\n+    boolean oldLenient \u003d reader.isLenient();\n+    reader.setLenient(true);\n+    try {\n+        JsonElement root \u003d Streams.parse(reader);\n+        return (T) fromJson(root, typeOfT);\n+    } finally {\n+        reader.setLenient(oldLenient);\n+    }\n }\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldValue": "@SuppressWarnings(\"unchecked\")",
            "newValue": "// this method is unsafe and should be used very carefully\n@SuppressWarnings(\"unchecked\")"
          }
        },
        {
          "type": "Ydocchange",
          "commitMessage": "Support mixed streaming and databinding with new APIs.\n",
          "commitDate": "9/1/10, 5:15 PM",
          "commitName": "747e3c3051153779954e49b7dbc475daa678e1f4",
          "commitAuthor": "Jesse Wilson",
          "commitDateOld": "9/1/10, 5:10 PM",
          "commitNameOld": "fa40b4c63a57e92e87b3fb6079b01fd5304a01c1",
          "commitAuthorOld": "Jesse Wilson",
          "daysBetweenCommits": 0.0,
          "commitsBetweenForRepo": 2,
          "commitsBetweenForFile": 1,
          "actualSource": "@SuppressWarnings(\"unchecked\")\npublic \u003cT\u003e T fromJson(JsonReader reader, Type typeOfT) throws JsonParseException {\n    boolean oldLenient \u003d reader.isLenient();\n    reader.setLenient(true);\n    try {\n        JsonElement root \u003d Streams.parse(reader);\n        return (T) fromJson(root, typeOfT);\n    } finally {\n        reader.setLenient(oldLenient);\n    }\n}",
          "path": "gson/src/main/java/com/google/gson/Gson.java",
          "functionStartLine": 477,
          "functionName": "fromJson",
          "functionAnnotation": "// this method is unsafe and should be used very carefully\n@SuppressWarnings(\"unchecked\")",
          "functionDoc": "Reads the next JSON value from {@code reader} and convert it to an object\nof type {@code typeOfT}.\n",
          "diff": "@@ -1,7 +1,11 @@\n @SuppressWarnings(\"unchecked\")\n-public \u003cT\u003e T fromJson(Reader json, Type typeOfT) throws JsonParseException {\n-    JsonReader jsonReader \u003d new JsonReader(json);\n-    jsonReader.setLenient(true);\n-    JsonElement root \u003d Streams.parse(jsonReader);\n-    return (T) fromJson(root, typeOfT);\n+public \u003cT\u003e T fromJson(JsonReader reader, Type typeOfT) throws JsonParseException {\n+    boolean oldLenient \u003d reader.isLenient();\n+    reader.setLenient(true);\n+    try {\n+        JsonElement root \u003d Streams.parse(reader);\n+        return (T) fromJson(root, typeOfT);\n+    } finally {\n+        reader.setLenient(oldLenient);\n+    }\n }\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldValue": "This method deserializes the Json read from the specified reader into an object of the\nspecified type. This method is useful if the specified object is a generic type. For\nnon-generic objects, use {@link #fromJson(Reader, Class)} instead. If you have the Json in a\nString form instead of a {@link Reader}, use {@link #fromJson(String, Type)} instead.\n\n@param \u003cT\u003e the type of the desired object\n@param json the reader producing Json from which the object is to be deserialized\n@param typeOfT The specific genericized type of src. You can obtain this type by using the\n{@link com.google.gson.reflect.TypeToken} class. For example, to get the type for\n{@code Collection\u003cFoo\u003e}, you should use:\n\u003cpre\u003e\nType typeOfT \u003d new TypeToken\u0026lt;Collection\u0026lt;Foo\u0026gt;\u0026gt;(){}.getType();\n\u003c/pre\u003e\n@return an object of type T from the json\n@throws JsonParseException if json is not a valid representation for an object of type typeOfT\n@since 1.2\n",
            "newValue": "Reads the next JSON value from {@code reader} and convert it to an object\nof type {@code typeOfT}.\n"
          }
        }
      ]
    },
    "fa40b4c63a57e92e87b3fb6079b01fd5304a01c1": {
      "type": "Ybodychange",
      "commitMessage": "Rename GsonReader to Streams; check that class in.\n",
      "commitDate": "9/1/10, 5:10 PM",
      "commitName": "fa40b4c63a57e92e87b3fb6079b01fd5304a01c1",
      "commitAuthor": "Jesse Wilson",
      "commitDateOld": "8/26/10, 10:59 PM",
      "commitNameOld": "7a7bbf754cfabbcb56d090b982bf4b128e15938d",
      "commitAuthorOld": "Jesse Wilson",
      "daysBetweenCommits": 5.76,
      "commitsBetweenForRepo": 8,
      "commitsBetweenForFile": 1,
      "actualSource": "@SuppressWarnings(\"unchecked\")\npublic \u003cT\u003e T fromJson(Reader json, Type typeOfT) throws JsonParseException {\n    JsonReader jsonReader \u003d new JsonReader(json);\n    jsonReader.setLenient(true);\n    JsonElement root \u003d Streams.parse(jsonReader);\n    return (T) fromJson(root, typeOfT);\n}",
      "path": "gson/src/main/java/com/google/gson/Gson.java",
      "functionStartLine": 443,
      "functionName": "fromJson",
      "functionAnnotation": "@SuppressWarnings(\"unchecked\")",
      "functionDoc": "This method deserializes the Json read from the specified reader into an object of the\nspecified type. This method is useful if the specified object is a generic type. For\nnon-generic objects, use {@link #fromJson(Reader, Class)} instead. If you have the Json in a\nString form instead of a {@link Reader}, use {@link #fromJson(String, Type)} instead.\n\n@param \u003cT\u003e the type of the desired object\n@param json the reader producing Json from which the object is to be deserialized\n@param typeOfT The specific genericized type of src. You can obtain this type by using the\n{@link com.google.gson.reflect.TypeToken} class. For example, to get the type for\n{@code Collection\u003cFoo\u003e}, you should use:\n\u003cpre\u003e\nType typeOfT \u003d new TypeToken\u0026lt;Collection\u0026lt;Foo\u0026gt;\u0026gt;(){}.getType();\n\u003c/pre\u003e\n@return an object of type T from the json\n@throws JsonParseException if json is not a valid representation for an object of type typeOfT\n@since 1.2\n",
      "diff": "@@ -1,7 +1,7 @@\n @SuppressWarnings(\"unchecked\")\n public \u003cT\u003e T fromJson(Reader json, Type typeOfT) throws JsonParseException {\n     JsonReader jsonReader \u003d new JsonReader(json);\n     jsonReader.setLenient(true);\n-    JsonElement root \u003d GsonReader.parse(jsonReader);\n+    JsonElement root \u003d Streams.parse(jsonReader);\n     return (T) fromJson(root, typeOfT);\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "7a7bbf754cfabbcb56d090b982bf4b128e15938d": {
      "type": "Ybodychange",
      "commitMessage": "Use JsonReader internally rather than JsonParserJavacc.\n\nFor raw parsing (ie. new JsonParser().parse()) the parse time has improved substantially. For example, JsonParserJavacc parsed my 48KiB buzz feed in 4.8ms. JsonReader parses the same feed in 0.9ms.\n\nhttp://microbenchmarks.appspot.com/run/limpbizkit@gmail.com/com.google.gson.GsonBenchmark/430001\n",
      "commitDate": "8/26/10, 10:59 PM",
      "commitName": "7a7bbf754cfabbcb56d090b982bf4b128e15938d",
      "commitAuthor": "Jesse Wilson",
      "commitDateOld": "1/9/10, 2:43 PM",
      "commitNameOld": "e3af076ff271968a1a639c5bbdc1ba967b11ea94",
      "commitAuthorOld": "Joel Leitch",
      "daysBetweenCommits": 229.3,
      "commitsBetweenForRepo": 53,
      "commitsBetweenForFile": 1,
      "actualSource": "@SuppressWarnings(\"unchecked\")\npublic \u003cT\u003e T fromJson(Reader json, Type typeOfT) throws JsonParseException {\n    JsonReader jsonReader \u003d new JsonReader(json);\n    jsonReader.setLenient(true);\n    JsonElement root \u003d GsonReader.parse(jsonReader);\n    return (T) fromJson(root, typeOfT);\n}",
      "path": "gson/src/main/java/com/google/gson/Gson.java",
      "functionStartLine": 443,
      "functionName": "fromJson",
      "functionAnnotation": "@SuppressWarnings(\"unchecked\")",
      "functionDoc": "This method deserializes the Json read from the specified reader into an object of the\nspecified type. This method is useful if the specified object is a generic type. For\nnon-generic objects, use {@link #fromJson(Reader, Class)} instead. If you have the Json in a\nString form instead of a {@link Reader}, use {@link #fromJson(String, Type)} instead.\n\n@param \u003cT\u003e the type of the desired object\n@param json the reader producing Json from which the object is to be deserialized\n@param typeOfT The specific genericized type of src. You can obtain this type by using the\n{@link com.google.gson.reflect.TypeToken} class. For example, to get the type for\n{@code Collection\u003cFoo\u003e}, you should use:\n\u003cpre\u003e\nType typeOfT \u003d new TypeToken\u0026lt;Collection\u0026lt;Foo\u0026gt;\u0026gt;(){}.getType();\n\u003c/pre\u003e\n@return an object of type T from the json\n@throws JsonParseException if json is not a valid representation for an object of type typeOfT\n@since 1.2\n",
      "diff": "@@ -1,6 +1,7 @@\n @SuppressWarnings(\"unchecked\")\n public \u003cT\u003e T fromJson(Reader json, Type typeOfT) throws JsonParseException {\n-    JsonElement root \u003d new JsonParser().parse(json);\n-    T target \u003d (T) fromJson(root, typeOfT);\n-    return target;\n+    JsonReader jsonReader \u003d new JsonReader(json);\n+    jsonReader.setLenient(true);\n+    JsonElement root \u003d GsonReader.parse(jsonReader);\n+    return (T) fromJson(root, typeOfT);\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "29ab864b2fda09ddee46554751f22f875c0ab736": {
      "type": "Ymultichange(Ybodychange,Yannotationchange)",
      "commitMessage": "Fixed bug 158\n",
      "commitDate": "9/23/09, 10:17 AM",
      "commitName": "29ab864b2fda09ddee46554751f22f875c0ab736",
      "commitAuthor": "Inderjeet Singh",
      "subchanges": [
        {
          "type": "Ybodychange",
          "commitMessage": "Fixed bug 158\n",
          "commitDate": "9/23/09, 10:17 AM",
          "commitName": "29ab864b2fda09ddee46554751f22f875c0ab736",
          "commitAuthor": "Inderjeet Singh",
          "commitDateOld": "9/22/09, 12:10 PM",
          "commitNameOld": "c5812bb485ff2ca86d67090b01b157f52c90e1fe",
          "commitAuthorOld": "Joel Leitch",
          "daysBetweenCommits": 0.92,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "actualSource": "@SuppressWarnings(\"unchecked\")\npublic \u003cT\u003e T fromJson(Reader json, Type typeOfT) throws JsonParseException {\n    JsonElement root \u003d new JsonParser().parse(json);\n    T target \u003d (T) fromJson(root, typeOfT);\n    return target;\n}",
          "path": "gson/src/main/java/com/google/gson/Gson.java",
          "functionStartLine": 445,
          "functionName": "fromJson",
          "functionAnnotation": "@SuppressWarnings(\"unchecked\")",
          "functionDoc": "This method deserializes the Json read from the specified reader into an object of the\nspecified type. This method is useful if the specified object is a generic type. For\nnon-generic objects, use {@link #fromJson(Reader, Class)} instead. If you have the Json in a\nString form instead of a {@link Reader}, use {@link #fromJson(String, Type)} instead.\n\n@param \u003cT\u003e the type of the desired object\n@param json the reader producing Json from which the object is to be deserialized\n@param typeOfT The specific genericized type of src. You can obtain this type by using the\n{@link com.google.gson.reflect.TypeToken} class. For example, to get the type for\n{@code Collection\u003cFoo\u003e}, you should use:\n\u003cpre\u003e\nType typeOfT \u003d new TypeToken\u0026lt;Collection\u0026lt;Foo\u0026gt;\u0026gt;(){}.getType();\n\u003c/pre\u003e\n@return an object of type T from the json\n@throws JsonParseException if json is not a valid representation for an object of type typeOfT\n@since 1.2\n",
          "diff": "@@ -1,5 +1,6 @@\n+@SuppressWarnings(\"unchecked\")\n public \u003cT\u003e T fromJson(Reader json, Type typeOfT) throws JsonParseException {\n     JsonElement root \u003d new JsonParser().parse(json);\n-    T target \u003d fromJson(root, typeOfT);\n+    T target \u003d (T) fromJson(root, typeOfT);\n     return target;\n }\n\\ No newline at end of file\n",
          "extendedDetails": {}
        },
        {
          "type": "Yannotationchange",
          "commitMessage": "Fixed bug 158\n",
          "commitDate": "9/23/09, 10:17 AM",
          "commitName": "29ab864b2fda09ddee46554751f22f875c0ab736",
          "commitAuthor": "Inderjeet Singh",
          "commitDateOld": "9/22/09, 12:10 PM",
          "commitNameOld": "c5812bb485ff2ca86d67090b01b157f52c90e1fe",
          "commitAuthorOld": "Joel Leitch",
          "daysBetweenCommits": 0.92,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "actualSource": "@SuppressWarnings(\"unchecked\")\npublic \u003cT\u003e T fromJson(Reader json, Type typeOfT) throws JsonParseException {\n    JsonElement root \u003d new JsonParser().parse(json);\n    T target \u003d (T) fromJson(root, typeOfT);\n    return target;\n}",
          "path": "gson/src/main/java/com/google/gson/Gson.java",
          "functionStartLine": 445,
          "functionName": "fromJson",
          "functionAnnotation": "@SuppressWarnings(\"unchecked\")",
          "functionDoc": "This method deserializes the Json read from the specified reader into an object of the\nspecified type. This method is useful if the specified object is a generic type. For\nnon-generic objects, use {@link #fromJson(Reader, Class)} instead. If you have the Json in a\nString form instead of a {@link Reader}, use {@link #fromJson(String, Type)} instead.\n\n@param \u003cT\u003e the type of the desired object\n@param json the reader producing Json from which the object is to be deserialized\n@param typeOfT The specific genericized type of src. You can obtain this type by using the\n{@link com.google.gson.reflect.TypeToken} class. For example, to get the type for\n{@code Collection\u003cFoo\u003e}, you should use:\n\u003cpre\u003e\nType typeOfT \u003d new TypeToken\u0026lt;Collection\u0026lt;Foo\u0026gt;\u0026gt;(){}.getType();\n\u003c/pre\u003e\n@return an object of type T from the json\n@throws JsonParseException if json is not a valid representation for an object of type typeOfT\n@since 1.2\n",
          "diff": "@@ -1,5 +1,6 @@\n+@SuppressWarnings(\"unchecked\")\n public \u003cT\u003e T fromJson(Reader json, Type typeOfT) throws JsonParseException {\n     JsonElement root \u003d new JsonParser().parse(json);\n-    T target \u003d fromJson(root, typeOfT);\n+    T target \u003d (T) fromJson(root, typeOfT);\n     return target;\n }\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldValue": "",
            "newValue": "@SuppressWarnings(\"unchecked\")"
          }
        }
      ]
    },
    "abf4ab2d78b2a7f3108fd7560145f45886f6b301": {
      "type": "Ymultichange(Ybodychange,Yannotationchange)",
      "commitMessage": "Fix project so it still compiles with JDK 1.5.\n",
      "commitDate": "5/19/09, 10:51 AM",
      "commitName": "abf4ab2d78b2a7f3108fd7560145f45886f6b301",
      "commitAuthor": "Joel Leitch",
      "subchanges": [
        {
          "type": "Ybodychange",
          "commitMessage": "Fix project so it still compiles with JDK 1.5.\n",
          "commitDate": "5/19/09, 10:51 AM",
          "commitName": "abf4ab2d78b2a7f3108fd7560145f45886f6b301",
          "commitAuthor": "Joel Leitch",
          "commitDateOld": "5/14/09, 1:18 PM",
          "commitNameOld": "6e59e502c2461c11d0e6099f10f65c666acabc45",
          "commitAuthorOld": "Inderjeet Singh",
          "daysBetweenCommits": 4.9,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "actualSource": "public \u003cT\u003e T fromJson(Reader json, Type typeOfT) throws JsonParseException {\n    JsonElement root \u003d new JsonParser().parse(json);\n    T target \u003d fromJson(root, typeOfT);\n    return target;\n}",
          "path": "gson/src/main/java/com/google/gson/Gson.java",
          "functionStartLine": 411,
          "functionName": "fromJson",
          "functionAnnotation": "",
          "functionDoc": "This method deserializes the Json read from the specified reader into an object of the\nspecified type. This method is useful if the specified object is a generic type. For\nnon-generic objects, use {@link #fromJson(Reader, Class)} instead. If you have the Json in a\nString form instead of a {@link Reader}, use {@link #fromJson(String, Type)} instead.\n\n@param \u003cT\u003e the type of the desired object\n@param json the reader producing Json from which the object is to be deserialized\n@param typeOfT The specific genericized type of src. You can obtain this type by using the\n{@link com.google.gson.reflect.TypeToken} class. For example, to get the type for\n{@code Collection\u003cFoo\u003e}, you should use:\n\u003cpre\u003e\nType typeOfT \u003d new TypeToken\u0026lt;Collection\u0026lt;Foo\u0026gt;\u0026gt;(){}.getType();\n\u003c/pre\u003e\n@return an object of type T from the json\n@throws JsonParseException if json is not a valid representation for an object of type typeOfT\n@since 1.2\n",
          "diff": "@@ -1,5 +1,5 @@\n-@SuppressWarnings(\"unchecked\")\n public \u003cT\u003e T fromJson(Reader json, Type typeOfT) throws JsonParseException {\n     JsonElement root \u003d new JsonParser().parse(json);\n-    return fromJson(root, typeOfT);\n+    T target \u003d fromJson(root, typeOfT);\n+    return target;\n }\n\\ No newline at end of file\n",
          "extendedDetails": {}
        },
        {
          "type": "Yannotationchange",
          "commitMessage": "Fix project so it still compiles with JDK 1.5.\n",
          "commitDate": "5/19/09, 10:51 AM",
          "commitName": "abf4ab2d78b2a7f3108fd7560145f45886f6b301",
          "commitAuthor": "Joel Leitch",
          "commitDateOld": "5/14/09, 1:18 PM",
          "commitNameOld": "6e59e502c2461c11d0e6099f10f65c666acabc45",
          "commitAuthorOld": "Inderjeet Singh",
          "daysBetweenCommits": 4.9,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "actualSource": "public \u003cT\u003e T fromJson(Reader json, Type typeOfT) throws JsonParseException {\n    JsonElement root \u003d new JsonParser().parse(json);\n    T target \u003d fromJson(root, typeOfT);\n    return target;\n}",
          "path": "gson/src/main/java/com/google/gson/Gson.java",
          "functionStartLine": 411,
          "functionName": "fromJson",
          "functionAnnotation": "",
          "functionDoc": "This method deserializes the Json read from the specified reader into an object of the\nspecified type. This method is useful if the specified object is a generic type. For\nnon-generic objects, use {@link #fromJson(Reader, Class)} instead. If you have the Json in a\nString form instead of a {@link Reader}, use {@link #fromJson(String, Type)} instead.\n\n@param \u003cT\u003e the type of the desired object\n@param json the reader producing Json from which the object is to be deserialized\n@param typeOfT The specific genericized type of src. You can obtain this type by using the\n{@link com.google.gson.reflect.TypeToken} class. For example, to get the type for\n{@code Collection\u003cFoo\u003e}, you should use:\n\u003cpre\u003e\nType typeOfT \u003d new TypeToken\u0026lt;Collection\u0026lt;Foo\u0026gt;\u0026gt;(){}.getType();\n\u003c/pre\u003e\n@return an object of type T from the json\n@throws JsonParseException if json is not a valid representation for an object of type typeOfT\n@since 1.2\n",
          "diff": "@@ -1,5 +1,5 @@\n-@SuppressWarnings(\"unchecked\")\n public \u003cT\u003e T fromJson(Reader json, Type typeOfT) throws JsonParseException {\n     JsonElement root \u003d new JsonParser().parse(json);\n-    return fromJson(root, typeOfT);\n+    T target \u003d fromJson(root, typeOfT);\n+    return target;\n }\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldValue": "@SuppressWarnings(\"unchecked\")",
            "newValue": ""
          }
        }
      ]
    },
    "6e59e502c2461c11d0e6099f10f65c666acabc45": {
      "type": "Ybodychange",
      "commitMessage": "Refactored the Async parser interface out of JsonParser into a new class JsonParserAsync. Updated the JsonParser to detect Eof and return a null instead of throwing a ParseException.\n",
      "commitDate": "5/14/09, 1:18 PM",
      "commitName": "6e59e502c2461c11d0e6099f10f65c666acabc45",
      "commitAuthor": "Inderjeet Singh",
      "commitDateOld": "4/3/09, 2:33 PM",
      "commitNameOld": "b44bbbf5e70d2589e3293be1c91c63dba6b5bbfb",
      "commitAuthorOld": "Inderjeet Singh",
      "daysBetweenCommits": 40.95,
      "commitsBetweenForRepo": 4,
      "commitsBetweenForFile": 1,
      "actualSource": "@SuppressWarnings(\"unchecked\")\npublic \u003cT\u003e T fromJson(Reader json, Type typeOfT) throws JsonParseException {\n    JsonElement root \u003d new JsonParser().parse(json);\n    return fromJson(root, typeOfT);\n}",
      "path": "gson/src/main/java/com/google/gson/Gson.java",
      "functionStartLine": 412,
      "functionName": "fromJson",
      "functionAnnotation": "@SuppressWarnings(\"unchecked\")",
      "functionDoc": "This method deserializes the Json read from the specified reader into an object of the\nspecified type. This method is useful if the specified object is a generic type. For\nnon-generic objects, use {@link #fromJson(Reader, Class)} instead. If you have the Json in a\nString form instead of a {@link Reader}, use {@link #fromJson(String, Type)} instead.\n\n@param \u003cT\u003e the type of the desired object\n@param json the reader producing Json from which the object is to be deserialized\n@param typeOfT The specific genericized type of src. You can obtain this type by using the\n{@link com.google.gson.reflect.TypeToken} class. For example, to get the type for\n{@code Collection\u003cFoo\u003e}, you should use:\n\u003cpre\u003e\nType typeOfT \u003d new TypeToken\u0026lt;Collection\u0026lt;Foo\u0026gt;\u0026gt;(){}.getType();\n\u003c/pre\u003e\n@return an object of type T from the json\n@throws JsonParseException if json is not a valid representation for an object of type typeOfT\n@since 1.2\n",
      "diff": "@@ -1,7 +1,5 @@\n @SuppressWarnings(\"unchecked\")\n public \u003cT\u003e T fromJson(Reader json, Type typeOfT) throws JsonParseException {\n     JsonElement root \u003d new JsonParser().parse(json);\n-    JsonDeserializationContext context \u003d new JsonDeserializationContextDefault(createDefaultObjectNavigatorFactory(), deserializers, objectConstructor);\n-    T target \u003d (T) context.deserialize(root, typeOfT);\n-    return target;\n+    return fromJson(root, typeOfT);\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "5c6d5a0d119481e7ca61b0884c881c6811d7af86": {
      "type": "Ybodychange",
      "commitMessage": "Remove unneeded exception handling in Gson class.\n",
      "commitDate": "4/1/09, 12:26 PM",
      "commitName": "5c6d5a0d119481e7ca61b0884c881c6811d7af86",
      "commitAuthor": "Joel Leitch",
      "commitDateOld": "4/1/09, 10:15 AM",
      "commitNameOld": "cee6c74960a5176d921eb16458cd053f39833639",
      "commitAuthorOld": "Inderjeet Singh",
      "daysBetweenCommits": 0.09,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "@SuppressWarnings(\"unchecked\")\npublic \u003cT\u003e T fromJson(Reader json, Type typeOfT) throws JsonParseException {\n    JsonElement root \u003d new JsonParser().parse(json);\n    JsonDeserializationContext context \u003d new JsonDeserializationContextDefault(createDefaultObjectNavigatorFactory(), deserializers, objectConstructor);\n    T target \u003d (T) context.deserialize(root, typeOfT);\n    return target;\n}",
      "path": "gson/src/main/java/com/google/gson/Gson.java",
      "functionStartLine": 375,
      "functionName": "fromJson",
      "functionAnnotation": "@SuppressWarnings(\"unchecked\")",
      "functionDoc": "This method deserializes the Json read from the specified reader into an object of the\nspecified type. This method is useful if the specified object is a generic type. For\nnon-generic objects, use {@link #fromJson(Reader, Class)} instead. If you have the Json in a\nString form instead of a {@link Reader}, use {@link #fromJson(String, Type)} instead.\n\n@param \u003cT\u003e the type of the desired object\n@param json the reader producing Json from which the object is to be deserialized\n@param typeOfT The specific genericized type of src. You can obtain this type by using the\n{@link com.google.gson.reflect.TypeToken} class. For example, to get the type for\n{@code Collection\u003cFoo\u003e}, you should use:\n\u003cpre\u003e\nType typeOfT \u003d new TypeToken\u0026lt;Collection\u0026lt;Foo\u0026gt;\u0026gt;(){}.getType();\n\u003c/pre\u003e\n@return an object of type T from the json\n@throws JsonParseException if json is not a valid representation for an object of type typeOfT\n@since 1.2\n",
      "diff": "@@ -1,13 +1,7 @@\n @SuppressWarnings(\"unchecked\")\n public \u003cT\u003e T fromJson(Reader json, Type typeOfT) throws JsonParseException {\n-    try {\n-        JsonElement root \u003d new JsonParser().parse(json);\n-        JsonDeserializationContext context \u003d new JsonDeserializationContextDefault(createDefaultObjectNavigatorFactory(), deserializers, objectConstructor);\n-        T target \u003d (T) context.deserialize(root, typeOfT);\n-        return target;\n-    } catch (StackOverflowError e) {\n-        throw new JsonParseException(\"Failed parsing JSON source: \" + json + \" to Json\", e);\n-    } catch (OutOfMemoryError e) {\n-        throw new JsonParseException(\"Failed parsing JSON source: \" + json + \" to Json\", e);\n-    }\n+    JsonElement root \u003d new JsonParser().parse(json);\n+    JsonDeserializationContext context \u003d new JsonDeserializationContextDefault(createDefaultObjectNavigatorFactory(), deserializers, objectConstructor);\n+    T target \u003d (T) context.deserialize(root, typeOfT);\n+    return target;\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "2034090b15cfef51d81e860b1d49340147378618": {
      "type": "Ybodychange",
      "commitMessage": "Changed version to 1.3 \nMade JsonParser.parse a non-static method.\n",
      "commitDate": "3/31/09, 10:53 AM",
      "commitName": "2034090b15cfef51d81e860b1d49340147378618",
      "commitAuthor": "Inderjeet Singh",
      "commitDateOld": "3/27/09, 12:43 PM",
      "commitNameOld": "c9cb05fc720a8b041a7fbcf1068beb85a134674a",
      "commitAuthorOld": "Joel Leitch",
      "daysBetweenCommits": 3.92,
      "commitsBetweenForRepo": 4,
      "commitsBetweenForFile": 1,
      "actualSource": "@SuppressWarnings(\"unchecked\")\npublic \u003cT\u003e T fromJson(Reader json, Type typeOfT) throws JsonParseException {\n    try {\n        JsonElement root \u003d new JsonParser().parse(json);\n        JsonDeserializationContext context \u003d new JsonDeserializationContextDefault(createDefaultObjectNavigatorFactory(), deserializers, objectConstructor);\n        T target \u003d (T) context.deserialize(root, typeOfT);\n        return target;\n    } catch (StackOverflowError e) {\n        throw new JsonParseException(\"Failed parsing JSON source: \" + json + \" to Json\", e);\n    } catch (OutOfMemoryError e) {\n        throw new JsonParseException(\"Failed parsing JSON source: \" + json + \" to Json\", e);\n    }\n}",
      "path": "gson/src/main/java/com/google/gson/Gson.java",
      "functionStartLine": 375,
      "functionName": "fromJson",
      "functionAnnotation": "@SuppressWarnings(\"unchecked\")",
      "functionDoc": "This method deserializes the Json read from the specified reader into an object of the\nspecified type. This method is useful if the specified object is a generic type. For\nnon-generic objects, use {@link #fromJson(Reader, Class)} instead. If you have the Json in a\nString form instead of a {@link Reader}, use {@link #fromJson(String, Type)} instead.\n\n@param \u003cT\u003e the type of the desired object\n@param json the reader producing Json from which the object is to be deserialized\n@param typeOfT The specific genericized type of src. You can obtain this type by using the\n{@link com.google.gson.reflect.TypeToken} class. For example, to get the type for\n{@code Collection\u003cFoo\u003e}, you should use:\n\u003cpre\u003e\nType typeOfT \u003d new TypeToken\u0026lt;Collection\u0026lt;Foo\u0026gt;\u0026gt;(){}.getType();\n\u003c/pre\u003e\n@return an object of type T from the json\n@throws JsonParseException if json is not a valid representation for an object of type typeOfT\n@since 1.2\n",
      "diff": "@@ -1,13 +1,13 @@\n @SuppressWarnings(\"unchecked\")\n public \u003cT\u003e T fromJson(Reader json, Type typeOfT) throws JsonParseException {\n     try {\n-        JsonElement root \u003d JsonParser.parse(json);\n+        JsonElement root \u003d new JsonParser().parse(json);\n         JsonDeserializationContext context \u003d new JsonDeserializationContextDefault(createDefaultObjectNavigatorFactory(), deserializers, objectConstructor);\n         T target \u003d (T) context.deserialize(root, typeOfT);\n         return target;\n     } catch (StackOverflowError e) {\n         throw new JsonParseException(\"Failed parsing JSON source: \" + json + \" to Json\", e);\n     } catch (OutOfMemoryError e) {\n         throw new JsonParseException(\"Failed parsing JSON source: \" + json + \" to Json\", e);\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "2c7cc620d4975521dc5d1c54ea1c0b2247b4fdad": {
      "type": "Ybodychange",
      "commitMessage": "Exposed API for JsonParser and added methods to Gson to deserialize from a parse tree.\n",
      "commitDate": "2/3/09, 5:56 PM",
      "commitName": "2c7cc620d4975521dc5d1c54ea1c0b2247b4fdad",
      "commitAuthor": "Inderjeet Singh",
      "commitDateOld": "1/20/09, 12:38 AM",
      "commitNameOld": "764e4d9aca8139540f3b37ec3977c07e3e705127",
      "commitAuthorOld": "Joel Leitch",
      "daysBetweenCommits": 14.72,
      "commitsBetweenForRepo": 2,
      "commitsBetweenForFile": 1,
      "actualSource": "@SuppressWarnings(\"unchecked\")\npublic \u003cT\u003e T fromJson(Reader json, Type typeOfT) throws JsonParseException {\n    try {\n        JsonElement root \u003d JsonParser.parse(json);\n        JsonDeserializationContext context \u003d new JsonDeserializationContextDefault(createDefaultObjectNavigatorFactory(), deserializers, objectConstructor);\n        T target \u003d (T) context.deserialize(root, typeOfT);\n        return target;\n    } catch (StackOverflowError e) {\n        throw new JsonParseException(\"Failed parsing JSON source: \" + json + \" to Json\", e);\n    } catch (OutOfMemoryError e) {\n        throw new JsonParseException(\"Failed parsing JSON source: \" + json + \" to Json\", e);\n    }\n}",
      "path": "gson/src/main/java/com/google/gson/Gson.java",
      "functionStartLine": 364,
      "functionName": "fromJson",
      "functionAnnotation": "@SuppressWarnings(\"unchecked\")",
      "functionDoc": "This method deserializes the Json read from the specified reader into an object of the\nspecified type. This method is useful if the specified object is a generic type. For\nnon-generic objects, use {@link #fromJson(Reader, Class)} instead. If you have the Json in a\nString form instead of a {@link Reader}, use {@link #fromJson(String, Type)} instead.\n\n@param \u003cT\u003e the type of the desired object\n@param json the reader producing Json from which the object is to be deserialized\n@param typeOfT The specific genericized type of src. You can obtain this type by using the\n{@link com.google.gson.reflect.TypeToken} class. For example, to get the type for\n{@code Collection\u003cFoo\u003e}, you should use:\n\u003cpre\u003e\nType typeOfT \u003d new TypeToken\u0026lt;Collection\u0026lt;Foo\u0026gt;\u0026gt;(){}.getType();\n\u003c/pre\u003e\n@return an object of type T from the json\n@throws JsonParseException if json is not a valid representation for an object of type typeOfT\n@since 1.2\n",
      "diff": "@@ -1,18 +1,13 @@\n @SuppressWarnings(\"unchecked\")\n public \u003cT\u003e T fromJson(Reader json, Type typeOfT) throws JsonParseException {\n     try {\n-        JsonParser parser \u003d new JsonParser(json);\n-        JsonElement root \u003d parser.parse();\n+        JsonElement root \u003d JsonParser.parse(json);\n         JsonDeserializationContext context \u003d new JsonDeserializationContextDefault(createDefaultObjectNavigatorFactory(), deserializers, objectConstructor);\n         T target \u003d (T) context.deserialize(root, typeOfT);\n         return target;\n-    } catch (TokenMgrError e) {\n-        throw new JsonParseException(\"Failed parsing JSON source: \" + json + \" to Json\", e);\n-    } catch (ParseException e) {\n-        throw new JsonParseException(\"Failed parsing JSON source: \" + json + \" to Json\", e);\n     } catch (StackOverflowError e) {\n         throw new JsonParseException(\"Failed parsing JSON source: \" + json + \" to Json\", e);\n     } catch (OutOfMemoryError e) {\n         throw new JsonParseException(\"Failed parsing JSON source: \" + json + \" to Json\", e);\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "cf2a457af7b0422e7728e0d55a4e794048af5a6b": {
      "type": "Ybodychange",
      "commitMessage": "Removed the TypeAdapter object from GSON now that the primitive objects and fields are created by a custom Type Adapter.\n",
      "commitDate": "11/14/08, 9:11 PM",
      "commitName": "cf2a457af7b0422e7728e0d55a4e794048af5a6b",
      "commitAuthor": "Joel Leitch",
      "commitDateOld": "10/30/08, 5:19 PM",
      "commitNameOld": "cc90a68241aa3ab849c0886b479da3a6449ba210",
      "commitAuthorOld": "Inderjeet Singh",
      "daysBetweenCommits": 15.2,
      "commitsBetweenForRepo": 15,
      "commitsBetweenForFile": 1,
      "actualSource": "@SuppressWarnings(\"unchecked\")\npublic \u003cT\u003e T fromJson(Reader json, Type typeOfT) throws JsonParseException {\n    try {\n        JsonParser parser \u003d new JsonParser(json);\n        JsonElement root \u003d parser.parse();\n        JsonDeserializationContext context \u003d new JsonDeserializationContextDefault(createDefaultObjectNavigatorFactory(), deserializers, objectConstructor);\n        T target \u003d (T) context.deserialize(root, typeOfT);\n        return target;\n    } catch (TokenMgrError e) {\n        throw new JsonParseException(\"Failed parsing JSON source: \" + json + \" to Json\", e);\n    } catch (ParseException e) {\n        throw new JsonParseException(\"Failed parsing JSON source: \" + json + \" to Json\", e);\n    } catch (StackOverflowError e) {\n        throw new JsonParseException(\"Failed parsing JSON source: \" + json + \" to Json\", e);\n    } catch (OutOfMemoryError e) {\n        throw new JsonParseException(\"Failed parsing JSON source: \" + json + \" to Json\", e);\n    }\n}",
      "path": "gson/src/main/java/com/google/gson/Gson.java",
      "functionStartLine": 367,
      "functionName": "fromJson",
      "functionAnnotation": "@SuppressWarnings(\"unchecked\")",
      "functionDoc": "This method deserializes the Json read from the specified reader into an object of the\nspecified type. This method is useful if the specified object is a generic type. For\nnon-generic objects, use {@link #fromJson(Reader, Class)} instead. If you have the Json in a\nString form instead of a {@link Reader}, use {@link #fromJson(String, Type)} instead.\n\n@param \u003cT\u003e the type of the desired object\n@param json the reader producing Json from which the object is to be deserialized\n@param typeOfT The specific genericized type of src. You can obtain this type by using the\n{@link com.google.gson.reflect.TypeToken} class. For example, to get the type for\n{@code Collection\u003cFoo\u003e}, you should use:\n\u003cpre\u003e\nType typeOfT \u003d new TypeToken\u0026lt;Collection\u0026lt;Foo\u0026gt;\u0026gt;(){}.getType();\n\u003c/pre\u003e\n@return an object of type T from the json\n@throws JsonParseException if json is not a valid representation for an object of type typeOfT\n@since 1.2\n",
      "diff": "@@ -1,18 +1,18 @@\n @SuppressWarnings(\"unchecked\")\n public \u003cT\u003e T fromJson(Reader json, Type typeOfT) throws JsonParseException {\n     try {\n         JsonParser parser \u003d new JsonParser(json);\n         JsonElement root \u003d parser.parse();\n-        JsonDeserializationContext context \u003d new JsonDeserializationContextDefault(createDefaultObjectNavigatorFactory(), deserializers, objectConstructor, typeAdapter);\n+        JsonDeserializationContext context \u003d new JsonDeserializationContextDefault(createDefaultObjectNavigatorFactory(), deserializers, objectConstructor);\n         T target \u003d (T) context.deserialize(root, typeOfT);\n         return target;\n     } catch (TokenMgrError e) {\n         throw new JsonParseException(\"Failed parsing JSON source: \" + json + \" to Json\", e);\n     } catch (ParseException e) {\n         throw new JsonParseException(\"Failed parsing JSON source: \" + json + \" to Json\", e);\n     } catch (StackOverflowError e) {\n         throw new JsonParseException(\"Failed parsing JSON source: \" + json + \" to Json\", e);\n     } catch (OutOfMemoryError e) {\n         throw new JsonParseException(\"Failed parsing JSON source: \" + json + \" to Json\", e);\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "9dfa454f6da6e88b51dba7840881feb874dbbdef": {
      "type": "Ybodychange",
      "commitMessage": "Fixed issue 63 where Gson could not operate in a thread-safe manner. Resolved the issue by recreating ObjectNavigatorFactory for each call instead of reusing the same object everywhere. This is needed since ObjectNavigatorFactory had MemoryRefStack that was incorrectly being shared across calls.\n",
      "commitDate": "10/20/08, 1:09 PM",
      "commitName": "9dfa454f6da6e88b51dba7840881feb874dbbdef",
      "commitAuthor": "Inderjeet Singh",
      "commitDateOld": "10/13/08, 11:40 AM",
      "commitNameOld": "2b9fd47b720f0743d69dfcc48bc04b471e37d240",
      "commitAuthorOld": "Inderjeet Singh",
      "daysBetweenCommits": 7.06,
      "commitsBetweenForRepo": 11,
      "commitsBetweenForFile": 1,
      "actualSource": "@SuppressWarnings(\"unchecked\")\npublic \u003cT\u003e T fromJson(Reader json, Type typeOfT) throws JsonParseException {\n    try {\n        JsonParser parser \u003d new JsonParser(json);\n        JsonElement root \u003d parser.parse();\n        JsonDeserializationContext context \u003d new JsonDeserializationContextDefault(createDefaultObjectNavigatorFactory(), deserializers, objectConstructor, typeAdapter);\n        T target \u003d (T) context.deserialize(root, typeOfT);\n        return target;\n    } catch (TokenMgrError e) {\n        throw new JsonParseException(\"Failed parsing JSON source: \" + json + \" to Json\", e);\n    } catch (ParseException e) {\n        throw new JsonParseException(\"Failed parsing JSON source: \" + json + \" to Json\", e);\n    } catch (StackOverflowError e) {\n        throw new JsonParseException(\"Failed parsing JSON source: \" + json + \" to Json\", e);\n    } catch (OutOfMemoryError e) {\n        throw new JsonParseException(\"Failed parsing JSON source: \" + json + \" to Json\", e);\n    }\n}",
      "path": "gson/src/main/java/com/google/gson/Gson.java",
      "functionStartLine": 375,
      "functionName": "fromJson",
      "functionAnnotation": "@SuppressWarnings(\"unchecked\")",
      "functionDoc": "This method deserializes the Json read from the specified reader into an object of the\nspecified type. This method is useful if the specified object is a generic type. For\nnon-generic objects, use {@link #fromJson(Reader, Class)} instead. If you have the Json in a\nString form instead of a {@link Reader}, use {@link #fromJson(String, Type)} instead.\n\n@param \u003cT\u003e the type of the desired object\n@param json the reader producing Json from which the object is to be deserialized\n@param typeOfT The specific genericized type of src. You can obtain this type by using the\n{@link com.google.gson.reflect.TypeToken} class. For example, to get the type for\n{@code Collection\u003cFoo\u003e}, you should use:\n\u003cpre\u003e\nType typeOfT \u003d new TypeToken\u0026lt;Collection\u0026lt;Foo\u0026gt;\u0026gt;(){}.getType();\n\u003c/pre\u003e\n@return an object of type T from the json\n@throws JsonParseException if json is not a valid representation for an object of type typeOfT\n@since 1.2\n",
      "diff": "@@ -1,18 +1,18 @@\n @SuppressWarnings(\"unchecked\")\n public \u003cT\u003e T fromJson(Reader json, Type typeOfT) throws JsonParseException {\n     try {\n         JsonParser parser \u003d new JsonParser(json);\n         JsonElement root \u003d parser.parse();\n-        JsonDeserializationContext context \u003d new JsonDeserializationContextDefault(navigatorFactory, deserializers, objectConstructor, typeAdapter);\n+        JsonDeserializationContext context \u003d new JsonDeserializationContextDefault(createDefaultObjectNavigatorFactory(), deserializers, objectConstructor, typeAdapter);\n         T target \u003d (T) context.deserialize(root, typeOfT);\n         return target;\n     } catch (TokenMgrError e) {\n         throw new JsonParseException(\"Failed parsing JSON source: \" + json + \" to Json\", e);\n     } catch (ParseException e) {\n         throw new JsonParseException(\"Failed parsing JSON source: \" + json + \" to Json\", e);\n     } catch (StackOverflowError e) {\n         throw new JsonParseException(\"Failed parsing JSON source: \" + json + \" to Json\", e);\n     } catch (OutOfMemoryError e) {\n         throw new JsonParseException(\"Failed parsing JSON source: \" + json + \" to Json\", e);\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "57d1f32de5bf3a7dd54613384cc7e979fba2660b": {
      "type": "Yintroduced",
      "commitMessage": "moved gson as a project under trunk\n",
      "commitDate": "8/31/08, 8:13 PM",
      "commitName": "57d1f32de5bf3a7dd54613384cc7e979fba2660b",
      "commitAuthor": "Inderjeet Singh",
      "diff": "@@ -0,0 +1,18 @@\n+@SuppressWarnings(\"unchecked\")\n+public \u003cT\u003e T fromJson(Reader json, Type typeOfT) throws JsonParseException {\n+    try {\n+        JsonParser parser \u003d new JsonParser(json);\n+        JsonElement root \u003d parser.parse();\n+        JsonDeserializationContext context \u003d new JsonDeserializationContextDefault(navigatorFactory, deserializers, objectConstructor, typeAdapter);\n+        T target \u003d (T) context.deserialize(root, typeOfT);\n+        return target;\n+    } catch (TokenMgrError e) {\n+        throw new JsonParseException(\"Failed parsing JSON source: \" + json + \" to Json\", e);\n+    } catch (ParseException e) {\n+        throw new JsonParseException(\"Failed parsing JSON source: \" + json + \" to Json\", e);\n+    } catch (StackOverflowError e) {\n+        throw new JsonParseException(\"Failed parsing JSON source: \" + json + \" to Json\", e);\n+    } catch (OutOfMemoryError e) {\n+        throw new JsonParseException(\"Failed parsing JSON source: \" + json + \" to Json\", e);\n+    }\n+}\n\\ No newline at end of file\n",
      "actualSource": "@SuppressWarnings(\"unchecked\")\npublic \u003cT\u003e T fromJson(Reader json, Type typeOfT) throws JsonParseException {\n    try {\n        JsonParser parser \u003d new JsonParser(json);\n        JsonElement root \u003d parser.parse();\n        JsonDeserializationContext context \u003d new JsonDeserializationContextDefault(navigatorFactory, deserializers, objectConstructor, typeAdapter);\n        T target \u003d (T) context.deserialize(root, typeOfT);\n        return target;\n    } catch (TokenMgrError e) {\n        throw new JsonParseException(\"Failed parsing JSON source: \" + json + \" to Json\", e);\n    } catch (ParseException e) {\n        throw new JsonParseException(\"Failed parsing JSON source: \" + json + \" to Json\", e);\n    } catch (StackOverflowError e) {\n        throw new JsonParseException(\"Failed parsing JSON source: \" + json + \" to Json\", e);\n    } catch (OutOfMemoryError e) {\n        throw new JsonParseException(\"Failed parsing JSON source: \" + json + \" to Json\", e);\n    }\n}",
      "path": "gson/src/main/java/com/google/gson/Gson.java",
      "functionStartLine": 372,
      "functionName": "fromJson",
      "functionAnnotation": "@SuppressWarnings(\"unchecked\")",
      "functionDoc": "This method deserializes the Json read from the specified reader into an object of the\nspecified type. This method is useful if the specified object is a generic type. For\nnon-generic objects, use {@link #fromJson(Reader, Class)} instead. If you have the Json in a\nString form instead of a {@link Reader}, use {@link #fromJson(String, Type)} instead.\n\n@param \u003cT\u003e the type of the desired object\n@param json the reader producing Json from which the object is to be deserialized\n@param typeOfT The specific genericized type of src. You can obtain this type by using the\n{@link com.google.gson.reflect.TypeToken} class. For example, to get the type for\n{@code Collection\u003cFoo\u003e}, you should use:\n\u003cpre\u003e\nType typeOfT \u003d new TypeToken\u0026lt;Collection\u0026lt;Foo\u0026gt;\u0026gt;(){}.getType();\n\u003c/pre\u003e\n@return an object of type T from the json\n@throws JsonParseException if json is not a valid representation for an object of type typeOfT\n@since 1.2\n"
    }
  }
}