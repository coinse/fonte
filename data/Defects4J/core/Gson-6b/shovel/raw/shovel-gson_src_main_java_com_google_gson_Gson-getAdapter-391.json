{
  "origin": "codeshovel",
  "repositoryName": "Gson-6b",
  "repositoryPath": "/tmp/Gson-6b//.git",
  "startCommitName": "HEAD",
  "sourceFileName": "Gson.java",
  "functionName": "getAdapter",
  "functionId": "getAdapter___type-TypeToken__T__",
  "sourceFilePath": "gson/src/main/java/com/google/gson/Gson.java",
  "functionAnnotation": "@SuppressWarnings(\"unchecked\")",
  "functionDoc": "Returns the type adapter for {@code} type.\n\n@throws IllegalArgumentException if this GSON cannot serialize and\n    deserialize {@code type}.\n",
  "functionStartLine": 391,
  "functionEndLine": 431,
  "numCommitsSeen": 192,
  "timeTaken": 3019,
  "changeHistory": [
    "6dc6b4be9208221caad81b52aec665f133b5e9af",
    "1e18dce002158992bbda1d3a19952fdf07f308f4",
    "d7fbac03844aa86dbb1c65a8ba50ac364c4b2050",
    "756131d869465ac70abb9595653ea967e6812231",
    "4c06b013697d06b327f3c537e23181887aeab774",
    "7e760143fdc8b689daeebdee33ad6ea7d0a62a56",
    "882c14a36782889b54fc284c43e386252ae2de23",
    "60e6ed912d52716f46a1ba71923ef203c4248857",
    "4b042671af018f308c2a261145dc6712e39b96e7",
    "041d499a7c4af1b70617001ded11dbc01732d97f",
    "95a345234fb1d51ada03f37d50769cd5198b5af3",
    "c5f1df10175c254b823fc019832bf1bf7b71e929"
  ],
  "changeHistoryShort": {
    "6dc6b4be9208221caad81b52aec665f133b5e9af": "Ybodychange",
    "1e18dce002158992bbda1d3a19952fdf07f308f4": "Ybodychange",
    "d7fbac03844aa86dbb1c65a8ba50ac364c4b2050": "Ybodychange",
    "756131d869465ac70abb9595653ea967e6812231": "Ymultichange(Ybodychange,Yannotationchange)",
    "4c06b013697d06b327f3c537e23181887aeab774": "Ybodychange",
    "7e760143fdc8b689daeebdee33ad6ea7d0a62a56": "Ymultichange(Ymovefromfile,Ybodychange)",
    "882c14a36782889b54fc284c43e386252ae2de23": "Ybodychange",
    "60e6ed912d52716f46a1ba71923ef203c4248857": "Yfilerename",
    "4b042671af018f308c2a261145dc6712e39b96e7": "Yformatchange",
    "041d499a7c4af1b70617001ded11dbc01732d97f": "Ybodychange",
    "95a345234fb1d51ada03f37d50769cd5198b5af3": "Ybodychange",
    "c5f1df10175c254b823fc019832bf1bf7b71e929": "Yintroduced"
  },
  "changeHistoryDetails": {
    "6dc6b4be9208221caad81b52aec665f133b5e9af": {
      "type": "Ybodychange",
      "commitMessage": "Fix object leak from ThreadLocal.\n",
      "commitDate": "1/14/13, 2:05 PM",
      "commitName": "6dc6b4be9208221caad81b52aec665f133b5e9af",
      "commitAuthor": "Joel Leitch",
      "commitDateOld": "12/20/12, 11:41 AM",
      "commitNameOld": "b0531e1649843ee68475c13a49f91585d2881d67",
      "commitAuthorOld": "Joel Leitch",
      "daysBetweenCommits": 25.1,
      "commitsBetweenForRepo": 4,
      "commitsBetweenForFile": 1,
      "actualSource": "@SuppressWarnings(\"unchecked\")\npublic \u003cT\u003e TypeAdapter\u003cT\u003e getAdapter(TypeToken\u003cT\u003e type) {\n    TypeAdapter\u003c?\u003e cached \u003d typeTokenCache.get(type);\n    if (cached !\u003d null) {\n        return (TypeAdapter\u003cT\u003e) cached;\n    }\n    Map\u003cTypeToken\u003c?\u003e, FutureTypeAdapter\u003c?\u003e\u003e threadCalls \u003d calls.get();\n    boolean requiresThreadLocalCleanup \u003d false;\n    if (threadCalls \u003d\u003d null) {\n        threadCalls \u003d new HashMap\u003cTypeToken\u003c?\u003e, FutureTypeAdapter\u003c?\u003e\u003e();\n        calls.set(threadCalls);\n        requiresThreadLocalCleanup \u003d true;\n    }\n    FutureTypeAdapter\u003cT\u003e ongoingCall \u003d (FutureTypeAdapter\u003cT\u003e) threadCalls.get(type);\n    if (ongoingCall !\u003d null) {\n        return ongoingCall;\n    }\n    try {\n        FutureTypeAdapter\u003cT\u003e call \u003d new FutureTypeAdapter\u003cT\u003e();\n        threadCalls.put(type, call);\n        for (TypeAdapterFactory factory : factories) {\n            TypeAdapter\u003cT\u003e candidate \u003d factory.create(this, type);\n            if (candidate !\u003d null) {\n                call.setDelegate(candidate);\n                typeTokenCache.put(type, candidate);\n                return candidate;\n            }\n        }\n        throw new IllegalArgumentException(\"GSON cannot handle \" + type);\n    } finally {\n        threadCalls.remove(type);\n        if (requiresThreadLocalCleanup) {\n            calls.remove();\n        }\n    }\n}",
      "path": "gson/src/main/java/com/google/gson/Gson.java",
      "functionStartLine": 331,
      "functionName": "getAdapter",
      "functionAnnotation": "@SuppressWarnings(\"unchecked\")",
      "functionDoc": "Returns the type adapter for {@code} type.\n\n@throws IllegalArgumentException if this GSON cannot serialize and\n    deserialize {@code type}.\n",
      "diff": "@@ -1,31 +1,36 @@\n @SuppressWarnings(\"unchecked\")\n public \u003cT\u003e TypeAdapter\u003cT\u003e getAdapter(TypeToken\u003cT\u003e type) {\n     TypeAdapter\u003c?\u003e cached \u003d typeTokenCache.get(type);\n     if (cached !\u003d null) {\n         return (TypeAdapter\u003cT\u003e) cached;\n     }\n     Map\u003cTypeToken\u003c?\u003e, FutureTypeAdapter\u003c?\u003e\u003e threadCalls \u003d calls.get();\n+    boolean requiresThreadLocalCleanup \u003d false;\n     if (threadCalls \u003d\u003d null) {\n         threadCalls \u003d new HashMap\u003cTypeToken\u003c?\u003e, FutureTypeAdapter\u003c?\u003e\u003e();\n         calls.set(threadCalls);\n+        requiresThreadLocalCleanup \u003d true;\n     }\n     FutureTypeAdapter\u003cT\u003e ongoingCall \u003d (FutureTypeAdapter\u003cT\u003e) threadCalls.get(type);\n     if (ongoingCall !\u003d null) {\n         return ongoingCall;\n     }\n-    FutureTypeAdapter\u003cT\u003e call \u003d new FutureTypeAdapter\u003cT\u003e();\n-    threadCalls.put(type, call);\n     try {\n+        FutureTypeAdapter\u003cT\u003e call \u003d new FutureTypeAdapter\u003cT\u003e();\n+        threadCalls.put(type, call);\n         for (TypeAdapterFactory factory : factories) {\n             TypeAdapter\u003cT\u003e candidate \u003d factory.create(this, type);\n             if (candidate !\u003d null) {\n                 call.setDelegate(candidate);\n                 typeTokenCache.put(type, candidate);\n                 return candidate;\n             }\n         }\n         throw new IllegalArgumentException(\"GSON cannot handle \" + type);\n     } finally {\n         threadCalls.remove(type);\n+        if (requiresThreadLocalCleanup) {\n+            calls.remove();\n+        }\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "1e18dce002158992bbda1d3a19952fdf07f308f4": {
      "type": "Ybodychange",
      "commitMessage": "Don\u0027t subclass ThreadLocal.\n\nThis attempts to address issue 402, wherein subclassing ThreadLocal is pinning a reference to a class, which transitively pins the entire application in containers like Tomcat.\n",
      "commitDate": "10/22/12, 7:41 PM",
      "commitName": "1e18dce002158992bbda1d3a19952fdf07f308f4",
      "commitAuthor": "Jesse Wilson",
      "commitDateOld": "10/22/12, 7:40 PM",
      "commitNameOld": "22c835f2bcd5ee39fd58556e01324f334c5f0cb7",
      "commitAuthorOld": "Jesse Wilson",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "@SuppressWarnings(\"unchecked\")\npublic \u003cT\u003e TypeAdapter\u003cT\u003e getAdapter(TypeToken\u003cT\u003e type) {\n    TypeAdapter\u003c?\u003e cached \u003d typeTokenCache.get(type);\n    if (cached !\u003d null) {\n        return (TypeAdapter\u003cT\u003e) cached;\n    }\n    Map\u003cTypeToken\u003c?\u003e, FutureTypeAdapter\u003c?\u003e\u003e threadCalls \u003d calls.get();\n    if (threadCalls \u003d\u003d null) {\n        threadCalls \u003d new HashMap\u003cTypeToken\u003c?\u003e, FutureTypeAdapter\u003c?\u003e\u003e();\n        calls.set(threadCalls);\n    }\n    FutureTypeAdapter\u003cT\u003e ongoingCall \u003d (FutureTypeAdapter\u003cT\u003e) threadCalls.get(type);\n    if (ongoingCall !\u003d null) {\n        return ongoingCall;\n    }\n    FutureTypeAdapter\u003cT\u003e call \u003d new FutureTypeAdapter\u003cT\u003e();\n    threadCalls.put(type, call);\n    try {\n        for (TypeAdapterFactory factory : factories) {\n            TypeAdapter\u003cT\u003e candidate \u003d factory.create(this, type);\n            if (candidate !\u003d null) {\n                call.setDelegate(candidate);\n                typeTokenCache.put(type, candidate);\n                return candidate;\n            }\n        }\n        throw new IllegalArgumentException(\"GSON cannot handle \" + type);\n    } finally {\n        threadCalls.remove(type);\n    }\n}",
      "path": "gson/src/main/java/com/google/gson/Gson.java",
      "functionStartLine": 335,
      "functionName": "getAdapter",
      "functionAnnotation": "@SuppressWarnings(\"unchecked\")",
      "functionDoc": "Returns the type adapter for {@code} type.\n\n@throws IllegalArgumentException if this GSON cannot serialize and\n    deserialize {@code type}.\n",
      "diff": "@@ -1,27 +1,31 @@\n @SuppressWarnings(\"unchecked\")\n public \u003cT\u003e TypeAdapter\u003cT\u003e getAdapter(TypeToken\u003cT\u003e type) {\n     TypeAdapter\u003c?\u003e cached \u003d typeTokenCache.get(type);\n     if (cached !\u003d null) {\n         return (TypeAdapter\u003cT\u003e) cached;\n     }\n     Map\u003cTypeToken\u003c?\u003e, FutureTypeAdapter\u003c?\u003e\u003e threadCalls \u003d calls.get();\n+    if (threadCalls \u003d\u003d null) {\n+        threadCalls \u003d new HashMap\u003cTypeToken\u003c?\u003e, FutureTypeAdapter\u003c?\u003e\u003e();\n+        calls.set(threadCalls);\n+    }\n     FutureTypeAdapter\u003cT\u003e ongoingCall \u003d (FutureTypeAdapter\u003cT\u003e) threadCalls.get(type);\n     if (ongoingCall !\u003d null) {\n         return ongoingCall;\n     }\n     FutureTypeAdapter\u003cT\u003e call \u003d new FutureTypeAdapter\u003cT\u003e();\n     threadCalls.put(type, call);\n     try {\n         for (TypeAdapterFactory factory : factories) {\n             TypeAdapter\u003cT\u003e candidate \u003d factory.create(this, type);\n             if (candidate !\u003d null) {\n                 call.setDelegate(candidate);\n                 typeTokenCache.put(type, candidate);\n                 return candidate;\n             }\n         }\n         throw new IllegalArgumentException(\"GSON cannot handle \" + type);\n     } finally {\n         threadCalls.remove(type);\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "d7fbac03844aa86dbb1c65a8ba50ac364c4b2050": {
      "type": "Ybodychange",
      "commitMessage": "Rename TypeAdapter.Factory to TypeAdapterFactory.\n",
      "commitDate": "12/23/11, 10:27 AM",
      "commitName": "d7fbac03844aa86dbb1c65a8ba50ac364c4b2050",
      "commitAuthor": "Jesse Wilson",
      "commitDateOld": "12/22/11, 2:31 PM",
      "commitNameOld": "bd937fe7b54392d7c9c7bac591bd813f510f5bfa",
      "commitAuthorOld": "Inderjeet Singh",
      "daysBetweenCommits": 0.83,
      "commitsBetweenForRepo": 3,
      "commitsBetweenForFile": 1,
      "actualSource": "@SuppressWarnings(\"unchecked\")\npublic \u003cT\u003e TypeAdapter\u003cT\u003e getAdapter(TypeToken\u003cT\u003e type) {\n    TypeAdapter\u003c?\u003e cached \u003d typeTokenCache.get(type);\n    if (cached !\u003d null) {\n        return (TypeAdapter\u003cT\u003e) cached;\n    }\n    Map\u003cTypeToken\u003c?\u003e, FutureTypeAdapter\u003c?\u003e\u003e threadCalls \u003d calls.get();\n    FutureTypeAdapter\u003cT\u003e ongoingCall \u003d (FutureTypeAdapter\u003cT\u003e) threadCalls.get(type);\n    if (ongoingCall !\u003d null) {\n        return ongoingCall;\n    }\n    FutureTypeAdapter\u003cT\u003e call \u003d new FutureTypeAdapter\u003cT\u003e();\n    threadCalls.put(type, call);\n    try {\n        for (TypeAdapterFactory factory : factories) {\n            TypeAdapter\u003cT\u003e candidate \u003d factory.create(this, type);\n            if (candidate !\u003d null) {\n                call.setDelegate(candidate);\n                typeTokenCache.put(type, candidate);\n                return candidate;\n            }\n        }\n        throw new IllegalArgumentException(\"GSON cannot handle \" + type);\n    } finally {\n        threadCalls.remove(type);\n    }\n}",
      "path": "gson/src/main/java/com/google/gson/Gson.java",
      "functionStartLine": 335,
      "functionName": "getAdapter",
      "functionAnnotation": "@SuppressWarnings(\"unchecked\")",
      "functionDoc": "Returns the type adapter for {@code} type.\n\n@throws IllegalArgumentException if this GSON cannot serialize and\n    deserialize {@code type}.\n",
      "diff": "@@ -1,27 +1,27 @@\n @SuppressWarnings(\"unchecked\")\n public \u003cT\u003e TypeAdapter\u003cT\u003e getAdapter(TypeToken\u003cT\u003e type) {\n     TypeAdapter\u003c?\u003e cached \u003d typeTokenCache.get(type);\n     if (cached !\u003d null) {\n         return (TypeAdapter\u003cT\u003e) cached;\n     }\n     Map\u003cTypeToken\u003c?\u003e, FutureTypeAdapter\u003c?\u003e\u003e threadCalls \u003d calls.get();\n     FutureTypeAdapter\u003cT\u003e ongoingCall \u003d (FutureTypeAdapter\u003cT\u003e) threadCalls.get(type);\n     if (ongoingCall !\u003d null) {\n         return ongoingCall;\n     }\n     FutureTypeAdapter\u003cT\u003e call \u003d new FutureTypeAdapter\u003cT\u003e();\n     threadCalls.put(type, call);\n     try {\n-        for (TypeAdapter.Factory factory : factories) {\n+        for (TypeAdapterFactory factory : factories) {\n             TypeAdapter\u003cT\u003e candidate \u003d factory.create(this, type);\n             if (candidate !\u003d null) {\n                 call.setDelegate(candidate);\n                 typeTokenCache.put(type, candidate);\n                 return candidate;\n             }\n         }\n         throw new IllegalArgumentException(\"GSON cannot handle \" + type);\n     } finally {\n         threadCalls.remove(type);\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "756131d869465ac70abb9595653ea967e6812231": {
      "type": "Ymultichange(Ybodychange,Yannotationchange)",
      "commitMessage": "removed Eclipse 3.7 warnings.\n",
      "commitDate": "12/4/11, 2:24 AM",
      "commitName": "756131d869465ac70abb9595653ea967e6812231",
      "commitAuthor": "Inderjeet Singh",
      "subchanges": [
        {
          "type": "Ybodychange",
          "commitMessage": "removed Eclipse 3.7 warnings.\n",
          "commitDate": "12/4/11, 2:24 AM",
          "commitName": "756131d869465ac70abb9595653ea967e6812231",
          "commitAuthor": "Inderjeet Singh",
          "commitDateOld": "12/3/11, 11:46 AM",
          "commitNameOld": "f602bce9f536df971b8bfa01b7ffb111e2896c97",
          "commitAuthorOld": "Jesse Wilson",
          "daysBetweenCommits": 0.61,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "actualSource": "@SuppressWarnings(\"unchecked\")\npublic \u003cT\u003e TypeAdapter\u003cT\u003e getAdapter(TypeToken\u003cT\u003e type) {\n    TypeAdapter\u003c?\u003e cached \u003d typeTokenCache.get(type);\n    if (cached !\u003d null) {\n        return (TypeAdapter\u003cT\u003e) cached;\n    }\n    Map\u003cTypeToken\u003c?\u003e, FutureTypeAdapter\u003c?\u003e\u003e threadCalls \u003d calls.get();\n    FutureTypeAdapter\u003cT\u003e ongoingCall \u003d (FutureTypeAdapter\u003cT\u003e) threadCalls.get(type);\n    if (ongoingCall !\u003d null) {\n        return ongoingCall;\n    }\n    FutureTypeAdapter\u003cT\u003e call \u003d new FutureTypeAdapter\u003cT\u003e();\n    threadCalls.put(type, call);\n    try {\n        for (TypeAdapter.Factory factory : factories) {\n            TypeAdapter\u003cT\u003e candidate \u003d factory.create(this, type);\n            if (candidate !\u003d null) {\n                call.setDelegate(candidate);\n                typeTokenCache.put(type, candidate);\n                return candidate;\n            }\n        }\n        throw new IllegalArgumentException(\"GSON cannot handle \" + type);\n    } finally {\n        threadCalls.remove(type);\n    }\n}",
          "path": "gson/src/main/java/com/google/gson/Gson.java",
          "functionStartLine": 334,
          "functionName": "getAdapter",
          "functionAnnotation": "@SuppressWarnings(\"unchecked\")",
          "functionDoc": "Returns the type adapter for {@code} type.\n\n@throws IllegalArgumentException if this GSON cannot serialize and\n    deserialize {@code type}.\n",
          "diff": "@@ -1,26 +1,27 @@\n+@SuppressWarnings(\"unchecked\")\n public \u003cT\u003e TypeAdapter\u003cT\u003e getAdapter(TypeToken\u003cT\u003e type) {\n     TypeAdapter\u003c?\u003e cached \u003d typeTokenCache.get(type);\n     if (cached !\u003d null) {\n         return (TypeAdapter\u003cT\u003e) cached;\n     }\n     Map\u003cTypeToken\u003c?\u003e, FutureTypeAdapter\u003c?\u003e\u003e threadCalls \u003d calls.get();\n-    @SuppressWarnings(\"unchecked\") FutureTypeAdapter\u003cT\u003e ongoingCall \u003d (FutureTypeAdapter\u003cT\u003e) threadCalls.get(type);\n+    FutureTypeAdapter\u003cT\u003e ongoingCall \u003d (FutureTypeAdapter\u003cT\u003e) threadCalls.get(type);\n     if (ongoingCall !\u003d null) {\n         return ongoingCall;\n     }\n     FutureTypeAdapter\u003cT\u003e call \u003d new FutureTypeAdapter\u003cT\u003e();\n     threadCalls.put(type, call);\n     try {\n         for (TypeAdapter.Factory factory : factories) {\n             TypeAdapter\u003cT\u003e candidate \u003d factory.create(this, type);\n             if (candidate !\u003d null) {\n                 call.setDelegate(candidate);\n                 typeTokenCache.put(type, candidate);\n                 return candidate;\n             }\n         }\n         throw new IllegalArgumentException(\"GSON cannot handle \" + type);\n     } finally {\n         threadCalls.remove(type);\n     }\n }\n\\ No newline at end of file\n",
          "extendedDetails": {}
        },
        {
          "type": "Yannotationchange",
          "commitMessage": "removed Eclipse 3.7 warnings.\n",
          "commitDate": "12/4/11, 2:24 AM",
          "commitName": "756131d869465ac70abb9595653ea967e6812231",
          "commitAuthor": "Inderjeet Singh",
          "commitDateOld": "12/3/11, 11:46 AM",
          "commitNameOld": "f602bce9f536df971b8bfa01b7ffb111e2896c97",
          "commitAuthorOld": "Jesse Wilson",
          "daysBetweenCommits": 0.61,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "actualSource": "@SuppressWarnings(\"unchecked\")\npublic \u003cT\u003e TypeAdapter\u003cT\u003e getAdapter(TypeToken\u003cT\u003e type) {\n    TypeAdapter\u003c?\u003e cached \u003d typeTokenCache.get(type);\n    if (cached !\u003d null) {\n        return (TypeAdapter\u003cT\u003e) cached;\n    }\n    Map\u003cTypeToken\u003c?\u003e, FutureTypeAdapter\u003c?\u003e\u003e threadCalls \u003d calls.get();\n    FutureTypeAdapter\u003cT\u003e ongoingCall \u003d (FutureTypeAdapter\u003cT\u003e) threadCalls.get(type);\n    if (ongoingCall !\u003d null) {\n        return ongoingCall;\n    }\n    FutureTypeAdapter\u003cT\u003e call \u003d new FutureTypeAdapter\u003cT\u003e();\n    threadCalls.put(type, call);\n    try {\n        for (TypeAdapter.Factory factory : factories) {\n            TypeAdapter\u003cT\u003e candidate \u003d factory.create(this, type);\n            if (candidate !\u003d null) {\n                call.setDelegate(candidate);\n                typeTokenCache.put(type, candidate);\n                return candidate;\n            }\n        }\n        throw new IllegalArgumentException(\"GSON cannot handle \" + type);\n    } finally {\n        threadCalls.remove(type);\n    }\n}",
          "path": "gson/src/main/java/com/google/gson/Gson.java",
          "functionStartLine": 334,
          "functionName": "getAdapter",
          "functionAnnotation": "@SuppressWarnings(\"unchecked\")",
          "functionDoc": "Returns the type adapter for {@code} type.\n\n@throws IllegalArgumentException if this GSON cannot serialize and\n    deserialize {@code type}.\n",
          "diff": "@@ -1,26 +1,27 @@\n+@SuppressWarnings(\"unchecked\")\n public \u003cT\u003e TypeAdapter\u003cT\u003e getAdapter(TypeToken\u003cT\u003e type) {\n     TypeAdapter\u003c?\u003e cached \u003d typeTokenCache.get(type);\n     if (cached !\u003d null) {\n         return (TypeAdapter\u003cT\u003e) cached;\n     }\n     Map\u003cTypeToken\u003c?\u003e, FutureTypeAdapter\u003c?\u003e\u003e threadCalls \u003d calls.get();\n-    @SuppressWarnings(\"unchecked\") FutureTypeAdapter\u003cT\u003e ongoingCall \u003d (FutureTypeAdapter\u003cT\u003e) threadCalls.get(type);\n+    FutureTypeAdapter\u003cT\u003e ongoingCall \u003d (FutureTypeAdapter\u003cT\u003e) threadCalls.get(type);\n     if (ongoingCall !\u003d null) {\n         return ongoingCall;\n     }\n     FutureTypeAdapter\u003cT\u003e call \u003d new FutureTypeAdapter\u003cT\u003e();\n     threadCalls.put(type, call);\n     try {\n         for (TypeAdapter.Factory factory : factories) {\n             TypeAdapter\u003cT\u003e candidate \u003d factory.create(this, type);\n             if (candidate !\u003d null) {\n                 call.setDelegate(candidate);\n                 typeTokenCache.put(type, candidate);\n                 return candidate;\n             }\n         }\n         throw new IllegalArgumentException(\"GSON cannot handle \" + type);\n     } finally {\n         threadCalls.remove(type);\n     }\n }\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldValue": "",
            "newValue": "@SuppressWarnings(\"unchecked\")"
          }
        }
      ]
    },
    "4c06b013697d06b327f3c537e23181887aeab774": {
      "type": "Ybodychange",
      "commitMessage": "Cache all computed type adapters. On one particularly violent test (issue 375) this improves performance by 77%.\n",
      "commitDate": "11/26/11, 7:30 AM",
      "commitName": "4c06b013697d06b327f3c537e23181887aeab774",
      "commitAuthor": "Jesse Wilson",
      "commitDateOld": "11/23/11, 5:39 AM",
      "commitNameOld": "bc68d7293c437fd2e5bbcd4bffff4414b03b74a6",
      "commitAuthorOld": "Jesse Wilson",
      "daysBetweenCommits": 3.08,
      "commitsBetweenForRepo": 3,
      "commitsBetweenForFile": 1,
      "actualSource": "public \u003cT\u003e TypeAdapter\u003cT\u003e getAdapter(TypeToken\u003cT\u003e type) {\n    TypeAdapter\u003c?\u003e cached \u003d typeTokenCache.get(type);\n    if (cached !\u003d null) {\n        return (TypeAdapter\u003cT\u003e) cached;\n    }\n    Map\u003cTypeToken\u003c?\u003e, FutureTypeAdapter\u003c?\u003e\u003e threadCalls \u003d calls.get();\n    @SuppressWarnings(\"unchecked\") FutureTypeAdapter\u003cT\u003e ongoingCall \u003d (FutureTypeAdapter\u003cT\u003e) threadCalls.get(type);\n    if (ongoingCall !\u003d null) {\n        return ongoingCall;\n    }\n    FutureTypeAdapter\u003cT\u003e call \u003d new FutureTypeAdapter\u003cT\u003e();\n    threadCalls.put(type, call);\n    try {\n        for (TypeAdapter.Factory factory : factories) {\n            TypeAdapter\u003cT\u003e candidate \u003d factory.create(this, type);\n            if (candidate !\u003d null) {\n                call.setDelegate(candidate);\n                typeTokenCache.put(type, candidate);\n                return candidate;\n            }\n        }\n        throw new IllegalArgumentException(\"GSON cannot handle \" + type);\n    } finally {\n        threadCalls.remove(type);\n    }\n}",
      "path": "gson/src/main/java/com/google/gson/Gson.java",
      "functionStartLine": 333,
      "functionName": "getAdapter",
      "functionAnnotation": "",
      "functionDoc": "Returns the type adapter for {@code} type.\n\n@throws IllegalArgumentException if this GSON cannot serialize and\n    deserialize {@code type}.\n",
      "diff": "@@ -1,21 +1,26 @@\n public \u003cT\u003e TypeAdapter\u003cT\u003e getAdapter(TypeToken\u003cT\u003e type) {\n+    TypeAdapter\u003c?\u003e cached \u003d typeTokenCache.get(type);\n+    if (cached !\u003d null) {\n+        return (TypeAdapter\u003cT\u003e) cached;\n+    }\n     Map\u003cTypeToken\u003c?\u003e, FutureTypeAdapter\u003c?\u003e\u003e threadCalls \u003d calls.get();\n     @SuppressWarnings(\"unchecked\") FutureTypeAdapter\u003cT\u003e ongoingCall \u003d (FutureTypeAdapter\u003cT\u003e) threadCalls.get(type);\n     if (ongoingCall !\u003d null) {\n         return ongoingCall;\n     }\n     FutureTypeAdapter\u003cT\u003e call \u003d new FutureTypeAdapter\u003cT\u003e();\n     threadCalls.put(type, call);\n     try {\n         for (TypeAdapter.Factory factory : factories) {\n             TypeAdapter\u003cT\u003e candidate \u003d factory.create(this, type);\n             if (candidate !\u003d null) {\n                 call.setDelegate(candidate);\n+                typeTokenCache.put(type, candidate);\n                 return candidate;\n             }\n         }\n         throw new IllegalArgumentException(\"GSON cannot handle \" + type);\n     } finally {\n         threadCalls.remove(type);\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "7e760143fdc8b689daeebdee33ad6ea7d0a62a56": {
      "type": "Ymultichange(Ymovefromfile,Ybodychange)",
      "commitMessage": "Smash together MiniGson and Gson. This changes Gson to be the MiniGson rather than delegating to the MiniGson. It means that the MiniGson objects passed into streaming type adapters are now fully-capable \u0027Gson\u0027 objects. \n\nThe most notable impact of this change is that it adds several new public APIs:\n - The TypeAdapter abstract class\n - The TypeAdapter.Factory interface\n - Four new methods on GsonBuilder to register streaming TypeAdapters (via Factory, via Class, via TypeToken, and as a type hierarchy)\n - Three new methods on Gson to lookup streaming TypeAdapters (by type, by class, and to get the next type adapter) \n\nStill outstanding:\n - Write beautiful prose to document the new APIs above\n - Change GsonBuilder\u0027s precedence so that both old and new-style type adapters are registered in one lot\n",
      "commitDate": "11/20/11, 7:23 AM",
      "commitName": "7e760143fdc8b689daeebdee33ad6ea7d0a62a56",
      "commitAuthor": "Jesse Wilson",
      "subchanges": [
        {
          "type": "Ymovefromfile",
          "commitMessage": "Smash together MiniGson and Gson. This changes Gson to be the MiniGson rather than delegating to the MiniGson. It means that the MiniGson objects passed into streaming type adapters are now fully-capable \u0027Gson\u0027 objects. \n\nThe most notable impact of this change is that it adds several new public APIs:\n - The TypeAdapter abstract class\n - The TypeAdapter.Factory interface\n - Four new methods on GsonBuilder to register streaming TypeAdapters (via Factory, via Class, via TypeToken, and as a type hierarchy)\n - Three new methods on Gson to lookup streaming TypeAdapters (by type, by class, and to get the next type adapter) \n\nStill outstanding:\n - Write beautiful prose to document the new APIs above\n - Change GsonBuilder\u0027s precedence so that both old and new-style type adapters are registered in one lot\n",
          "commitDate": "11/20/11, 7:23 AM",
          "commitName": "7e760143fdc8b689daeebdee33ad6ea7d0a62a56",
          "commitAuthor": "Jesse Wilson",
          "commitDateOld": "11/18/11, 8:07 AM",
          "commitNameOld": "df31d2db16fe9ef85b7152d002880d5546070fb2",
          "commitAuthorOld": "Jesse Wilson",
          "daysBetweenCommits": 1.97,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "actualSource": "public \u003cT\u003e TypeAdapter\u003cT\u003e getAdapter(TypeToken\u003cT\u003e type) {\n    Map\u003cTypeToken\u003c?\u003e, FutureTypeAdapter\u003c?\u003e\u003e threadCalls \u003d calls.get();\n    @SuppressWarnings(\"unchecked\") FutureTypeAdapter\u003cT\u003e ongoingCall \u003d (FutureTypeAdapter\u003cT\u003e) threadCalls.get(type);\n    if (ongoingCall !\u003d null) {\n        return ongoingCall;\n    }\n    FutureTypeAdapter\u003cT\u003e call \u003d new FutureTypeAdapter\u003cT\u003e();\n    threadCalls.put(type, call);\n    try {\n        for (TypeAdapter.Factory factory : factories) {\n            TypeAdapter\u003cT\u003e candidate \u003d factory.create(this, type);\n            if (candidate !\u003d null) {\n                call.setDelegate(candidate);\n                return candidate;\n            }\n        }\n        throw new IllegalArgumentException(\"GSON cannot handle \" + type);\n    } finally {\n        threadCalls.remove(type);\n    }\n}",
          "path": "gson/src/main/java/com/google/gson/Gson.java",
          "functionStartLine": 384,
          "functionName": "getAdapter",
          "functionAnnotation": "",
          "functionDoc": "Returns the type adapter for {@code} type.\n\n@throws IllegalArgumentException if this GSON cannot serialize and\n    deserialize {@code type}.\n",
          "diff": "@@ -1,21 +1,21 @@\n public \u003cT\u003e TypeAdapter\u003cT\u003e getAdapter(TypeToken\u003cT\u003e type) {\n     Map\u003cTypeToken\u003c?\u003e, FutureTypeAdapter\u003c?\u003e\u003e threadCalls \u003d calls.get();\n     @SuppressWarnings(\"unchecked\") FutureTypeAdapter\u003cT\u003e ongoingCall \u003d (FutureTypeAdapter\u003cT\u003e) threadCalls.get(type);\n     if (ongoingCall !\u003d null) {\n         return ongoingCall;\n     }\n     FutureTypeAdapter\u003cT\u003e call \u003d new FutureTypeAdapter\u003cT\u003e();\n     threadCalls.put(type, call);\n     try {\n         for (TypeAdapter.Factory factory : factories) {\n             TypeAdapter\u003cT\u003e candidate \u003d factory.create(this, type);\n             if (candidate !\u003d null) {\n                 call.setDelegate(candidate);\n                 return candidate;\n             }\n         }\n-        throw new IllegalArgumentException(\"This MiniGSON cannot handle \" + type);\n+        throw new IllegalArgumentException(\"GSON cannot handle \" + type);\n     } finally {\n         threadCalls.remove(type);\n     }\n }\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldPath": "gson/src/main/java/com/google/gson/internal/bind/MiniGson.java",
            "newPath": "gson/src/main/java/com/google/gson/Gson.java",
            "oldMethodName": "getAdapter",
            "newMethodName": "getAdapter"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "Smash together MiniGson and Gson. This changes Gson to be the MiniGson rather than delegating to the MiniGson. It means that the MiniGson objects passed into streaming type adapters are now fully-capable \u0027Gson\u0027 objects. \n\nThe most notable impact of this change is that it adds several new public APIs:\n - The TypeAdapter abstract class\n - The TypeAdapter.Factory interface\n - Four new methods on GsonBuilder to register streaming TypeAdapters (via Factory, via Class, via TypeToken, and as a type hierarchy)\n - Three new methods on Gson to lookup streaming TypeAdapters (by type, by class, and to get the next type adapter) \n\nStill outstanding:\n - Write beautiful prose to document the new APIs above\n - Change GsonBuilder\u0027s precedence so that both old and new-style type adapters are registered in one lot\n",
          "commitDate": "11/20/11, 7:23 AM",
          "commitName": "7e760143fdc8b689daeebdee33ad6ea7d0a62a56",
          "commitAuthor": "Jesse Wilson",
          "commitDateOld": "11/18/11, 8:07 AM",
          "commitNameOld": "df31d2db16fe9ef85b7152d002880d5546070fb2",
          "commitAuthorOld": "Jesse Wilson",
          "daysBetweenCommits": 1.97,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "actualSource": "public \u003cT\u003e TypeAdapter\u003cT\u003e getAdapter(TypeToken\u003cT\u003e type) {\n    Map\u003cTypeToken\u003c?\u003e, FutureTypeAdapter\u003c?\u003e\u003e threadCalls \u003d calls.get();\n    @SuppressWarnings(\"unchecked\") FutureTypeAdapter\u003cT\u003e ongoingCall \u003d (FutureTypeAdapter\u003cT\u003e) threadCalls.get(type);\n    if (ongoingCall !\u003d null) {\n        return ongoingCall;\n    }\n    FutureTypeAdapter\u003cT\u003e call \u003d new FutureTypeAdapter\u003cT\u003e();\n    threadCalls.put(type, call);\n    try {\n        for (TypeAdapter.Factory factory : factories) {\n            TypeAdapter\u003cT\u003e candidate \u003d factory.create(this, type);\n            if (candidate !\u003d null) {\n                call.setDelegate(candidate);\n                return candidate;\n            }\n        }\n        throw new IllegalArgumentException(\"GSON cannot handle \" + type);\n    } finally {\n        threadCalls.remove(type);\n    }\n}",
          "path": "gson/src/main/java/com/google/gson/Gson.java",
          "functionStartLine": 384,
          "functionName": "getAdapter",
          "functionAnnotation": "",
          "functionDoc": "Returns the type adapter for {@code} type.\n\n@throws IllegalArgumentException if this GSON cannot serialize and\n    deserialize {@code type}.\n",
          "diff": "@@ -1,21 +1,21 @@\n public \u003cT\u003e TypeAdapter\u003cT\u003e getAdapter(TypeToken\u003cT\u003e type) {\n     Map\u003cTypeToken\u003c?\u003e, FutureTypeAdapter\u003c?\u003e\u003e threadCalls \u003d calls.get();\n     @SuppressWarnings(\"unchecked\") FutureTypeAdapter\u003cT\u003e ongoingCall \u003d (FutureTypeAdapter\u003cT\u003e) threadCalls.get(type);\n     if (ongoingCall !\u003d null) {\n         return ongoingCall;\n     }\n     FutureTypeAdapter\u003cT\u003e call \u003d new FutureTypeAdapter\u003cT\u003e();\n     threadCalls.put(type, call);\n     try {\n         for (TypeAdapter.Factory factory : factories) {\n             TypeAdapter\u003cT\u003e candidate \u003d factory.create(this, type);\n             if (candidate !\u003d null) {\n                 call.setDelegate(candidate);\n                 return candidate;\n             }\n         }\n-        throw new IllegalArgumentException(\"This MiniGSON cannot handle \" + type);\n+        throw new IllegalArgumentException(\"GSON cannot handle \" + type);\n     } finally {\n         threadCalls.remove(type);\n     }\n }\n\\ No newline at end of file\n",
          "extendedDetails": {}
        }
      ]
    },
    "882c14a36782889b54fc284c43e386252ae2de23": {
      "type": "Ybodychange",
      "commitMessage": "Added support in Gson for serializing/deserializing from primitive char.\nCreated a new class for character/char tests, PrimitiveCharacterTest. This is the start of breaking down PrimitiveTest into smaller chunks.\nWhen MiniGson can not find a type adapter for a type, revised the message to say can\u0027t handle instead of can\u0027t serialize. \n",
      "commitDate": "9/15/11, 10:52 PM",
      "commitName": "882c14a36782889b54fc284c43e386252ae2de23",
      "commitAuthor": "Inderjeet Singh",
      "commitDateOld": "9/11/11, 12:04 AM",
      "commitNameOld": "25c6ae177b1ca56db7f3c29eb574bdd032a06165",
      "commitAuthorOld": "Jesse Wilson",
      "daysBetweenCommits": 4.95,
      "commitsBetweenForRepo": 10,
      "commitsBetweenForFile": 1,
      "actualSource": "public \u003cT\u003e TypeAdapter\u003cT\u003e getAdapter(TypeToken\u003cT\u003e type) {\n    Map\u003cTypeToken\u003c?\u003e, FutureTypeAdapter\u003c?\u003e\u003e threadCalls \u003d calls.get();\n    @SuppressWarnings(\"unchecked\") FutureTypeAdapter\u003cT\u003e ongoingCall \u003d (FutureTypeAdapter\u003cT\u003e) threadCalls.get(type);\n    if (ongoingCall !\u003d null) {\n        return ongoingCall;\n    }\n    FutureTypeAdapter\u003cT\u003e call \u003d new FutureTypeAdapter\u003cT\u003e();\n    threadCalls.put(type, call);\n    try {\n        for (TypeAdapter.Factory factory : factories) {\n            TypeAdapter\u003cT\u003e candidate \u003d factory.create(this, type);\n            if (candidate !\u003d null) {\n                call.setDelegate(candidate);\n                return candidate;\n            }\n        }\n        throw new IllegalArgumentException(\"This MiniGSON cannot handle \" + type);\n    } finally {\n        threadCalls.remove(type);\n    }\n}",
      "path": "gson/src/main/java/com/google/gson/internal/bind/MiniGson.java",
      "functionStartLine": 78,
      "functionName": "getAdapter",
      "functionAnnotation": "",
      "functionDoc": "Returns the type adapter for {@code} type.\n\n@throws IllegalArgumentException if this GSON cannot serialize and\n    deserialize {@code type}.\n",
      "diff": "@@ -1,21 +1,21 @@\n public \u003cT\u003e TypeAdapter\u003cT\u003e getAdapter(TypeToken\u003cT\u003e type) {\n     Map\u003cTypeToken\u003c?\u003e, FutureTypeAdapter\u003c?\u003e\u003e threadCalls \u003d calls.get();\n     @SuppressWarnings(\"unchecked\") FutureTypeAdapter\u003cT\u003e ongoingCall \u003d (FutureTypeAdapter\u003cT\u003e) threadCalls.get(type);\n     if (ongoingCall !\u003d null) {\n         return ongoingCall;\n     }\n     FutureTypeAdapter\u003cT\u003e call \u003d new FutureTypeAdapter\u003cT\u003e();\n     threadCalls.put(type, call);\n     try {\n         for (TypeAdapter.Factory factory : factories) {\n             TypeAdapter\u003cT\u003e candidate \u003d factory.create(this, type);\n             if (candidate !\u003d null) {\n                 call.setDelegate(candidate);\n                 return candidate;\n             }\n         }\n-        throw new IllegalArgumentException(\"This MiniGSON cannot serialize \" + type);\n+        throw new IllegalArgumentException(\"This MiniGSON cannot handle \" + type);\n     } finally {\n         threadCalls.remove(type);\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "60e6ed912d52716f46a1ba71923ef203c4248857": {
      "type": "Yfilerename",
      "commitMessage": "Promote MiniGson to gson.internal.bind\n",
      "commitDate": "8/2/11, 5:25 PM",
      "commitName": "60e6ed912d52716f46a1ba71923ef203c4248857",
      "commitAuthor": "Jesse Wilson",
      "commitDateOld": "8/2/11, 5:17 PM",
      "commitNameOld": "759eb8ede50f61fd525f5d703dd9fd45ddae1dcd",
      "commitAuthorOld": "Jesse Wilson",
      "daysBetweenCommits": 0.01,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "public \u003cT\u003e TypeAdapter\u003cT\u003e getAdapter(TypeToken\u003cT\u003e type) {\n    Map\u003cTypeToken\u003c?\u003e, FutureTypeAdapter\u003c?\u003e\u003e threadCalls \u003d calls.get();\n    @SuppressWarnings(\"unchecked\") FutureTypeAdapter\u003cT\u003e ongoingCall \u003d (FutureTypeAdapter\u003cT\u003e) threadCalls.get(type);\n    if (ongoingCall !\u003d null) {\n        return ongoingCall;\n    }\n    FutureTypeAdapter\u003cT\u003e call \u003d new FutureTypeAdapter\u003cT\u003e();\n    threadCalls.put(type, call);\n    try {\n        for (TypeAdapter.Factory factory : factories) {\n            TypeAdapter\u003cT\u003e candidate \u003d factory.create(this, type);\n            if (candidate !\u003d null) {\n                call.setDelegate(candidate);\n                return candidate;\n            }\n        }\n        throw new IllegalArgumentException(\"This MiniGSON cannot serialize \" + type);\n    } finally {\n        threadCalls.remove(type);\n    }\n}",
      "path": "gson/src/main/java/com/google/gson/internal/bind/MiniGson.java",
      "functionStartLine": 89,
      "functionName": "getAdapter",
      "functionAnnotation": "",
      "functionDoc": "Returns the type adapter for {@code} type.\n\n@throws IllegalArgumentException if this GSON cannot serialize and\n    deserialize {@code type}.\n",
      "diff": "",
      "extendedDetails": {
        "oldPath": "extras/src/main/java/com/google/gson/mini/MiniGson.java",
        "newPath": "gson/src/main/java/com/google/gson/internal/bind/MiniGson.java"
      }
    },
    "4b042671af018f308c2a261145dc6712e39b96e7": {
      "type": "Yformatchange",
      "commitMessage": "Cleanup after experimenting with specializing BoundField by type (ie. Field.setInt() to avoid autoboxing)\n",
      "commitDate": "7/15/11, 7:37 AM",
      "commitName": "4b042671af018f308c2a261145dc6712e39b96e7",
      "commitAuthor": "Jesse Wilson",
      "commitDateOld": "7/15/11, 6:43 AM",
      "commitNameOld": "3c4d121dc8736c7359731f9cb99098e2999f8575",
      "commitAuthorOld": "Jesse Wilson",
      "daysBetweenCommits": 0.04,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "public \u003cT\u003e TypeAdapter\u003cT\u003e getAdapter(TypeToken\u003cT\u003e type) {\n    Map\u003cTypeToken\u003c?\u003e, FutureTypeAdapter\u003c?\u003e\u003e threadCalls \u003d calls.get();\n    @SuppressWarnings(\"unchecked\") FutureTypeAdapter\u003cT\u003e ongoingCall \u003d (FutureTypeAdapter\u003cT\u003e) threadCalls.get(type);\n    if (ongoingCall !\u003d null) {\n        return ongoingCall;\n    }\n    FutureTypeAdapter\u003cT\u003e call \u003d new FutureTypeAdapter\u003cT\u003e();\n    threadCalls.put(type, call);\n    try {\n        for (TypeAdapter.Factory factory : factories) {\n            TypeAdapter\u003cT\u003e candidate \u003d factory.create(this, type);\n            if (candidate !\u003d null) {\n                call.setDelegate(candidate);\n                return candidate;\n            }\n        }\n        throw new IllegalArgumentException(\"This MiniGSON cannot serialize \" + type);\n    } finally {\n        threadCalls.remove(type);\n    }\n}",
      "path": "extras/src/main/java/com/google/gson/mini/MiniGson.java",
      "functionStartLine": 89,
      "functionName": "getAdapter",
      "functionAnnotation": "",
      "functionDoc": "Returns the type adapter for {@code} type.\n\n@throws IllegalArgumentException if this GSON cannot serialize and\n    deserialize {@code type}.\n",
      "diff": "",
      "extendedDetails": {}
    },
    "041d499a7c4af1b70617001ded11dbc01732d97f": {
      "type": "Ybodychange",
      "commitMessage": "Fix serialization where one type depends (possibly indireclty) on itself!\n",
      "commitDate": "7/12/11, 12:39 PM",
      "commitName": "041d499a7c4af1b70617001ded11dbc01732d97f",
      "commitAuthor": "Jesse Wilson",
      "commitDateOld": "7/11/11, 3:26 PM",
      "commitNameOld": "c6bef300579d96fe90e5be8240ee595ae8da66f1",
      "commitAuthorOld": "Jesse Wilson",
      "daysBetweenCommits": 0.88,
      "commitsBetweenForRepo": 3,
      "commitsBetweenForFile": 1,
      "actualSource": "public \u003cT\u003e TypeAdapter\u003cT\u003e getAdapter(TypeToken\u003cT\u003e type) {\n    Map\u003cTypeToken\u003c?\u003e, FutureTypeAdapter\u003c?\u003e\u003e threadCalls \u003d calls.get();\n    @SuppressWarnings(\"unchecked\") FutureTypeAdapter\u003cT\u003e ongoingCall \u003d (FutureTypeAdapter\u003cT\u003e) threadCalls.get(type);\n    if (ongoingCall !\u003d null) {\n        return ongoingCall;\n    }\n    FutureTypeAdapter\u003cT\u003e call \u003d new FutureTypeAdapter\u003cT\u003e();\n    threadCalls.put(type, call);\n    try {\n        for (TypeAdapter.Factory factory : factories) {\n            TypeAdapter\u003cT\u003e candidate \u003d factory.create(this, type);\n            if (candidate !\u003d null) {\n                call.setDelegate(candidate);\n                return candidate;\n            }\n        }\n        throw new IllegalArgumentException(\"This MiniGSON cannot serialize \" + type);\n    } finally {\n        threadCalls.remove(type);\n    }\n}",
      "path": "extras/src/main/java/com/google/gson/mini/MiniGson.java",
      "functionStartLine": 88,
      "functionName": "getAdapter",
      "functionAnnotation": "",
      "functionDoc": "Returns the type adapter for {@code} type.\n\n@throws IllegalArgumentException if this GSON cannot serialize and\n    deserialize {@code type}.\n",
      "diff": "@@ -1,9 +1,21 @@\n public \u003cT\u003e TypeAdapter\u003cT\u003e getAdapter(TypeToken\u003cT\u003e type) {\n-    for (TypeAdapter.Factory factory : factories) {\n-        TypeAdapter\u003cT\u003e candidate \u003d factory.create(this, type);\n-        if (candidate !\u003d null) {\n-            return candidate;\n-        }\n+    Map\u003cTypeToken\u003c?\u003e, FutureTypeAdapter\u003c?\u003e\u003e threadCalls \u003d calls.get();\n+    @SuppressWarnings(\"unchecked\") FutureTypeAdapter\u003cT\u003e ongoingCall \u003d (FutureTypeAdapter\u003cT\u003e) threadCalls.get(type);\n+    if (ongoingCall !\u003d null) {\n+        return ongoingCall;\n     }\n-    throw new IllegalArgumentException(\"This MiniGSON cannot serialize \" + type);\n+    FutureTypeAdapter\u003cT\u003e call \u003d new FutureTypeAdapter\u003cT\u003e();\n+    threadCalls.put(type, call);\n+    try {\n+        for (TypeAdapter.Factory factory : factories) {\n+            TypeAdapter\u003cT\u003e candidate \u003d factory.create(this, type);\n+            if (candidate !\u003d null) {\n+                call.setDelegate(candidate);\n+                return candidate;\n+            }\n+        }\n+        throw new IllegalArgumentException(\"This MiniGSON cannot serialize \" + type);\n+    } finally {\n+        threadCalls.remove(type);\n+    }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "95a345234fb1d51ada03f37d50769cd5198b5af3": {
      "type": "Ybodychange",
      "commitMessage": "MiniGSON Map adapters and support for nulls.\n",
      "commitDate": "7/11/11, 2:45 PM",
      "commitName": "95a345234fb1d51ada03f37d50769cd5198b5af3",
      "commitAuthor": "Jesse Wilson",
      "commitDateOld": "7/11/11, 9:46 AM",
      "commitNameOld": "c5f1df10175c254b823fc019832bf1bf7b71e929",
      "commitAuthorOld": "Jesse Wilson",
      "daysBetweenCommits": 0.21,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "public \u003cT\u003e TypeAdapter\u003cT\u003e getAdapter(TypeToken\u003cT\u003e type) {\n    for (TypeAdapter.Factory factory : factories) {\n        TypeAdapter\u003cT\u003e candidate \u003d factory.create(this, type);\n        if (candidate !\u003d null) {\n            return candidate;\n        }\n    }\n    throw new IllegalArgumentException(\"This MiniGSON cannot serialize \" + type);\n}",
      "path": "extras/src/main/java/com/google/gson/mini/MiniGson.java",
      "functionStartLine": 68,
      "functionName": "getAdapter",
      "functionAnnotation": "",
      "functionDoc": "Returns the type adapter for {@code} type.\n\n@throws IllegalArgumentException if this GSON cannot serialize and\n    deserialize {@code type}.\n",
      "diff": "",
      "extendedDetails": {}
    },
    "c5f1df10175c254b823fc019832bf1bf7b71e929": {
      "type": "Yintroduced",
      "commitMessage": "MiniGSON prototype!\n",
      "commitDate": "7/11/11, 9:46 AM",
      "commitName": "c5f1df10175c254b823fc019832bf1bf7b71e929",
      "commitAuthor": "Jesse Wilson",
      "diff": "@@ -0,0 +1,9 @@\n+public \u003cT\u003e TypeAdapter\u003cT\u003e getAdapter(TypeToken\u003cT\u003e type) {\n+    for (TypeAdapter.Factory factory : factories) {\n+        TypeAdapter\u003cT\u003e candidate \u003d factory.create(this, type);\n+        if (candidate !\u003d null) {\n+            return candidate;\n+        }\n+    }\n+    throw new IllegalArgumentException(\"This MiniGSON cannot serialize \" + type);\n+}\n\\ No newline at end of file\n",
      "actualSource": "public \u003cT\u003e TypeAdapter\u003cT\u003e getAdapter(TypeToken\u003cT\u003e type) {\n    for (TypeAdapter.Factory factory : factories) {\n        TypeAdapter\u003cT\u003e candidate \u003d factory.create(this, type);\n        if (candidate !\u003d null) {\n            return candidate;\n        }\n    }\n    throw new IllegalArgumentException(\"This MiniGSON cannot serialize \" + type);\n}",
      "path": "extras/src/main/java/com/google/gson/mini/MiniGson.java",
      "functionStartLine": 67,
      "functionName": "getAdapter",
      "functionAnnotation": "",
      "functionDoc": "Returns the type adapter for {@code} type.\n\n@throws IllegalArgumentException if this GSON cannot serialize and\n    deserialize {@code type}.\n"
    }
  }
}