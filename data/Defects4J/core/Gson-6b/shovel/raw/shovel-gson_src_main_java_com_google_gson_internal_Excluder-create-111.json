{
  "origin": "codeshovel",
  "repositoryName": "Gson-6b",
  "repositoryPath": "/tmp/Gson-6b//.git",
  "startCommitName": "HEAD",
  "sourceFileName": "Excluder.java",
  "functionName": "create",
  "functionId": "create___gson-Gson(modifiers-final)__type-TypeToken__T__(modifiers-final)",
  "sourceFilePath": "gson/src/main/java/com/google/gson/internal/Excluder.java",
  "functionAnnotation": "",
  "functionDoc": "",
  "functionStartLine": 111,
  "functionEndLine": 147,
  "numCommitsSeen": 18,
  "timeTaken": 2262,
  "changeHistory": [
    "83e5a4937cf13ab9b94a7bb12ce2fefa168752ed",
    "796a3812791d3d2ac3d70c63f0d02a04131fe5b4",
    "ecdf9150f6cc820dafddea5b545f456fed47472f",
    "f602bce9f536df971b8bfa01b7ffb111e2896c97",
    "26ab404599643fac25442646b829a65a7f86bca1",
    "aa2f61b7d8defddc2a78de43b8042178241daedb",
    "f777a192ee13fd59048aa7ba640cc8023051c89d",
    "7e760143fdc8b689daeebdee33ad6ea7d0a62a56",
    "25c6ae177b1ca56db7f3c29eb574bdd032a06165",
    "f50cce6d142e4e0b4bc6c9b52bf6ed82a9c7afaa",
    "d70fb90ef77be3d34686a98335fb1747f66b448b",
    "566c27cf211fcf307bcb94b47dbbe992fbe0d2d9"
  ],
  "changeHistoryShort": {
    "83e5a4937cf13ab9b94a7bb12ce2fefa168752ed": "Ybodychange",
    "796a3812791d3d2ac3d70c63f0d02a04131fe5b4": "Ybodychange",
    "ecdf9150f6cc820dafddea5b545f456fed47472f": "Ybodychange",
    "f602bce9f536df971b8bfa01b7ffb111e2896c97": "Ybodychange",
    "26ab404599643fac25442646b829a65a7f86bca1": "Ymultichange(Yparameterchange,Ybodychange)",
    "aa2f61b7d8defddc2a78de43b8042178241daedb": "Ymultichange(Ymovefromfile,Ybodychange)",
    "f777a192ee13fd59048aa7ba640cc8023051c89d": "Ybodychange",
    "7e760143fdc8b689daeebdee33ad6ea7d0a62a56": "Yparameterchange",
    "25c6ae177b1ca56db7f3c29eb574bdd032a06165": "Ymultichange(Ymovefromfile,Ybodychange,Yparametermetachange,Yparameterchange)",
    "f50cce6d142e4e0b4bc6c9b52bf6ed82a9c7afaa": "Ybodychange",
    "d70fb90ef77be3d34686a98335fb1747f66b448b": "Ybodychange",
    "566c27cf211fcf307bcb94b47dbbe992fbe0d2d9": "Yintroduced"
  },
  "changeHistoryDetails": {
    "83e5a4937cf13ab9b94a7bb12ce2fefa168752ed": {
      "type": "Ybodychange",
      "commitMessage": "Renamed Gson.getNextAdapter to getDelegateAdapter.\nDeleted testParameterizedMapSubclassDeserialization which we decided to not fix.\nAdded simple tests for getDelegateAdapter\n",
      "commitDate": "4/12/12, 11:49 AM",
      "commitName": "83e5a4937cf13ab9b94a7bb12ce2fefa168752ed",
      "commitAuthor": "Inderjeet Singh",
      "commitDateOld": "1/1/12, 4:42 AM",
      "commitNameOld": "796a3812791d3d2ac3d70c63f0d02a04131fe5b4",
      "commitAuthorOld": "Jesse Wilson",
      "daysBetweenCommits": 102.25,
      "commitsBetweenForRepo": 27,
      "commitsBetweenForFile": 1,
      "actualSource": "public \u003cT\u003e TypeAdapter\u003cT\u003e create(final Gson gson, final TypeToken\u003cT\u003e type) {\n    Class\u003c?\u003e rawType \u003d type.getRawType();\n    final boolean skipSerialize \u003d excludeClass(rawType, true);\n    final boolean skipDeserialize \u003d excludeClass(rawType, false);\n    if (!skipSerialize \u0026\u0026 !skipDeserialize) {\n        return null;\n    }\n    return new TypeAdapter\u003cT\u003e() {\n\n        private TypeAdapter\u003cT\u003e delegate;\n\n        @Override\n        public T read(JsonReader in) throws IOException {\n            if (skipDeserialize) {\n                in.skipValue();\n                return null;\n            }\n            return delegate().read(in);\n        }\n\n        @Override\n        public void write(JsonWriter out, T value) throws IOException {\n            if (skipSerialize) {\n                out.nullValue();\n                return;\n            }\n            delegate().write(out, value);\n        }\n\n        private TypeAdapter\u003cT\u003e delegate() {\n            TypeAdapter\u003cT\u003e d \u003d delegate;\n            return d !\u003d null ? d : (delegate \u003d gson.getDelegateAdapter(Excluder.this, type));\n        }\n    };\n}",
      "path": "gson/src/main/java/com/google/gson/internal/Excluder.java",
      "functionStartLine": 111,
      "functionName": "create",
      "functionAnnotation": "",
      "functionDoc": "",
      "diff": "@@ -1,35 +1,35 @@\n public \u003cT\u003e TypeAdapter\u003cT\u003e create(final Gson gson, final TypeToken\u003cT\u003e type) {\n     Class\u003c?\u003e rawType \u003d type.getRawType();\n     final boolean skipSerialize \u003d excludeClass(rawType, true);\n     final boolean skipDeserialize \u003d excludeClass(rawType, false);\n     if (!skipSerialize \u0026\u0026 !skipDeserialize) {\n         return null;\n     }\n     return new TypeAdapter\u003cT\u003e() {\n \n         private TypeAdapter\u003cT\u003e delegate;\n \n         @Override\n         public T read(JsonReader in) throws IOException {\n             if (skipDeserialize) {\n                 in.skipValue();\n                 return null;\n             }\n             return delegate().read(in);\n         }\n \n         @Override\n         public void write(JsonWriter out, T value) throws IOException {\n             if (skipSerialize) {\n                 out.nullValue();\n                 return;\n             }\n             delegate().write(out, value);\n         }\n \n         private TypeAdapter\u003cT\u003e delegate() {\n             TypeAdapter\u003cT\u003e d \u003d delegate;\n-            return d !\u003d null ? d : (delegate \u003d gson.getNextAdapter(Excluder.this, type));\n+            return d !\u003d null ? d : (delegate \u003d gson.getDelegateAdapter(Excluder.this, type));\n         }\n     };\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "796a3812791d3d2ac3d70c63f0d02a04131fe5b4": {
      "type": "Ybodychange",
      "commitMessage": "Kill GsonInternalAccess. Clients to this were all broken because nobody was ever assigning INSTANCE.\n",
      "commitDate": "1/1/12, 4:42 AM",
      "commitName": "796a3812791d3d2ac3d70c63f0d02a04131fe5b4",
      "commitAuthor": "Jesse Wilson",
      "commitDateOld": "12/30/11, 9:30 PM",
      "commitNameOld": "ecdf9150f6cc820dafddea5b545f456fed47472f",
      "commitAuthorOld": "Jesse Wilson",
      "daysBetweenCommits": 1.3,
      "commitsBetweenForRepo": 11,
      "commitsBetweenForFile": 1,
      "actualSource": "public \u003cT\u003e TypeAdapter\u003cT\u003e create(final Gson gson, final TypeToken\u003cT\u003e type) {\n    Class\u003c?\u003e rawType \u003d type.getRawType();\n    final boolean skipSerialize \u003d excludeClass(rawType, true);\n    final boolean skipDeserialize \u003d excludeClass(rawType, false);\n    if (!skipSerialize \u0026\u0026 !skipDeserialize) {\n        return null;\n    }\n    return new TypeAdapter\u003cT\u003e() {\n\n        private TypeAdapter\u003cT\u003e delegate;\n\n        @Override\n        public T read(JsonReader in) throws IOException {\n            if (skipDeserialize) {\n                in.skipValue();\n                return null;\n            }\n            return delegate().read(in);\n        }\n\n        @Override\n        public void write(JsonWriter out, T value) throws IOException {\n            if (skipSerialize) {\n                out.nullValue();\n                return;\n            }\n            delegate().write(out, value);\n        }\n\n        private TypeAdapter\u003cT\u003e delegate() {\n            TypeAdapter\u003cT\u003e d \u003d delegate;\n            return d !\u003d null ? d : (delegate \u003d gson.getNextAdapter(Excluder.this, type));\n        }\n    };\n}",
      "path": "gson/src/main/java/com/google/gson/internal/Excluder.java",
      "functionStartLine": 111,
      "functionName": "create",
      "functionAnnotation": "",
      "functionDoc": "",
      "diff": "@@ -1,35 +1,35 @@\n public \u003cT\u003e TypeAdapter\u003cT\u003e create(final Gson gson, final TypeToken\u003cT\u003e type) {\n     Class\u003c?\u003e rawType \u003d type.getRawType();\n     final boolean skipSerialize \u003d excludeClass(rawType, true);\n     final boolean skipDeserialize \u003d excludeClass(rawType, false);\n     if (!skipSerialize \u0026\u0026 !skipDeserialize) {\n         return null;\n     }\n     return new TypeAdapter\u003cT\u003e() {\n \n         private TypeAdapter\u003cT\u003e delegate;\n \n         @Override\n         public T read(JsonReader in) throws IOException {\n             if (skipDeserialize) {\n                 in.skipValue();\n                 return null;\n             }\n             return delegate().read(in);\n         }\n \n         @Override\n         public void write(JsonWriter out, T value) throws IOException {\n             if (skipSerialize) {\n                 out.nullValue();\n                 return;\n             }\n             delegate().write(out, value);\n         }\n \n         private TypeAdapter\u003cT\u003e delegate() {\n             TypeAdapter\u003cT\u003e d \u003d delegate;\n-            return d !\u003d null ? d : (delegate \u003d GsonInternalAccess.INSTANCE.getNextAdapter(gson, Excluder.this, type));\n+            return d !\u003d null ? d : (delegate \u003d gson.getNextAdapter(Excluder.this, type));\n         }\n     };\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "ecdf9150f6cc820dafddea5b545f456fed47472f": {
      "type": "Ybodychange",
      "commitMessage": "Hide Gson.getNextAdapter() for the current release.\n",
      "commitDate": "12/30/11, 9:30 PM",
      "commitName": "ecdf9150f6cc820dafddea5b545f456fed47472f",
      "commitAuthor": "Jesse Wilson",
      "commitDateOld": "12/23/11, 10:27 AM",
      "commitNameOld": "d7fbac03844aa86dbb1c65a8ba50ac364c4b2050",
      "commitAuthorOld": "Jesse Wilson",
      "daysBetweenCommits": 7.46,
      "commitsBetweenForRepo": 8,
      "commitsBetweenForFile": 1,
      "actualSource": "public \u003cT\u003e TypeAdapter\u003cT\u003e create(final Gson gson, final TypeToken\u003cT\u003e type) {\n    Class\u003c?\u003e rawType \u003d type.getRawType();\n    final boolean skipSerialize \u003d excludeClass(rawType, true);\n    final boolean skipDeserialize \u003d excludeClass(rawType, false);\n    if (!skipSerialize \u0026\u0026 !skipDeserialize) {\n        return null;\n    }\n    return new TypeAdapter\u003cT\u003e() {\n\n        private TypeAdapter\u003cT\u003e delegate;\n\n        @Override\n        public T read(JsonReader in) throws IOException {\n            if (skipDeserialize) {\n                in.skipValue();\n                return null;\n            }\n            return delegate().read(in);\n        }\n\n        @Override\n        public void write(JsonWriter out, T value) throws IOException {\n            if (skipSerialize) {\n                out.nullValue();\n                return;\n            }\n            delegate().write(out, value);\n        }\n\n        private TypeAdapter\u003cT\u003e delegate() {\n            TypeAdapter\u003cT\u003e d \u003d delegate;\n            return d !\u003d null ? d : (delegate \u003d GsonInternalAccess.INSTANCE.getNextAdapter(gson, Excluder.this, type));\n        }\n    };\n}",
      "path": "gson/src/main/java/com/google/gson/internal/Excluder.java",
      "functionStartLine": 111,
      "functionName": "create",
      "functionAnnotation": "",
      "functionDoc": "",
      "diff": "@@ -1,35 +1,35 @@\n public \u003cT\u003e TypeAdapter\u003cT\u003e create(final Gson gson, final TypeToken\u003cT\u003e type) {\n     Class\u003c?\u003e rawType \u003d type.getRawType();\n     final boolean skipSerialize \u003d excludeClass(rawType, true);\n     final boolean skipDeserialize \u003d excludeClass(rawType, false);\n     if (!skipSerialize \u0026\u0026 !skipDeserialize) {\n         return null;\n     }\n     return new TypeAdapter\u003cT\u003e() {\n \n         private TypeAdapter\u003cT\u003e delegate;\n \n         @Override\n         public T read(JsonReader in) throws IOException {\n             if (skipDeserialize) {\n                 in.skipValue();\n                 return null;\n             }\n             return delegate().read(in);\n         }\n \n         @Override\n         public void write(JsonWriter out, T value) throws IOException {\n             if (skipSerialize) {\n                 out.nullValue();\n                 return;\n             }\n             delegate().write(out, value);\n         }\n \n         private TypeAdapter\u003cT\u003e delegate() {\n             TypeAdapter\u003cT\u003e d \u003d delegate;\n-            return d !\u003d null ? d : (delegate \u003d gson.getNextAdapter(Excluder.this, type));\n+            return d !\u003d null ? d : (delegate \u003d GsonInternalAccess.INSTANCE.getNextAdapter(gson, Excluder.this, type));\n         }\n     };\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "f602bce9f536df971b8bfa01b7ffb111e2896c97": {
      "type": "Ybodychange",
      "commitMessage": "Nice documentation for TypeAdapter.\n",
      "commitDate": "12/3/11, 11:46 AM",
      "commitName": "f602bce9f536df971b8bfa01b7ffb111e2896c97",
      "commitAuthor": "Jesse Wilson",
      "commitDateOld": "12/2/11, 2:57 PM",
      "commitNameOld": "26ab404599643fac25442646b829a65a7f86bca1",
      "commitAuthorOld": "Jesse Wilson",
      "daysBetweenCommits": 0.87,
      "commitsBetweenForRepo": 4,
      "commitsBetweenForFile": 1,
      "actualSource": "public \u003cT\u003e TypeAdapter\u003cT\u003e create(final Gson gson, final TypeToken\u003cT\u003e type) {\n    Class\u003c?\u003e rawType \u003d type.getRawType();\n    final boolean skipSerialize \u003d excludeClass(rawType, true);\n    final boolean skipDeserialize \u003d excludeClass(rawType, false);\n    if (!skipSerialize \u0026\u0026 !skipDeserialize) {\n        return null;\n    }\n    return new TypeAdapter\u003cT\u003e() {\n\n        private TypeAdapter\u003cT\u003e delegate;\n\n        @Override\n        public T read(JsonReader in) throws IOException {\n            if (skipDeserialize) {\n                in.skipValue();\n                return null;\n            }\n            return delegate().read(in);\n        }\n\n        @Override\n        public void write(JsonWriter out, T value) throws IOException {\n            if (skipSerialize) {\n                out.nullValue();\n                return;\n            }\n            delegate().write(out, value);\n        }\n\n        private TypeAdapter\u003cT\u003e delegate() {\n            TypeAdapter\u003cT\u003e d \u003d delegate;\n            return d !\u003d null ? d : (delegate \u003d gson.getNextAdapter(Excluder.this, type));\n        }\n    };\n}",
      "path": "gson/src/main/java/com/google/gson/internal/Excluder.java",
      "functionStartLine": 110,
      "functionName": "create",
      "functionAnnotation": "",
      "functionDoc": "",
      "diff": "@@ -1,35 +1,35 @@\n public \u003cT\u003e TypeAdapter\u003cT\u003e create(final Gson gson, final TypeToken\u003cT\u003e type) {\n     Class\u003c?\u003e rawType \u003d type.getRawType();\n     final boolean skipSerialize \u003d excludeClass(rawType, true);\n     final boolean skipDeserialize \u003d excludeClass(rawType, false);\n     if (!skipSerialize \u0026\u0026 !skipDeserialize) {\n         return null;\n     }\n     return new TypeAdapter\u003cT\u003e() {\n \n         private TypeAdapter\u003cT\u003e delegate;\n \n         @Override\n-        public T read(JsonReader reader) throws IOException {\n+        public T read(JsonReader in) throws IOException {\n             if (skipDeserialize) {\n-                reader.skipValue();\n+                in.skipValue();\n                 return null;\n             }\n-            return delegate().read(reader);\n+            return delegate().read(in);\n         }\n \n         @Override\n-        public void write(JsonWriter writer, T value) throws IOException {\n+        public void write(JsonWriter out, T value) throws IOException {\n             if (skipSerialize) {\n-                writer.nullValue();\n+                out.nullValue();\n                 return;\n             }\n-            delegate().write(writer, value);\n+            delegate().write(out, value);\n         }\n \n         private TypeAdapter\u003cT\u003e delegate() {\n             TypeAdapter\u003cT\u003e d \u003d delegate;\n             return d !\u003d null ? d : (delegate \u003d gson.getNextAdapter(Excluder.this, type));\n         }\n     };\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "26ab404599643fac25442646b829a65a7f86bca1": {
      "type": "Ymultichange(Yparameterchange,Ybodychange)",
      "commitMessage": "Cleanup names for TypeAdapters.\n",
      "commitDate": "12/2/11, 2:57 PM",
      "commitName": "26ab404599643fac25442646b829a65a7f86bca1",
      "commitAuthor": "Jesse Wilson",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "Cleanup names for TypeAdapters.\n",
          "commitDate": "12/2/11, 2:57 PM",
          "commitName": "26ab404599643fac25442646b829a65a7f86bca1",
          "commitAuthor": "Jesse Wilson",
          "commitDateOld": "11/21/11, 11:37 PM",
          "commitNameOld": "aa2f61b7d8defddc2a78de43b8042178241daedb",
          "commitAuthorOld": "Jesse Wilson",
          "daysBetweenCommits": 10.64,
          "commitsBetweenForRepo": 15,
          "commitsBetweenForFile": 1,
          "actualSource": "public \u003cT\u003e TypeAdapter\u003cT\u003e create(final Gson gson, final TypeToken\u003cT\u003e type) {\n    Class\u003c?\u003e rawType \u003d type.getRawType();\n    final boolean skipSerialize \u003d excludeClass(rawType, true);\n    final boolean skipDeserialize \u003d excludeClass(rawType, false);\n    if (!skipSerialize \u0026\u0026 !skipDeserialize) {\n        return null;\n    }\n    return new TypeAdapter\u003cT\u003e() {\n\n        private TypeAdapter\u003cT\u003e delegate;\n\n        @Override\n        public T read(JsonReader reader) throws IOException {\n            if (skipDeserialize) {\n                reader.skipValue();\n                return null;\n            }\n            return delegate().read(reader);\n        }\n\n        @Override\n        public void write(JsonWriter writer, T value) throws IOException {\n            if (skipSerialize) {\n                writer.nullValue();\n                return;\n            }\n            delegate().write(writer, value);\n        }\n\n        private TypeAdapter\u003cT\u003e delegate() {\n            TypeAdapter\u003cT\u003e d \u003d delegate;\n            return d !\u003d null ? d : (delegate \u003d gson.getNextAdapter(Excluder.this, type));\n        }\n    };\n}",
          "path": "gson/src/main/java/com/google/gson/internal/Excluder.java",
          "functionStartLine": 110,
          "functionName": "create",
          "functionAnnotation": "",
          "functionDoc": "",
          "diff": "@@ -1,35 +1,35 @@\n-public \u003cT\u003e TypeAdapter\u003cT\u003e create(final Gson context, final TypeToken\u003cT\u003e type) {\n+public \u003cT\u003e TypeAdapter\u003cT\u003e create(final Gson gson, final TypeToken\u003cT\u003e type) {\n     Class\u003c?\u003e rawType \u003d type.getRawType();\n     final boolean skipSerialize \u003d excludeClass(rawType, true);\n     final boolean skipDeserialize \u003d excludeClass(rawType, false);\n     if (!skipSerialize \u0026\u0026 !skipDeserialize) {\n         return null;\n     }\n     return new TypeAdapter\u003cT\u003e() {\n \n         private TypeAdapter\u003cT\u003e delegate;\n \n         @Override\n         public T read(JsonReader reader) throws IOException {\n             if (skipDeserialize) {\n                 reader.skipValue();\n                 return null;\n             }\n             return delegate().read(reader);\n         }\n \n         @Override\n         public void write(JsonWriter writer, T value) throws IOException {\n             if (skipSerialize) {\n                 writer.nullValue();\n                 return;\n             }\n             delegate().write(writer, value);\n         }\n \n         private TypeAdapter\u003cT\u003e delegate() {\n             TypeAdapter\u003cT\u003e d \u003d delegate;\n-            return d !\u003d null ? d : (delegate \u003d context.getNextAdapter(Excluder.this, type));\n+            return d !\u003d null ? d : (delegate \u003d gson.getNextAdapter(Excluder.this, type));\n         }\n     };\n }\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldValue": "[context-Gson(modifiers-final), type-TypeToken\u003cT\u003e(modifiers-final)]",
            "newValue": "[gson-Gson(modifiers-final), type-TypeToken\u003cT\u003e(modifiers-final)]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "Cleanup names for TypeAdapters.\n",
          "commitDate": "12/2/11, 2:57 PM",
          "commitName": "26ab404599643fac25442646b829a65a7f86bca1",
          "commitAuthor": "Jesse Wilson",
          "commitDateOld": "11/21/11, 11:37 PM",
          "commitNameOld": "aa2f61b7d8defddc2a78de43b8042178241daedb",
          "commitAuthorOld": "Jesse Wilson",
          "daysBetweenCommits": 10.64,
          "commitsBetweenForRepo": 15,
          "commitsBetweenForFile": 1,
          "actualSource": "public \u003cT\u003e TypeAdapter\u003cT\u003e create(final Gson gson, final TypeToken\u003cT\u003e type) {\n    Class\u003c?\u003e rawType \u003d type.getRawType();\n    final boolean skipSerialize \u003d excludeClass(rawType, true);\n    final boolean skipDeserialize \u003d excludeClass(rawType, false);\n    if (!skipSerialize \u0026\u0026 !skipDeserialize) {\n        return null;\n    }\n    return new TypeAdapter\u003cT\u003e() {\n\n        private TypeAdapter\u003cT\u003e delegate;\n\n        @Override\n        public T read(JsonReader reader) throws IOException {\n            if (skipDeserialize) {\n                reader.skipValue();\n                return null;\n            }\n            return delegate().read(reader);\n        }\n\n        @Override\n        public void write(JsonWriter writer, T value) throws IOException {\n            if (skipSerialize) {\n                writer.nullValue();\n                return;\n            }\n            delegate().write(writer, value);\n        }\n\n        private TypeAdapter\u003cT\u003e delegate() {\n            TypeAdapter\u003cT\u003e d \u003d delegate;\n            return d !\u003d null ? d : (delegate \u003d gson.getNextAdapter(Excluder.this, type));\n        }\n    };\n}",
          "path": "gson/src/main/java/com/google/gson/internal/Excluder.java",
          "functionStartLine": 110,
          "functionName": "create",
          "functionAnnotation": "",
          "functionDoc": "",
          "diff": "@@ -1,35 +1,35 @@\n-public \u003cT\u003e TypeAdapter\u003cT\u003e create(final Gson context, final TypeToken\u003cT\u003e type) {\n+public \u003cT\u003e TypeAdapter\u003cT\u003e create(final Gson gson, final TypeToken\u003cT\u003e type) {\n     Class\u003c?\u003e rawType \u003d type.getRawType();\n     final boolean skipSerialize \u003d excludeClass(rawType, true);\n     final boolean skipDeserialize \u003d excludeClass(rawType, false);\n     if (!skipSerialize \u0026\u0026 !skipDeserialize) {\n         return null;\n     }\n     return new TypeAdapter\u003cT\u003e() {\n \n         private TypeAdapter\u003cT\u003e delegate;\n \n         @Override\n         public T read(JsonReader reader) throws IOException {\n             if (skipDeserialize) {\n                 reader.skipValue();\n                 return null;\n             }\n             return delegate().read(reader);\n         }\n \n         @Override\n         public void write(JsonWriter writer, T value) throws IOException {\n             if (skipSerialize) {\n                 writer.nullValue();\n                 return;\n             }\n             delegate().write(writer, value);\n         }\n \n         private TypeAdapter\u003cT\u003e delegate() {\n             TypeAdapter\u003cT\u003e d \u003d delegate;\n-            return d !\u003d null ? d : (delegate \u003d context.getNextAdapter(Excluder.this, type));\n+            return d !\u003d null ? d : (delegate \u003d gson.getNextAdapter(Excluder.this, type));\n         }\n     };\n }\n\\ No newline at end of file\n",
          "extendedDetails": {}
        }
      ]
    },
    "aa2f61b7d8defddc2a78de43b8042178241daedb": {
      "type": "Ymultichange(Ymovefromfile,Ybodychange)",
      "commitMessage": "Rename GsonExclusionStrategy to Excluder. The new class is its own factory, which simplifies its caller in GsonBuilder. It no longer implements ExclusionStrategy, which allows the callers to pass in a boolean for serialize/deserialize. This allows us to use one excluder for both code paths. The delegate ExclusionStrategy instances might end up not being shared so it has two lists internally.\n",
      "commitDate": "11/21/11, 11:37 PM",
      "commitName": "aa2f61b7d8defddc2a78de43b8042178241daedb",
      "commitAuthor": "Jesse Wilson",
      "subchanges": [
        {
          "type": "Ymovefromfile",
          "commitMessage": "Rename GsonExclusionStrategy to Excluder. The new class is its own factory, which simplifies its caller in GsonBuilder. It no longer implements ExclusionStrategy, which allows the callers to pass in a boolean for serialize/deserialize. This allows us to use one excluder for both code paths. The delegate ExclusionStrategy instances might end up not being shared so it has two lists internally.\n",
          "commitDate": "11/21/11, 11:37 PM",
          "commitName": "aa2f61b7d8defddc2a78de43b8042178241daedb",
          "commitAuthor": "Jesse Wilson",
          "commitDateOld": "11/21/11, 10:07 PM",
          "commitNameOld": "fed332906debe74d0879c77a03825b66f7970c41",
          "commitAuthorOld": "Jesse Wilson",
          "daysBetweenCommits": 0.06,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "actualSource": "public \u003cT\u003e TypeAdapter\u003cT\u003e create(final Gson context, final TypeToken\u003cT\u003e type) {\n    Class\u003c?\u003e rawType \u003d type.getRawType();\n    final boolean skipSerialize \u003d excludeClass(rawType, true);\n    final boolean skipDeserialize \u003d excludeClass(rawType, false);\n    if (!skipSerialize \u0026\u0026 !skipDeserialize) {\n        return null;\n    }\n    return new TypeAdapter\u003cT\u003e() {\n\n        private TypeAdapter\u003cT\u003e delegate;\n\n        @Override\n        public T read(JsonReader reader) throws IOException {\n            if (skipDeserialize) {\n                reader.skipValue();\n                return null;\n            }\n            return delegate().read(reader);\n        }\n\n        @Override\n        public void write(JsonWriter writer, T value) throws IOException {\n            if (skipSerialize) {\n                writer.nullValue();\n                return;\n            }\n            delegate().write(writer, value);\n        }\n\n        private TypeAdapter\u003cT\u003e delegate() {\n            TypeAdapter\u003cT\u003e d \u003d delegate;\n            return d !\u003d null ? d : (delegate \u003d context.getNextAdapter(Excluder.this, type));\n        }\n    };\n}",
          "path": "gson/src/main/java/com/google/gson/internal/Excluder.java",
          "functionStartLine": 110,
          "functionName": "create",
          "functionAnnotation": "",
          "functionDoc": "",
          "diff": "@@ -1,35 +1,35 @@\n public \u003cT\u003e TypeAdapter\u003cT\u003e create(final Gson context, final TypeToken\u003cT\u003e type) {\n     Class\u003c?\u003e rawType \u003d type.getRawType();\n-    final boolean skipSerialize \u003d serializationExclusionStrategy.shouldSkipClass(rawType);\n-    final boolean skipDeserialize \u003d deserializationExclusionStrategy.shouldSkipClass(rawType);\n+    final boolean skipSerialize \u003d excludeClass(rawType, true);\n+    final boolean skipDeserialize \u003d excludeClass(rawType, false);\n     if (!skipSerialize \u0026\u0026 !skipDeserialize) {\n         return null;\n     }\n     return new TypeAdapter\u003cT\u003e() {\n \n         private TypeAdapter\u003cT\u003e delegate;\n \n         @Override\n         public T read(JsonReader reader) throws IOException {\n             if (skipDeserialize) {\n                 reader.skipValue();\n                 return null;\n             }\n             return delegate().read(reader);\n         }\n \n         @Override\n         public void write(JsonWriter writer, T value) throws IOException {\n             if (skipSerialize) {\n                 writer.nullValue();\n                 return;\n             }\n             delegate().write(writer, value);\n         }\n \n         private TypeAdapter\u003cT\u003e delegate() {\n             TypeAdapter\u003cT\u003e d \u003d delegate;\n-            return d !\u003d null ? d : (delegate \u003d context.getNextAdapter(ExcludedTypeAdapterFactory.this, type));\n+            return d !\u003d null ? d : (delegate \u003d context.getNextAdapter(Excluder.this, type));\n         }\n     };\n }\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldPath": "gson/src/main/java/com/google/gson/internal/bind/ExcludedTypeAdapterFactory.java",
            "newPath": "gson/src/main/java/com/google/gson/internal/Excluder.java",
            "oldMethodName": "create",
            "newMethodName": "create"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "Rename GsonExclusionStrategy to Excluder. The new class is its own factory, which simplifies its caller in GsonBuilder. It no longer implements ExclusionStrategy, which allows the callers to pass in a boolean for serialize/deserialize. This allows us to use one excluder for both code paths. The delegate ExclusionStrategy instances might end up not being shared so it has two lists internally.\n",
          "commitDate": "11/21/11, 11:37 PM",
          "commitName": "aa2f61b7d8defddc2a78de43b8042178241daedb",
          "commitAuthor": "Jesse Wilson",
          "commitDateOld": "11/21/11, 10:07 PM",
          "commitNameOld": "fed332906debe74d0879c77a03825b66f7970c41",
          "commitAuthorOld": "Jesse Wilson",
          "daysBetweenCommits": 0.06,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "actualSource": "public \u003cT\u003e TypeAdapter\u003cT\u003e create(final Gson context, final TypeToken\u003cT\u003e type) {\n    Class\u003c?\u003e rawType \u003d type.getRawType();\n    final boolean skipSerialize \u003d excludeClass(rawType, true);\n    final boolean skipDeserialize \u003d excludeClass(rawType, false);\n    if (!skipSerialize \u0026\u0026 !skipDeserialize) {\n        return null;\n    }\n    return new TypeAdapter\u003cT\u003e() {\n\n        private TypeAdapter\u003cT\u003e delegate;\n\n        @Override\n        public T read(JsonReader reader) throws IOException {\n            if (skipDeserialize) {\n                reader.skipValue();\n                return null;\n            }\n            return delegate().read(reader);\n        }\n\n        @Override\n        public void write(JsonWriter writer, T value) throws IOException {\n            if (skipSerialize) {\n                writer.nullValue();\n                return;\n            }\n            delegate().write(writer, value);\n        }\n\n        private TypeAdapter\u003cT\u003e delegate() {\n            TypeAdapter\u003cT\u003e d \u003d delegate;\n            return d !\u003d null ? d : (delegate \u003d context.getNextAdapter(Excluder.this, type));\n        }\n    };\n}",
          "path": "gson/src/main/java/com/google/gson/internal/Excluder.java",
          "functionStartLine": 110,
          "functionName": "create",
          "functionAnnotation": "",
          "functionDoc": "",
          "diff": "@@ -1,35 +1,35 @@\n public \u003cT\u003e TypeAdapter\u003cT\u003e create(final Gson context, final TypeToken\u003cT\u003e type) {\n     Class\u003c?\u003e rawType \u003d type.getRawType();\n-    final boolean skipSerialize \u003d serializationExclusionStrategy.shouldSkipClass(rawType);\n-    final boolean skipDeserialize \u003d deserializationExclusionStrategy.shouldSkipClass(rawType);\n+    final boolean skipSerialize \u003d excludeClass(rawType, true);\n+    final boolean skipDeserialize \u003d excludeClass(rawType, false);\n     if (!skipSerialize \u0026\u0026 !skipDeserialize) {\n         return null;\n     }\n     return new TypeAdapter\u003cT\u003e() {\n \n         private TypeAdapter\u003cT\u003e delegate;\n \n         @Override\n         public T read(JsonReader reader) throws IOException {\n             if (skipDeserialize) {\n                 reader.skipValue();\n                 return null;\n             }\n             return delegate().read(reader);\n         }\n \n         @Override\n         public void write(JsonWriter writer, T value) throws IOException {\n             if (skipSerialize) {\n                 writer.nullValue();\n                 return;\n             }\n             delegate().write(writer, value);\n         }\n \n         private TypeAdapter\u003cT\u003e delegate() {\n             TypeAdapter\u003cT\u003e d \u003d delegate;\n-            return d !\u003d null ? d : (delegate \u003d context.getNextAdapter(ExcludedTypeAdapterFactory.this, type));\n+            return d !\u003d null ? d : (delegate \u003d context.getNextAdapter(Excluder.this, type));\n         }\n     };\n }\n\\ No newline at end of file\n",
          "extendedDetails": {}
        }
      ]
    },
    "f777a192ee13fd59048aa7ba640cc8023051c89d": {
      "type": "Ybodychange",
      "commitMessage": "Remove dead code and fold contents of single-member helper classes into their clients.\n",
      "commitDate": "11/20/11, 1:02 PM",
      "commitName": "f777a192ee13fd59048aa7ba640cc8023051c89d",
      "commitAuthor": "Jesse Wilson",
      "commitDateOld": "11/20/11, 7:23 AM",
      "commitNameOld": "7e760143fdc8b689daeebdee33ad6ea7d0a62a56",
      "commitAuthorOld": "Jesse Wilson",
      "daysBetweenCommits": 0.24,
      "commitsBetweenForRepo": 7,
      "commitsBetweenForFile": 1,
      "actualSource": "public \u003cT\u003e TypeAdapter\u003cT\u003e create(final Gson context, final TypeToken\u003cT\u003e type) {\n    Class\u003c?\u003e rawType \u003d type.getRawType();\n    final boolean skipSerialize \u003d serializationExclusionStrategy.shouldSkipClass(rawType);\n    final boolean skipDeserialize \u003d deserializationExclusionStrategy.shouldSkipClass(rawType);\n    if (!skipSerialize \u0026\u0026 !skipDeserialize) {\n        return null;\n    }\n    return new TypeAdapter\u003cT\u003e() {\n\n        private TypeAdapter\u003cT\u003e delegate;\n\n        @Override\n        public T read(JsonReader reader) throws IOException {\n            if (skipDeserialize) {\n                reader.skipValue();\n                return null;\n            }\n            return delegate().read(reader);\n        }\n\n        @Override\n        public void write(JsonWriter writer, T value) throws IOException {\n            if (skipSerialize) {\n                writer.nullValue();\n                return;\n            }\n            delegate().write(writer, value);\n        }\n\n        private TypeAdapter\u003cT\u003e delegate() {\n            TypeAdapter\u003cT\u003e d \u003d delegate;\n            return d !\u003d null ? d : (delegate \u003d context.getNextAdapter(ExcludedTypeAdapterFactory.this, type));\n        }\n    };\n}",
      "path": "gson/src/main/java/com/google/gson/internal/bind/ExcludedTypeAdapterFactory.java",
      "functionStartLine": 41,
      "functionName": "create",
      "functionAnnotation": "",
      "functionDoc": "",
      "diff": "",
      "extendedDetails": {}
    },
    "7e760143fdc8b689daeebdee33ad6ea7d0a62a56": {
      "type": "Yparameterchange",
      "commitMessage": "Smash together MiniGson and Gson. This changes Gson to be the MiniGson rather than delegating to the MiniGson. It means that the MiniGson objects passed into streaming type adapters are now fully-capable \u0027Gson\u0027 objects. \n\nThe most notable impact of this change is that it adds several new public APIs:\n - The TypeAdapter abstract class\n - The TypeAdapter.Factory interface\n - Four new methods on GsonBuilder to register streaming TypeAdapters (via Factory, via Class, via TypeToken, and as a type hierarchy)\n - Three new methods on Gson to lookup streaming TypeAdapters (by type, by class, and to get the next type adapter) \n\nStill outstanding:\n - Write beautiful prose to document the new APIs above\n - Change GsonBuilder\u0027s precedence so that both old and new-style type adapters are registered in one lot\n",
      "commitDate": "11/20/11, 7:23 AM",
      "commitName": "7e760143fdc8b689daeebdee33ad6ea7d0a62a56",
      "commitAuthor": "Jesse Wilson",
      "commitDateOld": "9/11/11, 12:04 AM",
      "commitNameOld": "25c6ae177b1ca56db7f3c29eb574bdd032a06165",
      "commitAuthorOld": "Jesse Wilson",
      "daysBetweenCommits": 70.35,
      "commitsBetweenForRepo": 85,
      "commitsBetweenForFile": 1,
      "actualSource": "public \u003cT\u003e TypeAdapter\u003cT\u003e create(final Gson context, final TypeToken\u003cT\u003e type) {\n    Class\u003c?\u003e rawType \u003d type.getRawType();\n    final boolean skipSerialize \u003d serializationExclusionStrategy.shouldSkipClass(rawType);\n    final boolean skipDeserialize \u003d deserializationExclusionStrategy.shouldSkipClass(rawType);\n    if (!skipSerialize \u0026\u0026 !skipDeserialize) {\n        return null;\n    }\n    return new TypeAdapter\u003cT\u003e() {\n\n        private TypeAdapter\u003cT\u003e delegate;\n\n        @Override\n        public T read(JsonReader reader) throws IOException {\n            if (skipDeserialize) {\n                reader.skipValue();\n                return null;\n            }\n            return delegate().read(reader);\n        }\n\n        @Override\n        public void write(JsonWriter writer, T value) throws IOException {\n            if (skipSerialize) {\n                writer.nullValue();\n                return;\n            }\n            delegate().write(writer, value);\n        }\n\n        private TypeAdapter\u003cT\u003e delegate() {\n            TypeAdapter\u003cT\u003e d \u003d delegate;\n            return d !\u003d null ? d : (delegate \u003d context.getNextAdapter(ExcludedTypeAdapterFactory.this, type));\n        }\n    };\n}",
      "path": "gson/src/main/java/com/google/gson/internal/bind/ExcludedTypeAdapterFactory.java",
      "functionStartLine": 41,
      "functionName": "create",
      "functionAnnotation": "",
      "functionDoc": "",
      "diff": "@@ -1,35 +1,35 @@\n-public \u003cT\u003e TypeAdapter\u003cT\u003e create(final MiniGson context, final TypeToken\u003cT\u003e type) {\n+public \u003cT\u003e TypeAdapter\u003cT\u003e create(final Gson context, final TypeToken\u003cT\u003e type) {\n     Class\u003c?\u003e rawType \u003d type.getRawType();\n     final boolean skipSerialize \u003d serializationExclusionStrategy.shouldSkipClass(rawType);\n     final boolean skipDeserialize \u003d deserializationExclusionStrategy.shouldSkipClass(rawType);\n     if (!skipSerialize \u0026\u0026 !skipDeserialize) {\n         return null;\n     }\n     return new TypeAdapter\u003cT\u003e() {\n \n         private TypeAdapter\u003cT\u003e delegate;\n \n         @Override\n         public T read(JsonReader reader) throws IOException {\n             if (skipDeserialize) {\n                 reader.skipValue();\n                 return null;\n             }\n             return delegate().read(reader);\n         }\n \n         @Override\n         public void write(JsonWriter writer, T value) throws IOException {\n             if (skipSerialize) {\n                 writer.nullValue();\n                 return;\n             }\n             delegate().write(writer, value);\n         }\n \n         private TypeAdapter\u003cT\u003e delegate() {\n             TypeAdapter\u003cT\u003e d \u003d delegate;\n             return d !\u003d null ? d : (delegate \u003d context.getNextAdapter(ExcludedTypeAdapterFactory.this, type));\n         }\n     };\n }\n\\ No newline at end of file\n",
      "extendedDetails": {
        "oldValue": "[context-MiniGson(modifiers-final), type-TypeToken\u003cT\u003e(modifiers-final)]",
        "newValue": "[context-Gson(modifiers-final), type-TypeToken\u003cT\u003e(modifiers-final)]"
      }
    },
    "25c6ae177b1ca56db7f3c29eb574bdd032a06165": {
      "type": "Ymultichange(Ymovefromfile,Ybodychange,Yparametermetachange,Yparameterchange)",
      "commitMessage": "Down to 22 failing tests.\n\nConsolidated all of the different code paths that we use to construct instances. We now have an ObjectConstructor class that knows what type it constructs; this means that we don\u0027t need to ever do reflection to lookup a constructor at construction time.\n\nCleaned up some buggy type adapters, particularly around handling of null.\n\nRemoved dead code for object graph navigation.\n\nMoved some classes into \u0027internal\u0027 so they are visible to the \u0027bind\u0027 subpackage.\n\nTurned some TypeAdapterFactory/TypeAdapter pairs inside out so that the TypeAdapter is now the inner class. This is necessary so that the factories can take parameters.\n\nAdded an API to request the \u0027next\u0027 type adapter for a type. This allows type adapters to compose other type adapters. We\u0027re using this in two places:\n - where the user has excluded a type from serialization but not deserialization, we need to use the \"default\" deserialization but interpose null on serialization. We create a type adapter that delegates for one and returns null for the other.\n - similarly when a DOM type serializer is registered but no deserializer, or vice versa.\nThis is the biggest change to the MiniGson core.\n\nFor backwards compatibility, return null for the empty string.\n\nSimplify JsonSerializationContext/JsonDeserializationContext to simply call through to GSON. SerializeDefault is currently unsupported.\n\nMore useful error messages when calling getAsBoolean on a JsonNull.\n\nRemove currently unused MemoryRefStack. We might need this back again, though wiring it back in will be much more difficult because we don\u0027t interject ourselves between the users\u0027 various type adapters.\n",
      "commitDate": "9/11/11, 12:04 AM",
      "commitName": "25c6ae177b1ca56db7f3c29eb574bdd032a06165",
      "commitAuthor": "Jesse Wilson",
      "subchanges": [
        {
          "type": "Ymovefromfile",
          "commitMessage": "Down to 22 failing tests.\n\nConsolidated all of the different code paths that we use to construct instances. We now have an ObjectConstructor class that knows what type it constructs; this means that we don\u0027t need to ever do reflection to lookup a constructor at construction time.\n\nCleaned up some buggy type adapters, particularly around handling of null.\n\nRemoved dead code for object graph navigation.\n\nMoved some classes into \u0027internal\u0027 so they are visible to the \u0027bind\u0027 subpackage.\n\nTurned some TypeAdapterFactory/TypeAdapter pairs inside out so that the TypeAdapter is now the inner class. This is necessary so that the factories can take parameters.\n\nAdded an API to request the \u0027next\u0027 type adapter for a type. This allows type adapters to compose other type adapters. We\u0027re using this in two places:\n - where the user has excluded a type from serialization but not deserialization, we need to use the \"default\" deserialization but interpose null on serialization. We create a type adapter that delegates for one and returns null for the other.\n - similarly when a DOM type serializer is registered but no deserializer, or vice versa.\nThis is the biggest change to the MiniGson core.\n\nFor backwards compatibility, return null for the empty string.\n\nSimplify JsonSerializationContext/JsonDeserializationContext to simply call through to GSON. SerializeDefault is currently unsupported.\n\nMore useful error messages when calling getAsBoolean on a JsonNull.\n\nRemove currently unused MemoryRefStack. We might need this back again, though wiring it back in will be much more difficult because we don\u0027t interject ourselves between the users\u0027 various type adapters.\n",
          "commitDate": "9/11/11, 12:04 AM",
          "commitName": "25c6ae177b1ca56db7f3c29eb574bdd032a06165",
          "commitAuthor": "Jesse Wilson",
          "commitDateOld": "9/9/11, 1:17 AM",
          "commitNameOld": "cdd5d80b85155c21c61f888fb3e70c65e72edef7",
          "commitAuthorOld": "Jesse Wilson",
          "daysBetweenCommits": 1.95,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "actualSource": "public \u003cT\u003e TypeAdapter\u003cT\u003e create(final MiniGson context, final TypeToken\u003cT\u003e type) {\n    Class\u003c?\u003e rawType \u003d type.getRawType();\n    final boolean skipSerialize \u003d serializationExclusionStrategy.shouldSkipClass(rawType);\n    final boolean skipDeserialize \u003d deserializationExclusionStrategy.shouldSkipClass(rawType);\n    if (!skipSerialize \u0026\u0026 !skipDeserialize) {\n        return null;\n    }\n    return new TypeAdapter\u003cT\u003e() {\n\n        private TypeAdapter\u003cT\u003e delegate;\n\n        @Override\n        public T read(JsonReader reader) throws IOException {\n            if (skipDeserialize) {\n                reader.skipValue();\n                return null;\n            }\n            return delegate().read(reader);\n        }\n\n        @Override\n        public void write(JsonWriter writer, T value) throws IOException {\n            if (skipSerialize) {\n                writer.nullValue();\n                return;\n            }\n            delegate().write(writer, value);\n        }\n\n        private TypeAdapter\u003cT\u003e delegate() {\n            TypeAdapter\u003cT\u003e d \u003d delegate;\n            return d !\u003d null ? d : (delegate \u003d context.getNextAdapter(ExcludedTypeAdapterFactory.this, type));\n        }\n    };\n}",
          "path": "gson/src/main/java/com/google/gson/internal/bind/ExcludedTypeAdapterFactory.java",
          "functionStartLine": 39,
          "functionName": "create",
          "functionAnnotation": "",
          "functionDoc": "",
          "diff": "@@ -1,35 +1,35 @@\n-public \u003cT\u003e TypeAdapter\u003cT\u003e create(final MiniGson miniGson, TypeToken\u003cT\u003e type) {\n-    final Type typeOfT \u003d type.getType();\n-    final JsonSerializer serializer \u003d serializers.getHandlerFor(typeOfT, false);\n-    final JsonDeserializer deserializer \u003d deserializers.getHandlerFor(typeOfT, false);\n-    if (serializer \u003d\u003d null \u0026\u0026 deserializer \u003d\u003d null) {\n+public \u003cT\u003e TypeAdapter\u003cT\u003e create(final MiniGson context, final TypeToken\u003cT\u003e type) {\n+    Class\u003c?\u003e rawType \u003d type.getRawType();\n+    final boolean skipSerialize \u003d serializationExclusionStrategy.shouldSkipClass(rawType);\n+    final boolean skipDeserialize \u003d deserializationExclusionStrategy.shouldSkipClass(rawType);\n+    if (!skipSerialize \u0026\u0026 !skipDeserialize) {\n         return null;\n     }\n-    return new TypeAdapter() {\n+    return new TypeAdapter\u003cT\u003e() {\n+\n+        private TypeAdapter\u003cT\u003e delegate;\n \n         @Override\n-        public Object read(JsonReader reader) throws IOException {\n-            if (deserializer \u003d\u003d null) {\n-                throw new UnsupportedOperationException();\n-            }\n-            JsonElement value \u003d Streams.parse(reader);\n-            if (value.isJsonNull()) {\n+        public T read(JsonReader reader) throws IOException {\n+            if (skipDeserialize) {\n+                reader.skipValue();\n                 return null;\n             }\n-            return deserializer.deserialize(value, typeOfT, createDeserializationContext(miniGson));\n+            return delegate().read(reader);\n         }\n \n         @Override\n-        public void write(JsonWriter writer, Object value) throws IOException {\n-            if (serializer \u003d\u003d null) {\n-                throw new UnsupportedOperationException();\n-            }\n-            if (value \u003d\u003d null) {\n+        public void write(JsonWriter writer, T value) throws IOException {\n+            if (skipSerialize) {\n                 writer.nullValue();\n                 return;\n             }\n-            JsonElement element \u003d serializer.serialize(value, typeOfT, createSerializationContext(miniGson));\n-            Streams.write(element, serializeNulls, writer);\n+            delegate().write(writer, value);\n+        }\n+\n+        private TypeAdapter\u003cT\u003e delegate() {\n+            TypeAdapter\u003cT\u003e d \u003d delegate;\n+            return d !\u003d null ? d : (delegate \u003d context.getNextAdapter(ExcludedTypeAdapterFactory.this, type));\n         }\n     };\n }\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldPath": "gson/src/main/java/com/google/gson/GsonToMiniGsonTypeAdapter.java",
            "newPath": "gson/src/main/java/com/google/gson/internal/bind/ExcludedTypeAdapterFactory.java",
            "oldMethodName": "create",
            "newMethodName": "create"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "Down to 22 failing tests.\n\nConsolidated all of the different code paths that we use to construct instances. We now have an ObjectConstructor class that knows what type it constructs; this means that we don\u0027t need to ever do reflection to lookup a constructor at construction time.\n\nCleaned up some buggy type adapters, particularly around handling of null.\n\nRemoved dead code for object graph navigation.\n\nMoved some classes into \u0027internal\u0027 so they are visible to the \u0027bind\u0027 subpackage.\n\nTurned some TypeAdapterFactory/TypeAdapter pairs inside out so that the TypeAdapter is now the inner class. This is necessary so that the factories can take parameters.\n\nAdded an API to request the \u0027next\u0027 type adapter for a type. This allows type adapters to compose other type adapters. We\u0027re using this in two places:\n - where the user has excluded a type from serialization but not deserialization, we need to use the \"default\" deserialization but interpose null on serialization. We create a type adapter that delegates for one and returns null for the other.\n - similarly when a DOM type serializer is registered but no deserializer, or vice versa.\nThis is the biggest change to the MiniGson core.\n\nFor backwards compatibility, return null for the empty string.\n\nSimplify JsonSerializationContext/JsonDeserializationContext to simply call through to GSON. SerializeDefault is currently unsupported.\n\nMore useful error messages when calling getAsBoolean on a JsonNull.\n\nRemove currently unused MemoryRefStack. We might need this back again, though wiring it back in will be much more difficult because we don\u0027t interject ourselves between the users\u0027 various type adapters.\n",
          "commitDate": "9/11/11, 12:04 AM",
          "commitName": "25c6ae177b1ca56db7f3c29eb574bdd032a06165",
          "commitAuthor": "Jesse Wilson",
          "commitDateOld": "9/9/11, 1:17 AM",
          "commitNameOld": "cdd5d80b85155c21c61f888fb3e70c65e72edef7",
          "commitAuthorOld": "Jesse Wilson",
          "daysBetweenCommits": 1.95,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "actualSource": "public \u003cT\u003e TypeAdapter\u003cT\u003e create(final MiniGson context, final TypeToken\u003cT\u003e type) {\n    Class\u003c?\u003e rawType \u003d type.getRawType();\n    final boolean skipSerialize \u003d serializationExclusionStrategy.shouldSkipClass(rawType);\n    final boolean skipDeserialize \u003d deserializationExclusionStrategy.shouldSkipClass(rawType);\n    if (!skipSerialize \u0026\u0026 !skipDeserialize) {\n        return null;\n    }\n    return new TypeAdapter\u003cT\u003e() {\n\n        private TypeAdapter\u003cT\u003e delegate;\n\n        @Override\n        public T read(JsonReader reader) throws IOException {\n            if (skipDeserialize) {\n                reader.skipValue();\n                return null;\n            }\n            return delegate().read(reader);\n        }\n\n        @Override\n        public void write(JsonWriter writer, T value) throws IOException {\n            if (skipSerialize) {\n                writer.nullValue();\n                return;\n            }\n            delegate().write(writer, value);\n        }\n\n        private TypeAdapter\u003cT\u003e delegate() {\n            TypeAdapter\u003cT\u003e d \u003d delegate;\n            return d !\u003d null ? d : (delegate \u003d context.getNextAdapter(ExcludedTypeAdapterFactory.this, type));\n        }\n    };\n}",
          "path": "gson/src/main/java/com/google/gson/internal/bind/ExcludedTypeAdapterFactory.java",
          "functionStartLine": 39,
          "functionName": "create",
          "functionAnnotation": "",
          "functionDoc": "",
          "diff": "@@ -1,35 +1,35 @@\n-public \u003cT\u003e TypeAdapter\u003cT\u003e create(final MiniGson miniGson, TypeToken\u003cT\u003e type) {\n-    final Type typeOfT \u003d type.getType();\n-    final JsonSerializer serializer \u003d serializers.getHandlerFor(typeOfT, false);\n-    final JsonDeserializer deserializer \u003d deserializers.getHandlerFor(typeOfT, false);\n-    if (serializer \u003d\u003d null \u0026\u0026 deserializer \u003d\u003d null) {\n+public \u003cT\u003e TypeAdapter\u003cT\u003e create(final MiniGson context, final TypeToken\u003cT\u003e type) {\n+    Class\u003c?\u003e rawType \u003d type.getRawType();\n+    final boolean skipSerialize \u003d serializationExclusionStrategy.shouldSkipClass(rawType);\n+    final boolean skipDeserialize \u003d deserializationExclusionStrategy.shouldSkipClass(rawType);\n+    if (!skipSerialize \u0026\u0026 !skipDeserialize) {\n         return null;\n     }\n-    return new TypeAdapter() {\n+    return new TypeAdapter\u003cT\u003e() {\n+\n+        private TypeAdapter\u003cT\u003e delegate;\n \n         @Override\n-        public Object read(JsonReader reader) throws IOException {\n-            if (deserializer \u003d\u003d null) {\n-                throw new UnsupportedOperationException();\n-            }\n-            JsonElement value \u003d Streams.parse(reader);\n-            if (value.isJsonNull()) {\n+        public T read(JsonReader reader) throws IOException {\n+            if (skipDeserialize) {\n+                reader.skipValue();\n                 return null;\n             }\n-            return deserializer.deserialize(value, typeOfT, createDeserializationContext(miniGson));\n+            return delegate().read(reader);\n         }\n \n         @Override\n-        public void write(JsonWriter writer, Object value) throws IOException {\n-            if (serializer \u003d\u003d null) {\n-                throw new UnsupportedOperationException();\n-            }\n-            if (value \u003d\u003d null) {\n+        public void write(JsonWriter writer, T value) throws IOException {\n+            if (skipSerialize) {\n                 writer.nullValue();\n                 return;\n             }\n-            JsonElement element \u003d serializer.serialize(value, typeOfT, createSerializationContext(miniGson));\n-            Streams.write(element, serializeNulls, writer);\n+            delegate().write(writer, value);\n+        }\n+\n+        private TypeAdapter\u003cT\u003e delegate() {\n+            TypeAdapter\u003cT\u003e d \u003d delegate;\n+            return d !\u003d null ? d : (delegate \u003d context.getNextAdapter(ExcludedTypeAdapterFactory.this, type));\n         }\n     };\n }\n\\ No newline at end of file\n",
          "extendedDetails": {}
        },
        {
          "type": "Yparametermetachange",
          "commitMessage": "Down to 22 failing tests.\n\nConsolidated all of the different code paths that we use to construct instances. We now have an ObjectConstructor class that knows what type it constructs; this means that we don\u0027t need to ever do reflection to lookup a constructor at construction time.\n\nCleaned up some buggy type adapters, particularly around handling of null.\n\nRemoved dead code for object graph navigation.\n\nMoved some classes into \u0027internal\u0027 so they are visible to the \u0027bind\u0027 subpackage.\n\nTurned some TypeAdapterFactory/TypeAdapter pairs inside out so that the TypeAdapter is now the inner class. This is necessary so that the factories can take parameters.\n\nAdded an API to request the \u0027next\u0027 type adapter for a type. This allows type adapters to compose other type adapters. We\u0027re using this in two places:\n - where the user has excluded a type from serialization but not deserialization, we need to use the \"default\" deserialization but interpose null on serialization. We create a type adapter that delegates for one and returns null for the other.\n - similarly when a DOM type serializer is registered but no deserializer, or vice versa.\nThis is the biggest change to the MiniGson core.\n\nFor backwards compatibility, return null for the empty string.\n\nSimplify JsonSerializationContext/JsonDeserializationContext to simply call through to GSON. SerializeDefault is currently unsupported.\n\nMore useful error messages when calling getAsBoolean on a JsonNull.\n\nRemove currently unused MemoryRefStack. We might need this back again, though wiring it back in will be much more difficult because we don\u0027t interject ourselves between the users\u0027 various type adapters.\n",
          "commitDate": "9/11/11, 12:04 AM",
          "commitName": "25c6ae177b1ca56db7f3c29eb574bdd032a06165",
          "commitAuthor": "Jesse Wilson",
          "commitDateOld": "9/9/11, 1:17 AM",
          "commitNameOld": "cdd5d80b85155c21c61f888fb3e70c65e72edef7",
          "commitAuthorOld": "Jesse Wilson",
          "daysBetweenCommits": 1.95,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "actualSource": "public \u003cT\u003e TypeAdapter\u003cT\u003e create(final MiniGson context, final TypeToken\u003cT\u003e type) {\n    Class\u003c?\u003e rawType \u003d type.getRawType();\n    final boolean skipSerialize \u003d serializationExclusionStrategy.shouldSkipClass(rawType);\n    final boolean skipDeserialize \u003d deserializationExclusionStrategy.shouldSkipClass(rawType);\n    if (!skipSerialize \u0026\u0026 !skipDeserialize) {\n        return null;\n    }\n    return new TypeAdapter\u003cT\u003e() {\n\n        private TypeAdapter\u003cT\u003e delegate;\n\n        @Override\n        public T read(JsonReader reader) throws IOException {\n            if (skipDeserialize) {\n                reader.skipValue();\n                return null;\n            }\n            return delegate().read(reader);\n        }\n\n        @Override\n        public void write(JsonWriter writer, T value) throws IOException {\n            if (skipSerialize) {\n                writer.nullValue();\n                return;\n            }\n            delegate().write(writer, value);\n        }\n\n        private TypeAdapter\u003cT\u003e delegate() {\n            TypeAdapter\u003cT\u003e d \u003d delegate;\n            return d !\u003d null ? d : (delegate \u003d context.getNextAdapter(ExcludedTypeAdapterFactory.this, type));\n        }\n    };\n}",
          "path": "gson/src/main/java/com/google/gson/internal/bind/ExcludedTypeAdapterFactory.java",
          "functionStartLine": 39,
          "functionName": "create",
          "functionAnnotation": "",
          "functionDoc": "",
          "diff": "@@ -1,35 +1,35 @@\n-public \u003cT\u003e TypeAdapter\u003cT\u003e create(final MiniGson miniGson, TypeToken\u003cT\u003e type) {\n-    final Type typeOfT \u003d type.getType();\n-    final JsonSerializer serializer \u003d serializers.getHandlerFor(typeOfT, false);\n-    final JsonDeserializer deserializer \u003d deserializers.getHandlerFor(typeOfT, false);\n-    if (serializer \u003d\u003d null \u0026\u0026 deserializer \u003d\u003d null) {\n+public \u003cT\u003e TypeAdapter\u003cT\u003e create(final MiniGson context, final TypeToken\u003cT\u003e type) {\n+    Class\u003c?\u003e rawType \u003d type.getRawType();\n+    final boolean skipSerialize \u003d serializationExclusionStrategy.shouldSkipClass(rawType);\n+    final boolean skipDeserialize \u003d deserializationExclusionStrategy.shouldSkipClass(rawType);\n+    if (!skipSerialize \u0026\u0026 !skipDeserialize) {\n         return null;\n     }\n-    return new TypeAdapter() {\n+    return new TypeAdapter\u003cT\u003e() {\n+\n+        private TypeAdapter\u003cT\u003e delegate;\n \n         @Override\n-        public Object read(JsonReader reader) throws IOException {\n-            if (deserializer \u003d\u003d null) {\n-                throw new UnsupportedOperationException();\n-            }\n-            JsonElement value \u003d Streams.parse(reader);\n-            if (value.isJsonNull()) {\n+        public T read(JsonReader reader) throws IOException {\n+            if (skipDeserialize) {\n+                reader.skipValue();\n                 return null;\n             }\n-            return deserializer.deserialize(value, typeOfT, createDeserializationContext(miniGson));\n+            return delegate().read(reader);\n         }\n \n         @Override\n-        public void write(JsonWriter writer, Object value) throws IOException {\n-            if (serializer \u003d\u003d null) {\n-                throw new UnsupportedOperationException();\n-            }\n-            if (value \u003d\u003d null) {\n+        public void write(JsonWriter writer, T value) throws IOException {\n+            if (skipSerialize) {\n                 writer.nullValue();\n                 return;\n             }\n-            JsonElement element \u003d serializer.serialize(value, typeOfT, createSerializationContext(miniGson));\n-            Streams.write(element, serializeNulls, writer);\n+            delegate().write(writer, value);\n+        }\n+\n+        private TypeAdapter\u003cT\u003e delegate() {\n+            TypeAdapter\u003cT\u003e d \u003d delegate;\n+            return d !\u003d null ? d : (delegate \u003d context.getNextAdapter(ExcludedTypeAdapterFactory.this, type));\n         }\n     };\n }\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldValue": "[miniGson-MiniGson(modifiers-final), type-TypeToken\u003cT\u003e]",
            "newValue": "[context-MiniGson(modifiers-final), type-TypeToken\u003cT\u003e(modifiers-final)]"
          }
        },
        {
          "type": "Yparameterchange",
          "commitMessage": "Down to 22 failing tests.\n\nConsolidated all of the different code paths that we use to construct instances. We now have an ObjectConstructor class that knows what type it constructs; this means that we don\u0027t need to ever do reflection to lookup a constructor at construction time.\n\nCleaned up some buggy type adapters, particularly around handling of null.\n\nRemoved dead code for object graph navigation.\n\nMoved some classes into \u0027internal\u0027 so they are visible to the \u0027bind\u0027 subpackage.\n\nTurned some TypeAdapterFactory/TypeAdapter pairs inside out so that the TypeAdapter is now the inner class. This is necessary so that the factories can take parameters.\n\nAdded an API to request the \u0027next\u0027 type adapter for a type. This allows type adapters to compose other type adapters. We\u0027re using this in two places:\n - where the user has excluded a type from serialization but not deserialization, we need to use the \"default\" deserialization but interpose null on serialization. We create a type adapter that delegates for one and returns null for the other.\n - similarly when a DOM type serializer is registered but no deserializer, or vice versa.\nThis is the biggest change to the MiniGson core.\n\nFor backwards compatibility, return null for the empty string.\n\nSimplify JsonSerializationContext/JsonDeserializationContext to simply call through to GSON. SerializeDefault is currently unsupported.\n\nMore useful error messages when calling getAsBoolean on a JsonNull.\n\nRemove currently unused MemoryRefStack. We might need this back again, though wiring it back in will be much more difficult because we don\u0027t interject ourselves between the users\u0027 various type adapters.\n",
          "commitDate": "9/11/11, 12:04 AM",
          "commitName": "25c6ae177b1ca56db7f3c29eb574bdd032a06165",
          "commitAuthor": "Jesse Wilson",
          "commitDateOld": "9/9/11, 1:17 AM",
          "commitNameOld": "cdd5d80b85155c21c61f888fb3e70c65e72edef7",
          "commitAuthorOld": "Jesse Wilson",
          "daysBetweenCommits": 1.95,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "actualSource": "public \u003cT\u003e TypeAdapter\u003cT\u003e create(final MiniGson context, final TypeToken\u003cT\u003e type) {\n    Class\u003c?\u003e rawType \u003d type.getRawType();\n    final boolean skipSerialize \u003d serializationExclusionStrategy.shouldSkipClass(rawType);\n    final boolean skipDeserialize \u003d deserializationExclusionStrategy.shouldSkipClass(rawType);\n    if (!skipSerialize \u0026\u0026 !skipDeserialize) {\n        return null;\n    }\n    return new TypeAdapter\u003cT\u003e() {\n\n        private TypeAdapter\u003cT\u003e delegate;\n\n        @Override\n        public T read(JsonReader reader) throws IOException {\n            if (skipDeserialize) {\n                reader.skipValue();\n                return null;\n            }\n            return delegate().read(reader);\n        }\n\n        @Override\n        public void write(JsonWriter writer, T value) throws IOException {\n            if (skipSerialize) {\n                writer.nullValue();\n                return;\n            }\n            delegate().write(writer, value);\n        }\n\n        private TypeAdapter\u003cT\u003e delegate() {\n            TypeAdapter\u003cT\u003e d \u003d delegate;\n            return d !\u003d null ? d : (delegate \u003d context.getNextAdapter(ExcludedTypeAdapterFactory.this, type));\n        }\n    };\n}",
          "path": "gson/src/main/java/com/google/gson/internal/bind/ExcludedTypeAdapterFactory.java",
          "functionStartLine": 39,
          "functionName": "create",
          "functionAnnotation": "",
          "functionDoc": "",
          "diff": "@@ -1,35 +1,35 @@\n-public \u003cT\u003e TypeAdapter\u003cT\u003e create(final MiniGson miniGson, TypeToken\u003cT\u003e type) {\n-    final Type typeOfT \u003d type.getType();\n-    final JsonSerializer serializer \u003d serializers.getHandlerFor(typeOfT, false);\n-    final JsonDeserializer deserializer \u003d deserializers.getHandlerFor(typeOfT, false);\n-    if (serializer \u003d\u003d null \u0026\u0026 deserializer \u003d\u003d null) {\n+public \u003cT\u003e TypeAdapter\u003cT\u003e create(final MiniGson context, final TypeToken\u003cT\u003e type) {\n+    Class\u003c?\u003e rawType \u003d type.getRawType();\n+    final boolean skipSerialize \u003d serializationExclusionStrategy.shouldSkipClass(rawType);\n+    final boolean skipDeserialize \u003d deserializationExclusionStrategy.shouldSkipClass(rawType);\n+    if (!skipSerialize \u0026\u0026 !skipDeserialize) {\n         return null;\n     }\n-    return new TypeAdapter() {\n+    return new TypeAdapter\u003cT\u003e() {\n+\n+        private TypeAdapter\u003cT\u003e delegate;\n \n         @Override\n-        public Object read(JsonReader reader) throws IOException {\n-            if (deserializer \u003d\u003d null) {\n-                throw new UnsupportedOperationException();\n-            }\n-            JsonElement value \u003d Streams.parse(reader);\n-            if (value.isJsonNull()) {\n+        public T read(JsonReader reader) throws IOException {\n+            if (skipDeserialize) {\n+                reader.skipValue();\n                 return null;\n             }\n-            return deserializer.deserialize(value, typeOfT, createDeserializationContext(miniGson));\n+            return delegate().read(reader);\n         }\n \n         @Override\n-        public void write(JsonWriter writer, Object value) throws IOException {\n-            if (serializer \u003d\u003d null) {\n-                throw new UnsupportedOperationException();\n-            }\n-            if (value \u003d\u003d null) {\n+        public void write(JsonWriter writer, T value) throws IOException {\n+            if (skipSerialize) {\n                 writer.nullValue();\n                 return;\n             }\n-            JsonElement element \u003d serializer.serialize(value, typeOfT, createSerializationContext(miniGson));\n-            Streams.write(element, serializeNulls, writer);\n+            delegate().write(writer, value);\n+        }\n+\n+        private TypeAdapter\u003cT\u003e delegate() {\n+            TypeAdapter\u003cT\u003e d \u003d delegate;\n+            return d !\u003d null ? d : (delegate \u003d context.getNextAdapter(ExcludedTypeAdapterFactory.this, type));\n         }\n     };\n }\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldValue": "[miniGson-MiniGson(modifiers-final), type-TypeToken\u003cT\u003e]",
            "newValue": "[context-MiniGson(modifiers-final), type-TypeToken\u003cT\u003e(modifiers-final)]"
          }
        }
      ]
    },
    "f50cce6d142e4e0b4bc6c9b52bf6ed82a9c7afaa": {
      "type": "Ybodychange",
      "commitMessage": "Don\u0027t call deserializers with null\n",
      "commitDate": "9/9/11, 1:13 AM",
      "commitName": "f50cce6d142e4e0b4bc6c9b52bf6ed82a9c7afaa",
      "commitAuthor": "Jesse Wilson",
      "commitDateOld": "9/8/11, 8:31 PM",
      "commitNameOld": "3aeb70e0305a598a9ceddc0390d693874dcc892d",
      "commitAuthorOld": "Jesse Wilson",
      "daysBetweenCommits": 0.2,
      "commitsBetweenForRepo": 23,
      "commitsBetweenForFile": 1,
      "actualSource": "public \u003cT\u003e TypeAdapter\u003cT\u003e create(final MiniGson miniGson, TypeToken\u003cT\u003e type) {\n    final Type typeOfT \u003d type.getType();\n    final JsonSerializer serializer \u003d serializers.getHandlerFor(typeOfT, false);\n    final JsonDeserializer deserializer \u003d deserializers.getHandlerFor(typeOfT, false);\n    if (serializer \u003d\u003d null \u0026\u0026 deserializer \u003d\u003d null) {\n        return null;\n    }\n    return new TypeAdapter() {\n\n        @Override\n        public Object read(JsonReader reader) throws IOException {\n            if (deserializer \u003d\u003d null) {\n                throw new UnsupportedOperationException();\n            }\n            JsonElement value \u003d Streams.parse(reader);\n            if (value.isJsonNull()) {\n                return null;\n            }\n            return deserializer.deserialize(value, typeOfT, createDeserializationContext(miniGson));\n        }\n\n        @Override\n        public void write(JsonWriter writer, Object value) throws IOException {\n            if (serializer \u003d\u003d null) {\n                throw new UnsupportedOperationException();\n            }\n            if (value \u003d\u003d null) {\n                writer.nullValue();\n                return;\n            }\n            JsonElement element \u003d serializer.serialize(value, typeOfT, createSerializationContext(miniGson));\n            Streams.write(element, serializeNulls, writer);\n        }\n    };\n}",
      "path": "gson/src/main/java/com/google/gson/GsonToMiniGsonTypeAdapter.java",
      "functionStartLine": 40,
      "functionName": "create",
      "functionAnnotation": "",
      "functionDoc": "",
      "diff": "@@ -1,31 +1,35 @@\n public \u003cT\u003e TypeAdapter\u003cT\u003e create(final MiniGson miniGson, TypeToken\u003cT\u003e type) {\n     final Type typeOfT \u003d type.getType();\n     final JsonSerializer serializer \u003d serializers.getHandlerFor(typeOfT, false);\n     final JsonDeserializer deserializer \u003d deserializers.getHandlerFor(typeOfT, false);\n     if (serializer \u003d\u003d null \u0026\u0026 deserializer \u003d\u003d null) {\n         return null;\n     }\n     return new TypeAdapter() {\n \n         @Override\n         public Object read(JsonReader reader) throws IOException {\n             if (deserializer \u003d\u003d null) {\n                 throw new UnsupportedOperationException();\n             }\n-            return deserializer.deserialize(Streams.parse(reader), typeOfT, createDeserializationContext(miniGson));\n+            JsonElement value \u003d Streams.parse(reader);\n+            if (value.isJsonNull()) {\n+                return null;\n+            }\n+            return deserializer.deserialize(value, typeOfT, createDeserializationContext(miniGson));\n         }\n \n         @Override\n         public void write(JsonWriter writer, Object value) throws IOException {\n             if (serializer \u003d\u003d null) {\n                 throw new UnsupportedOperationException();\n             }\n             if (value \u003d\u003d null) {\n                 writer.nullValue();\n                 return;\n             }\n             JsonElement element \u003d serializer.serialize(value, typeOfT, createSerializationContext(miniGson));\n             Streams.write(element, serializeNulls, writer);\n         }\n     };\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "d70fb90ef77be3d34686a98335fb1747f66b448b": {
      "type": "Ybodychange",
      "commitMessage": "Added methods to convert to JsonElement in TypeAdapter.\nUsing lenient mode while working with Gson.\nHandling nulls while invoking legacy Gson type adapters.\n",
      "commitDate": "8/2/11, 7:40 PM",
      "commitName": "d70fb90ef77be3d34686a98335fb1747f66b448b",
      "commitAuthor": "Inderjeet Singh",
      "commitDateOld": "8/2/11, 7:17 PM",
      "commitNameOld": "566c27cf211fcf307bcb94b47dbbe992fbe0d2d9",
      "commitAuthorOld": "Inderjeet Singh",
      "daysBetweenCommits": 0.02,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "public \u003cT\u003e TypeAdapter\u003cT\u003e create(final MiniGson miniGson, TypeToken\u003cT\u003e type) {\n    final Type typeOfT \u003d type.getType();\n    final JsonSerializer serializer \u003d serializers.getHandlerFor(typeOfT, false);\n    final JsonDeserializer deserializer \u003d deserializers.getHandlerFor(typeOfT, false);\n    if (serializer \u003d\u003d null \u0026\u0026 deserializer \u003d\u003d null) {\n        return null;\n    }\n    return new TypeAdapter() {\n\n        @Override\n        public Object read(JsonReader reader) throws IOException {\n            if (deserializer \u003d\u003d null) {\n                throw new UnsupportedOperationException();\n            }\n            return deserializer.deserialize(Streams.parse(reader), typeOfT, createDeserializationContext(miniGson));\n        }\n\n        @Override\n        public void write(JsonWriter writer, Object value) throws IOException {\n            if (serializer \u003d\u003d null) {\n                throw new UnsupportedOperationException();\n            }\n            if (value \u003d\u003d null) {\n                writer.nullValue();\n                return;\n            }\n            JsonElement element \u003d serializer.serialize(value, typeOfT, createSerializationContext(miniGson));\n            Streams.write(element, serializeNulls, writer);\n        }\n    };\n}",
      "path": "gson/src/main/java/com/google/gson/GsonToMiniGsonTypeAdapter.java",
      "functionStartLine": 43,
      "functionName": "create",
      "functionAnnotation": "",
      "functionDoc": "",
      "diff": "@@ -1,27 +1,31 @@\n public \u003cT\u003e TypeAdapter\u003cT\u003e create(final MiniGson miniGson, TypeToken\u003cT\u003e type) {\n     final Type typeOfT \u003d type.getType();\n     final JsonSerializer serializer \u003d serializers.getHandlerFor(typeOfT, false);\n     final JsonDeserializer deserializer \u003d deserializers.getHandlerFor(typeOfT, false);\n     if (serializer \u003d\u003d null \u0026\u0026 deserializer \u003d\u003d null) {\n         return null;\n     }\n     return new TypeAdapter() {\n \n         @Override\n         public Object read(JsonReader reader) throws IOException {\n             if (deserializer \u003d\u003d null) {\n                 throw new UnsupportedOperationException();\n             }\n             return deserializer.deserialize(Streams.parse(reader), typeOfT, createDeserializationContext(miniGson));\n         }\n \n         @Override\n         public void write(JsonWriter writer, Object value) throws IOException {\n             if (serializer \u003d\u003d null) {\n                 throw new UnsupportedOperationException();\n             }\n+            if (value \u003d\u003d null) {\n+                writer.nullValue();\n+                return;\n+            }\n             JsonElement element \u003d serializer.serialize(value, typeOfT, createSerializationContext(miniGson));\n             Streams.write(element, serializeNulls, writer);\n         }\n     };\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "566c27cf211fcf307bcb94b47dbbe992fbe0d2d9": {
      "type": "Yintroduced",
      "commitMessage": "Adapted legacy Gson adapters into mini Gson.\n",
      "commitDate": "8/2/11, 7:17 PM",
      "commitName": "566c27cf211fcf307bcb94b47dbbe992fbe0d2d9",
      "commitAuthor": "Inderjeet Singh",
      "diff": "@@ -0,0 +1,27 @@\n+public \u003cT\u003e TypeAdapter\u003cT\u003e create(final MiniGson miniGson, TypeToken\u003cT\u003e type) {\n+    final Type typeOfT \u003d type.getType();\n+    final JsonSerializer serializer \u003d serializers.getHandlerFor(typeOfT, false);\n+    final JsonDeserializer deserializer \u003d deserializers.getHandlerFor(typeOfT, false);\n+    if (serializer \u003d\u003d null \u0026\u0026 deserializer \u003d\u003d null) {\n+        return null;\n+    }\n+    return new TypeAdapter() {\n+\n+        @Override\n+        public Object read(JsonReader reader) throws IOException {\n+            if (deserializer \u003d\u003d null) {\n+                throw new UnsupportedOperationException();\n+            }\n+            return deserializer.deserialize(Streams.parse(reader), typeOfT, createDeserializationContext(miniGson));\n+        }\n+\n+        @Override\n+        public void write(JsonWriter writer, Object value) throws IOException {\n+            if (serializer \u003d\u003d null) {\n+                throw new UnsupportedOperationException();\n+            }\n+            JsonElement element \u003d serializer.serialize(value, typeOfT, createSerializationContext(miniGson));\n+            Streams.write(element, serializeNulls, writer);\n+        }\n+    };\n+}\n\\ No newline at end of file\n",
      "actualSource": "public \u003cT\u003e TypeAdapter\u003cT\u003e create(final MiniGson miniGson, TypeToken\u003cT\u003e type) {\n    final Type typeOfT \u003d type.getType();\n    final JsonSerializer serializer \u003d serializers.getHandlerFor(typeOfT, false);\n    final JsonDeserializer deserializer \u003d deserializers.getHandlerFor(typeOfT, false);\n    if (serializer \u003d\u003d null \u0026\u0026 deserializer \u003d\u003d null) {\n        return null;\n    }\n    return new TypeAdapter() {\n\n        @Override\n        public Object read(JsonReader reader) throws IOException {\n            if (deserializer \u003d\u003d null) {\n                throw new UnsupportedOperationException();\n            }\n            return deserializer.deserialize(Streams.parse(reader), typeOfT, createDeserializationContext(miniGson));\n        }\n\n        @Override\n        public void write(JsonWriter writer, Object value) throws IOException {\n            if (serializer \u003d\u003d null) {\n                throw new UnsupportedOperationException();\n            }\n            JsonElement element \u003d serializer.serialize(value, typeOfT, createSerializationContext(miniGson));\n            Streams.write(element, serializeNulls, writer);\n        }\n    };\n}",
      "path": "gson/src/main/java/com/google/gson/GsonToMiniGsonTypeAdapter.java",
      "functionStartLine": 42,
      "functionName": "create",
      "functionAnnotation": "",
      "functionDoc": ""
    }
  }
}