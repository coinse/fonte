{
  "origin": "codeshovel",
  "repositoryName": "Gson-10b",
  "repositoryPath": "/tmp/Gson-10b//.git",
  "startCommitName": "HEAD",
  "sourceFileName": "UnsafeAllocator.java",
  "functionName": "create",
  "functionId": "create",
  "sourceFilePath": "gson/src/main/java/com/google/gson/internal/UnsafeAllocator.java",
  "functionAnnotation": "",
  "functionDoc": "",
  "functionStartLine": 34,
  "functionEndLine": 107,
  "numCommitsSeen": 14,
  "timeTaken": 1042,
  "changeHistory": [
    "ab40462cc76f6708e3ce2e981f5c6b485347702b",
    "f1f838cf2030bdc057ef08ebafce08221bd306cb",
    "98aa12458904cd8cb74ca40a905ddc790e14501b",
    "533ea1755d807f75a53c6bb3a2b0d4b8ee9794bc",
    "5bc80cd6937faae894c5b578b78ed071c7c8d61d",
    "4efb133b4a6cc93708dda782d948b9c88c3b5ff0",
    "b51ffc1060103ab27cfc6a6f107f04111ba098f6",
    "861e047a6222d581ecf1f617599629bbf8654d34",
    "43137b6b4f005e70561a147b868284d94527069f"
  ],
  "changeHistoryShort": {
    "ab40462cc76f6708e3ce2e981f5c6b485347702b": "Ybodychange",
    "f1f838cf2030bdc057ef08ebafce08221bd306cb": "Ybodychange",
    "98aa12458904cd8cb74ca40a905ddc790e14501b": "Yfilerename",
    "533ea1755d807f75a53c6bb3a2b0d4b8ee9794bc": "Yformatchange",
    "5bc80cd6937faae894c5b578b78ed071c7c8d61d": "Ymultichange(Yfilerename,Yreturntypechange,Ybodychange)",
    "4efb133b4a6cc93708dda782d948b9c88c3b5ff0": "Ymultichange(Yfilerename,Yreturntypechange,Ybodychange)",
    "b51ffc1060103ab27cfc6a6f107f04111ba098f6": "Ybodychange",
    "861e047a6222d581ecf1f617599629bbf8654d34": "Yfilerename",
    "43137b6b4f005e70561a147b868284d94527069f": "Yintroduced"
  },
  "changeHistoryDetails": {
    "ab40462cc76f6708e3ce2e981f5c6b485347702b": {
      "type": "Ybodychange",
      "commitMessage": "Check if class can be instantiated based on class modifiers. If not throw an unsupported operation exception.\n",
      "commitDate": "4/20/16, 1:43 AM",
      "commitName": "ab40462cc76f6708e3ce2e981f5c6b485347702b",
      "commitAuthor": "Ugljesa Jovanovic",
      "commitDateOld": "8/8/14, 10:32 PM",
      "commitNameOld": "f1f838cf2030bdc057ef08ebafce08221bd306cb",
      "commitAuthorOld": "Jake Wharton",
      "daysBetweenCommits": 620.13,
      "commitsBetweenForRepo": 175,
      "commitsBetweenForFile": 1,
      "actualSource": "public static UnsafeAllocator create() {\n    try {\n        Class\u003c?\u003e unsafeClass \u003d Class.forName(\"sun.misc.Unsafe\");\n        Field f \u003d unsafeClass.getDeclaredField(\"theUnsafe\");\n        f.setAccessible(true);\n        final Object unsafe \u003d f.get(null);\n        final Method allocateInstance \u003d unsafeClass.getMethod(\"allocateInstance\", Class.class);\n        return new UnsafeAllocator() {\n\n            @Override\n            @SuppressWarnings(\"unchecked\")\n            public \u003cT\u003e T newInstance(Class\u003cT\u003e c) throws Exception {\n                assertInstantiable(c);\n                return (T) allocateInstance.invoke(unsafe, c);\n            }\n        };\n    } catch (Exception ignored) {\n    }\n    try {\n        Method getConstructorId \u003d ObjectStreamClass.class.getDeclaredMethod(\"getConstructorId\", Class.class);\n        getConstructorId.setAccessible(true);\n        final int constructorId \u003d (Integer) getConstructorId.invoke(null, Object.class);\n        final Method newInstance \u003d ObjectStreamClass.class.getDeclaredMethod(\"newInstance\", Class.class, int.class);\n        newInstance.setAccessible(true);\n        return new UnsafeAllocator() {\n\n            @Override\n            @SuppressWarnings(\"unchecked\")\n            public \u003cT\u003e T newInstance(Class\u003cT\u003e c) throws Exception {\n                assertInstantiable(c);\n                return (T) newInstance.invoke(null, c, constructorId);\n            }\n        };\n    } catch (Exception ignored) {\n    }\n    try {\n        final Method newInstance \u003d ObjectInputStream.class.getDeclaredMethod(\"newInstance\", Class.class, Class.class);\n        newInstance.setAccessible(true);\n        return new UnsafeAllocator() {\n\n            @Override\n            @SuppressWarnings(\"unchecked\")\n            public \u003cT\u003e T newInstance(Class\u003cT\u003e c) throws Exception {\n                assertInstantiable(c);\n                return (T) newInstance.invoke(null, c, Object.class);\n            }\n        };\n    } catch (Exception ignored) {\n    }\n    return new UnsafeAllocator() {\n\n        @Override\n        public \u003cT\u003e T newInstance(Class\u003cT\u003e c) {\n            throw new UnsupportedOperationException(\"Cannot allocate \" + c);\n        }\n    };\n}",
      "path": "gson/src/main/java/com/google/gson/internal/UnsafeAllocator.java",
      "functionStartLine": 34,
      "functionName": "create",
      "functionAnnotation": "",
      "functionDoc": "",
      "diff": "@@ -1,54 +1,57 @@\n public static UnsafeAllocator create() {\n     try {\n         Class\u003c?\u003e unsafeClass \u003d Class.forName(\"sun.misc.Unsafe\");\n         Field f \u003d unsafeClass.getDeclaredField(\"theUnsafe\");\n         f.setAccessible(true);\n         final Object unsafe \u003d f.get(null);\n         final Method allocateInstance \u003d unsafeClass.getMethod(\"allocateInstance\", Class.class);\n         return new UnsafeAllocator() {\n \n             @Override\n             @SuppressWarnings(\"unchecked\")\n             public \u003cT\u003e T newInstance(Class\u003cT\u003e c) throws Exception {\n+                assertInstantiable(c);\n                 return (T) allocateInstance.invoke(unsafe, c);\n             }\n         };\n     } catch (Exception ignored) {\n     }\n     try {\n         Method getConstructorId \u003d ObjectStreamClass.class.getDeclaredMethod(\"getConstructorId\", Class.class);\n         getConstructorId.setAccessible(true);\n         final int constructorId \u003d (Integer) getConstructorId.invoke(null, Object.class);\n         final Method newInstance \u003d ObjectStreamClass.class.getDeclaredMethod(\"newInstance\", Class.class, int.class);\n         newInstance.setAccessible(true);\n         return new UnsafeAllocator() {\n \n             @Override\n             @SuppressWarnings(\"unchecked\")\n             public \u003cT\u003e T newInstance(Class\u003cT\u003e c) throws Exception {\n+                assertInstantiable(c);\n                 return (T) newInstance.invoke(null, c, constructorId);\n             }\n         };\n     } catch (Exception ignored) {\n     }\n     try {\n         final Method newInstance \u003d ObjectInputStream.class.getDeclaredMethod(\"newInstance\", Class.class, Class.class);\n         newInstance.setAccessible(true);\n         return new UnsafeAllocator() {\n \n             @Override\n             @SuppressWarnings(\"unchecked\")\n             public \u003cT\u003e T newInstance(Class\u003cT\u003e c) throws Exception {\n+                assertInstantiable(c);\n                 return (T) newInstance.invoke(null, c, Object.class);\n             }\n         };\n     } catch (Exception ignored) {\n     }\n     return new UnsafeAllocator() {\n \n         @Override\n         public \u003cT\u003e T newInstance(Class\u003cT\u003e c) {\n             throw new UnsupportedOperationException(\"Cannot allocate \" + c);\n         }\n     };\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "f1f838cf2030bdc057ef08ebafce08221bd306cb": {
      "type": "Ybodychange",
      "commitMessage": "Favor post-Gingerbread instantiation mechanism.\n\npre-Gingerbread is now a small subset of the Android OS distribution and is constantly shrinking toward zero.\n",
      "commitDate": "8/8/14, 10:32 PM",
      "commitName": "f1f838cf2030bdc057ef08ebafce08221bd306cb",
      "commitAuthor": "Jake Wharton",
      "commitDateOld": "8/2/11, 6:25 PM",
      "commitNameOld": "98aa12458904cd8cb74ca40a905ddc790e14501b",
      "commitAuthorOld": "Jesse Wilson",
      "daysBetweenCommits": 1102.17,
      "commitsBetweenForRepo": 394,
      "commitsBetweenForFile": 1,
      "actualSource": "public static UnsafeAllocator create() {\n    try {\n        Class\u003c?\u003e unsafeClass \u003d Class.forName(\"sun.misc.Unsafe\");\n        Field f \u003d unsafeClass.getDeclaredField(\"theUnsafe\");\n        f.setAccessible(true);\n        final Object unsafe \u003d f.get(null);\n        final Method allocateInstance \u003d unsafeClass.getMethod(\"allocateInstance\", Class.class);\n        return new UnsafeAllocator() {\n\n            @Override\n            @SuppressWarnings(\"unchecked\")\n            public \u003cT\u003e T newInstance(Class\u003cT\u003e c) throws Exception {\n                return (T) allocateInstance.invoke(unsafe, c);\n            }\n        };\n    } catch (Exception ignored) {\n    }\n    try {\n        Method getConstructorId \u003d ObjectStreamClass.class.getDeclaredMethod(\"getConstructorId\", Class.class);\n        getConstructorId.setAccessible(true);\n        final int constructorId \u003d (Integer) getConstructorId.invoke(null, Object.class);\n        final Method newInstance \u003d ObjectStreamClass.class.getDeclaredMethod(\"newInstance\", Class.class, int.class);\n        newInstance.setAccessible(true);\n        return new UnsafeAllocator() {\n\n            @Override\n            @SuppressWarnings(\"unchecked\")\n            public \u003cT\u003e T newInstance(Class\u003cT\u003e c) throws Exception {\n                return (T) newInstance.invoke(null, c, constructorId);\n            }\n        };\n    } catch (Exception ignored) {\n    }\n    try {\n        final Method newInstance \u003d ObjectInputStream.class.getDeclaredMethod(\"newInstance\", Class.class, Class.class);\n        newInstance.setAccessible(true);\n        return new UnsafeAllocator() {\n\n            @Override\n            @SuppressWarnings(\"unchecked\")\n            public \u003cT\u003e T newInstance(Class\u003cT\u003e c) throws Exception {\n                return (T) newInstance.invoke(null, c, Object.class);\n            }\n        };\n    } catch (Exception ignored) {\n    }\n    return new UnsafeAllocator() {\n\n        @Override\n        public \u003cT\u003e T newInstance(Class\u003cT\u003e c) {\n            throw new UnsupportedOperationException(\"Cannot allocate \" + c);\n        }\n    };\n}",
      "path": "gson/src/main/java/com/google/gson/internal/UnsafeAllocator.java",
      "functionStartLine": 33,
      "functionName": "create",
      "functionAnnotation": "",
      "functionDoc": "",
      "diff": "@@ -1,54 +1,54 @@\n public static UnsafeAllocator create() {\n     try {\n         Class\u003c?\u003e unsafeClass \u003d Class.forName(\"sun.misc.Unsafe\");\n         Field f \u003d unsafeClass.getDeclaredField(\"theUnsafe\");\n         f.setAccessible(true);\n         final Object unsafe \u003d f.get(null);\n         final Method allocateInstance \u003d unsafeClass.getMethod(\"allocateInstance\", Class.class);\n         return new UnsafeAllocator() {\n \n             @Override\n             @SuppressWarnings(\"unchecked\")\n             public \u003cT\u003e T newInstance(Class\u003cT\u003e c) throws Exception {\n                 return (T) allocateInstance.invoke(unsafe, c);\n             }\n         };\n     } catch (Exception ignored) {\n     }\n     try {\n-        final Method newInstance \u003d ObjectInputStream.class.getDeclaredMethod(\"newInstance\", Class.class, Class.class);\n-        newInstance.setAccessible(true);\n-        return new UnsafeAllocator() {\n-\n-            @Override\n-            @SuppressWarnings(\"unchecked\")\n-            public \u003cT\u003e T newInstance(Class\u003cT\u003e c) throws Exception {\n-                return (T) newInstance.invoke(null, c, Object.class);\n-            }\n-        };\n-    } catch (Exception ignored) {\n-    }\n-    try {\n         Method getConstructorId \u003d ObjectStreamClass.class.getDeclaredMethod(\"getConstructorId\", Class.class);\n         getConstructorId.setAccessible(true);\n         final int constructorId \u003d (Integer) getConstructorId.invoke(null, Object.class);\n         final Method newInstance \u003d ObjectStreamClass.class.getDeclaredMethod(\"newInstance\", Class.class, int.class);\n         newInstance.setAccessible(true);\n         return new UnsafeAllocator() {\n \n             @Override\n             @SuppressWarnings(\"unchecked\")\n             public \u003cT\u003e T newInstance(Class\u003cT\u003e c) throws Exception {\n                 return (T) newInstance.invoke(null, c, constructorId);\n             }\n         };\n     } catch (Exception ignored) {\n     }\n+    try {\n+        final Method newInstance \u003d ObjectInputStream.class.getDeclaredMethod(\"newInstance\", Class.class, Class.class);\n+        newInstance.setAccessible(true);\n+        return new UnsafeAllocator() {\n+\n+            @Override\n+            @SuppressWarnings(\"unchecked\")\n+            public \u003cT\u003e T newInstance(Class\u003cT\u003e c) throws Exception {\n+                return (T) newInstance.invoke(null, c, Object.class);\n+            }\n+        };\n+    } catch (Exception ignored) {\n+    }\n     return new UnsafeAllocator() {\n \n         @Override\n         public \u003cT\u003e T newInstance(Class\u003cT\u003e c) {\n             throw new UnsupportedOperationException(\"Cannot allocate \" + c);\n         }\n     };\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "98aa12458904cd8cb74ca40a905ddc790e14501b": {
      "type": "Yfilerename",
      "commitMessage": "Unsafe allocation for reflective type adapters.\n",
      "commitDate": "8/2/11, 6:25 PM",
      "commitName": "98aa12458904cd8cb74ca40a905ddc790e14501b",
      "commitAuthor": "Jesse Wilson",
      "commitDateOld": "8/2/11, 6:25 PM",
      "commitNameOld": "b922500c239406c755149e9a9ca1164a2e2e2c90",
      "commitAuthorOld": "Inderjeet Singh",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "public static UnsafeAllocator create() {\n    try {\n        Class\u003c?\u003e unsafeClass \u003d Class.forName(\"sun.misc.Unsafe\");\n        Field f \u003d unsafeClass.getDeclaredField(\"theUnsafe\");\n        f.setAccessible(true);\n        final Object unsafe \u003d f.get(null);\n        final Method allocateInstance \u003d unsafeClass.getMethod(\"allocateInstance\", Class.class);\n        return new UnsafeAllocator() {\n\n            @Override\n            @SuppressWarnings(\"unchecked\")\n            public \u003cT\u003e T newInstance(Class\u003cT\u003e c) throws Exception {\n                return (T) allocateInstance.invoke(unsafe, c);\n            }\n        };\n    } catch (Exception ignored) {\n    }\n    try {\n        final Method newInstance \u003d ObjectInputStream.class.getDeclaredMethod(\"newInstance\", Class.class, Class.class);\n        newInstance.setAccessible(true);\n        return new UnsafeAllocator() {\n\n            @Override\n            @SuppressWarnings(\"unchecked\")\n            public \u003cT\u003e T newInstance(Class\u003cT\u003e c) throws Exception {\n                return (T) newInstance.invoke(null, c, Object.class);\n            }\n        };\n    } catch (Exception ignored) {\n    }\n    try {\n        Method getConstructorId \u003d ObjectStreamClass.class.getDeclaredMethod(\"getConstructorId\", Class.class);\n        getConstructorId.setAccessible(true);\n        final int constructorId \u003d (Integer) getConstructorId.invoke(null, Object.class);\n        final Method newInstance \u003d ObjectStreamClass.class.getDeclaredMethod(\"newInstance\", Class.class, int.class);\n        newInstance.setAccessible(true);\n        return new UnsafeAllocator() {\n\n            @Override\n            @SuppressWarnings(\"unchecked\")\n            public \u003cT\u003e T newInstance(Class\u003cT\u003e c) throws Exception {\n                return (T) newInstance.invoke(null, c, constructorId);\n            }\n        };\n    } catch (Exception ignored) {\n    }\n    return new UnsafeAllocator() {\n\n        @Override\n        public \u003cT\u003e T newInstance(Class\u003cT\u003e c) {\n            throw new UnsupportedOperationException(\"Cannot allocate \" + c);\n        }\n    };\n}",
      "path": "gson/src/main/java/com/google/gson/internal/UnsafeAllocator.java",
      "functionStartLine": 33,
      "functionName": "create",
      "functionAnnotation": "",
      "functionDoc": "",
      "diff": "",
      "extendedDetails": {
        "oldPath": "gson/src/main/java/com/google/gson/UnsafeAllocator.java",
        "newPath": "gson/src/main/java/com/google/gson/internal/UnsafeAllocator.java"
      }
    },
    "533ea1755d807f75a53c6bb3a2b0d4b8ee9794bc": {
      "type": "Yformatchange",
      "commitMessage": "Fix typo\n",
      "commitDate": "6/3/11, 12:05 PM",
      "commitName": "533ea1755d807f75a53c6bb3a2b0d4b8ee9794bc",
      "commitAuthor": "Joel Leitch",
      "commitDateOld": "3/30/11, 6:59 AM",
      "commitNameOld": "5bc80cd6937faae894c5b578b78ed071c7c8d61d",
      "commitAuthorOld": "Inderjeet Singh",
      "daysBetweenCommits": 65.21,
      "commitsBetweenForRepo": 82,
      "commitsBetweenForFile": 1,
      "actualSource": "public static UnsafeAllocator create() {\n    try {\n        Class\u003c?\u003e unsafeClass \u003d Class.forName(\"sun.misc.Unsafe\");\n        Field f \u003d unsafeClass.getDeclaredField(\"theUnsafe\");\n        f.setAccessible(true);\n        final Object unsafe \u003d f.get(null);\n        final Method allocateInstance \u003d unsafeClass.getMethod(\"allocateInstance\", Class.class);\n        return new UnsafeAllocator() {\n\n            @Override\n            @SuppressWarnings(\"unchecked\")\n            public \u003cT\u003e T newInstance(Class\u003cT\u003e c) throws Exception {\n                return (T) allocateInstance.invoke(unsafe, c);\n            }\n        };\n    } catch (Exception ignored) {\n    }\n    try {\n        final Method newInstance \u003d ObjectInputStream.class.getDeclaredMethod(\"newInstance\", Class.class, Class.class);\n        newInstance.setAccessible(true);\n        return new UnsafeAllocator() {\n\n            @Override\n            @SuppressWarnings(\"unchecked\")\n            public \u003cT\u003e T newInstance(Class\u003cT\u003e c) throws Exception {\n                return (T) newInstance.invoke(null, c, Object.class);\n            }\n        };\n    } catch (Exception ignored) {\n    }\n    try {\n        Method getConstructorId \u003d ObjectStreamClass.class.getDeclaredMethod(\"getConstructorId\", Class.class);\n        getConstructorId.setAccessible(true);\n        final int constructorId \u003d (Integer) getConstructorId.invoke(null, Object.class);\n        final Method newInstance \u003d ObjectStreamClass.class.getDeclaredMethod(\"newInstance\", Class.class, int.class);\n        newInstance.setAccessible(true);\n        return new UnsafeAllocator() {\n\n            @Override\n            @SuppressWarnings(\"unchecked\")\n            public \u003cT\u003e T newInstance(Class\u003cT\u003e c) throws Exception {\n                return (T) newInstance.invoke(null, c, constructorId);\n            }\n        };\n    } catch (Exception ignored) {\n    }\n    return new UnsafeAllocator() {\n\n        @Override\n        public \u003cT\u003e T newInstance(Class\u003cT\u003e c) {\n            throw new UnsupportedOperationException(\"Cannot allocate \" + c);\n        }\n    };\n}",
      "path": "gson/src/main/java/com/google/gson/UnsafeAllocator.java",
      "functionStartLine": 33,
      "functionName": "create",
      "functionAnnotation": "",
      "functionDoc": "",
      "diff": "",
      "extendedDetails": {}
    },
    "5bc80cd6937faae894c5b578b78ed071c7c8d61d": {
      "type": "Ymultichange(Yfilerename,Yreturntypechange,Ybodychange)",
      "commitMessage": "Moved Cache, LruCache, Pair, Primitives and UnsafeAllocator to com.google.gson and made them package private.\n",
      "commitDate": "3/30/11, 6:59 AM",
      "commitName": "5bc80cd6937faae894c5b578b78ed071c7c8d61d",
      "commitAuthor": "Inderjeet Singh",
      "subchanges": [
        {
          "type": "Yfilerename",
          "commitMessage": "Moved Cache, LruCache, Pair, Primitives and UnsafeAllocator to com.google.gson and made them package private.\n",
          "commitDate": "3/30/11, 6:59 AM",
          "commitName": "5bc80cd6937faae894c5b578b78ed071c7c8d61d",
          "commitAuthor": "Inderjeet Singh",
          "commitDateOld": "3/29/11, 2:48 PM",
          "commitNameOld": "46a8e9b4119992d73e61dc1ce37f2b94d53c819e",
          "commitAuthorOld": "Jesse Wilson",
          "daysBetweenCommits": 0.67,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "actualSource": "public static UnsafeAllocator create() {\n    try {\n        Class\u003c?\u003e unsafeClass \u003d Class.forName(\"sun.misc.Unsafe\");\n        Field f \u003d unsafeClass.getDeclaredField(\"theUnsafe\");\n        f.setAccessible(true);\n        final Object unsafe \u003d f.get(null);\n        final Method allocateInstance \u003d unsafeClass.getMethod(\"allocateInstance\", Class.class);\n        return new UnsafeAllocator() {\n\n            @Override\n            @SuppressWarnings(\"unchecked\")\n            public \u003cT\u003e T newInstance(Class\u003cT\u003e c) throws Exception {\n                return (T) allocateInstance.invoke(unsafe, c);\n            }\n        };\n    } catch (Exception ignored) {\n    }\n    try {\n        final Method newInstance \u003d ObjectInputStream.class.getDeclaredMethod(\"newInstance\", Class.class, Class.class);\n        newInstance.setAccessible(true);\n        return new UnsafeAllocator() {\n\n            @Override\n            @SuppressWarnings(\"unchecked\")\n            public \u003cT\u003e T newInstance(Class\u003cT\u003e c) throws Exception {\n                return (T) newInstance.invoke(null, c, Object.class);\n            }\n        };\n    } catch (Exception ignored) {\n    }\n    try {\n        Method getConstructorId \u003d ObjectStreamClass.class.getDeclaredMethod(\"getConstructorId\", Class.class);\n        getConstructorId.setAccessible(true);\n        final int constructorId \u003d (Integer) getConstructorId.invoke(null, Object.class);\n        final Method newInstance \u003d ObjectStreamClass.class.getDeclaredMethod(\"newInstance\", Class.class, int.class);\n        newInstance.setAccessible(true);\n        return new UnsafeAllocator() {\n\n            @Override\n            @SuppressWarnings(\"unchecked\")\n            public \u003cT\u003e T newInstance(Class\u003cT\u003e c) throws Exception {\n                return (T) newInstance.invoke(null, c, constructorId);\n            }\n        };\n    } catch (Exception ignored) {\n    }\n    return new UnsafeAllocator() {\n\n        @Override\n        public \u003cT\u003e T newInstance(Class\u003cT\u003e c) {\n            throw new UnsupportedOperationException(\"Cannot allocate \" + c);\n        }\n    };\n}",
          "path": "gson/src/main/java/com/google/gson/UnsafeAllocator.java",
          "functionStartLine": 33,
          "functionName": "create",
          "functionAnnotation": "",
          "functionDoc": "",
          "diff": "@@ -1,54 +1,54 @@\n-public static $UnsafeAllocator create() {\n+public static UnsafeAllocator create() {\n     try {\n         Class\u003c?\u003e unsafeClass \u003d Class.forName(\"sun.misc.Unsafe\");\n         Field f \u003d unsafeClass.getDeclaredField(\"theUnsafe\");\n         f.setAccessible(true);\n         final Object unsafe \u003d f.get(null);\n         final Method allocateInstance \u003d unsafeClass.getMethod(\"allocateInstance\", Class.class);\n-        return new $UnsafeAllocator() {\n+        return new UnsafeAllocator() {\n \n             @Override\n             @SuppressWarnings(\"unchecked\")\n             public \u003cT\u003e T newInstance(Class\u003cT\u003e c) throws Exception {\n                 return (T) allocateInstance.invoke(unsafe, c);\n             }\n         };\n     } catch (Exception ignored) {\n     }\n     try {\n         final Method newInstance \u003d ObjectInputStream.class.getDeclaredMethod(\"newInstance\", Class.class, Class.class);\n         newInstance.setAccessible(true);\n-        return new $UnsafeAllocator() {\n+        return new UnsafeAllocator() {\n \n             @Override\n             @SuppressWarnings(\"unchecked\")\n             public \u003cT\u003e T newInstance(Class\u003cT\u003e c) throws Exception {\n                 return (T) newInstance.invoke(null, c, Object.class);\n             }\n         };\n     } catch (Exception ignored) {\n     }\n     try {\n         Method getConstructorId \u003d ObjectStreamClass.class.getDeclaredMethod(\"getConstructorId\", Class.class);\n         getConstructorId.setAccessible(true);\n         final int constructorId \u003d (Integer) getConstructorId.invoke(null, Object.class);\n         final Method newInstance \u003d ObjectStreamClass.class.getDeclaredMethod(\"newInstance\", Class.class, int.class);\n         newInstance.setAccessible(true);\n-        return new $UnsafeAllocator() {\n+        return new UnsafeAllocator() {\n \n             @Override\n             @SuppressWarnings(\"unchecked\")\n             public \u003cT\u003e T newInstance(Class\u003cT\u003e c) throws Exception {\n                 return (T) newInstance.invoke(null, c, constructorId);\n             }\n         };\n     } catch (Exception ignored) {\n     }\n-    return new $UnsafeAllocator() {\n+    return new UnsafeAllocator() {\n \n         @Override\n         public \u003cT\u003e T newInstance(Class\u003cT\u003e c) {\n             throw new UnsupportedOperationException(\"Cannot allocate \" + c);\n         }\n     };\n }\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldPath": "gson/src/main/java/com/google/gson/internal/$UnsafeAllocator.java",
            "newPath": "gson/src/main/java/com/google/gson/UnsafeAllocator.java"
          }
        },
        {
          "type": "Yreturntypechange",
          "commitMessage": "Moved Cache, LruCache, Pair, Primitives and UnsafeAllocator to com.google.gson and made them package private.\n",
          "commitDate": "3/30/11, 6:59 AM",
          "commitName": "5bc80cd6937faae894c5b578b78ed071c7c8d61d",
          "commitAuthor": "Inderjeet Singh",
          "commitDateOld": "3/29/11, 2:48 PM",
          "commitNameOld": "46a8e9b4119992d73e61dc1ce37f2b94d53c819e",
          "commitAuthorOld": "Jesse Wilson",
          "daysBetweenCommits": 0.67,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "actualSource": "public static UnsafeAllocator create() {\n    try {\n        Class\u003c?\u003e unsafeClass \u003d Class.forName(\"sun.misc.Unsafe\");\n        Field f \u003d unsafeClass.getDeclaredField(\"theUnsafe\");\n        f.setAccessible(true);\n        final Object unsafe \u003d f.get(null);\n        final Method allocateInstance \u003d unsafeClass.getMethod(\"allocateInstance\", Class.class);\n        return new UnsafeAllocator() {\n\n            @Override\n            @SuppressWarnings(\"unchecked\")\n            public \u003cT\u003e T newInstance(Class\u003cT\u003e c) throws Exception {\n                return (T) allocateInstance.invoke(unsafe, c);\n            }\n        };\n    } catch (Exception ignored) {\n    }\n    try {\n        final Method newInstance \u003d ObjectInputStream.class.getDeclaredMethod(\"newInstance\", Class.class, Class.class);\n        newInstance.setAccessible(true);\n        return new UnsafeAllocator() {\n\n            @Override\n            @SuppressWarnings(\"unchecked\")\n            public \u003cT\u003e T newInstance(Class\u003cT\u003e c) throws Exception {\n                return (T) newInstance.invoke(null, c, Object.class);\n            }\n        };\n    } catch (Exception ignored) {\n    }\n    try {\n        Method getConstructorId \u003d ObjectStreamClass.class.getDeclaredMethod(\"getConstructorId\", Class.class);\n        getConstructorId.setAccessible(true);\n        final int constructorId \u003d (Integer) getConstructorId.invoke(null, Object.class);\n        final Method newInstance \u003d ObjectStreamClass.class.getDeclaredMethod(\"newInstance\", Class.class, int.class);\n        newInstance.setAccessible(true);\n        return new UnsafeAllocator() {\n\n            @Override\n            @SuppressWarnings(\"unchecked\")\n            public \u003cT\u003e T newInstance(Class\u003cT\u003e c) throws Exception {\n                return (T) newInstance.invoke(null, c, constructorId);\n            }\n        };\n    } catch (Exception ignored) {\n    }\n    return new UnsafeAllocator() {\n\n        @Override\n        public \u003cT\u003e T newInstance(Class\u003cT\u003e c) {\n            throw new UnsupportedOperationException(\"Cannot allocate \" + c);\n        }\n    };\n}",
          "path": "gson/src/main/java/com/google/gson/UnsafeAllocator.java",
          "functionStartLine": 33,
          "functionName": "create",
          "functionAnnotation": "",
          "functionDoc": "",
          "diff": "@@ -1,54 +1,54 @@\n-public static $UnsafeAllocator create() {\n+public static UnsafeAllocator create() {\n     try {\n         Class\u003c?\u003e unsafeClass \u003d Class.forName(\"sun.misc.Unsafe\");\n         Field f \u003d unsafeClass.getDeclaredField(\"theUnsafe\");\n         f.setAccessible(true);\n         final Object unsafe \u003d f.get(null);\n         final Method allocateInstance \u003d unsafeClass.getMethod(\"allocateInstance\", Class.class);\n-        return new $UnsafeAllocator() {\n+        return new UnsafeAllocator() {\n \n             @Override\n             @SuppressWarnings(\"unchecked\")\n             public \u003cT\u003e T newInstance(Class\u003cT\u003e c) throws Exception {\n                 return (T) allocateInstance.invoke(unsafe, c);\n             }\n         };\n     } catch (Exception ignored) {\n     }\n     try {\n         final Method newInstance \u003d ObjectInputStream.class.getDeclaredMethod(\"newInstance\", Class.class, Class.class);\n         newInstance.setAccessible(true);\n-        return new $UnsafeAllocator() {\n+        return new UnsafeAllocator() {\n \n             @Override\n             @SuppressWarnings(\"unchecked\")\n             public \u003cT\u003e T newInstance(Class\u003cT\u003e c) throws Exception {\n                 return (T) newInstance.invoke(null, c, Object.class);\n             }\n         };\n     } catch (Exception ignored) {\n     }\n     try {\n         Method getConstructorId \u003d ObjectStreamClass.class.getDeclaredMethod(\"getConstructorId\", Class.class);\n         getConstructorId.setAccessible(true);\n         final int constructorId \u003d (Integer) getConstructorId.invoke(null, Object.class);\n         final Method newInstance \u003d ObjectStreamClass.class.getDeclaredMethod(\"newInstance\", Class.class, int.class);\n         newInstance.setAccessible(true);\n-        return new $UnsafeAllocator() {\n+        return new UnsafeAllocator() {\n \n             @Override\n             @SuppressWarnings(\"unchecked\")\n             public \u003cT\u003e T newInstance(Class\u003cT\u003e c) throws Exception {\n                 return (T) newInstance.invoke(null, c, constructorId);\n             }\n         };\n     } catch (Exception ignored) {\n     }\n-    return new $UnsafeAllocator() {\n+    return new UnsafeAllocator() {\n \n         @Override\n         public \u003cT\u003e T newInstance(Class\u003cT\u003e c) {\n             throw new UnsupportedOperationException(\"Cannot allocate \" + c);\n         }\n     };\n }\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldValue": "$UnsafeAllocator",
            "newValue": "UnsafeAllocator"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "Moved Cache, LruCache, Pair, Primitives and UnsafeAllocator to com.google.gson and made them package private.\n",
          "commitDate": "3/30/11, 6:59 AM",
          "commitName": "5bc80cd6937faae894c5b578b78ed071c7c8d61d",
          "commitAuthor": "Inderjeet Singh",
          "commitDateOld": "3/29/11, 2:48 PM",
          "commitNameOld": "46a8e9b4119992d73e61dc1ce37f2b94d53c819e",
          "commitAuthorOld": "Jesse Wilson",
          "daysBetweenCommits": 0.67,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "actualSource": "public static UnsafeAllocator create() {\n    try {\n        Class\u003c?\u003e unsafeClass \u003d Class.forName(\"sun.misc.Unsafe\");\n        Field f \u003d unsafeClass.getDeclaredField(\"theUnsafe\");\n        f.setAccessible(true);\n        final Object unsafe \u003d f.get(null);\n        final Method allocateInstance \u003d unsafeClass.getMethod(\"allocateInstance\", Class.class);\n        return new UnsafeAllocator() {\n\n            @Override\n            @SuppressWarnings(\"unchecked\")\n            public \u003cT\u003e T newInstance(Class\u003cT\u003e c) throws Exception {\n                return (T) allocateInstance.invoke(unsafe, c);\n            }\n        };\n    } catch (Exception ignored) {\n    }\n    try {\n        final Method newInstance \u003d ObjectInputStream.class.getDeclaredMethod(\"newInstance\", Class.class, Class.class);\n        newInstance.setAccessible(true);\n        return new UnsafeAllocator() {\n\n            @Override\n            @SuppressWarnings(\"unchecked\")\n            public \u003cT\u003e T newInstance(Class\u003cT\u003e c) throws Exception {\n                return (T) newInstance.invoke(null, c, Object.class);\n            }\n        };\n    } catch (Exception ignored) {\n    }\n    try {\n        Method getConstructorId \u003d ObjectStreamClass.class.getDeclaredMethod(\"getConstructorId\", Class.class);\n        getConstructorId.setAccessible(true);\n        final int constructorId \u003d (Integer) getConstructorId.invoke(null, Object.class);\n        final Method newInstance \u003d ObjectStreamClass.class.getDeclaredMethod(\"newInstance\", Class.class, int.class);\n        newInstance.setAccessible(true);\n        return new UnsafeAllocator() {\n\n            @Override\n            @SuppressWarnings(\"unchecked\")\n            public \u003cT\u003e T newInstance(Class\u003cT\u003e c) throws Exception {\n                return (T) newInstance.invoke(null, c, constructorId);\n            }\n        };\n    } catch (Exception ignored) {\n    }\n    return new UnsafeAllocator() {\n\n        @Override\n        public \u003cT\u003e T newInstance(Class\u003cT\u003e c) {\n            throw new UnsupportedOperationException(\"Cannot allocate \" + c);\n        }\n    };\n}",
          "path": "gson/src/main/java/com/google/gson/UnsafeAllocator.java",
          "functionStartLine": 33,
          "functionName": "create",
          "functionAnnotation": "",
          "functionDoc": "",
          "diff": "@@ -1,54 +1,54 @@\n-public static $UnsafeAllocator create() {\n+public static UnsafeAllocator create() {\n     try {\n         Class\u003c?\u003e unsafeClass \u003d Class.forName(\"sun.misc.Unsafe\");\n         Field f \u003d unsafeClass.getDeclaredField(\"theUnsafe\");\n         f.setAccessible(true);\n         final Object unsafe \u003d f.get(null);\n         final Method allocateInstance \u003d unsafeClass.getMethod(\"allocateInstance\", Class.class);\n-        return new $UnsafeAllocator() {\n+        return new UnsafeAllocator() {\n \n             @Override\n             @SuppressWarnings(\"unchecked\")\n             public \u003cT\u003e T newInstance(Class\u003cT\u003e c) throws Exception {\n                 return (T) allocateInstance.invoke(unsafe, c);\n             }\n         };\n     } catch (Exception ignored) {\n     }\n     try {\n         final Method newInstance \u003d ObjectInputStream.class.getDeclaredMethod(\"newInstance\", Class.class, Class.class);\n         newInstance.setAccessible(true);\n-        return new $UnsafeAllocator() {\n+        return new UnsafeAllocator() {\n \n             @Override\n             @SuppressWarnings(\"unchecked\")\n             public \u003cT\u003e T newInstance(Class\u003cT\u003e c) throws Exception {\n                 return (T) newInstance.invoke(null, c, Object.class);\n             }\n         };\n     } catch (Exception ignored) {\n     }\n     try {\n         Method getConstructorId \u003d ObjectStreamClass.class.getDeclaredMethod(\"getConstructorId\", Class.class);\n         getConstructorId.setAccessible(true);\n         final int constructorId \u003d (Integer) getConstructorId.invoke(null, Object.class);\n         final Method newInstance \u003d ObjectStreamClass.class.getDeclaredMethod(\"newInstance\", Class.class, int.class);\n         newInstance.setAccessible(true);\n-        return new $UnsafeAllocator() {\n+        return new UnsafeAllocator() {\n \n             @Override\n             @SuppressWarnings(\"unchecked\")\n             public \u003cT\u003e T newInstance(Class\u003cT\u003e c) throws Exception {\n                 return (T) newInstance.invoke(null, c, constructorId);\n             }\n         };\n     } catch (Exception ignored) {\n     }\n-    return new $UnsafeAllocator() {\n+    return new UnsafeAllocator() {\n \n         @Override\n         public \u003cT\u003e T newInstance(Class\u003cT\u003e c) {\n             throw new UnsupportedOperationException(\"Cannot allocate \" + c);\n         }\n     };\n }\n\\ No newline at end of file\n",
          "extendedDetails": {}
        }
      ]
    },
    "4efb133b4a6cc93708dda782d948b9c88c3b5ff0": {
      "type": "Ymultichange(Yfilerename,Yreturntypechange,Ybodychange)",
      "commitMessage": "bling bling\n\nPrefix internal classes with $ to prevent them from interfering with IDE\u0027s auto import functionality.\n",
      "commitDate": "3/29/11, 2:24 PM",
      "commitName": "4efb133b4a6cc93708dda782d948b9c88c3b5ff0",
      "commitAuthor": "Jesse Wilson",
      "subchanges": [
        {
          "type": "Yfilerename",
          "commitMessage": "bling bling\n\nPrefix internal classes with $ to prevent them from interfering with IDE\u0027s auto import functionality.\n",
          "commitDate": "3/29/11, 2:24 PM",
          "commitName": "4efb133b4a6cc93708dda782d948b9c88c3b5ff0",
          "commitAuthor": "Jesse Wilson",
          "commitDateOld": "3/29/11, 2:18 PM",
          "commitNameOld": "5e74dabad9acaed40c2c0db88680f09bbbdbf28d",
          "commitAuthorOld": "Joel Leitch",
          "daysBetweenCommits": 0.0,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "actualSource": "public static $UnsafeAllocator create() {\n    try {\n        Class\u003c?\u003e unsafeClass \u003d Class.forName(\"sun.misc.Unsafe\");\n        Field f \u003d unsafeClass.getDeclaredField(\"theUnsafe\");\n        f.setAccessible(true);\n        final Object unsafe \u003d f.get(null);\n        final Method allocateInstance \u003d unsafeClass.getMethod(\"allocateInstance\", Class.class);\n        return new $UnsafeAllocator() {\n\n            @Override\n            @SuppressWarnings(\"unchecked\")\n            public \u003cT\u003e T newInstance(Class\u003cT\u003e c) throws Exception {\n                return (T) allocateInstance.invoke(unsafe, c);\n            }\n        };\n    } catch (Exception ignored) {\n    }\n    try {\n        final Method newInstance \u003d ObjectInputStream.class.getDeclaredMethod(\"newInstance\", Class.class, Class.class);\n        newInstance.setAccessible(true);\n        return new $UnsafeAllocator() {\n\n            @Override\n            @SuppressWarnings(\"unchecked\")\n            public \u003cT\u003e T newInstance(Class\u003cT\u003e c) throws Exception {\n                return (T) newInstance.invoke(null, c, Object.class);\n            }\n        };\n    } catch (Exception ignored) {\n    }\n    try {\n        Method getConstructorId \u003d ObjectStreamClass.class.getDeclaredMethod(\"getConstructorId\", Class.class);\n        getConstructorId.setAccessible(true);\n        final int constructorId \u003d (Integer) getConstructorId.invoke(null, Object.class);\n        final Method newInstance \u003d ObjectStreamClass.class.getDeclaredMethod(\"newInstance\", Class.class, int.class);\n        newInstance.setAccessible(true);\n        return new $UnsafeAllocator() {\n\n            @Override\n            @SuppressWarnings(\"unchecked\")\n            public \u003cT\u003e T newInstance(Class\u003cT\u003e c) throws Exception {\n                return (T) newInstance.invoke(null, c, constructorId);\n            }\n        };\n    } catch (Exception ignored) {\n    }\n    return new $UnsafeAllocator() {\n\n        @Override\n        public \u003cT\u003e T newInstance(Class\u003cT\u003e c) {\n            throw new UnsupportedOperationException(\"Cannot allocate \" + c);\n        }\n    };\n}",
          "path": "gson/src/main/java/com/google/gson/internal/$UnsafeAllocator.java",
          "functionStartLine": 33,
          "functionName": "create",
          "functionAnnotation": "",
          "functionDoc": "",
          "diff": "@@ -1,54 +1,54 @@\n-public static UnsafeAllocator create() {\n+public static $UnsafeAllocator create() {\n     try {\n         Class\u003c?\u003e unsafeClass \u003d Class.forName(\"sun.misc.Unsafe\");\n         Field f \u003d unsafeClass.getDeclaredField(\"theUnsafe\");\n         f.setAccessible(true);\n         final Object unsafe \u003d f.get(null);\n         final Method allocateInstance \u003d unsafeClass.getMethod(\"allocateInstance\", Class.class);\n-        return new UnsafeAllocator() {\n+        return new $UnsafeAllocator() {\n \n             @Override\n             @SuppressWarnings(\"unchecked\")\n             public \u003cT\u003e T newInstance(Class\u003cT\u003e c) throws Exception {\n                 return (T) allocateInstance.invoke(unsafe, c);\n             }\n         };\n     } catch (Exception ignored) {\n     }\n     try {\n         final Method newInstance \u003d ObjectInputStream.class.getDeclaredMethod(\"newInstance\", Class.class, Class.class);\n         newInstance.setAccessible(true);\n-        return new UnsafeAllocator() {\n+        return new $UnsafeAllocator() {\n \n             @Override\n             @SuppressWarnings(\"unchecked\")\n             public \u003cT\u003e T newInstance(Class\u003cT\u003e c) throws Exception {\n                 return (T) newInstance.invoke(null, c, Object.class);\n             }\n         };\n     } catch (Exception ignored) {\n     }\n     try {\n         Method getConstructorId \u003d ObjectStreamClass.class.getDeclaredMethod(\"getConstructorId\", Class.class);\n         getConstructorId.setAccessible(true);\n         final int constructorId \u003d (Integer) getConstructorId.invoke(null, Object.class);\n         final Method newInstance \u003d ObjectStreamClass.class.getDeclaredMethod(\"newInstance\", Class.class, int.class);\n         newInstance.setAccessible(true);\n-        return new UnsafeAllocator() {\n+        return new $UnsafeAllocator() {\n \n             @Override\n             @SuppressWarnings(\"unchecked\")\n             public \u003cT\u003e T newInstance(Class\u003cT\u003e c) throws Exception {\n                 return (T) newInstance.invoke(null, c, constructorId);\n             }\n         };\n     } catch (Exception ignored) {\n     }\n-    return new UnsafeAllocator() {\n+    return new $UnsafeAllocator() {\n \n         @Override\n         public \u003cT\u003e T newInstance(Class\u003cT\u003e c) {\n             throw new UnsupportedOperationException(\"Cannot allocate \" + c);\n         }\n     };\n }\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldPath": "gson/src/main/java/com/google/gson/internal/UnsafeAllocator.java",
            "newPath": "gson/src/main/java/com/google/gson/internal/$UnsafeAllocator.java"
          }
        },
        {
          "type": "Yreturntypechange",
          "commitMessage": "bling bling\n\nPrefix internal classes with $ to prevent them from interfering with IDE\u0027s auto import functionality.\n",
          "commitDate": "3/29/11, 2:24 PM",
          "commitName": "4efb133b4a6cc93708dda782d948b9c88c3b5ff0",
          "commitAuthor": "Jesse Wilson",
          "commitDateOld": "3/29/11, 2:18 PM",
          "commitNameOld": "5e74dabad9acaed40c2c0db88680f09bbbdbf28d",
          "commitAuthorOld": "Joel Leitch",
          "daysBetweenCommits": 0.0,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "actualSource": "public static $UnsafeAllocator create() {\n    try {\n        Class\u003c?\u003e unsafeClass \u003d Class.forName(\"sun.misc.Unsafe\");\n        Field f \u003d unsafeClass.getDeclaredField(\"theUnsafe\");\n        f.setAccessible(true);\n        final Object unsafe \u003d f.get(null);\n        final Method allocateInstance \u003d unsafeClass.getMethod(\"allocateInstance\", Class.class);\n        return new $UnsafeAllocator() {\n\n            @Override\n            @SuppressWarnings(\"unchecked\")\n            public \u003cT\u003e T newInstance(Class\u003cT\u003e c) throws Exception {\n                return (T) allocateInstance.invoke(unsafe, c);\n            }\n        };\n    } catch (Exception ignored) {\n    }\n    try {\n        final Method newInstance \u003d ObjectInputStream.class.getDeclaredMethod(\"newInstance\", Class.class, Class.class);\n        newInstance.setAccessible(true);\n        return new $UnsafeAllocator() {\n\n            @Override\n            @SuppressWarnings(\"unchecked\")\n            public \u003cT\u003e T newInstance(Class\u003cT\u003e c) throws Exception {\n                return (T) newInstance.invoke(null, c, Object.class);\n            }\n        };\n    } catch (Exception ignored) {\n    }\n    try {\n        Method getConstructorId \u003d ObjectStreamClass.class.getDeclaredMethod(\"getConstructorId\", Class.class);\n        getConstructorId.setAccessible(true);\n        final int constructorId \u003d (Integer) getConstructorId.invoke(null, Object.class);\n        final Method newInstance \u003d ObjectStreamClass.class.getDeclaredMethod(\"newInstance\", Class.class, int.class);\n        newInstance.setAccessible(true);\n        return new $UnsafeAllocator() {\n\n            @Override\n            @SuppressWarnings(\"unchecked\")\n            public \u003cT\u003e T newInstance(Class\u003cT\u003e c) throws Exception {\n                return (T) newInstance.invoke(null, c, constructorId);\n            }\n        };\n    } catch (Exception ignored) {\n    }\n    return new $UnsafeAllocator() {\n\n        @Override\n        public \u003cT\u003e T newInstance(Class\u003cT\u003e c) {\n            throw new UnsupportedOperationException(\"Cannot allocate \" + c);\n        }\n    };\n}",
          "path": "gson/src/main/java/com/google/gson/internal/$UnsafeAllocator.java",
          "functionStartLine": 33,
          "functionName": "create",
          "functionAnnotation": "",
          "functionDoc": "",
          "diff": "@@ -1,54 +1,54 @@\n-public static UnsafeAllocator create() {\n+public static $UnsafeAllocator create() {\n     try {\n         Class\u003c?\u003e unsafeClass \u003d Class.forName(\"sun.misc.Unsafe\");\n         Field f \u003d unsafeClass.getDeclaredField(\"theUnsafe\");\n         f.setAccessible(true);\n         final Object unsafe \u003d f.get(null);\n         final Method allocateInstance \u003d unsafeClass.getMethod(\"allocateInstance\", Class.class);\n-        return new UnsafeAllocator() {\n+        return new $UnsafeAllocator() {\n \n             @Override\n             @SuppressWarnings(\"unchecked\")\n             public \u003cT\u003e T newInstance(Class\u003cT\u003e c) throws Exception {\n                 return (T) allocateInstance.invoke(unsafe, c);\n             }\n         };\n     } catch (Exception ignored) {\n     }\n     try {\n         final Method newInstance \u003d ObjectInputStream.class.getDeclaredMethod(\"newInstance\", Class.class, Class.class);\n         newInstance.setAccessible(true);\n-        return new UnsafeAllocator() {\n+        return new $UnsafeAllocator() {\n \n             @Override\n             @SuppressWarnings(\"unchecked\")\n             public \u003cT\u003e T newInstance(Class\u003cT\u003e c) throws Exception {\n                 return (T) newInstance.invoke(null, c, Object.class);\n             }\n         };\n     } catch (Exception ignored) {\n     }\n     try {\n         Method getConstructorId \u003d ObjectStreamClass.class.getDeclaredMethod(\"getConstructorId\", Class.class);\n         getConstructorId.setAccessible(true);\n         final int constructorId \u003d (Integer) getConstructorId.invoke(null, Object.class);\n         final Method newInstance \u003d ObjectStreamClass.class.getDeclaredMethod(\"newInstance\", Class.class, int.class);\n         newInstance.setAccessible(true);\n-        return new UnsafeAllocator() {\n+        return new $UnsafeAllocator() {\n \n             @Override\n             @SuppressWarnings(\"unchecked\")\n             public \u003cT\u003e T newInstance(Class\u003cT\u003e c) throws Exception {\n                 return (T) newInstance.invoke(null, c, constructorId);\n             }\n         };\n     } catch (Exception ignored) {\n     }\n-    return new UnsafeAllocator() {\n+    return new $UnsafeAllocator() {\n \n         @Override\n         public \u003cT\u003e T newInstance(Class\u003cT\u003e c) {\n             throw new UnsupportedOperationException(\"Cannot allocate \" + c);\n         }\n     };\n }\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldValue": "UnsafeAllocator",
            "newValue": "$UnsafeAllocator"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "bling bling\n\nPrefix internal classes with $ to prevent them from interfering with IDE\u0027s auto import functionality.\n",
          "commitDate": "3/29/11, 2:24 PM",
          "commitName": "4efb133b4a6cc93708dda782d948b9c88c3b5ff0",
          "commitAuthor": "Jesse Wilson",
          "commitDateOld": "3/29/11, 2:18 PM",
          "commitNameOld": "5e74dabad9acaed40c2c0db88680f09bbbdbf28d",
          "commitAuthorOld": "Joel Leitch",
          "daysBetweenCommits": 0.0,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "actualSource": "public static $UnsafeAllocator create() {\n    try {\n        Class\u003c?\u003e unsafeClass \u003d Class.forName(\"sun.misc.Unsafe\");\n        Field f \u003d unsafeClass.getDeclaredField(\"theUnsafe\");\n        f.setAccessible(true);\n        final Object unsafe \u003d f.get(null);\n        final Method allocateInstance \u003d unsafeClass.getMethod(\"allocateInstance\", Class.class);\n        return new $UnsafeAllocator() {\n\n            @Override\n            @SuppressWarnings(\"unchecked\")\n            public \u003cT\u003e T newInstance(Class\u003cT\u003e c) throws Exception {\n                return (T) allocateInstance.invoke(unsafe, c);\n            }\n        };\n    } catch (Exception ignored) {\n    }\n    try {\n        final Method newInstance \u003d ObjectInputStream.class.getDeclaredMethod(\"newInstance\", Class.class, Class.class);\n        newInstance.setAccessible(true);\n        return new $UnsafeAllocator() {\n\n            @Override\n            @SuppressWarnings(\"unchecked\")\n            public \u003cT\u003e T newInstance(Class\u003cT\u003e c) throws Exception {\n                return (T) newInstance.invoke(null, c, Object.class);\n            }\n        };\n    } catch (Exception ignored) {\n    }\n    try {\n        Method getConstructorId \u003d ObjectStreamClass.class.getDeclaredMethod(\"getConstructorId\", Class.class);\n        getConstructorId.setAccessible(true);\n        final int constructorId \u003d (Integer) getConstructorId.invoke(null, Object.class);\n        final Method newInstance \u003d ObjectStreamClass.class.getDeclaredMethod(\"newInstance\", Class.class, int.class);\n        newInstance.setAccessible(true);\n        return new $UnsafeAllocator() {\n\n            @Override\n            @SuppressWarnings(\"unchecked\")\n            public \u003cT\u003e T newInstance(Class\u003cT\u003e c) throws Exception {\n                return (T) newInstance.invoke(null, c, constructorId);\n            }\n        };\n    } catch (Exception ignored) {\n    }\n    return new $UnsafeAllocator() {\n\n        @Override\n        public \u003cT\u003e T newInstance(Class\u003cT\u003e c) {\n            throw new UnsupportedOperationException(\"Cannot allocate \" + c);\n        }\n    };\n}",
          "path": "gson/src/main/java/com/google/gson/internal/$UnsafeAllocator.java",
          "functionStartLine": 33,
          "functionName": "create",
          "functionAnnotation": "",
          "functionDoc": "",
          "diff": "@@ -1,54 +1,54 @@\n-public static UnsafeAllocator create() {\n+public static $UnsafeAllocator create() {\n     try {\n         Class\u003c?\u003e unsafeClass \u003d Class.forName(\"sun.misc.Unsafe\");\n         Field f \u003d unsafeClass.getDeclaredField(\"theUnsafe\");\n         f.setAccessible(true);\n         final Object unsafe \u003d f.get(null);\n         final Method allocateInstance \u003d unsafeClass.getMethod(\"allocateInstance\", Class.class);\n-        return new UnsafeAllocator() {\n+        return new $UnsafeAllocator() {\n \n             @Override\n             @SuppressWarnings(\"unchecked\")\n             public \u003cT\u003e T newInstance(Class\u003cT\u003e c) throws Exception {\n                 return (T) allocateInstance.invoke(unsafe, c);\n             }\n         };\n     } catch (Exception ignored) {\n     }\n     try {\n         final Method newInstance \u003d ObjectInputStream.class.getDeclaredMethod(\"newInstance\", Class.class, Class.class);\n         newInstance.setAccessible(true);\n-        return new UnsafeAllocator() {\n+        return new $UnsafeAllocator() {\n \n             @Override\n             @SuppressWarnings(\"unchecked\")\n             public \u003cT\u003e T newInstance(Class\u003cT\u003e c) throws Exception {\n                 return (T) newInstance.invoke(null, c, Object.class);\n             }\n         };\n     } catch (Exception ignored) {\n     }\n     try {\n         Method getConstructorId \u003d ObjectStreamClass.class.getDeclaredMethod(\"getConstructorId\", Class.class);\n         getConstructorId.setAccessible(true);\n         final int constructorId \u003d (Integer) getConstructorId.invoke(null, Object.class);\n         final Method newInstance \u003d ObjectStreamClass.class.getDeclaredMethod(\"newInstance\", Class.class, int.class);\n         newInstance.setAccessible(true);\n-        return new UnsafeAllocator() {\n+        return new $UnsafeAllocator() {\n \n             @Override\n             @SuppressWarnings(\"unchecked\")\n             public \u003cT\u003e T newInstance(Class\u003cT\u003e c) throws Exception {\n                 return (T) newInstance.invoke(null, c, constructorId);\n             }\n         };\n     } catch (Exception ignored) {\n     }\n-    return new UnsafeAllocator() {\n+    return new $UnsafeAllocator() {\n \n         @Override\n         public \u003cT\u003e T newInstance(Class\u003cT\u003e c) {\n             throw new UnsupportedOperationException(\"Cannot allocate \" + c);\n         }\n     };\n }\n\\ No newline at end of file\n",
          "extendedDetails": {}
        }
      ]
    },
    "b51ffc1060103ab27cfc6a6f107f04111ba098f6": {
      "type": "Ybodychange",
      "commitMessage": "Removed eclipse warnings about missing overrides and declared exceptions that are never thrown.\n",
      "commitDate": "3/24/11, 1:08 PM",
      "commitName": "b51ffc1060103ab27cfc6a6f107f04111ba098f6",
      "commitAuthor": "Inderjeet Singh",
      "commitDateOld": "3/21/11, 3:30 PM",
      "commitNameOld": "861e047a6222d581ecf1f617599629bbf8654d34",
      "commitAuthorOld": "Joel Leitch",
      "daysBetweenCommits": 2.9,
      "commitsBetweenForRepo": 5,
      "commitsBetweenForFile": 1,
      "actualSource": "public static UnsafeAllocator create() {\n    try {\n        Class\u003c?\u003e unsafeClass \u003d Class.forName(\"sun.misc.Unsafe\");\n        Field f \u003d unsafeClass.getDeclaredField(\"theUnsafe\");\n        f.setAccessible(true);\n        final Object unsafe \u003d f.get(null);\n        final Method allocateInstance \u003d unsafeClass.getMethod(\"allocateInstance\", Class.class);\n        return new UnsafeAllocator() {\n\n            @Override\n            @SuppressWarnings(\"unchecked\")\n            public \u003cT\u003e T newInstance(Class\u003cT\u003e c) throws Exception {\n                return (T) allocateInstance.invoke(unsafe, c);\n            }\n        };\n    } catch (Exception ignored) {\n    }\n    try {\n        final Method newInstance \u003d ObjectInputStream.class.getDeclaredMethod(\"newInstance\", Class.class, Class.class);\n        newInstance.setAccessible(true);\n        return new UnsafeAllocator() {\n\n            @Override\n            @SuppressWarnings(\"unchecked\")\n            public \u003cT\u003e T newInstance(Class\u003cT\u003e c) throws Exception {\n                return (T) newInstance.invoke(null, c, Object.class);\n            }\n        };\n    } catch (Exception ignored) {\n    }\n    try {\n        Method getConstructorId \u003d ObjectStreamClass.class.getDeclaredMethod(\"getConstructorId\", Class.class);\n        getConstructorId.setAccessible(true);\n        final int constructorId \u003d (Integer) getConstructorId.invoke(null, Object.class);\n        final Method newInstance \u003d ObjectStreamClass.class.getDeclaredMethod(\"newInstance\", Class.class, int.class);\n        newInstance.setAccessible(true);\n        return new UnsafeAllocator() {\n\n            @Override\n            @SuppressWarnings(\"unchecked\")\n            public \u003cT\u003e T newInstance(Class\u003cT\u003e c) throws Exception {\n                return (T) newInstance.invoke(null, c, constructorId);\n            }\n        };\n    } catch (Exception ignored) {\n    }\n    return new UnsafeAllocator() {\n\n        @Override\n        public \u003cT\u003e T newInstance(Class\u003cT\u003e c) {\n            throw new UnsupportedOperationException(\"Cannot allocate \" + c);\n        }\n    };\n}",
      "path": "gson/src/main/java/com/google/gson/internal/UnsafeAllocator.java",
      "functionStartLine": 33,
      "functionName": "create",
      "functionAnnotation": "",
      "functionDoc": "",
      "diff": "@@ -1,50 +1,54 @@\n public static UnsafeAllocator create() {\n     try {\n         Class\u003c?\u003e unsafeClass \u003d Class.forName(\"sun.misc.Unsafe\");\n         Field f \u003d unsafeClass.getDeclaredField(\"theUnsafe\");\n         f.setAccessible(true);\n         final Object unsafe \u003d f.get(null);\n         final Method allocateInstance \u003d unsafeClass.getMethod(\"allocateInstance\", Class.class);\n         return new UnsafeAllocator() {\n \n+            @Override\n             @SuppressWarnings(\"unchecked\")\n             public \u003cT\u003e T newInstance(Class\u003cT\u003e c) throws Exception {\n                 return (T) allocateInstance.invoke(unsafe, c);\n             }\n         };\n     } catch (Exception ignored) {\n     }\n     try {\n         final Method newInstance \u003d ObjectInputStream.class.getDeclaredMethod(\"newInstance\", Class.class, Class.class);\n         newInstance.setAccessible(true);\n         return new UnsafeAllocator() {\n \n+            @Override\n             @SuppressWarnings(\"unchecked\")\n             public \u003cT\u003e T newInstance(Class\u003cT\u003e c) throws Exception {\n                 return (T) newInstance.invoke(null, c, Object.class);\n             }\n         };\n     } catch (Exception ignored) {\n     }\n     try {\n         Method getConstructorId \u003d ObjectStreamClass.class.getDeclaredMethod(\"getConstructorId\", Class.class);\n         getConstructorId.setAccessible(true);\n         final int constructorId \u003d (Integer) getConstructorId.invoke(null, Object.class);\n         final Method newInstance \u003d ObjectStreamClass.class.getDeclaredMethod(\"newInstance\", Class.class, int.class);\n         newInstance.setAccessible(true);\n         return new UnsafeAllocator() {\n \n+            @Override\n             @SuppressWarnings(\"unchecked\")\n             public \u003cT\u003e T newInstance(Class\u003cT\u003e c) throws Exception {\n                 return (T) newInstance.invoke(null, c, constructorId);\n             }\n         };\n     } catch (Exception ignored) {\n     }\n     return new UnsafeAllocator() {\n \n-        public \u003cT\u003e T newInstance(Class\u003cT\u003e c) throws InstantiationException {\n+        @Override\n+        public \u003cT\u003e T newInstance(Class\u003cT\u003e c) {\n             throw new UnsupportedOperationException(\"Cannot allocate \" + c);\n         }\n     };\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "861e047a6222d581ecf1f617599629bbf8654d34": {
      "type": "Yfilerename",
      "commitMessage": "Create an \"internals\" package for classes that we do not want to share, but is needed across multiple pacakges.\n\nAs well, move non-Gson specific classes, such as Preconditions, to this new \"internals\" package.\n",
      "commitDate": "3/21/11, 3:30 PM",
      "commitName": "861e047a6222d581ecf1f617599629bbf8654d34",
      "commitAuthor": "Joel Leitch",
      "commitDateOld": "3/21/11, 3:10 PM",
      "commitNameOld": "657688ca797a08975aea47d364b309ac8b7c12bb",
      "commitAuthorOld": "Jesse Wilson",
      "daysBetweenCommits": 0.01,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "public static UnsafeAllocator create() {\n    try {\n        Class\u003c?\u003e unsafeClass \u003d Class.forName(\"sun.misc.Unsafe\");\n        Field f \u003d unsafeClass.getDeclaredField(\"theUnsafe\");\n        f.setAccessible(true);\n        final Object unsafe \u003d f.get(null);\n        final Method allocateInstance \u003d unsafeClass.getMethod(\"allocateInstance\", Class.class);\n        return new UnsafeAllocator() {\n\n            @SuppressWarnings(\"unchecked\")\n            public \u003cT\u003e T newInstance(Class\u003cT\u003e c) throws Exception {\n                return (T) allocateInstance.invoke(unsafe, c);\n            }\n        };\n    } catch (Exception ignored) {\n    }\n    try {\n        final Method newInstance \u003d ObjectInputStream.class.getDeclaredMethod(\"newInstance\", Class.class, Class.class);\n        newInstance.setAccessible(true);\n        return new UnsafeAllocator() {\n\n            @SuppressWarnings(\"unchecked\")\n            public \u003cT\u003e T newInstance(Class\u003cT\u003e c) throws Exception {\n                return (T) newInstance.invoke(null, c, Object.class);\n            }\n        };\n    } catch (Exception ignored) {\n    }\n    try {\n        Method getConstructorId \u003d ObjectStreamClass.class.getDeclaredMethod(\"getConstructorId\", Class.class);\n        getConstructorId.setAccessible(true);\n        final int constructorId \u003d (Integer) getConstructorId.invoke(null, Object.class);\n        final Method newInstance \u003d ObjectStreamClass.class.getDeclaredMethod(\"newInstance\", Class.class, int.class);\n        newInstance.setAccessible(true);\n        return new UnsafeAllocator() {\n\n            @SuppressWarnings(\"unchecked\")\n            public \u003cT\u003e T newInstance(Class\u003cT\u003e c) throws Exception {\n                return (T) newInstance.invoke(null, c, constructorId);\n            }\n        };\n    } catch (Exception ignored) {\n    }\n    return new UnsafeAllocator() {\n\n        public \u003cT\u003e T newInstance(Class\u003cT\u003e c) throws InstantiationException {\n            throw new UnsupportedOperationException(\"Cannot allocate \" + c);\n        }\n    };\n}",
      "path": "gson/src/main/java/com/google/gson/internal/UnsafeAllocator.java",
      "functionStartLine": 33,
      "functionName": "create",
      "functionAnnotation": "",
      "functionDoc": "",
      "diff": "",
      "extendedDetails": {
        "oldPath": "gson/src/main/java/com/google/gson/UnsafeAllocator.java",
        "newPath": "gson/src/main/java/com/google/gson/internal/UnsafeAllocator.java"
      }
    },
    "43137b6b4f005e70561a147b868284d94527069f": {
      "type": "Yintroduced",
      "commitMessage": "Fix unsafe allocations on Android\n",
      "commitDate": "3/10/11, 4:44 PM",
      "commitName": "43137b6b4f005e70561a147b868284d94527069f",
      "commitAuthor": "Jesse Wilson",
      "diff": "@@ -0,0 +1,50 @@\n+public static UnsafeAllocator create() {\n+    try {\n+        Class\u003c?\u003e unsafeClass \u003d Class.forName(\"sun.misc.Unsafe\");\n+        Field f \u003d unsafeClass.getDeclaredField(\"theUnsafe\");\n+        f.setAccessible(true);\n+        final Object unsafe \u003d f.get(null);\n+        final Method allocateInstance \u003d unsafeClass.getMethod(\"allocateInstance\", Class.class);\n+        return new UnsafeAllocator() {\n+\n+            @SuppressWarnings(\"unchecked\")\n+            public \u003cT\u003e T newInstance(Class\u003cT\u003e c) throws Exception {\n+                return (T) allocateInstance.invoke(unsafe, c);\n+            }\n+        };\n+    } catch (Exception ignored) {\n+    }\n+    try {\n+        final Method newInstance \u003d ObjectInputStream.class.getDeclaredMethod(\"newInstance\", Class.class, Class.class);\n+        newInstance.setAccessible(true);\n+        return new UnsafeAllocator() {\n+\n+            @SuppressWarnings(\"unchecked\")\n+            public \u003cT\u003e T newInstance(Class\u003cT\u003e c) throws Exception {\n+                return (T) newInstance.invoke(null, c, Object.class);\n+            }\n+        };\n+    } catch (Exception ignored) {\n+    }\n+    try {\n+        Method getConstructorId \u003d ObjectStreamClass.class.getDeclaredMethod(\"getConstructorId\", Class.class);\n+        getConstructorId.setAccessible(true);\n+        final int constructorId \u003d (Integer) getConstructorId.invoke(null, Object.class);\n+        final Method newInstance \u003d ObjectStreamClass.class.getDeclaredMethod(\"newInstance\", Class.class, int.class);\n+        newInstance.setAccessible(true);\n+        return new UnsafeAllocator() {\n+\n+            @SuppressWarnings(\"unchecked\")\n+            public \u003cT\u003e T newInstance(Class\u003cT\u003e c) throws Exception {\n+                return (T) newInstance.invoke(null, c, constructorId);\n+            }\n+        };\n+    } catch (Exception ignored) {\n+    }\n+    return new UnsafeAllocator() {\n+\n+        public \u003cT\u003e T newInstance(Class\u003cT\u003e c) throws InstantiationException {\n+            throw new UnsupportedOperationException(\"Cannot allocate \" + c);\n+        }\n+    };\n+}\n\\ No newline at end of file\n",
      "actualSource": "public static UnsafeAllocator create() {\n    try {\n        Class\u003c?\u003e unsafeClass \u003d Class.forName(\"sun.misc.Unsafe\");\n        Field f \u003d unsafeClass.getDeclaredField(\"theUnsafe\");\n        f.setAccessible(true);\n        final Object unsafe \u003d f.get(null);\n        final Method allocateInstance \u003d unsafeClass.getMethod(\"allocateInstance\", Class.class);\n        return new UnsafeAllocator() {\n\n            @SuppressWarnings(\"unchecked\")\n            public \u003cT\u003e T newInstance(Class\u003cT\u003e c) throws Exception {\n                return (T) allocateInstance.invoke(unsafe, c);\n            }\n        };\n    } catch (Exception ignored) {\n    }\n    try {\n        final Method newInstance \u003d ObjectInputStream.class.getDeclaredMethod(\"newInstance\", Class.class, Class.class);\n        newInstance.setAccessible(true);\n        return new UnsafeAllocator() {\n\n            @SuppressWarnings(\"unchecked\")\n            public \u003cT\u003e T newInstance(Class\u003cT\u003e c) throws Exception {\n                return (T) newInstance.invoke(null, c, Object.class);\n            }\n        };\n    } catch (Exception ignored) {\n    }\n    try {\n        Method getConstructorId \u003d ObjectStreamClass.class.getDeclaredMethod(\"getConstructorId\", Class.class);\n        getConstructorId.setAccessible(true);\n        final int constructorId \u003d (Integer) getConstructorId.invoke(null, Object.class);\n        final Method newInstance \u003d ObjectStreamClass.class.getDeclaredMethod(\"newInstance\", Class.class, int.class);\n        newInstance.setAccessible(true);\n        return new UnsafeAllocator() {\n\n            @SuppressWarnings(\"unchecked\")\n            public \u003cT\u003e T newInstance(Class\u003cT\u003e c) throws Exception {\n                return (T) newInstance.invoke(null, c, constructorId);\n            }\n        };\n    } catch (Exception ignored) {\n    }\n    return new UnsafeAllocator() {\n\n        public \u003cT\u003e T newInstance(Class\u003cT\u003e c) throws InstantiationException {\n            throw new UnsupportedOperationException(\"Cannot allocate \" + c);\n        }\n    };\n}",
      "path": "gson/src/main/java/com/google/gson/UnsafeAllocator.java",
      "functionStartLine": 33,
      "functionName": "create",
      "functionAnnotation": "",
      "functionDoc": ""
    }
  }
}