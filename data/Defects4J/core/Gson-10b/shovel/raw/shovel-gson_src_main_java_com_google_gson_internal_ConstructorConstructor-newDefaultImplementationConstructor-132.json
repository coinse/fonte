{
  "origin": "codeshovel",
  "repositoryName": "Gson-10b",
  "repositoryPath": "/tmp/Gson-10b//.git",
  "startCommitName": "HEAD",
  "sourceFileName": "ConstructorConstructor.java",
  "functionName": "newDefaultImplementationConstructor",
  "functionId": "newDefaultImplementationConstructor___type-Type(modifiers-final)__rawType-Class__? super T__",
  "sourceFilePath": "gson/src/main/java/com/google/gson/internal/ConstructorConstructor.java",
  "functionAnnotation": "// use runtime checks to guarantee that \u0027T\u0027 is what it is\n@SuppressWarnings(\"unchecked\")",
  "functionDoc": "Constructors for common interface types like Map and List and their\nsubtypes.\n",
  "functionStartLine": 132,
  "functionEndLine": 214,
  "numCommitsSeen": 26,
  "timeTaken": 1813,
  "changeHistory": [
    "371aff7ce4fb73ed997cbf6aa08706f272cef0c6",
    "fef43b2aaa4fd7cb8f0dff395980c69f614635af",
    "2ecce944948e63f703e10cd34f4e2f410a7f3921",
    "f29d5bc37b52c4b8d2ad15a10bb0c7f684c1d45d",
    "af6aa5f782dcfc38a060d2de9476337e14ffedcb",
    "7d53113ebc9ef6921c6238f013aabd10890611a0",
    "14f16e2d0c3c60338d69a3e0f653b8b876fdc1be",
    "1a4f690335ae1129620079c4b5587a7261206c12",
    "ad3489f557d951ebd4574d04adf4b0bb4108d05f",
    "4a6c084ef73e5e8a3fca12f9bb829a218fad7a84",
    "25c6ae177b1ca56db7f3c29eb574bdd032a06165"
  ],
  "changeHistoryShort": {
    "371aff7ce4fb73ed997cbf6aa08706f272cef0c6": "Ybodychange",
    "fef43b2aaa4fd7cb8f0dff395980c69f614635af": "Ybodychange",
    "2ecce944948e63f703e10cd34f4e2f410a7f3921": "Ydocchange",
    "f29d5bc37b52c4b8d2ad15a10bb0c7f684c1d45d": "Ybodychange",
    "af6aa5f782dcfc38a060d2de9476337e14ffedcb": "Ybodychange",
    "7d53113ebc9ef6921c6238f013aabd10890611a0": "Ymultichange(Ybodychange,Yparametermetachange)",
    "14f16e2d0c3c60338d69a3e0f653b8b876fdc1be": "Ybodychange",
    "1a4f690335ae1129620079c4b5587a7261206c12": "Ymultichange(Yparameterchange,Ybodychange)",
    "ad3489f557d951ebd4574d04adf4b0bb4108d05f": "Ybodychange",
    "4a6c084ef73e5e8a3fca12f9bb829a218fad7a84": "Ybodychange",
    "25c6ae177b1ca56db7f3c29eb574bdd032a06165": "Yintroduced"
  },
  "changeHistoryDetails": {
    "371aff7ce4fb73ed997cbf6aa08706f272cef0c6": {
      "type": "Ybodychange",
      "commitMessage": "Switch default Queue implementation to ArrayDeque.\n\nNow that we require Java 1.6 or newer this much more efficient implementation can be used as the default.\n",
      "commitDate": "4/26/16, 9:37 PM",
      "commitName": "371aff7ce4fb73ed997cbf6aa08706f272cef0c6",
      "commitAuthor": "Jake Wharton",
      "commitDateOld": "11/4/15, 9:25 PM",
      "commitNameOld": "fef43b2aaa4fd7cb8f0dff395980c69f614635af",
      "commitAuthorOld": "Inderjeet Singh",
      "daysBetweenCommits": 173.97,
      "commitsBetweenForRepo": 92,
      "commitsBetweenForFile": 1,
      "actualSource": "@SuppressWarnings(\"unchecked\")\nprivate \u003cT\u003e ObjectConstructor\u003cT\u003e newDefaultImplementationConstructor(final Type type, Class\u003c? super T\u003e rawType) {\n    if (Collection.class.isAssignableFrom(rawType)) {\n        if (SortedSet.class.isAssignableFrom(rawType)) {\n            return new ObjectConstructor\u003cT\u003e() {\n\n                @Override\n                public T construct() {\n                    return (T) new TreeSet\u003cObject\u003e();\n                }\n            };\n        } else if (EnumSet.class.isAssignableFrom(rawType)) {\n            return new ObjectConstructor\u003cT\u003e() {\n\n                @SuppressWarnings(\"rawtypes\")\n                @Override\n                public T construct() {\n                    if (type instanceof ParameterizedType) {\n                        Type elementType \u003d ((ParameterizedType) type).getActualTypeArguments()[0];\n                        if (elementType instanceof Class) {\n                            return (T) EnumSet.noneOf((Class) elementType);\n                        } else {\n                            throw new JsonIOException(\"Invalid EnumSet type: \" + type.toString());\n                        }\n                    } else {\n                        throw new JsonIOException(\"Invalid EnumSet type: \" + type.toString());\n                    }\n                }\n            };\n        } else if (Set.class.isAssignableFrom(rawType)) {\n            return new ObjectConstructor\u003cT\u003e() {\n\n                @Override\n                public T construct() {\n                    return (T) new LinkedHashSet\u003cObject\u003e();\n                }\n            };\n        } else if (Queue.class.isAssignableFrom(rawType)) {\n            return new ObjectConstructor\u003cT\u003e() {\n\n                @Override\n                public T construct() {\n                    return (T) new ArrayDeque\u003cObject\u003e();\n                }\n            };\n        } else {\n            return new ObjectConstructor\u003cT\u003e() {\n\n                @Override\n                public T construct() {\n                    return (T) new ArrayList\u003cObject\u003e();\n                }\n            };\n        }\n    }\n    if (Map.class.isAssignableFrom(rawType)) {\n        if (ConcurrentNavigableMap.class.isAssignableFrom(rawType)) {\n            return new ObjectConstructor\u003cT\u003e() {\n\n                @Override\n                public T construct() {\n                    return (T) new ConcurrentSkipListMap\u003cObject, Object\u003e();\n                }\n            };\n        } else if (ConcurrentMap.class.isAssignableFrom(rawType)) {\n            return new ObjectConstructor\u003cT\u003e() {\n\n                @Override\n                public T construct() {\n                    return (T) new ConcurrentHashMap\u003cObject, Object\u003e();\n                }\n            };\n        } else if (SortedMap.class.isAssignableFrom(rawType)) {\n            return new ObjectConstructor\u003cT\u003e() {\n\n                @Override\n                public T construct() {\n                    return (T) new TreeMap\u003cObject, Object\u003e();\n                }\n            };\n        } else if (type instanceof ParameterizedType \u0026\u0026 !(String.class.isAssignableFrom(TypeToken.get(((ParameterizedType) type).getActualTypeArguments()[0]).getRawType()))) {\n            return new ObjectConstructor\u003cT\u003e() {\n\n                @Override\n                public T construct() {\n                    return (T) new LinkedHashMap\u003cObject, Object\u003e();\n                }\n            };\n        } else {\n            return new ObjectConstructor\u003cT\u003e() {\n\n                @Override\n                public T construct() {\n                    return (T) new LinkedTreeMap\u003cString, Object\u003e();\n                }\n            };\n        }\n    }\n    return null;\n}",
      "path": "gson/src/main/java/com/google/gson/internal/ConstructorConstructor.java",
      "functionStartLine": 132,
      "functionName": "newDefaultImplementationConstructor",
      "functionAnnotation": "// use runtime checks to guarantee that \u0027T\u0027 is what it is\n@SuppressWarnings(\"unchecked\")",
      "functionDoc": "Constructors for common interface types like Map and List and their\nsubtypes.\n",
      "diff": "@@ -1,100 +1,100 @@\n @SuppressWarnings(\"unchecked\")\n private \u003cT\u003e ObjectConstructor\u003cT\u003e newDefaultImplementationConstructor(final Type type, Class\u003c? super T\u003e rawType) {\n     if (Collection.class.isAssignableFrom(rawType)) {\n         if (SortedSet.class.isAssignableFrom(rawType)) {\n             return new ObjectConstructor\u003cT\u003e() {\n \n                 @Override\n                 public T construct() {\n                     return (T) new TreeSet\u003cObject\u003e();\n                 }\n             };\n         } else if (EnumSet.class.isAssignableFrom(rawType)) {\n             return new ObjectConstructor\u003cT\u003e() {\n \n                 @SuppressWarnings(\"rawtypes\")\n                 @Override\n                 public T construct() {\n                     if (type instanceof ParameterizedType) {\n                         Type elementType \u003d ((ParameterizedType) type).getActualTypeArguments()[0];\n                         if (elementType instanceof Class) {\n                             return (T) EnumSet.noneOf((Class) elementType);\n                         } else {\n                             throw new JsonIOException(\"Invalid EnumSet type: \" + type.toString());\n                         }\n                     } else {\n                         throw new JsonIOException(\"Invalid EnumSet type: \" + type.toString());\n                     }\n                 }\n             };\n         } else if (Set.class.isAssignableFrom(rawType)) {\n             return new ObjectConstructor\u003cT\u003e() {\n \n                 @Override\n                 public T construct() {\n                     return (T) new LinkedHashSet\u003cObject\u003e();\n                 }\n             };\n         } else if (Queue.class.isAssignableFrom(rawType)) {\n             return new ObjectConstructor\u003cT\u003e() {\n \n                 @Override\n                 public T construct() {\n-                    return (T) new LinkedList\u003cObject\u003e();\n+                    return (T) new ArrayDeque\u003cObject\u003e();\n                 }\n             };\n         } else {\n             return new ObjectConstructor\u003cT\u003e() {\n \n                 @Override\n                 public T construct() {\n                     return (T) new ArrayList\u003cObject\u003e();\n                 }\n             };\n         }\n     }\n     if (Map.class.isAssignableFrom(rawType)) {\n         if (ConcurrentNavigableMap.class.isAssignableFrom(rawType)) {\n             return new ObjectConstructor\u003cT\u003e() {\n \n                 @Override\n                 public T construct() {\n                     return (T) new ConcurrentSkipListMap\u003cObject, Object\u003e();\n                 }\n             };\n         } else if (ConcurrentMap.class.isAssignableFrom(rawType)) {\n             return new ObjectConstructor\u003cT\u003e() {\n \n                 @Override\n                 public T construct() {\n                     return (T) new ConcurrentHashMap\u003cObject, Object\u003e();\n                 }\n             };\n         } else if (SortedMap.class.isAssignableFrom(rawType)) {\n             return new ObjectConstructor\u003cT\u003e() {\n \n                 @Override\n                 public T construct() {\n                     return (T) new TreeMap\u003cObject, Object\u003e();\n                 }\n             };\n         } else if (type instanceof ParameterizedType \u0026\u0026 !(String.class.isAssignableFrom(TypeToken.get(((ParameterizedType) type).getActualTypeArguments()[0]).getRawType()))) {\n             return new ObjectConstructor\u003cT\u003e() {\n \n                 @Override\n                 public T construct() {\n                     return (T) new LinkedHashMap\u003cObject, Object\u003e();\n                 }\n             };\n         } else {\n             return new ObjectConstructor\u003cT\u003e() {\n \n                 @Override\n                 public T construct() {\n                     return (T) new LinkedTreeMap\u003cString, Object\u003e();\n                 }\n             };\n         }\n     }\n     return null;\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "fef43b2aaa4fd7cb8f0dff395980c69f614635af": {
      "type": "Ybodychange",
      "commitMessage": "Added support to serialize/deserialize ConcurrentMap and ConcurrentNavigableMap.\n",
      "commitDate": "11/4/15, 9:25 PM",
      "commitName": "fef43b2aaa4fd7cb8f0dff395980c69f614635af",
      "commitAuthor": "Inderjeet Singh",
      "commitDateOld": "9/27/15, 3:31 AM",
      "commitNameOld": "2ecce944948e63f703e10cd34f4e2f410a7f3921",
      "commitAuthorOld": "dushyant",
      "daysBetweenCommits": 38.79,
      "commitsBetweenForRepo": 25,
      "commitsBetweenForFile": 1,
      "actualSource": "@SuppressWarnings(\"unchecked\")\nprivate \u003cT\u003e ObjectConstructor\u003cT\u003e newDefaultImplementationConstructor(final Type type, Class\u003c? super T\u003e rawType) {\n    if (Collection.class.isAssignableFrom(rawType)) {\n        if (SortedSet.class.isAssignableFrom(rawType)) {\n            return new ObjectConstructor\u003cT\u003e() {\n\n                @Override\n                public T construct() {\n                    return (T) new TreeSet\u003cObject\u003e();\n                }\n            };\n        } else if (EnumSet.class.isAssignableFrom(rawType)) {\n            return new ObjectConstructor\u003cT\u003e() {\n\n                @SuppressWarnings(\"rawtypes\")\n                @Override\n                public T construct() {\n                    if (type instanceof ParameterizedType) {\n                        Type elementType \u003d ((ParameterizedType) type).getActualTypeArguments()[0];\n                        if (elementType instanceof Class) {\n                            return (T) EnumSet.noneOf((Class) elementType);\n                        } else {\n                            throw new JsonIOException(\"Invalid EnumSet type: \" + type.toString());\n                        }\n                    } else {\n                        throw new JsonIOException(\"Invalid EnumSet type: \" + type.toString());\n                    }\n                }\n            };\n        } else if (Set.class.isAssignableFrom(rawType)) {\n            return new ObjectConstructor\u003cT\u003e() {\n\n                @Override\n                public T construct() {\n                    return (T) new LinkedHashSet\u003cObject\u003e();\n                }\n            };\n        } else if (Queue.class.isAssignableFrom(rawType)) {\n            return new ObjectConstructor\u003cT\u003e() {\n\n                @Override\n                public T construct() {\n                    return (T) new LinkedList\u003cObject\u003e();\n                }\n            };\n        } else {\n            return new ObjectConstructor\u003cT\u003e() {\n\n                @Override\n                public T construct() {\n                    return (T) new ArrayList\u003cObject\u003e();\n                }\n            };\n        }\n    }\n    if (Map.class.isAssignableFrom(rawType)) {\n        if (ConcurrentNavigableMap.class.isAssignableFrom(rawType)) {\n            return new ObjectConstructor\u003cT\u003e() {\n\n                @Override\n                public T construct() {\n                    return (T) new ConcurrentSkipListMap\u003cObject, Object\u003e();\n                }\n            };\n        } else if (ConcurrentMap.class.isAssignableFrom(rawType)) {\n            return new ObjectConstructor\u003cT\u003e() {\n\n                @Override\n                public T construct() {\n                    return (T) new ConcurrentHashMap\u003cObject, Object\u003e();\n                }\n            };\n        } else if (SortedMap.class.isAssignableFrom(rawType)) {\n            return new ObjectConstructor\u003cT\u003e() {\n\n                @Override\n                public T construct() {\n                    return (T) new TreeMap\u003cObject, Object\u003e();\n                }\n            };\n        } else if (type instanceof ParameterizedType \u0026\u0026 !(String.class.isAssignableFrom(TypeToken.get(((ParameterizedType) type).getActualTypeArguments()[0]).getRawType()))) {\n            return new ObjectConstructor\u003cT\u003e() {\n\n                @Override\n                public T construct() {\n                    return (T) new LinkedHashMap\u003cObject, Object\u003e();\n                }\n            };\n        } else {\n            return new ObjectConstructor\u003cT\u003e() {\n\n                @Override\n                public T construct() {\n                    return (T) new LinkedTreeMap\u003cString, Object\u003e();\n                }\n            };\n        }\n    }\n    return null;\n}",
      "path": "gson/src/main/java/com/google/gson/internal/ConstructorConstructor.java",
      "functionStartLine": 132,
      "functionName": "newDefaultImplementationConstructor",
      "functionAnnotation": "// use runtime checks to guarantee that \u0027T\u0027 is what it is\n@SuppressWarnings(\"unchecked\")",
      "functionDoc": "Constructors for common interface types like Map and List and their\nsubtypes.\n",
      "diff": "@@ -1,76 +1,100 @@\n @SuppressWarnings(\"unchecked\")\n private \u003cT\u003e ObjectConstructor\u003cT\u003e newDefaultImplementationConstructor(final Type type, Class\u003c? super T\u003e rawType) {\n     if (Collection.class.isAssignableFrom(rawType)) {\n         if (SortedSet.class.isAssignableFrom(rawType)) {\n             return new ObjectConstructor\u003cT\u003e() {\n \n+                @Override\n                 public T construct() {\n                     return (T) new TreeSet\u003cObject\u003e();\n                 }\n             };\n         } else if (EnumSet.class.isAssignableFrom(rawType)) {\n             return new ObjectConstructor\u003cT\u003e() {\n \n                 @SuppressWarnings(\"rawtypes\")\n+                @Override\n                 public T construct() {\n                     if (type instanceof ParameterizedType) {\n                         Type elementType \u003d ((ParameterizedType) type).getActualTypeArguments()[0];\n                         if (elementType instanceof Class) {\n                             return (T) EnumSet.noneOf((Class) elementType);\n                         } else {\n                             throw new JsonIOException(\"Invalid EnumSet type: \" + type.toString());\n                         }\n                     } else {\n                         throw new JsonIOException(\"Invalid EnumSet type: \" + type.toString());\n                     }\n                 }\n             };\n         } else if (Set.class.isAssignableFrom(rawType)) {\n             return new ObjectConstructor\u003cT\u003e() {\n \n+                @Override\n                 public T construct() {\n                     return (T) new LinkedHashSet\u003cObject\u003e();\n                 }\n             };\n         } else if (Queue.class.isAssignableFrom(rawType)) {\n             return new ObjectConstructor\u003cT\u003e() {\n \n+                @Override\n                 public T construct() {\n                     return (T) new LinkedList\u003cObject\u003e();\n                 }\n             };\n         } else {\n             return new ObjectConstructor\u003cT\u003e() {\n \n+                @Override\n                 public T construct() {\n                     return (T) new ArrayList\u003cObject\u003e();\n                 }\n             };\n         }\n     }\n     if (Map.class.isAssignableFrom(rawType)) {\n-        if (SortedMap.class.isAssignableFrom(rawType)) {\n+        if (ConcurrentNavigableMap.class.isAssignableFrom(rawType)) {\n             return new ObjectConstructor\u003cT\u003e() {\n \n+                @Override\n+                public T construct() {\n+                    return (T) new ConcurrentSkipListMap\u003cObject, Object\u003e();\n+                }\n+            };\n+        } else if (ConcurrentMap.class.isAssignableFrom(rawType)) {\n+            return new ObjectConstructor\u003cT\u003e() {\n+\n+                @Override\n+                public T construct() {\n+                    return (T) new ConcurrentHashMap\u003cObject, Object\u003e();\n+                }\n+            };\n+        } else if (SortedMap.class.isAssignableFrom(rawType)) {\n+            return new ObjectConstructor\u003cT\u003e() {\n+\n+                @Override\n                 public T construct() {\n                     return (T) new TreeMap\u003cObject, Object\u003e();\n                 }\n             };\n         } else if (type instanceof ParameterizedType \u0026\u0026 !(String.class.isAssignableFrom(TypeToken.get(((ParameterizedType) type).getActualTypeArguments()[0]).getRawType()))) {\n             return new ObjectConstructor\u003cT\u003e() {\n \n+                @Override\n                 public T construct() {\n                     return (T) new LinkedHashMap\u003cObject, Object\u003e();\n                 }\n             };\n         } else {\n             return new ObjectConstructor\u003cT\u003e() {\n \n+                @Override\n                 public T construct() {\n                     return (T) new LinkedTreeMap\u003cString, Object\u003e();\n                 }\n             };\n         }\n     }\n     return null;\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "2ecce944948e63f703e10cd34f4e2f410a7f3921": {
      "type": "Ydocchange",
      "commitMessage": "typo\n",
      "commitDate": "9/27/15, 3:31 AM",
      "commitName": "2ecce944948e63f703e10cd34f4e2f410a7f3921",
      "commitAuthor": "dushyant",
      "commitDateOld": "5/3/13, 9:11 AM",
      "commitNameOld": "f29d5bc37b52c4b8d2ad15a10bb0c7f684c1d45d",
      "commitAuthorOld": "Joel Leitch",
      "daysBetweenCommits": 876.76,
      "commitsBetweenForRepo": 104,
      "commitsBetweenForFile": 1,
      "actualSource": "@SuppressWarnings(\"unchecked\")\nprivate \u003cT\u003e ObjectConstructor\u003cT\u003e newDefaultImplementationConstructor(final Type type, Class\u003c? super T\u003e rawType) {\n    if (Collection.class.isAssignableFrom(rawType)) {\n        if (SortedSet.class.isAssignableFrom(rawType)) {\n            return new ObjectConstructor\u003cT\u003e() {\n\n                public T construct() {\n                    return (T) new TreeSet\u003cObject\u003e();\n                }\n            };\n        } else if (EnumSet.class.isAssignableFrom(rawType)) {\n            return new ObjectConstructor\u003cT\u003e() {\n\n                @SuppressWarnings(\"rawtypes\")\n                public T construct() {\n                    if (type instanceof ParameterizedType) {\n                        Type elementType \u003d ((ParameterizedType) type).getActualTypeArguments()[0];\n                        if (elementType instanceof Class) {\n                            return (T) EnumSet.noneOf((Class) elementType);\n                        } else {\n                            throw new JsonIOException(\"Invalid EnumSet type: \" + type.toString());\n                        }\n                    } else {\n                        throw new JsonIOException(\"Invalid EnumSet type: \" + type.toString());\n                    }\n                }\n            };\n        } else if (Set.class.isAssignableFrom(rawType)) {\n            return new ObjectConstructor\u003cT\u003e() {\n\n                public T construct() {\n                    return (T) new LinkedHashSet\u003cObject\u003e();\n                }\n            };\n        } else if (Queue.class.isAssignableFrom(rawType)) {\n            return new ObjectConstructor\u003cT\u003e() {\n\n                public T construct() {\n                    return (T) new LinkedList\u003cObject\u003e();\n                }\n            };\n        } else {\n            return new ObjectConstructor\u003cT\u003e() {\n\n                public T construct() {\n                    return (T) new ArrayList\u003cObject\u003e();\n                }\n            };\n        }\n    }\n    if (Map.class.isAssignableFrom(rawType)) {\n        if (SortedMap.class.isAssignableFrom(rawType)) {\n            return new ObjectConstructor\u003cT\u003e() {\n\n                public T construct() {\n                    return (T) new TreeMap\u003cObject, Object\u003e();\n                }\n            };\n        } else if (type instanceof ParameterizedType \u0026\u0026 !(String.class.isAssignableFrom(TypeToken.get(((ParameterizedType) type).getActualTypeArguments()[0]).getRawType()))) {\n            return new ObjectConstructor\u003cT\u003e() {\n\n                public T construct() {\n                    return (T) new LinkedHashMap\u003cObject, Object\u003e();\n                }\n            };\n        } else {\n            return new ObjectConstructor\u003cT\u003e() {\n\n                public T construct() {\n                    return (T) new LinkedTreeMap\u003cString, Object\u003e();\n                }\n            };\n        }\n    }\n    return null;\n}",
      "path": "gson/src/main/java/com/google/gson/internal/ConstructorConstructor.java",
      "functionStartLine": 128,
      "functionName": "newDefaultImplementationConstructor",
      "functionAnnotation": "// use runtime checks to guarantee that \u0027T\u0027 is what it is\n@SuppressWarnings(\"unchecked\")",
      "functionDoc": "Constructors for common interface types like Map and List and their\nsubtypes.\n",
      "diff": "",
      "extendedDetails": {
        "oldValue": "Constructors for common interface types like Map and List and their\nsubytpes.\n",
        "newValue": "Constructors for common interface types like Map and List and their\nsubtypes.\n"
      }
    },
    "f29d5bc37b52c4b8d2ad15a10bb0c7f684c1d45d": {
      "type": "Ybodychange",
      "commitMessage": "Create a LinkedTreeMap based on the LinkedHashTreeMap; however, removed all the hashing from it as resorted to a single tree. The insertion order is still preserved.\n",
      "commitDate": "5/3/13, 9:11 AM",
      "commitName": "f29d5bc37b52c4b8d2ad15a10bb0c7f684c1d45d",
      "commitAuthor": "Joel Leitch",
      "commitDateOld": "4/4/13, 2:40 PM",
      "commitNameOld": "edd6c19670b7d56700b2093071122a0015c06e95",
      "commitAuthorOld": "Inderjeet Singh",
      "daysBetweenCommits": 28.77,
      "commitsBetweenForRepo": 16,
      "commitsBetweenForFile": 1,
      "actualSource": "@SuppressWarnings(\"unchecked\")\nprivate \u003cT\u003e ObjectConstructor\u003cT\u003e newDefaultImplementationConstructor(final Type type, Class\u003c? super T\u003e rawType) {\n    if (Collection.class.isAssignableFrom(rawType)) {\n        if (SortedSet.class.isAssignableFrom(rawType)) {\n            return new ObjectConstructor\u003cT\u003e() {\n\n                public T construct() {\n                    return (T) new TreeSet\u003cObject\u003e();\n                }\n            };\n        } else if (EnumSet.class.isAssignableFrom(rawType)) {\n            return new ObjectConstructor\u003cT\u003e() {\n\n                @SuppressWarnings(\"rawtypes\")\n                public T construct() {\n                    if (type instanceof ParameterizedType) {\n                        Type elementType \u003d ((ParameterizedType) type).getActualTypeArguments()[0];\n                        if (elementType instanceof Class) {\n                            return (T) EnumSet.noneOf((Class) elementType);\n                        } else {\n                            throw new JsonIOException(\"Invalid EnumSet type: \" + type.toString());\n                        }\n                    } else {\n                        throw new JsonIOException(\"Invalid EnumSet type: \" + type.toString());\n                    }\n                }\n            };\n        } else if (Set.class.isAssignableFrom(rawType)) {\n            return new ObjectConstructor\u003cT\u003e() {\n\n                public T construct() {\n                    return (T) new LinkedHashSet\u003cObject\u003e();\n                }\n            };\n        } else if (Queue.class.isAssignableFrom(rawType)) {\n            return new ObjectConstructor\u003cT\u003e() {\n\n                public T construct() {\n                    return (T) new LinkedList\u003cObject\u003e();\n                }\n            };\n        } else {\n            return new ObjectConstructor\u003cT\u003e() {\n\n                public T construct() {\n                    return (T) new ArrayList\u003cObject\u003e();\n                }\n            };\n        }\n    }\n    if (Map.class.isAssignableFrom(rawType)) {\n        if (SortedMap.class.isAssignableFrom(rawType)) {\n            return new ObjectConstructor\u003cT\u003e() {\n\n                public T construct() {\n                    return (T) new TreeMap\u003cObject, Object\u003e();\n                }\n            };\n        } else if (type instanceof ParameterizedType \u0026\u0026 !(String.class.isAssignableFrom(TypeToken.get(((ParameterizedType) type).getActualTypeArguments()[0]).getRawType()))) {\n            return new ObjectConstructor\u003cT\u003e() {\n\n                public T construct() {\n                    return (T) new LinkedHashMap\u003cObject, Object\u003e();\n                }\n            };\n        } else {\n            return new ObjectConstructor\u003cT\u003e() {\n\n                public T construct() {\n                    return (T) new LinkedTreeMap\u003cString, Object\u003e();\n                }\n            };\n        }\n    }\n    return null;\n}",
      "path": "gson/src/main/java/com/google/gson/internal/ConstructorConstructor.java",
      "functionStartLine": 128,
      "functionName": "newDefaultImplementationConstructor",
      "functionAnnotation": "// use runtime checks to guarantee that \u0027T\u0027 is what it is\n@SuppressWarnings(\"unchecked\")",
      "functionDoc": "Constructors for common interface types like Map and List and their\nsubytpes.\n",
      "diff": "@@ -1,76 +1,76 @@\n @SuppressWarnings(\"unchecked\")\n private \u003cT\u003e ObjectConstructor\u003cT\u003e newDefaultImplementationConstructor(final Type type, Class\u003c? super T\u003e rawType) {\n     if (Collection.class.isAssignableFrom(rawType)) {\n         if (SortedSet.class.isAssignableFrom(rawType)) {\n             return new ObjectConstructor\u003cT\u003e() {\n \n                 public T construct() {\n                     return (T) new TreeSet\u003cObject\u003e();\n                 }\n             };\n         } else if (EnumSet.class.isAssignableFrom(rawType)) {\n             return new ObjectConstructor\u003cT\u003e() {\n \n                 @SuppressWarnings(\"rawtypes\")\n                 public T construct() {\n                     if (type instanceof ParameterizedType) {\n                         Type elementType \u003d ((ParameterizedType) type).getActualTypeArguments()[0];\n                         if (elementType instanceof Class) {\n                             return (T) EnumSet.noneOf((Class) elementType);\n                         } else {\n                             throw new JsonIOException(\"Invalid EnumSet type: \" + type.toString());\n                         }\n                     } else {\n                         throw new JsonIOException(\"Invalid EnumSet type: \" + type.toString());\n                     }\n                 }\n             };\n         } else if (Set.class.isAssignableFrom(rawType)) {\n             return new ObjectConstructor\u003cT\u003e() {\n \n                 public T construct() {\n                     return (T) new LinkedHashSet\u003cObject\u003e();\n                 }\n             };\n         } else if (Queue.class.isAssignableFrom(rawType)) {\n             return new ObjectConstructor\u003cT\u003e() {\n \n                 public T construct() {\n                     return (T) new LinkedList\u003cObject\u003e();\n                 }\n             };\n         } else {\n             return new ObjectConstructor\u003cT\u003e() {\n \n                 public T construct() {\n                     return (T) new ArrayList\u003cObject\u003e();\n                 }\n             };\n         }\n     }\n     if (Map.class.isAssignableFrom(rawType)) {\n         if (SortedMap.class.isAssignableFrom(rawType)) {\n             return new ObjectConstructor\u003cT\u003e() {\n \n                 public T construct() {\n                     return (T) new TreeMap\u003cObject, Object\u003e();\n                 }\n             };\n         } else if (type instanceof ParameterizedType \u0026\u0026 !(String.class.isAssignableFrom(TypeToken.get(((ParameterizedType) type).getActualTypeArguments()[0]).getRawType()))) {\n             return new ObjectConstructor\u003cT\u003e() {\n \n                 public T construct() {\n                     return (T) new LinkedHashMap\u003cObject, Object\u003e();\n                 }\n             };\n         } else {\n             return new ObjectConstructor\u003cT\u003e() {\n \n                 public T construct() {\n-                    return (T) new LinkedHashTreeMap\u003cString, Object\u003e();\n+                    return (T) new LinkedTreeMap\u003cString, Object\u003e();\n                 }\n             };\n         }\n     }\n     return null;\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "af6aa5f782dcfc38a060d2de9476337e14ffedcb": {
      "type": "Ybodychange",
      "commitMessage": "Use the LinkedHashTreeMap instead of LinkedTreeMap and delete the LinkedTreeMap version.\n",
      "commitDate": "4/4/13, 2:31 PM",
      "commitName": "af6aa5f782dcfc38a060d2de9476337e14ffedcb",
      "commitAuthor": "Joel Leitch",
      "commitDateOld": "4/4/13, 2:15 PM",
      "commitNameOld": "7d53113ebc9ef6921c6238f013aabd10890611a0",
      "commitAuthorOld": "Inderjeet Singh",
      "daysBetweenCommits": 0.01,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "@SuppressWarnings(\"unchecked\")\nprivate \u003cT\u003e ObjectConstructor\u003cT\u003e newDefaultImplementationConstructor(final Type type, Class\u003c? super T\u003e rawType) {\n    if (Collection.class.isAssignableFrom(rawType)) {\n        if (SortedSet.class.isAssignableFrom(rawType)) {\n            return new ObjectConstructor\u003cT\u003e() {\n\n                public T construct() {\n                    return (T) new TreeSet\u003cObject\u003e();\n                }\n            };\n        } else if (EnumSet.class.isAssignableFrom(rawType)) {\n            return new ObjectConstructor\u003cT\u003e() {\n\n                @SuppressWarnings(\"rawtypes\")\n                public T construct() {\n                    if (type instanceof ParameterizedType) {\n                        Type elementType \u003d ((ParameterizedType) type).getActualTypeArguments()[0];\n                        if (elementType instanceof Class) {\n                            return (T) EnumSet.noneOf((Class) elementType);\n                        } else {\n                            throw new JsonIOException(\"Invalid EnumSet type: \" + type.toString());\n                        }\n                    } else {\n                        throw new JsonIOException(\"Invalid EnumSet type: \" + type.toString());\n                    }\n                }\n            };\n        } else if (Set.class.isAssignableFrom(rawType)) {\n            return new ObjectConstructor\u003cT\u003e() {\n\n                public T construct() {\n                    return (T) new LinkedHashSet\u003cObject\u003e();\n                }\n            };\n        } else if (Queue.class.isAssignableFrom(rawType)) {\n            return new ObjectConstructor\u003cT\u003e() {\n\n                public T construct() {\n                    return (T) new LinkedList\u003cObject\u003e();\n                }\n            };\n        } else {\n            return new ObjectConstructor\u003cT\u003e() {\n\n                public T construct() {\n                    return (T) new ArrayList\u003cObject\u003e();\n                }\n            };\n        }\n    }\n    if (Map.class.isAssignableFrom(rawType)) {\n        if (SortedMap.class.isAssignableFrom(rawType)) {\n            return new ObjectConstructor\u003cT\u003e() {\n\n                public T construct() {\n                    return (T) new TreeMap\u003cObject, Object\u003e();\n                }\n            };\n        } else if (type instanceof ParameterizedType \u0026\u0026 !(String.class.isAssignableFrom(TypeToken.get(((ParameterizedType) type).getActualTypeArguments()[0]).getRawType()))) {\n            return new ObjectConstructor\u003cT\u003e() {\n\n                public T construct() {\n                    return (T) new LinkedHashMap\u003cObject, Object\u003e();\n                }\n            };\n        } else {\n            return new ObjectConstructor\u003cT\u003e() {\n\n                public T construct() {\n                    return (T) new LinkedHashTreeMap\u003cString, Object\u003e();\n                }\n            };\n        }\n    }\n    return null;\n}",
      "path": "gson/src/main/java/com/google/gson/internal/ConstructorConstructor.java",
      "functionStartLine": 128,
      "functionName": "newDefaultImplementationConstructor",
      "functionAnnotation": "// use runtime checks to guarantee that \u0027T\u0027 is what it is\n@SuppressWarnings(\"unchecked\")",
      "functionDoc": "Constructors for common interface types like Map and List and their\nsubytpes.\n",
      "diff": "@@ -1,76 +1,76 @@\n @SuppressWarnings(\"unchecked\")\n private \u003cT\u003e ObjectConstructor\u003cT\u003e newDefaultImplementationConstructor(final Type type, Class\u003c? super T\u003e rawType) {\n     if (Collection.class.isAssignableFrom(rawType)) {\n         if (SortedSet.class.isAssignableFrom(rawType)) {\n             return new ObjectConstructor\u003cT\u003e() {\n \n                 public T construct() {\n                     return (T) new TreeSet\u003cObject\u003e();\n                 }\n             };\n         } else if (EnumSet.class.isAssignableFrom(rawType)) {\n             return new ObjectConstructor\u003cT\u003e() {\n \n                 @SuppressWarnings(\"rawtypes\")\n                 public T construct() {\n                     if (type instanceof ParameterizedType) {\n                         Type elementType \u003d ((ParameterizedType) type).getActualTypeArguments()[0];\n                         if (elementType instanceof Class) {\n                             return (T) EnumSet.noneOf((Class) elementType);\n                         } else {\n                             throw new JsonIOException(\"Invalid EnumSet type: \" + type.toString());\n                         }\n                     } else {\n                         throw new JsonIOException(\"Invalid EnumSet type: \" + type.toString());\n                     }\n                 }\n             };\n         } else if (Set.class.isAssignableFrom(rawType)) {\n             return new ObjectConstructor\u003cT\u003e() {\n \n                 public T construct() {\n                     return (T) new LinkedHashSet\u003cObject\u003e();\n                 }\n             };\n         } else if (Queue.class.isAssignableFrom(rawType)) {\n             return new ObjectConstructor\u003cT\u003e() {\n \n                 public T construct() {\n                     return (T) new LinkedList\u003cObject\u003e();\n                 }\n             };\n         } else {\n             return new ObjectConstructor\u003cT\u003e() {\n \n                 public T construct() {\n                     return (T) new ArrayList\u003cObject\u003e();\n                 }\n             };\n         }\n     }\n     if (Map.class.isAssignableFrom(rawType)) {\n         if (SortedMap.class.isAssignableFrom(rawType)) {\n             return new ObjectConstructor\u003cT\u003e() {\n \n                 public T construct() {\n                     return (T) new TreeMap\u003cObject, Object\u003e();\n                 }\n             };\n         } else if (type instanceof ParameterizedType \u0026\u0026 !(String.class.isAssignableFrom(TypeToken.get(((ParameterizedType) type).getActualTypeArguments()[0]).getRawType()))) {\n             return new ObjectConstructor\u003cT\u003e() {\n \n                 public T construct() {\n                     return (T) new LinkedHashMap\u003cObject, Object\u003e();\n                 }\n             };\n         } else {\n             return new ObjectConstructor\u003cT\u003e() {\n \n                 public T construct() {\n-                    return (T) new LinkedTreeMap\u003cString, Object\u003e();\n+                    return (T) new LinkedHashTreeMap\u003cString, Object\u003e();\n                 }\n             };\n         }\n     }\n     return null;\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "7d53113ebc9ef6921c6238f013aabd10890611a0": {
      "type": "Ymultichange(Ybodychange,Yparametermetachange)",
      "commitMessage": "fixed https://code.google.com/p/google-gson/issues/detail?id\u003d509 by adding construction for EnumSet\n",
      "commitDate": "4/4/13, 2:15 PM",
      "commitName": "7d53113ebc9ef6921c6238f013aabd10890611a0",
      "commitAuthor": "Inderjeet Singh",
      "subchanges": [
        {
          "type": "Ybodychange",
          "commitMessage": "fixed https://code.google.com/p/google-gson/issues/detail?id\u003d509 by adding construction for EnumSet\n",
          "commitDate": "4/4/13, 2:15 PM",
          "commitName": "7d53113ebc9ef6921c6238f013aabd10890611a0",
          "commitAuthor": "Inderjeet Singh",
          "commitDateOld": "10/24/12, 1:40 PM",
          "commitNameOld": "040bae34d701172375e5aaef7492a5782933d46d",
          "commitAuthorOld": "Joel Leitch",
          "daysBetweenCommits": 162.02,
          "commitsBetweenForRepo": 12,
          "commitsBetweenForFile": 1,
          "actualSource": "@SuppressWarnings(\"unchecked\")\nprivate \u003cT\u003e ObjectConstructor\u003cT\u003e newDefaultImplementationConstructor(final Type type, Class\u003c? super T\u003e rawType) {\n    if (Collection.class.isAssignableFrom(rawType)) {\n        if (SortedSet.class.isAssignableFrom(rawType)) {\n            return new ObjectConstructor\u003cT\u003e() {\n\n                public T construct() {\n                    return (T) new TreeSet\u003cObject\u003e();\n                }\n            };\n        } else if (EnumSet.class.isAssignableFrom(rawType)) {\n            return new ObjectConstructor\u003cT\u003e() {\n\n                @SuppressWarnings(\"rawtypes\")\n                public T construct() {\n                    if (type instanceof ParameterizedType) {\n                        Type elementType \u003d ((ParameterizedType) type).getActualTypeArguments()[0];\n                        if (elementType instanceof Class) {\n                            return (T) EnumSet.noneOf((Class) elementType);\n                        } else {\n                            throw new JsonIOException(\"Invalid EnumSet type: \" + type.toString());\n                        }\n                    } else {\n                        throw new JsonIOException(\"Invalid EnumSet type: \" + type.toString());\n                    }\n                }\n            };\n        } else if (Set.class.isAssignableFrom(rawType)) {\n            return new ObjectConstructor\u003cT\u003e() {\n\n                public T construct() {\n                    return (T) new LinkedHashSet\u003cObject\u003e();\n                }\n            };\n        } else if (Queue.class.isAssignableFrom(rawType)) {\n            return new ObjectConstructor\u003cT\u003e() {\n\n                public T construct() {\n                    return (T) new LinkedList\u003cObject\u003e();\n                }\n            };\n        } else {\n            return new ObjectConstructor\u003cT\u003e() {\n\n                public T construct() {\n                    return (T) new ArrayList\u003cObject\u003e();\n                }\n            };\n        }\n    }\n    if (Map.class.isAssignableFrom(rawType)) {\n        if (SortedMap.class.isAssignableFrom(rawType)) {\n            return new ObjectConstructor\u003cT\u003e() {\n\n                public T construct() {\n                    return (T) new TreeMap\u003cObject, Object\u003e();\n                }\n            };\n        } else if (type instanceof ParameterizedType \u0026\u0026 !(String.class.isAssignableFrom(TypeToken.get(((ParameterizedType) type).getActualTypeArguments()[0]).getRawType()))) {\n            return new ObjectConstructor\u003cT\u003e() {\n\n                public T construct() {\n                    return (T) new LinkedHashMap\u003cObject, Object\u003e();\n                }\n            };\n        } else {\n            return new ObjectConstructor\u003cT\u003e() {\n\n                public T construct() {\n                    return (T) new LinkedTreeMap\u003cString, Object\u003e();\n                }\n            };\n        }\n    }\n    return null;\n}",
          "path": "gson/src/main/java/com/google/gson/internal/ConstructorConstructor.java",
          "functionStartLine": 128,
          "functionName": "newDefaultImplementationConstructor",
          "functionAnnotation": "// use runtime checks to guarantee that \u0027T\u0027 is what it is\n@SuppressWarnings(\"unchecked\")",
          "functionDoc": "Constructors for common interface types like Map and List and their\nsubytpes.\n",
          "diff": "@@ -1,59 +1,76 @@\n @SuppressWarnings(\"unchecked\")\n-private \u003cT\u003e ObjectConstructor\u003cT\u003e newDefaultImplementationConstructor(Type type, Class\u003c? super T\u003e rawType) {\n+private \u003cT\u003e ObjectConstructor\u003cT\u003e newDefaultImplementationConstructor(final Type type, Class\u003c? super T\u003e rawType) {\n     if (Collection.class.isAssignableFrom(rawType)) {\n         if (SortedSet.class.isAssignableFrom(rawType)) {\n             return new ObjectConstructor\u003cT\u003e() {\n \n                 public T construct() {\n                     return (T) new TreeSet\u003cObject\u003e();\n                 }\n             };\n+        } else if (EnumSet.class.isAssignableFrom(rawType)) {\n+            return new ObjectConstructor\u003cT\u003e() {\n+\n+                @SuppressWarnings(\"rawtypes\")\n+                public T construct() {\n+                    if (type instanceof ParameterizedType) {\n+                        Type elementType \u003d ((ParameterizedType) type).getActualTypeArguments()[0];\n+                        if (elementType instanceof Class) {\n+                            return (T) EnumSet.noneOf((Class) elementType);\n+                        } else {\n+                            throw new JsonIOException(\"Invalid EnumSet type: \" + type.toString());\n+                        }\n+                    } else {\n+                        throw new JsonIOException(\"Invalid EnumSet type: \" + type.toString());\n+                    }\n+                }\n+            };\n         } else if (Set.class.isAssignableFrom(rawType)) {\n             return new ObjectConstructor\u003cT\u003e() {\n \n                 public T construct() {\n                     return (T) new LinkedHashSet\u003cObject\u003e();\n                 }\n             };\n         } else if (Queue.class.isAssignableFrom(rawType)) {\n             return new ObjectConstructor\u003cT\u003e() {\n \n                 public T construct() {\n                     return (T) new LinkedList\u003cObject\u003e();\n                 }\n             };\n         } else {\n             return new ObjectConstructor\u003cT\u003e() {\n \n                 public T construct() {\n                     return (T) new ArrayList\u003cObject\u003e();\n                 }\n             };\n         }\n     }\n     if (Map.class.isAssignableFrom(rawType)) {\n         if (SortedMap.class.isAssignableFrom(rawType)) {\n             return new ObjectConstructor\u003cT\u003e() {\n \n                 public T construct() {\n                     return (T) new TreeMap\u003cObject, Object\u003e();\n                 }\n             };\n         } else if (type instanceof ParameterizedType \u0026\u0026 !(String.class.isAssignableFrom(TypeToken.get(((ParameterizedType) type).getActualTypeArguments()[0]).getRawType()))) {\n             return new ObjectConstructor\u003cT\u003e() {\n \n                 public T construct() {\n                     return (T) new LinkedHashMap\u003cObject, Object\u003e();\n                 }\n             };\n         } else {\n             return new ObjectConstructor\u003cT\u003e() {\n \n                 public T construct() {\n                     return (T) new LinkedTreeMap\u003cString, Object\u003e();\n                 }\n             };\n         }\n     }\n     return null;\n }\n\\ No newline at end of file\n",
          "extendedDetails": {}
        },
        {
          "type": "Yparametermetachange",
          "commitMessage": "fixed https://code.google.com/p/google-gson/issues/detail?id\u003d509 by adding construction for EnumSet\n",
          "commitDate": "4/4/13, 2:15 PM",
          "commitName": "7d53113ebc9ef6921c6238f013aabd10890611a0",
          "commitAuthor": "Inderjeet Singh",
          "commitDateOld": "10/24/12, 1:40 PM",
          "commitNameOld": "040bae34d701172375e5aaef7492a5782933d46d",
          "commitAuthorOld": "Joel Leitch",
          "daysBetweenCommits": 162.02,
          "commitsBetweenForRepo": 12,
          "commitsBetweenForFile": 1,
          "actualSource": "@SuppressWarnings(\"unchecked\")\nprivate \u003cT\u003e ObjectConstructor\u003cT\u003e newDefaultImplementationConstructor(final Type type, Class\u003c? super T\u003e rawType) {\n    if (Collection.class.isAssignableFrom(rawType)) {\n        if (SortedSet.class.isAssignableFrom(rawType)) {\n            return new ObjectConstructor\u003cT\u003e() {\n\n                public T construct() {\n                    return (T) new TreeSet\u003cObject\u003e();\n                }\n            };\n        } else if (EnumSet.class.isAssignableFrom(rawType)) {\n            return new ObjectConstructor\u003cT\u003e() {\n\n                @SuppressWarnings(\"rawtypes\")\n                public T construct() {\n                    if (type instanceof ParameterizedType) {\n                        Type elementType \u003d ((ParameterizedType) type).getActualTypeArguments()[0];\n                        if (elementType instanceof Class) {\n                            return (T) EnumSet.noneOf((Class) elementType);\n                        } else {\n                            throw new JsonIOException(\"Invalid EnumSet type: \" + type.toString());\n                        }\n                    } else {\n                        throw new JsonIOException(\"Invalid EnumSet type: \" + type.toString());\n                    }\n                }\n            };\n        } else if (Set.class.isAssignableFrom(rawType)) {\n            return new ObjectConstructor\u003cT\u003e() {\n\n                public T construct() {\n                    return (T) new LinkedHashSet\u003cObject\u003e();\n                }\n            };\n        } else if (Queue.class.isAssignableFrom(rawType)) {\n            return new ObjectConstructor\u003cT\u003e() {\n\n                public T construct() {\n                    return (T) new LinkedList\u003cObject\u003e();\n                }\n            };\n        } else {\n            return new ObjectConstructor\u003cT\u003e() {\n\n                public T construct() {\n                    return (T) new ArrayList\u003cObject\u003e();\n                }\n            };\n        }\n    }\n    if (Map.class.isAssignableFrom(rawType)) {\n        if (SortedMap.class.isAssignableFrom(rawType)) {\n            return new ObjectConstructor\u003cT\u003e() {\n\n                public T construct() {\n                    return (T) new TreeMap\u003cObject, Object\u003e();\n                }\n            };\n        } else if (type instanceof ParameterizedType \u0026\u0026 !(String.class.isAssignableFrom(TypeToken.get(((ParameterizedType) type).getActualTypeArguments()[0]).getRawType()))) {\n            return new ObjectConstructor\u003cT\u003e() {\n\n                public T construct() {\n                    return (T) new LinkedHashMap\u003cObject, Object\u003e();\n                }\n            };\n        } else {\n            return new ObjectConstructor\u003cT\u003e() {\n\n                public T construct() {\n                    return (T) new LinkedTreeMap\u003cString, Object\u003e();\n                }\n            };\n        }\n    }\n    return null;\n}",
          "path": "gson/src/main/java/com/google/gson/internal/ConstructorConstructor.java",
          "functionStartLine": 128,
          "functionName": "newDefaultImplementationConstructor",
          "functionAnnotation": "// use runtime checks to guarantee that \u0027T\u0027 is what it is\n@SuppressWarnings(\"unchecked\")",
          "functionDoc": "Constructors for common interface types like Map and List and their\nsubytpes.\n",
          "diff": "@@ -1,59 +1,76 @@\n @SuppressWarnings(\"unchecked\")\n-private \u003cT\u003e ObjectConstructor\u003cT\u003e newDefaultImplementationConstructor(Type type, Class\u003c? super T\u003e rawType) {\n+private \u003cT\u003e ObjectConstructor\u003cT\u003e newDefaultImplementationConstructor(final Type type, Class\u003c? super T\u003e rawType) {\n     if (Collection.class.isAssignableFrom(rawType)) {\n         if (SortedSet.class.isAssignableFrom(rawType)) {\n             return new ObjectConstructor\u003cT\u003e() {\n \n                 public T construct() {\n                     return (T) new TreeSet\u003cObject\u003e();\n                 }\n             };\n+        } else if (EnumSet.class.isAssignableFrom(rawType)) {\n+            return new ObjectConstructor\u003cT\u003e() {\n+\n+                @SuppressWarnings(\"rawtypes\")\n+                public T construct() {\n+                    if (type instanceof ParameterizedType) {\n+                        Type elementType \u003d ((ParameterizedType) type).getActualTypeArguments()[0];\n+                        if (elementType instanceof Class) {\n+                            return (T) EnumSet.noneOf((Class) elementType);\n+                        } else {\n+                            throw new JsonIOException(\"Invalid EnumSet type: \" + type.toString());\n+                        }\n+                    } else {\n+                        throw new JsonIOException(\"Invalid EnumSet type: \" + type.toString());\n+                    }\n+                }\n+            };\n         } else if (Set.class.isAssignableFrom(rawType)) {\n             return new ObjectConstructor\u003cT\u003e() {\n \n                 public T construct() {\n                     return (T) new LinkedHashSet\u003cObject\u003e();\n                 }\n             };\n         } else if (Queue.class.isAssignableFrom(rawType)) {\n             return new ObjectConstructor\u003cT\u003e() {\n \n                 public T construct() {\n                     return (T) new LinkedList\u003cObject\u003e();\n                 }\n             };\n         } else {\n             return new ObjectConstructor\u003cT\u003e() {\n \n                 public T construct() {\n                     return (T) new ArrayList\u003cObject\u003e();\n                 }\n             };\n         }\n     }\n     if (Map.class.isAssignableFrom(rawType)) {\n         if (SortedMap.class.isAssignableFrom(rawType)) {\n             return new ObjectConstructor\u003cT\u003e() {\n \n                 public T construct() {\n                     return (T) new TreeMap\u003cObject, Object\u003e();\n                 }\n             };\n         } else if (type instanceof ParameterizedType \u0026\u0026 !(String.class.isAssignableFrom(TypeToken.get(((ParameterizedType) type).getActualTypeArguments()[0]).getRawType()))) {\n             return new ObjectConstructor\u003cT\u003e() {\n \n                 public T construct() {\n                     return (T) new LinkedHashMap\u003cObject, Object\u003e();\n                 }\n             };\n         } else {\n             return new ObjectConstructor\u003cT\u003e() {\n \n                 public T construct() {\n                     return (T) new LinkedTreeMap\u003cString, Object\u003e();\n                 }\n             };\n         }\n     }\n     return null;\n }\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldValue": "[type-Type, rawType-Class\u003c? super T\u003e]",
            "newValue": "[type-Type(modifiers-final), rawType-Class\u003c? super T\u003e]"
          }
        }
      ]
    },
    "14f16e2d0c3c60338d69a3e0f653b8b876fdc1be": {
      "type": "Ybodychange",
      "commitMessage": "Adding Red-Black Tree implementation and tying it into the Gson bindings.\n",
      "commitDate": "10/10/12, 8:15 PM",
      "commitName": "14f16e2d0c3c60338d69a3e0f653b8b876fdc1be",
      "commitAuthor": "Joel Leitch",
      "commitDateOld": "8/15/12, 7:58 AM",
      "commitNameOld": "1a4f690335ae1129620079c4b5587a7261206c12",
      "commitAuthorOld": "Jesse Wilson",
      "daysBetweenCommits": 56.51,
      "commitsBetweenForRepo": 32,
      "commitsBetweenForFile": 1,
      "actualSource": "@SuppressWarnings(\"unchecked\")\nprivate \u003cT\u003e ObjectConstructor\u003cT\u003e newDefaultImplementationConstructor(Type type, Class\u003c? super T\u003e rawType) {\n    if (Collection.class.isAssignableFrom(rawType)) {\n        if (SortedSet.class.isAssignableFrom(rawType)) {\n            return new ObjectConstructor\u003cT\u003e() {\n\n                public T construct() {\n                    return (T) new TreeSet\u003cObject\u003e();\n                }\n            };\n        } else if (Set.class.isAssignableFrom(rawType)) {\n            return new ObjectConstructor\u003cT\u003e() {\n\n                public T construct() {\n                    return (T) new LinkedHashSet\u003cObject\u003e();\n                }\n            };\n        } else if (Queue.class.isAssignableFrom(rawType)) {\n            return new ObjectConstructor\u003cT\u003e() {\n\n                public T construct() {\n                    return (T) new LinkedList\u003cObject\u003e();\n                }\n            };\n        } else {\n            return new ObjectConstructor\u003cT\u003e() {\n\n                public T construct() {\n                    return (T) new ArrayList\u003cObject\u003e();\n                }\n            };\n        }\n    }\n    if (Map.class.isAssignableFrom(rawType)) {\n        if (SortedMap.class.isAssignableFrom(rawType)) {\n            return new ObjectConstructor\u003cT\u003e() {\n\n                public T construct() {\n                    return (T) new TreeMap\u003cObject, Object\u003e();\n                }\n            };\n        } else if (type instanceof ParameterizedType \u0026\u0026 !(String.class.isAssignableFrom(TypeToken.get(((ParameterizedType) type).getActualTypeArguments()[0]).getRawType()))) {\n            return new ObjectConstructor\u003cT\u003e() {\n\n                public T construct() {\n                    return (T) new LinkedHashMap\u003cObject, Object\u003e();\n                }\n            };\n        } else {\n            return new ObjectConstructor\u003cT\u003e() {\n\n                public T construct() {\n                    return (T) new LinkedTreeMap\u003cString, Object\u003e();\n                }\n            };\n        }\n    }\n    return null;\n}",
      "path": "gson/src/main/java/com/google/gson/internal/ConstructorConstructor.java",
      "functionStartLine": 119,
      "functionName": "newDefaultImplementationConstructor",
      "functionAnnotation": "// use runtime checks to guarantee that \u0027T\u0027 is what it is\n@SuppressWarnings(\"unchecked\")",
      "functionDoc": "Constructors for common interface types like Map and List and their\nsubytpes.\n",
      "diff": "@@ -1,52 +1,59 @@\n @SuppressWarnings(\"unchecked\")\n private \u003cT\u003e ObjectConstructor\u003cT\u003e newDefaultImplementationConstructor(Type type, Class\u003c? super T\u003e rawType) {\n     if (Collection.class.isAssignableFrom(rawType)) {\n         if (SortedSet.class.isAssignableFrom(rawType)) {\n             return new ObjectConstructor\u003cT\u003e() {\n \n                 public T construct() {\n                     return (T) new TreeSet\u003cObject\u003e();\n                 }\n             };\n         } else if (Set.class.isAssignableFrom(rawType)) {\n             return new ObjectConstructor\u003cT\u003e() {\n \n                 public T construct() {\n                     return (T) new LinkedHashSet\u003cObject\u003e();\n                 }\n             };\n         } else if (Queue.class.isAssignableFrom(rawType)) {\n             return new ObjectConstructor\u003cT\u003e() {\n \n                 public T construct() {\n                     return (T) new LinkedList\u003cObject\u003e();\n                 }\n             };\n         } else {\n             return new ObjectConstructor\u003cT\u003e() {\n \n                 public T construct() {\n                     return (T) new ArrayList\u003cObject\u003e();\n                 }\n             };\n         }\n     }\n     if (Map.class.isAssignableFrom(rawType)) {\n-        if (type instanceof ParameterizedType \u0026\u0026 ((ParameterizedType) type).getActualTypeArguments()[0] \u003d\u003d String.class) {\n+        if (SortedMap.class.isAssignableFrom(rawType)) {\n             return new ObjectConstructor\u003cT\u003e() {\n \n                 public T construct() {\n-                    return (T) new StringMap\u003cObject\u003e();\n+                    return (T) new TreeMap\u003cObject, Object\u003e();\n+                }\n+            };\n+        } else if (type instanceof ParameterizedType \u0026\u0026 !(String.class.isAssignableFrom(TypeToken.get(((ParameterizedType) type).getActualTypeArguments()[0]).getRawType()))) {\n+            return new ObjectConstructor\u003cT\u003e() {\n+\n+                public T construct() {\n+                    return (T) new LinkedHashMap\u003cObject, Object\u003e();\n                 }\n             };\n         } else {\n             return new ObjectConstructor\u003cT\u003e() {\n \n                 public T construct() {\n-                    return (T) new LinkedHashMap\u003cObject, Object\u003e();\n+                    return (T) new LinkedTreeMap\u003cString, Object\u003e();\n                 }\n             };\n         }\n     }\n     return null;\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "1a4f690335ae1129620079c4b5587a7261206c12": {
      "type": "Ymultichange(Yparameterchange,Ybodychange)",
      "commitMessage": "Regretfully enable serialization for StringMap and LazilyParsedNumber.\n\nOne of our favorite users (my employer!) is stuck in a sad situation where they need to serialize objects returned from Gson; this is a workable escape hatch.\n",
      "commitDate": "8/15/12, 7:58 AM",
      "commitName": "1a4f690335ae1129620079c4b5587a7261206c12",
      "commitAuthor": "Jesse Wilson",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "Regretfully enable serialization for StringMap and LazilyParsedNumber.\n\nOne of our favorite users (my employer!) is stuck in a sad situation where they need to serialize objects returned from Gson; this is a workable escape hatch.\n",
          "commitDate": "8/15/12, 7:58 AM",
          "commitName": "1a4f690335ae1129620079c4b5587a7261206c12",
          "commitAuthor": "Jesse Wilson",
          "commitDateOld": "3/11/12, 6:54 AM",
          "commitNameOld": "ad3489f557d951ebd4574d04adf4b0bb4108d05f",
          "commitAuthorOld": "Jesse Wilson",
          "daysBetweenCommits": 157.04,
          "commitsBetweenForRepo": 47,
          "commitsBetweenForFile": 1,
          "actualSource": "@SuppressWarnings(\"unchecked\")\nprivate \u003cT\u003e ObjectConstructor\u003cT\u003e newDefaultImplementationConstructor(Type type, Class\u003c? super T\u003e rawType) {\n    if (Collection.class.isAssignableFrom(rawType)) {\n        if (SortedSet.class.isAssignableFrom(rawType)) {\n            return new ObjectConstructor\u003cT\u003e() {\n\n                public T construct() {\n                    return (T) new TreeSet\u003cObject\u003e();\n                }\n            };\n        } else if (Set.class.isAssignableFrom(rawType)) {\n            return new ObjectConstructor\u003cT\u003e() {\n\n                public T construct() {\n                    return (T) new LinkedHashSet\u003cObject\u003e();\n                }\n            };\n        } else if (Queue.class.isAssignableFrom(rawType)) {\n            return new ObjectConstructor\u003cT\u003e() {\n\n                public T construct() {\n                    return (T) new LinkedList\u003cObject\u003e();\n                }\n            };\n        } else {\n            return new ObjectConstructor\u003cT\u003e() {\n\n                public T construct() {\n                    return (T) new ArrayList\u003cObject\u003e();\n                }\n            };\n        }\n    }\n    if (Map.class.isAssignableFrom(rawType)) {\n        if (type instanceof ParameterizedType \u0026\u0026 ((ParameterizedType) type).getActualTypeArguments()[0] \u003d\u003d String.class) {\n            return new ObjectConstructor\u003cT\u003e() {\n\n                public T construct() {\n                    return (T) new StringMap\u003cObject\u003e();\n                }\n            };\n        } else {\n            return new ObjectConstructor\u003cT\u003e() {\n\n                public T construct() {\n                    return (T) new LinkedHashMap\u003cObject, Object\u003e();\n                }\n            };\n        }\n    }\n    return null;\n}",
          "path": "gson/src/main/java/com/google/gson/internal/ConstructorConstructor.java",
          "functionStartLine": 116,
          "functionName": "newDefaultImplementationConstructor",
          "functionAnnotation": "// use runtime checks to guarantee that \u0027T\u0027 is what it is\n@SuppressWarnings(\"unchecked\")",
          "functionDoc": "Constructors for common interface types like Map and List and their\nsubytpes.\n",
          "diff": "@@ -1,43 +1,52 @@\n @SuppressWarnings(\"unchecked\")\n-private \u003cT\u003e ObjectConstructor\u003cT\u003e newDefaultImplementationConstructor(Class\u003c? super T\u003e rawType) {\n+private \u003cT\u003e ObjectConstructor\u003cT\u003e newDefaultImplementationConstructor(Type type, Class\u003c? super T\u003e rawType) {\n     if (Collection.class.isAssignableFrom(rawType)) {\n         if (SortedSet.class.isAssignableFrom(rawType)) {\n             return new ObjectConstructor\u003cT\u003e() {\n \n                 public T construct() {\n                     return (T) new TreeSet\u003cObject\u003e();\n                 }\n             };\n         } else if (Set.class.isAssignableFrom(rawType)) {\n             return new ObjectConstructor\u003cT\u003e() {\n \n                 public T construct() {\n                     return (T) new LinkedHashSet\u003cObject\u003e();\n                 }\n             };\n         } else if (Queue.class.isAssignableFrom(rawType)) {\n             return new ObjectConstructor\u003cT\u003e() {\n \n                 public T construct() {\n                     return (T) new LinkedList\u003cObject\u003e();\n                 }\n             };\n         } else {\n             return new ObjectConstructor\u003cT\u003e() {\n \n                 public T construct() {\n                     return (T) new ArrayList\u003cObject\u003e();\n                 }\n             };\n         }\n     }\n     if (Map.class.isAssignableFrom(rawType)) {\n-        return new ObjectConstructor\u003cT\u003e() {\n+        if (type instanceof ParameterizedType \u0026\u0026 ((ParameterizedType) type).getActualTypeArguments()[0] \u003d\u003d String.class) {\n+            return new ObjectConstructor\u003cT\u003e() {\n \n-            public T construct() {\n-                return (T) new LinkedHashMap\u003cObject, Object\u003e();\n-            }\n-        };\n+                public T construct() {\n+                    return (T) new StringMap\u003cObject\u003e();\n+                }\n+            };\n+        } else {\n+            return new ObjectConstructor\u003cT\u003e() {\n+\n+                public T construct() {\n+                    return (T) new LinkedHashMap\u003cObject, Object\u003e();\n+                }\n+            };\n+        }\n     }\n     return null;\n }\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldValue": "[rawType-Class\u003c? super T\u003e]",
            "newValue": "[type-Type, rawType-Class\u003c? super T\u003e]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "Regretfully enable serialization for StringMap and LazilyParsedNumber.\n\nOne of our favorite users (my employer!) is stuck in a sad situation where they need to serialize objects returned from Gson; this is a workable escape hatch.\n",
          "commitDate": "8/15/12, 7:58 AM",
          "commitName": "1a4f690335ae1129620079c4b5587a7261206c12",
          "commitAuthor": "Jesse Wilson",
          "commitDateOld": "3/11/12, 6:54 AM",
          "commitNameOld": "ad3489f557d951ebd4574d04adf4b0bb4108d05f",
          "commitAuthorOld": "Jesse Wilson",
          "daysBetweenCommits": 157.04,
          "commitsBetweenForRepo": 47,
          "commitsBetweenForFile": 1,
          "actualSource": "@SuppressWarnings(\"unchecked\")\nprivate \u003cT\u003e ObjectConstructor\u003cT\u003e newDefaultImplementationConstructor(Type type, Class\u003c? super T\u003e rawType) {\n    if (Collection.class.isAssignableFrom(rawType)) {\n        if (SortedSet.class.isAssignableFrom(rawType)) {\n            return new ObjectConstructor\u003cT\u003e() {\n\n                public T construct() {\n                    return (T) new TreeSet\u003cObject\u003e();\n                }\n            };\n        } else if (Set.class.isAssignableFrom(rawType)) {\n            return new ObjectConstructor\u003cT\u003e() {\n\n                public T construct() {\n                    return (T) new LinkedHashSet\u003cObject\u003e();\n                }\n            };\n        } else if (Queue.class.isAssignableFrom(rawType)) {\n            return new ObjectConstructor\u003cT\u003e() {\n\n                public T construct() {\n                    return (T) new LinkedList\u003cObject\u003e();\n                }\n            };\n        } else {\n            return new ObjectConstructor\u003cT\u003e() {\n\n                public T construct() {\n                    return (T) new ArrayList\u003cObject\u003e();\n                }\n            };\n        }\n    }\n    if (Map.class.isAssignableFrom(rawType)) {\n        if (type instanceof ParameterizedType \u0026\u0026 ((ParameterizedType) type).getActualTypeArguments()[0] \u003d\u003d String.class) {\n            return new ObjectConstructor\u003cT\u003e() {\n\n                public T construct() {\n                    return (T) new StringMap\u003cObject\u003e();\n                }\n            };\n        } else {\n            return new ObjectConstructor\u003cT\u003e() {\n\n                public T construct() {\n                    return (T) new LinkedHashMap\u003cObject, Object\u003e();\n                }\n            };\n        }\n    }\n    return null;\n}",
          "path": "gson/src/main/java/com/google/gson/internal/ConstructorConstructor.java",
          "functionStartLine": 116,
          "functionName": "newDefaultImplementationConstructor",
          "functionAnnotation": "// use runtime checks to guarantee that \u0027T\u0027 is what it is\n@SuppressWarnings(\"unchecked\")",
          "functionDoc": "Constructors for common interface types like Map and List and their\nsubytpes.\n",
          "diff": "@@ -1,43 +1,52 @@\n @SuppressWarnings(\"unchecked\")\n-private \u003cT\u003e ObjectConstructor\u003cT\u003e newDefaultImplementationConstructor(Class\u003c? super T\u003e rawType) {\n+private \u003cT\u003e ObjectConstructor\u003cT\u003e newDefaultImplementationConstructor(Type type, Class\u003c? super T\u003e rawType) {\n     if (Collection.class.isAssignableFrom(rawType)) {\n         if (SortedSet.class.isAssignableFrom(rawType)) {\n             return new ObjectConstructor\u003cT\u003e() {\n \n                 public T construct() {\n                     return (T) new TreeSet\u003cObject\u003e();\n                 }\n             };\n         } else if (Set.class.isAssignableFrom(rawType)) {\n             return new ObjectConstructor\u003cT\u003e() {\n \n                 public T construct() {\n                     return (T) new LinkedHashSet\u003cObject\u003e();\n                 }\n             };\n         } else if (Queue.class.isAssignableFrom(rawType)) {\n             return new ObjectConstructor\u003cT\u003e() {\n \n                 public T construct() {\n                     return (T) new LinkedList\u003cObject\u003e();\n                 }\n             };\n         } else {\n             return new ObjectConstructor\u003cT\u003e() {\n \n                 public T construct() {\n                     return (T) new ArrayList\u003cObject\u003e();\n                 }\n             };\n         }\n     }\n     if (Map.class.isAssignableFrom(rawType)) {\n-        return new ObjectConstructor\u003cT\u003e() {\n+        if (type instanceof ParameterizedType \u0026\u0026 ((ParameterizedType) type).getActualTypeArguments()[0] \u003d\u003d String.class) {\n+            return new ObjectConstructor\u003cT\u003e() {\n \n-            public T construct() {\n-                return (T) new LinkedHashMap\u003cObject, Object\u003e();\n-            }\n-        };\n+                public T construct() {\n+                    return (T) new StringMap\u003cObject\u003e();\n+                }\n+            };\n+        } else {\n+            return new ObjectConstructor\u003cT\u003e() {\n+\n+                public T construct() {\n+                    return (T) new LinkedHashMap\u003cObject, Object\u003e();\n+                }\n+            };\n+        }\n     }\n     return null;\n }\n\\ No newline at end of file\n",
          "extendedDetails": {}
        }
      ]
    },
    "ad3489f557d951ebd4574d04adf4b0bb4108d05f": {
      "type": "Ybodychange",
      "commitMessage": "First steps to StringMap, an alternative to LinkedHashmap.\n",
      "commitDate": "3/11/12, 6:54 AM",
      "commitName": "ad3489f557d951ebd4574d04adf4b0bb4108d05f",
      "commitAuthor": "Jesse Wilson",
      "commitDateOld": "1/1/12, 5:42 AM",
      "commitNameOld": "6cca23c172612aded9ee2996a5177cb7b9a84390",
      "commitAuthorOld": "Jesse Wilson",
      "daysBetweenCommits": 70.01,
      "commitsBetweenForRepo": 11,
      "commitsBetweenForFile": 1,
      "actualSource": "@SuppressWarnings(\"unchecked\")\nprivate \u003cT\u003e ObjectConstructor\u003cT\u003e newDefaultImplementationConstructor(Class\u003c? super T\u003e rawType) {\n    if (Collection.class.isAssignableFrom(rawType)) {\n        if (SortedSet.class.isAssignableFrom(rawType)) {\n            return new ObjectConstructor\u003cT\u003e() {\n\n                public T construct() {\n                    return (T) new TreeSet\u003cObject\u003e();\n                }\n            };\n        } else if (Set.class.isAssignableFrom(rawType)) {\n            return new ObjectConstructor\u003cT\u003e() {\n\n                public T construct() {\n                    return (T) new LinkedHashSet\u003cObject\u003e();\n                }\n            };\n        } else if (Queue.class.isAssignableFrom(rawType)) {\n            return new ObjectConstructor\u003cT\u003e() {\n\n                public T construct() {\n                    return (T) new LinkedList\u003cObject\u003e();\n                }\n            };\n        } else {\n            return new ObjectConstructor\u003cT\u003e() {\n\n                public T construct() {\n                    return (T) new ArrayList\u003cObject\u003e();\n                }\n            };\n        }\n    }\n    if (Map.class.isAssignableFrom(rawType)) {\n        return new ObjectConstructor\u003cT\u003e() {\n\n            public T construct() {\n                return (T) new LinkedHashMap\u003cObject, Object\u003e();\n            }\n        };\n    }\n    return null;\n}",
      "path": "gson/src/main/java/com/google/gson/internal/ConstructorConstructor.java",
      "functionStartLine": 115,
      "functionName": "newDefaultImplementationConstructor",
      "functionAnnotation": "// use runtime checks to guarantee that \u0027T\u0027 is what it is\n@SuppressWarnings(\"unchecked\")",
      "functionDoc": "Constructors for common interface types like Map and List and their\nsubytpes.\n",
      "diff": "",
      "extendedDetails": {}
    },
    "4a6c084ef73e5e8a3fca12f9bb829a218fad7a84": {
      "type": "Ybodychange",
      "commitMessage": "removed JDK 1.5 incompatible use of @Overrides annotation on overridden interface methods.\n",
      "commitDate": "9/15/11, 8:27 PM",
      "commitName": "4a6c084ef73e5e8a3fca12f9bb829a218fad7a84",
      "commitAuthor": "Inderjeet Singh",
      "commitDateOld": "9/11/11, 12:04 AM",
      "commitNameOld": "25c6ae177b1ca56db7f3c29eb574bdd032a06165",
      "commitAuthorOld": "Jesse Wilson",
      "daysBetweenCommits": 4.85,
      "commitsBetweenForRepo": 4,
      "commitsBetweenForFile": 1,
      "actualSource": "@SuppressWarnings(\"unchecked\")\nprivate \u003cT\u003e ObjectConstructor\u003cT\u003e newDefaultImplementationConstructor(Class\u003c? super T\u003e rawType) {\n    if (Collection.class.isAssignableFrom(rawType)) {\n        if (SortedSet.class.isAssignableFrom(rawType)) {\n            return new ObjectConstructor\u003cT\u003e() {\n\n                public T construct() {\n                    return (T) new TreeSet\u003cObject\u003e();\n                }\n            };\n        } else if (Set.class.isAssignableFrom(rawType)) {\n            return new ObjectConstructor\u003cT\u003e() {\n\n                public T construct() {\n                    return (T) new LinkedHashSet\u003cObject\u003e();\n                }\n            };\n        } else if (Queue.class.isAssignableFrom(rawType)) {\n            return new ObjectConstructor\u003cT\u003e() {\n\n                public T construct() {\n                    return (T) new LinkedList\u003cObject\u003e();\n                }\n            };\n        } else {\n            return new ObjectConstructor\u003cT\u003e() {\n\n                public T construct() {\n                    return (T) new ArrayList\u003cObject\u003e();\n                }\n            };\n        }\n    }\n    if (Map.class.isAssignableFrom(rawType)) {\n        return new ObjectConstructor\u003cT\u003e() {\n\n            public T construct() {\n                return (T) new LinkedHashMap\u003cObject, Object\u003e();\n            }\n        };\n    }\n    return null;\n}",
      "path": "gson/src/main/java/com/google/gson/internal/ConstructorConstructor.java",
      "functionStartLine": 114,
      "functionName": "newDefaultImplementationConstructor",
      "functionAnnotation": "// use runtime checks to guarantee that \u0027T\u0027 is what it is\n@SuppressWarnings(\"unchecked\")",
      "functionDoc": "Constructors for common interface types like Map and List and their\nsubytpes.\n",
      "diff": "@@ -1,48 +1,43 @@\n @SuppressWarnings(\"unchecked\")\n private \u003cT\u003e ObjectConstructor\u003cT\u003e newDefaultImplementationConstructor(Class\u003c? super T\u003e rawType) {\n     if (Collection.class.isAssignableFrom(rawType)) {\n         if (SortedSet.class.isAssignableFrom(rawType)) {\n             return new ObjectConstructor\u003cT\u003e() {\n \n-                @Override\n                 public T construct() {\n                     return (T) new TreeSet\u003cObject\u003e();\n                 }\n             };\n         } else if (Set.class.isAssignableFrom(rawType)) {\n             return new ObjectConstructor\u003cT\u003e() {\n \n-                @Override\n                 public T construct() {\n                     return (T) new LinkedHashSet\u003cObject\u003e();\n                 }\n             };\n         } else if (Queue.class.isAssignableFrom(rawType)) {\n             return new ObjectConstructor\u003cT\u003e() {\n \n-                @Override\n                 public T construct() {\n                     return (T) new LinkedList\u003cObject\u003e();\n                 }\n             };\n         } else {\n             return new ObjectConstructor\u003cT\u003e() {\n \n-                @Override\n                 public T construct() {\n                     return (T) new ArrayList\u003cObject\u003e();\n                 }\n             };\n         }\n     }\n     if (Map.class.isAssignableFrom(rawType)) {\n         return new ObjectConstructor\u003cT\u003e() {\n \n-            @Override\n             public T construct() {\n                 return (T) new LinkedHashMap\u003cObject, Object\u003e();\n             }\n         };\n     }\n     return null;\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "25c6ae177b1ca56db7f3c29eb574bdd032a06165": {
      "type": "Yintroduced",
      "commitMessage": "Down to 22 failing tests.\n\nConsolidated all of the different code paths that we use to construct instances. We now have an ObjectConstructor class that knows what type it constructs; this means that we don\u0027t need to ever do reflection to lookup a constructor at construction time.\n\nCleaned up some buggy type adapters, particularly around handling of null.\n\nRemoved dead code for object graph navigation.\n\nMoved some classes into \u0027internal\u0027 so they are visible to the \u0027bind\u0027 subpackage.\n\nTurned some TypeAdapterFactory/TypeAdapter pairs inside out so that the TypeAdapter is now the inner class. This is necessary so that the factories can take parameters.\n\nAdded an API to request the \u0027next\u0027 type adapter for a type. This allows type adapters to compose other type adapters. We\u0027re using this in two places:\n - where the user has excluded a type from serialization but not deserialization, we need to use the \"default\" deserialization but interpose null on serialization. We create a type adapter that delegates for one and returns null for the other.\n - similarly when a DOM type serializer is registered but no deserializer, or vice versa.\nThis is the biggest change to the MiniGson core.\n\nFor backwards compatibility, return null for the empty string.\n\nSimplify JsonSerializationContext/JsonDeserializationContext to simply call through to GSON. SerializeDefault is currently unsupported.\n\nMore useful error messages when calling getAsBoolean on a JsonNull.\n\nRemove currently unused MemoryRefStack. We might need this back again, though wiring it back in will be much more difficult because we don\u0027t interject ourselves between the users\u0027 various type adapters.\n",
      "commitDate": "9/11/11, 12:04 AM",
      "commitName": "25c6ae177b1ca56db7f3c29eb574bdd032a06165",
      "commitAuthor": "Jesse Wilson",
      "diff": "@@ -0,0 +1,48 @@\n+@SuppressWarnings(\"unchecked\")\n+private \u003cT\u003e ObjectConstructor\u003cT\u003e newDefaultImplementationConstructor(Class\u003c? super T\u003e rawType) {\n+    if (Collection.class.isAssignableFrom(rawType)) {\n+        if (SortedSet.class.isAssignableFrom(rawType)) {\n+            return new ObjectConstructor\u003cT\u003e() {\n+\n+                @Override\n+                public T construct() {\n+                    return (T) new TreeSet\u003cObject\u003e();\n+                }\n+            };\n+        } else if (Set.class.isAssignableFrom(rawType)) {\n+            return new ObjectConstructor\u003cT\u003e() {\n+\n+                @Override\n+                public T construct() {\n+                    return (T) new LinkedHashSet\u003cObject\u003e();\n+                }\n+            };\n+        } else if (Queue.class.isAssignableFrom(rawType)) {\n+            return new ObjectConstructor\u003cT\u003e() {\n+\n+                @Override\n+                public T construct() {\n+                    return (T) new LinkedList\u003cObject\u003e();\n+                }\n+            };\n+        } else {\n+            return new ObjectConstructor\u003cT\u003e() {\n+\n+                @Override\n+                public T construct() {\n+                    return (T) new ArrayList\u003cObject\u003e();\n+                }\n+            };\n+        }\n+    }\n+    if (Map.class.isAssignableFrom(rawType)) {\n+        return new ObjectConstructor\u003cT\u003e() {\n+\n+            @Override\n+            public T construct() {\n+                return (T) new LinkedHashMap\u003cObject, Object\u003e();\n+            }\n+        };\n+    }\n+    return null;\n+}\n\\ No newline at end of file\n",
      "actualSource": "@SuppressWarnings(\"unchecked\")\nprivate \u003cT\u003e ObjectConstructor\u003cT\u003e newDefaultImplementationConstructor(Class\u003c? super T\u003e rawType) {\n    if (Collection.class.isAssignableFrom(rawType)) {\n        if (SortedSet.class.isAssignableFrom(rawType)) {\n            return new ObjectConstructor\u003cT\u003e() {\n\n                @Override\n                public T construct() {\n                    return (T) new TreeSet\u003cObject\u003e();\n                }\n            };\n        } else if (Set.class.isAssignableFrom(rawType)) {\n            return new ObjectConstructor\u003cT\u003e() {\n\n                @Override\n                public T construct() {\n                    return (T) new LinkedHashSet\u003cObject\u003e();\n                }\n            };\n        } else if (Queue.class.isAssignableFrom(rawType)) {\n            return new ObjectConstructor\u003cT\u003e() {\n\n                @Override\n                public T construct() {\n                    return (T) new LinkedList\u003cObject\u003e();\n                }\n            };\n        } else {\n            return new ObjectConstructor\u003cT\u003e() {\n\n                @Override\n                public T construct() {\n                    return (T) new ArrayList\u003cObject\u003e();\n                }\n            };\n        }\n    }\n    if (Map.class.isAssignableFrom(rawType)) {\n        return new ObjectConstructor\u003cT\u003e() {\n\n            @Override\n            public T construct() {\n                return (T) new LinkedHashMap\u003cObject, Object\u003e();\n            }\n        };\n    }\n    return null;\n}",
      "path": "gson/src/main/java/com/google/gson/internal/ConstructorConstructor.java",
      "functionStartLine": 114,
      "functionName": "newDefaultImplementationConstructor",
      "functionAnnotation": "// use runtime checks to guarantee that \u0027T\u0027 is what it is\n@SuppressWarnings(\"unchecked\")",
      "functionDoc": "Constructors for common interface types like Map and List and their\nsubytpes.\n"
    }
  }
}