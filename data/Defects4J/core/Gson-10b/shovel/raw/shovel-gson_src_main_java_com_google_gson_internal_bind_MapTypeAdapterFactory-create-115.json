{
  "origin": "codeshovel",
  "repositoryName": "Gson-10b",
  "repositoryPath": "/tmp/Gson-10b//.git",
  "startCommitName": "HEAD",
  "sourceFileName": "MapTypeAdapterFactory.java",
  "functionName": "create",
  "functionId": "create___gson-Gson__typeToken-TypeToken__T__",
  "sourceFilePath": "gson/src/main/java/com/google/gson/internal/bind/MapTypeAdapterFactory.java",
  "functionAnnotation": "@Override",
  "functionDoc": "",
  "functionStartLine": 115,
  "functionEndLine": 134,
  "numCommitsSeen": 42,
  "timeTaken": 1993,
  "changeHistory": [
    "e5b3f6368db33c846b094b0d695d3a1b826e3892",
    "6cca23c172612aded9ee2996a5177cb7b9a84390",
    "26ab404599643fac25442646b829a65a7f86bca1",
    "7e760143fdc8b689daeebdee33ad6ea7d0a62a56",
    "31964507c1caabc9a70e3270fa56aaee29eff6b2",
    "194c18d20c6a05c9454ca9e0bc5503f2581ee3ea",
    "b2d5940a9baf82c6aa796adf710b86fe64fe14e7",
    "a98d6eae472df67317d58d34f13438bb958668b1",
    "25c6ae177b1ca56db7f3c29eb574bdd032a06165",
    "3aeb70e0305a598a9ceddc0390d693874dcc892d"
  ],
  "changeHistoryShort": {
    "e5b3f6368db33c846b094b0d695d3a1b826e3892": "Yannotationchange",
    "6cca23c172612aded9ee2996a5177cb7b9a84390": "Ybodychange",
    "26ab404599643fac25442646b829a65a7f86bca1": "Ymultichange(Yparameterchange,Ybodychange)",
    "7e760143fdc8b689daeebdee33ad6ea7d0a62a56": "Yparameterchange",
    "31964507c1caabc9a70e3270fa56aaee29eff6b2": "Ybodychange",
    "194c18d20c6a05c9454ca9e0bc5503f2581ee3ea": "Ybodychange",
    "b2d5940a9baf82c6aa796adf710b86fe64fe14e7": "Ybodychange",
    "a98d6eae472df67317d58d34f13438bb958668b1": "Ybodychange",
    "25c6ae177b1ca56db7f3c29eb574bdd032a06165": "Ymultichange(Ymovefromfile,Ybodychange)",
    "3aeb70e0305a598a9ceddc0390d693874dcc892d": "Yintroduced"
  },
  "changeHistoryDetails": {
    "e5b3f6368db33c846b094b0d695d3a1b826e3892": {
      "type": "Yannotationchange",
      "commitMessage": "updated minimum JDK version to 1.6.\nAdded Overrides for methods implementing an interface.\n",
      "commitDate": "11/4/15, 6:52 PM",
      "commitName": "e5b3f6368db33c846b094b0d695d3a1b826e3892",
      "commitAuthor": "Inderjeet Singh",
      "commitDateOld": "4/12/13, 1:09 PM",
      "commitNameOld": "26016ca66e8cb76ada0a01fa9420a88a8d346f68",
      "commitAuthorOld": "Inderjeet Singh",
      "daysBetweenCommits": 936.28,
      "commitsBetweenForRepo": 141,
      "commitsBetweenForFile": 1,
      "actualSource": "@Override\npublic \u003cT\u003e TypeAdapter\u003cT\u003e create(Gson gson, TypeToken\u003cT\u003e typeToken) {\n    Type type \u003d typeToken.getType();\n    Class\u003c? super T\u003e rawType \u003d typeToken.getRawType();\n    if (!Map.class.isAssignableFrom(rawType)) {\n        return null;\n    }\n    Class\u003c?\u003e rawTypeOfSrc \u003d $Gson$Types.getRawType(type);\n    Type[] keyAndValueTypes \u003d $Gson$Types.getMapKeyAndValueTypes(type, rawTypeOfSrc);\n    TypeAdapter\u003c?\u003e keyAdapter \u003d getKeyAdapter(gson, keyAndValueTypes[0]);\n    TypeAdapter\u003c?\u003e valueAdapter \u003d gson.getAdapter(TypeToken.get(keyAndValueTypes[1]));\n    ObjectConstructor\u003cT\u003e constructor \u003d constructorConstructor.get(typeToken);\n    @SuppressWarnings({ \"unchecked\", \"rawtypes\" }) TypeAdapter\u003cT\u003e result \u003d new Adapter(gson, keyAndValueTypes[0], keyAdapter, keyAndValueTypes[1], valueAdapter, constructor);\n    return result;\n}",
      "path": "gson/src/main/java/com/google/gson/internal/bind/MapTypeAdapterFactory.java",
      "functionStartLine": 115,
      "functionName": "create",
      "functionAnnotation": "@Override",
      "functionDoc": "",
      "diff": "@@ -1,14 +1,15 @@\n+@Override\n public \u003cT\u003e TypeAdapter\u003cT\u003e create(Gson gson, TypeToken\u003cT\u003e typeToken) {\n     Type type \u003d typeToken.getType();\n     Class\u003c? super T\u003e rawType \u003d typeToken.getRawType();\n     if (!Map.class.isAssignableFrom(rawType)) {\n         return null;\n     }\n     Class\u003c?\u003e rawTypeOfSrc \u003d $Gson$Types.getRawType(type);\n     Type[] keyAndValueTypes \u003d $Gson$Types.getMapKeyAndValueTypes(type, rawTypeOfSrc);\n     TypeAdapter\u003c?\u003e keyAdapter \u003d getKeyAdapter(gson, keyAndValueTypes[0]);\n     TypeAdapter\u003c?\u003e valueAdapter \u003d gson.getAdapter(TypeToken.get(keyAndValueTypes[1]));\n     ObjectConstructor\u003cT\u003e constructor \u003d constructorConstructor.get(typeToken);\n     @SuppressWarnings({ \"unchecked\", \"rawtypes\" }) TypeAdapter\u003cT\u003e result \u003d new Adapter(gson, keyAndValueTypes[0], keyAdapter, keyAndValueTypes[1], valueAdapter, constructor);\n     return result;\n }\n\\ No newline at end of file\n",
      "extendedDetails": {
        "oldValue": "",
        "newValue": "@Override"
      }
    },
    "6cca23c172612aded9ee2996a5177cb7b9a84390": {
      "type": "Ybodychange",
      "commitMessage": "Get GraphAdapterBuilder working for serialization and deserialization using InstanceCreators to get a sneak peek at a value under construction.\n",
      "commitDate": "1/1/12, 5:42 AM",
      "commitName": "6cca23c172612aded9ee2996a5177cb7b9a84390",
      "commitAuthor": "Jesse Wilson",
      "commitDateOld": "12/31/11, 12:52 AM",
      "commitNameOld": "6c78bf5247828219d4383c1b5dd13d494fa65cec",
      "commitAuthorOld": "Inderjeet Singh",
      "daysBetweenCommits": 1.2,
      "commitsBetweenForRepo": 7,
      "commitsBetweenForFile": 1,
      "actualSource": "public \u003cT\u003e TypeAdapter\u003cT\u003e create(Gson gson, TypeToken\u003cT\u003e typeToken) {\n    Type type \u003d typeToken.getType();\n    Class\u003c? super T\u003e rawType \u003d typeToken.getRawType();\n    if (!Map.class.isAssignableFrom(rawType)) {\n        return null;\n    }\n    Class\u003c?\u003e rawTypeOfSrc \u003d $Gson$Types.getRawType(type);\n    Type[] keyAndValueTypes \u003d $Gson$Types.getMapKeyAndValueTypes(type, rawTypeOfSrc);\n    TypeAdapter\u003c?\u003e keyAdapter \u003d getKeyAdapter(gson, keyAndValueTypes[0]);\n    TypeAdapter\u003c?\u003e valueAdapter \u003d gson.getAdapter(TypeToken.get(keyAndValueTypes[1]));\n    ObjectConstructor\u003cT\u003e constructor \u003d constructorConstructor.get(typeToken);\n    @SuppressWarnings({ \"unchecked\", \"rawtypes\" }) TypeAdapter\u003cT\u003e result \u003d new Adapter(gson, keyAndValueTypes[0], keyAdapter, keyAndValueTypes[1], valueAdapter, constructor);\n    return result;\n}",
      "path": "gson/src/main/java/com/google/gson/internal/bind/MapTypeAdapterFactory.java",
      "functionStartLine": 116,
      "functionName": "create",
      "functionAnnotation": "",
      "functionDoc": "",
      "diff": "@@ -1,14 +1,14 @@\n public \u003cT\u003e TypeAdapter\u003cT\u003e create(Gson gson, TypeToken\u003cT\u003e typeToken) {\n     Type type \u003d typeToken.getType();\n     Class\u003c? super T\u003e rawType \u003d typeToken.getRawType();\n     if (!Map.class.isAssignableFrom(rawType)) {\n         return null;\n     }\n     Class\u003c?\u003e rawTypeOfSrc \u003d $Gson$Types.getRawType(type);\n     Type[] keyAndValueTypes \u003d $Gson$Types.getMapKeyAndValueTypes(type, rawTypeOfSrc);\n     TypeAdapter\u003c?\u003e keyAdapter \u003d getKeyAdapter(gson, keyAndValueTypes[0]);\n     TypeAdapter\u003c?\u003e valueAdapter \u003d gson.getAdapter(TypeToken.get(keyAndValueTypes[1]));\n-    ObjectConstructor\u003cT\u003e constructor \u003d constructorConstructor.getConstructor(typeToken);\n+    ObjectConstructor\u003cT\u003e constructor \u003d constructorConstructor.get(typeToken);\n     @SuppressWarnings({ \"unchecked\", \"rawtypes\" }) TypeAdapter\u003cT\u003e result \u003d new Adapter(gson, keyAndValueTypes[0], keyAdapter, keyAndValueTypes[1], valueAdapter, constructor);\n     return result;\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "26ab404599643fac25442646b829a65a7f86bca1": {
      "type": "Ymultichange(Yparameterchange,Ybodychange)",
      "commitMessage": "Cleanup names for TypeAdapters.\n",
      "commitDate": "12/2/11, 2:57 PM",
      "commitName": "26ab404599643fac25442646b829a65a7f86bca1",
      "commitAuthor": "Jesse Wilson",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "Cleanup names for TypeAdapters.\n",
          "commitDate": "12/2/11, 2:57 PM",
          "commitName": "26ab404599643fac25442646b829a65a7f86bca1",
          "commitAuthor": "Jesse Wilson",
          "commitDateOld": "11/26/11, 7:36 AM",
          "commitNameOld": "852cd720590c120f23f033f53540a73ac64c4234",
          "commitAuthorOld": "Jesse Wilson",
          "daysBetweenCommits": 6.31,
          "commitsBetweenForRepo": 3,
          "commitsBetweenForFile": 1,
          "actualSource": "public \u003cT\u003e TypeAdapter\u003cT\u003e create(Gson gson, TypeToken\u003cT\u003e typeToken) {\n    Type type \u003d typeToken.getType();\n    Class\u003c? super T\u003e rawType \u003d typeToken.getRawType();\n    if (!Map.class.isAssignableFrom(rawType)) {\n        return null;\n    }\n    Class\u003c?\u003e rawTypeOfSrc \u003d $Gson$Types.getRawType(type);\n    Type[] keyAndValueTypes \u003d $Gson$Types.getMapKeyAndValueTypes(type, rawTypeOfSrc);\n    TypeAdapter\u003c?\u003e keyAdapter \u003d getKeyAdapter(gson, keyAndValueTypes[0]);\n    TypeAdapter\u003c?\u003e valueAdapter \u003d gson.getAdapter(TypeToken.get(keyAndValueTypes[1]));\n    ObjectConstructor\u003cT\u003e constructor \u003d constructorConstructor.getConstructor(typeToken);\n    @SuppressWarnings({ \"unchecked\", \"rawtypes\" }) TypeAdapter\u003cT\u003e result \u003d new Adapter(gson, keyAndValueTypes[0], keyAdapter, keyAndValueTypes[1], valueAdapter, constructor);\n    return result;\n}",
          "path": "gson/src/main/java/com/google/gson/internal/bind/MapTypeAdapterFactory.java",
          "functionStartLine": 114,
          "functionName": "create",
          "functionAnnotation": "",
          "functionDoc": "",
          "diff": "@@ -1,14 +1,14 @@\n-public \u003cT\u003e TypeAdapter\u003cT\u003e create(Gson context, TypeToken\u003cT\u003e typeToken) {\n+public \u003cT\u003e TypeAdapter\u003cT\u003e create(Gson gson, TypeToken\u003cT\u003e typeToken) {\n     Type type \u003d typeToken.getType();\n     Class\u003c? super T\u003e rawType \u003d typeToken.getRawType();\n     if (!Map.class.isAssignableFrom(rawType)) {\n         return null;\n     }\n     Class\u003c?\u003e rawTypeOfSrc \u003d $Gson$Types.getRawType(type);\n     Type[] keyAndValueTypes \u003d $Gson$Types.getMapKeyAndValueTypes(type, rawTypeOfSrc);\n-    TypeAdapter\u003c?\u003e keyAdapter \u003d getKeyAdapter(context, keyAndValueTypes[0]);\n-    TypeAdapter\u003c?\u003e valueAdapter \u003d context.getAdapter(TypeToken.get(keyAndValueTypes[1]));\n+    TypeAdapter\u003c?\u003e keyAdapter \u003d getKeyAdapter(gson, keyAndValueTypes[0]);\n+    TypeAdapter\u003c?\u003e valueAdapter \u003d gson.getAdapter(TypeToken.get(keyAndValueTypes[1]));\n     ObjectConstructor\u003cT\u003e constructor \u003d constructorConstructor.getConstructor(typeToken);\n-    @SuppressWarnings({ \"unchecked\", \"rawtypes\" }) TypeAdapter\u003cT\u003e result \u003d new Adapter(context, keyAndValueTypes[0], keyAdapter, keyAndValueTypes[1], valueAdapter, constructor);\n+    @SuppressWarnings({ \"unchecked\", \"rawtypes\" }) TypeAdapter\u003cT\u003e result \u003d new Adapter(gson, keyAndValueTypes[0], keyAdapter, keyAndValueTypes[1], valueAdapter, constructor);\n     return result;\n }\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldValue": "[context-Gson, typeToken-TypeToken\u003cT\u003e]",
            "newValue": "[gson-Gson, typeToken-TypeToken\u003cT\u003e]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "Cleanup names for TypeAdapters.\n",
          "commitDate": "12/2/11, 2:57 PM",
          "commitName": "26ab404599643fac25442646b829a65a7f86bca1",
          "commitAuthor": "Jesse Wilson",
          "commitDateOld": "11/26/11, 7:36 AM",
          "commitNameOld": "852cd720590c120f23f033f53540a73ac64c4234",
          "commitAuthorOld": "Jesse Wilson",
          "daysBetweenCommits": 6.31,
          "commitsBetweenForRepo": 3,
          "commitsBetweenForFile": 1,
          "actualSource": "public \u003cT\u003e TypeAdapter\u003cT\u003e create(Gson gson, TypeToken\u003cT\u003e typeToken) {\n    Type type \u003d typeToken.getType();\n    Class\u003c? super T\u003e rawType \u003d typeToken.getRawType();\n    if (!Map.class.isAssignableFrom(rawType)) {\n        return null;\n    }\n    Class\u003c?\u003e rawTypeOfSrc \u003d $Gson$Types.getRawType(type);\n    Type[] keyAndValueTypes \u003d $Gson$Types.getMapKeyAndValueTypes(type, rawTypeOfSrc);\n    TypeAdapter\u003c?\u003e keyAdapter \u003d getKeyAdapter(gson, keyAndValueTypes[0]);\n    TypeAdapter\u003c?\u003e valueAdapter \u003d gson.getAdapter(TypeToken.get(keyAndValueTypes[1]));\n    ObjectConstructor\u003cT\u003e constructor \u003d constructorConstructor.getConstructor(typeToken);\n    @SuppressWarnings({ \"unchecked\", \"rawtypes\" }) TypeAdapter\u003cT\u003e result \u003d new Adapter(gson, keyAndValueTypes[0], keyAdapter, keyAndValueTypes[1], valueAdapter, constructor);\n    return result;\n}",
          "path": "gson/src/main/java/com/google/gson/internal/bind/MapTypeAdapterFactory.java",
          "functionStartLine": 114,
          "functionName": "create",
          "functionAnnotation": "",
          "functionDoc": "",
          "diff": "@@ -1,14 +1,14 @@\n-public \u003cT\u003e TypeAdapter\u003cT\u003e create(Gson context, TypeToken\u003cT\u003e typeToken) {\n+public \u003cT\u003e TypeAdapter\u003cT\u003e create(Gson gson, TypeToken\u003cT\u003e typeToken) {\n     Type type \u003d typeToken.getType();\n     Class\u003c? super T\u003e rawType \u003d typeToken.getRawType();\n     if (!Map.class.isAssignableFrom(rawType)) {\n         return null;\n     }\n     Class\u003c?\u003e rawTypeOfSrc \u003d $Gson$Types.getRawType(type);\n     Type[] keyAndValueTypes \u003d $Gson$Types.getMapKeyAndValueTypes(type, rawTypeOfSrc);\n-    TypeAdapter\u003c?\u003e keyAdapter \u003d getKeyAdapter(context, keyAndValueTypes[0]);\n-    TypeAdapter\u003c?\u003e valueAdapter \u003d context.getAdapter(TypeToken.get(keyAndValueTypes[1]));\n+    TypeAdapter\u003c?\u003e keyAdapter \u003d getKeyAdapter(gson, keyAndValueTypes[0]);\n+    TypeAdapter\u003c?\u003e valueAdapter \u003d gson.getAdapter(TypeToken.get(keyAndValueTypes[1]));\n     ObjectConstructor\u003cT\u003e constructor \u003d constructorConstructor.getConstructor(typeToken);\n-    @SuppressWarnings({ \"unchecked\", \"rawtypes\" }) TypeAdapter\u003cT\u003e result \u003d new Adapter(context, keyAndValueTypes[0], keyAdapter, keyAndValueTypes[1], valueAdapter, constructor);\n+    @SuppressWarnings({ \"unchecked\", \"rawtypes\" }) TypeAdapter\u003cT\u003e result \u003d new Adapter(gson, keyAndValueTypes[0], keyAdapter, keyAndValueTypes[1], valueAdapter, constructor);\n     return result;\n }\n\\ No newline at end of file\n",
          "extendedDetails": {}
        }
      ]
    },
    "7e760143fdc8b689daeebdee33ad6ea7d0a62a56": {
      "type": "Yparameterchange",
      "commitMessage": "Smash together MiniGson and Gson. This changes Gson to be the MiniGson rather than delegating to the MiniGson. It means that the MiniGson objects passed into streaming type adapters are now fully-capable \u0027Gson\u0027 objects. \n\nThe most notable impact of this change is that it adds several new public APIs:\n - The TypeAdapter abstract class\n - The TypeAdapter.Factory interface\n - Four new methods on GsonBuilder to register streaming TypeAdapters (via Factory, via Class, via TypeToken, and as a type hierarchy)\n - Three new methods on Gson to lookup streaming TypeAdapters (by type, by class, and to get the next type adapter) \n\nStill outstanding:\n - Write beautiful prose to document the new APIs above\n - Change GsonBuilder\u0027s precedence so that both old and new-style type adapters are registered in one lot\n",
      "commitDate": "11/20/11, 7:23 AM",
      "commitName": "7e760143fdc8b689daeebdee33ad6ea7d0a62a56",
      "commitAuthor": "Jesse Wilson",
      "commitDateOld": "10/20/11, 2:32 PM",
      "commitNameOld": "31964507c1caabc9a70e3270fa56aaee29eff6b2",
      "commitAuthorOld": "Inderjeet Singh",
      "daysBetweenCommits": 30.74,
      "commitsBetweenForRepo": 25,
      "commitsBetweenForFile": 1,
      "actualSource": "public \u003cT\u003e TypeAdapter\u003cT\u003e create(Gson context, TypeToken\u003cT\u003e typeToken) {\n    Type type \u003d typeToken.getType();\n    Class\u003c? super T\u003e rawType \u003d typeToken.getRawType();\n    if (!Map.class.isAssignableFrom(rawType)) {\n        return null;\n    }\n    Class\u003c?\u003e rawTypeOfSrc \u003d $Gson$Types.getRawType(type);\n    Type[] keyAndValueTypes \u003d $Gson$Types.getMapKeyAndValueTypes(type, rawTypeOfSrc);\n    TypeAdapter\u003c?\u003e keyAdapter \u003d getKeyAdapter(context, keyAndValueTypes[0]);\n    TypeAdapter\u003c?\u003e valueAdapter \u003d context.getAdapter(TypeToken.get(keyAndValueTypes[1]));\n    ObjectConstructor\u003cT\u003e constructor \u003d constructorConstructor.getConstructor(typeToken);\n    @SuppressWarnings({ \"unchecked\", \"rawtypes\" }) TypeAdapter\u003cT\u003e result \u003d new Adapter(context, keyAndValueTypes[0], keyAdapter, keyAndValueTypes[1], valueAdapter, constructor);\n    return result;\n}",
      "path": "gson/src/main/java/com/google/gson/internal/bind/MapTypeAdapterFactory.java",
      "functionStartLine": 113,
      "functionName": "create",
      "functionAnnotation": "",
      "functionDoc": "",
      "diff": "@@ -1,14 +1,14 @@\n-public \u003cT\u003e TypeAdapter\u003cT\u003e create(MiniGson context, TypeToken\u003cT\u003e typeToken) {\n+public \u003cT\u003e TypeAdapter\u003cT\u003e create(Gson context, TypeToken\u003cT\u003e typeToken) {\n     Type type \u003d typeToken.getType();\n     Class\u003c? super T\u003e rawType \u003d typeToken.getRawType();\n     if (!Map.class.isAssignableFrom(rawType)) {\n         return null;\n     }\n     Class\u003c?\u003e rawTypeOfSrc \u003d $Gson$Types.getRawType(type);\n     Type[] keyAndValueTypes \u003d $Gson$Types.getMapKeyAndValueTypes(type, rawTypeOfSrc);\n     TypeAdapter\u003c?\u003e keyAdapter \u003d getKeyAdapter(context, keyAndValueTypes[0]);\n     TypeAdapter\u003c?\u003e valueAdapter \u003d context.getAdapter(TypeToken.get(keyAndValueTypes[1]));\n     ObjectConstructor\u003cT\u003e constructor \u003d constructorConstructor.getConstructor(typeToken);\n     @SuppressWarnings({ \"unchecked\", \"rawtypes\" }) TypeAdapter\u003cT\u003e result \u003d new Adapter(context, keyAndValueTypes[0], keyAdapter, keyAndValueTypes[1], valueAdapter, constructor);\n     return result;\n }\n\\ No newline at end of file\n",
      "extendedDetails": {
        "oldValue": "[context-MiniGson, typeToken-TypeToken\u003cT\u003e]",
        "newValue": "[context-Gson, typeToken-TypeToken\u003cT\u003e]"
      }
    },
    "31964507c1caabc9a70e3270fa56aaee29eff6b2": {
      "type": "Ybodychange",
      "commitMessage": "Updated SuppressWarnings annotations to Eclipse 3.6/3.7 which is unfortunately incompatible with Eclipse 3.5 (rawtypes vs unchecked)\nThis CL eliminates all eclipse warnings.\n",
      "commitDate": "10/20/11, 2:32 PM",
      "commitName": "31964507c1caabc9a70e3270fa56aaee29eff6b2",
      "commitAuthor": "Inderjeet Singh",
      "commitDateOld": "10/19/11, 9:24 PM",
      "commitNameOld": "194c18d20c6a05c9454ca9e0bc5503f2581ee3ea",
      "commitAuthorOld": "Jesse Wilson",
      "daysBetweenCommits": 0.71,
      "commitsBetweenForRepo": 2,
      "commitsBetweenForFile": 1,
      "actualSource": "public \u003cT\u003e TypeAdapter\u003cT\u003e create(MiniGson context, TypeToken\u003cT\u003e typeToken) {\n    Type type \u003d typeToken.getType();\n    Class\u003c? super T\u003e rawType \u003d typeToken.getRawType();\n    if (!Map.class.isAssignableFrom(rawType)) {\n        return null;\n    }\n    Class\u003c?\u003e rawTypeOfSrc \u003d $Gson$Types.getRawType(type);\n    Type[] keyAndValueTypes \u003d $Gson$Types.getMapKeyAndValueTypes(type, rawTypeOfSrc);\n    TypeAdapter\u003c?\u003e keyAdapter \u003d getKeyAdapter(context, keyAndValueTypes[0]);\n    TypeAdapter\u003c?\u003e valueAdapter \u003d context.getAdapter(TypeToken.get(keyAndValueTypes[1]));\n    ObjectConstructor\u003cT\u003e constructor \u003d constructorConstructor.getConstructor(typeToken);\n    @SuppressWarnings({ \"unchecked\", \"rawtypes\" }) TypeAdapter\u003cT\u003e result \u003d new Adapter(context, keyAndValueTypes[0], keyAdapter, keyAndValueTypes[1], valueAdapter, constructor);\n    return result;\n}",
      "path": "gson/src/main/java/com/google/gson/internal/bind/MapTypeAdapterFactory.java",
      "functionStartLine": 111,
      "functionName": "create",
      "functionAnnotation": "",
      "functionDoc": "",
      "diff": "@@ -1,14 +1,14 @@\n public \u003cT\u003e TypeAdapter\u003cT\u003e create(MiniGson context, TypeToken\u003cT\u003e typeToken) {\n     Type type \u003d typeToken.getType();\n     Class\u003c? super T\u003e rawType \u003d typeToken.getRawType();\n     if (!Map.class.isAssignableFrom(rawType)) {\n         return null;\n     }\n     Class\u003c?\u003e rawTypeOfSrc \u003d $Gson$Types.getRawType(type);\n     Type[] keyAndValueTypes \u003d $Gson$Types.getMapKeyAndValueTypes(type, rawTypeOfSrc);\n     TypeAdapter\u003c?\u003e keyAdapter \u003d getKeyAdapter(context, keyAndValueTypes[0]);\n     TypeAdapter\u003c?\u003e valueAdapter \u003d context.getAdapter(TypeToken.get(keyAndValueTypes[1]));\n     ObjectConstructor\u003cT\u003e constructor \u003d constructorConstructor.getConstructor(typeToken);\n-    @SuppressWarnings(\"unchecked\") TypeAdapter\u003cT\u003e result \u003d new Adapter(context, keyAndValueTypes[0], keyAdapter, keyAndValueTypes[1], valueAdapter, constructor);\n+    @SuppressWarnings({ \"unchecked\", \"rawtypes\" }) TypeAdapter\u003cT\u003e result \u003d new Adapter(context, keyAndValueTypes[0], keyAdapter, keyAndValueTypes[1], valueAdapter, constructor);\n     return result;\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "194c18d20c6a05c9454ca9e0bc5503f2581ee3ea": {
      "type": "Ybodychange",
      "commitMessage": "Be backwards-compatible for serialization of maps whose keys aren\u0027t primitives.\n",
      "commitDate": "10/19/11, 9:24 PM",
      "commitName": "194c18d20c6a05c9454ca9e0bc5503f2581ee3ea",
      "commitAuthor": "Jesse Wilson",
      "commitDateOld": "10/13/11, 8:20 PM",
      "commitNameOld": "0e02cbb33ec43b301b6835a99db020a2df3c6f51",
      "commitAuthorOld": "Jesse Wilson",
      "daysBetweenCommits": 6.04,
      "commitsBetweenForRepo": 2,
      "commitsBetweenForFile": 1,
      "actualSource": "public \u003cT\u003e TypeAdapter\u003cT\u003e create(MiniGson context, TypeToken\u003cT\u003e typeToken) {\n    Type type \u003d typeToken.getType();\n    Class\u003c? super T\u003e rawType \u003d typeToken.getRawType();\n    if (!Map.class.isAssignableFrom(rawType)) {\n        return null;\n    }\n    Class\u003c?\u003e rawTypeOfSrc \u003d $Gson$Types.getRawType(type);\n    Type[] keyAndValueTypes \u003d $Gson$Types.getMapKeyAndValueTypes(type, rawTypeOfSrc);\n    TypeAdapter\u003c?\u003e keyAdapter \u003d getKeyAdapter(context, keyAndValueTypes[0]);\n    TypeAdapter\u003c?\u003e valueAdapter \u003d context.getAdapter(TypeToken.get(keyAndValueTypes[1]));\n    ObjectConstructor\u003cT\u003e constructor \u003d constructorConstructor.getConstructor(typeToken);\n    @SuppressWarnings(\"unchecked\") TypeAdapter\u003cT\u003e result \u003d new Adapter(context, keyAndValueTypes[0], keyAdapter, keyAndValueTypes[1], valueAdapter, constructor);\n    return result;\n}",
      "path": "gson/src/main/java/com/google/gson/internal/bind/MapTypeAdapterFactory.java",
      "functionStartLine": 111,
      "functionName": "create",
      "functionAnnotation": "",
      "functionDoc": "",
      "diff": "@@ -1,14 +1,14 @@\n public \u003cT\u003e TypeAdapter\u003cT\u003e create(MiniGson context, TypeToken\u003cT\u003e typeToken) {\n     Type type \u003d typeToken.getType();\n     Class\u003c? super T\u003e rawType \u003d typeToken.getRawType();\n     if (!Map.class.isAssignableFrom(rawType)) {\n         return null;\n     }\n     Class\u003c?\u003e rawTypeOfSrc \u003d $Gson$Types.getRawType(type);\n     Type[] keyAndValueTypes \u003d $Gson$Types.getMapKeyAndValueTypes(type, rawTypeOfSrc);\n-    TypeAdapter\u003c?\u003e keyAdapter \u003d context.getAdapter(TypeToken.get(keyAndValueTypes[0]));\n+    TypeAdapter\u003c?\u003e keyAdapter \u003d getKeyAdapter(context, keyAndValueTypes[0]);\n     TypeAdapter\u003c?\u003e valueAdapter \u003d context.getAdapter(TypeToken.get(keyAndValueTypes[1]));\n     ObjectConstructor\u003cT\u003e constructor \u003d constructorConstructor.getConstructor(typeToken);\n     @SuppressWarnings(\"unchecked\") TypeAdapter\u003cT\u003e result \u003d new Adapter(context, keyAndValueTypes[0], keyAdapter, keyAndValueTypes[1], valueAdapter, constructor);\n     return result;\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "b2d5940a9baf82c6aa796adf710b86fe64fe14e7": {
      "type": "Ybodychange",
      "commitMessage": "Implemented runtime type serialization for keys and values of a map.\nThis fixes MoreSpecificTypeSerializationTest.testMapOfSubclassFields\n",
      "commitDate": "9/27/11, 8:20 AM",
      "commitName": "b2d5940a9baf82c6aa796adf710b86fe64fe14e7",
      "commitAuthor": "Inderjeet Singh",
      "commitDateOld": "9/11/11, 10:51 PM",
      "commitNameOld": "a98d6eae472df67317d58d34f13438bb958668b1",
      "commitAuthorOld": "Jesse Wilson",
      "daysBetweenCommits": 15.4,
      "commitsBetweenForRepo": 20,
      "commitsBetweenForFile": 1,
      "actualSource": "public \u003cT\u003e TypeAdapter\u003cT\u003e create(MiniGson context, TypeToken\u003cT\u003e typeToken) {\n    Type type \u003d typeToken.getType();\n    Class\u003c? super T\u003e rawType \u003d typeToken.getRawType();\n    if (!Map.class.isAssignableFrom(rawType)) {\n        return null;\n    }\n    Class\u003c?\u003e rawTypeOfSrc \u003d $Gson$Types.getRawType(type);\n    Type[] keyAndValueTypes \u003d $Gson$Types.getMapKeyAndValueTypes(type, rawTypeOfSrc);\n    TypeAdapter\u003c?\u003e keyAdapter \u003d context.getAdapter(TypeToken.get(keyAndValueTypes[0]));\n    TypeAdapter\u003c?\u003e valueAdapter \u003d context.getAdapter(TypeToken.get(keyAndValueTypes[1]));\n    ObjectConstructor\u003cT\u003e constructor \u003d constructorConstructor.getConstructor(typeToken);\n    @SuppressWarnings(\"unchecked\") TypeAdapter\u003cT\u003e result \u003d new Adapter(context, keyAndValueTypes[0], keyAdapter, keyAndValueTypes[1], valueAdapter, constructor);\n    return result;\n}",
      "path": "gson/src/main/java/com/google/gson/internal/bind/MapTypeAdapterFactory.java",
      "functionStartLine": 112,
      "functionName": "create",
      "functionAnnotation": "",
      "functionDoc": "",
      "diff": "@@ -1,14 +1,14 @@\n public \u003cT\u003e TypeAdapter\u003cT\u003e create(MiniGson context, TypeToken\u003cT\u003e typeToken) {\n     Type type \u003d typeToken.getType();\n     Class\u003c? super T\u003e rawType \u003d typeToken.getRawType();\n     if (!Map.class.isAssignableFrom(rawType)) {\n         return null;\n     }\n     Class\u003c?\u003e rawTypeOfSrc \u003d $Gson$Types.getRawType(type);\n     Type[] keyAndValueTypes \u003d $Gson$Types.getMapKeyAndValueTypes(type, rawTypeOfSrc);\n     TypeAdapter\u003c?\u003e keyAdapter \u003d context.getAdapter(TypeToken.get(keyAndValueTypes[0]));\n     TypeAdapter\u003c?\u003e valueAdapter \u003d context.getAdapter(TypeToken.get(keyAndValueTypes[1]));\n     ObjectConstructor\u003cT\u003e constructor \u003d constructorConstructor.getConstructor(typeToken);\n-    @SuppressWarnings(\"unchecked\") TypeAdapter\u003cT\u003e result \u003d new Adapter(keyAdapter, valueAdapter, constructor);\n+    @SuppressWarnings(\"unchecked\") TypeAdapter\u003cT\u003e result \u003d new Adapter(context, keyAndValueTypes[0], keyAdapter, keyAndValueTypes[1], valueAdapter, constructor);\n     return result;\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "a98d6eae472df67317d58d34f13438bb958668b1": {
      "type": "Ybodychange",
      "commitMessage": "Fix the map type adapter to support array serialization natively.\n",
      "commitDate": "9/11/11, 10:51 PM",
      "commitName": "a98d6eae472df67317d58d34f13438bb958668b1",
      "commitAuthor": "Jesse Wilson",
      "commitDateOld": "9/11/11, 12:04 AM",
      "commitNameOld": "25c6ae177b1ca56db7f3c29eb574bdd032a06165",
      "commitAuthorOld": "Jesse Wilson",
      "daysBetweenCommits": 0.95,
      "commitsBetweenForRepo": 2,
      "commitsBetweenForFile": 1,
      "actualSource": "public \u003cT\u003e TypeAdapter\u003cT\u003e create(MiniGson context, TypeToken\u003cT\u003e typeToken) {\n    Type type \u003d typeToken.getType();\n    Class\u003c? super T\u003e rawType \u003d typeToken.getRawType();\n    if (!Map.class.isAssignableFrom(rawType)) {\n        return null;\n    }\n    Class\u003c?\u003e rawTypeOfSrc \u003d $Gson$Types.getRawType(type);\n    Type[] keyAndValueTypes \u003d $Gson$Types.getMapKeyAndValueTypes(type, rawTypeOfSrc);\n    TypeAdapter\u003c?\u003e keyAdapter \u003d context.getAdapter(TypeToken.get(keyAndValueTypes[0]));\n    TypeAdapter\u003c?\u003e valueAdapter \u003d context.getAdapter(TypeToken.get(keyAndValueTypes[1]));\n    ObjectConstructor\u003cT\u003e constructor \u003d constructorConstructor.getConstructor(typeToken);\n    @SuppressWarnings(\"unchecked\") TypeAdapter\u003cT\u003e result \u003d new Adapter(keyAdapter, valueAdapter, constructor);\n    return result;\n}",
      "path": "gson/src/main/java/com/google/gson/internal/bind/MapTypeAdapterFactory.java",
      "functionStartLine": 111,
      "functionName": "create",
      "functionAnnotation": "",
      "functionDoc": "",
      "diff": "@@ -1,13 +1,14 @@\n public \u003cT\u003e TypeAdapter\u003cT\u003e create(MiniGson context, TypeToken\u003cT\u003e typeToken) {\n     Type type \u003d typeToken.getType();\n     Class\u003c? super T\u003e rawType \u003d typeToken.getRawType();\n     if (!Map.class.isAssignableFrom(rawType)) {\n         return null;\n     }\n     Class\u003c?\u003e rawTypeOfSrc \u003d $Gson$Types.getRawType(type);\n-    Type childGenericType \u003d $Gson$Types.getMapKeyAndValueTypes(type, rawTypeOfSrc)[1];\n-    TypeAdapter valueAdapter \u003d context.getAdapter(TypeToken.get(childGenericType));\n+    Type[] keyAndValueTypes \u003d $Gson$Types.getMapKeyAndValueTypes(type, rawTypeOfSrc);\n+    TypeAdapter\u003c?\u003e keyAdapter \u003d context.getAdapter(TypeToken.get(keyAndValueTypes[0]));\n+    TypeAdapter\u003c?\u003e valueAdapter \u003d context.getAdapter(TypeToken.get(keyAndValueTypes[1]));\n     ObjectConstructor\u003cT\u003e constructor \u003d constructorConstructor.getConstructor(typeToken);\n-    @SuppressWarnings(\"unchecked\") TypeAdapter\u003cT\u003e result \u003d new Adapter(valueAdapter, constructor);\n+    @SuppressWarnings(\"unchecked\") TypeAdapter\u003cT\u003e result \u003d new Adapter(keyAdapter, valueAdapter, constructor);\n     return result;\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "25c6ae177b1ca56db7f3c29eb574bdd032a06165": {
      "type": "Ymultichange(Ymovefromfile,Ybodychange)",
      "commitMessage": "Down to 22 failing tests.\n\nConsolidated all of the different code paths that we use to construct instances. We now have an ObjectConstructor class that knows what type it constructs; this means that we don\u0027t need to ever do reflection to lookup a constructor at construction time.\n\nCleaned up some buggy type adapters, particularly around handling of null.\n\nRemoved dead code for object graph navigation.\n\nMoved some classes into \u0027internal\u0027 so they are visible to the \u0027bind\u0027 subpackage.\n\nTurned some TypeAdapterFactory/TypeAdapter pairs inside out so that the TypeAdapter is now the inner class. This is necessary so that the factories can take parameters.\n\nAdded an API to request the \u0027next\u0027 type adapter for a type. This allows type adapters to compose other type adapters. We\u0027re using this in two places:\n - where the user has excluded a type from serialization but not deserialization, we need to use the \"default\" deserialization but interpose null on serialization. We create a type adapter that delegates for one and returns null for the other.\n - similarly when a DOM type serializer is registered but no deserializer, or vice versa.\nThis is the biggest change to the MiniGson core.\n\nFor backwards compatibility, return null for the empty string.\n\nSimplify JsonSerializationContext/JsonDeserializationContext to simply call through to GSON. SerializeDefault is currently unsupported.\n\nMore useful error messages when calling getAsBoolean on a JsonNull.\n\nRemove currently unused MemoryRefStack. We might need this back again, though wiring it back in will be much more difficult because we don\u0027t interject ourselves between the users\u0027 various type adapters.\n",
      "commitDate": "9/11/11, 12:04 AM",
      "commitName": "25c6ae177b1ca56db7f3c29eb574bdd032a06165",
      "commitAuthor": "Jesse Wilson",
      "subchanges": [
        {
          "type": "Ymovefromfile",
          "commitMessage": "Down to 22 failing tests.\n\nConsolidated all of the different code paths that we use to construct instances. We now have an ObjectConstructor class that knows what type it constructs; this means that we don\u0027t need to ever do reflection to lookup a constructor at construction time.\n\nCleaned up some buggy type adapters, particularly around handling of null.\n\nRemoved dead code for object graph navigation.\n\nMoved some classes into \u0027internal\u0027 so they are visible to the \u0027bind\u0027 subpackage.\n\nTurned some TypeAdapterFactory/TypeAdapter pairs inside out so that the TypeAdapter is now the inner class. This is necessary so that the factories can take parameters.\n\nAdded an API to request the \u0027next\u0027 type adapter for a type. This allows type adapters to compose other type adapters. We\u0027re using this in two places:\n - where the user has excluded a type from serialization but not deserialization, we need to use the \"default\" deserialization but interpose null on serialization. We create a type adapter that delegates for one and returns null for the other.\n - similarly when a DOM type serializer is registered but no deserializer, or vice versa.\nThis is the biggest change to the MiniGson core.\n\nFor backwards compatibility, return null for the empty string.\n\nSimplify JsonSerializationContext/JsonDeserializationContext to simply call through to GSON. SerializeDefault is currently unsupported.\n\nMore useful error messages when calling getAsBoolean on a JsonNull.\n\nRemove currently unused MemoryRefStack. We might need this back again, though wiring it back in will be much more difficult because we don\u0027t interject ourselves between the users\u0027 various type adapters.\n",
          "commitDate": "9/11/11, 12:04 AM",
          "commitName": "25c6ae177b1ca56db7f3c29eb574bdd032a06165",
          "commitAuthor": "Jesse Wilson",
          "commitDateOld": "9/9/11, 1:17 AM",
          "commitNameOld": "cdd5d80b85155c21c61f888fb3e70c65e72edef7",
          "commitAuthorOld": "Jesse Wilson",
          "daysBetweenCommits": 1.95,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "actualSource": "public \u003cT\u003e TypeAdapter\u003cT\u003e create(MiniGson context, TypeToken\u003cT\u003e typeToken) {\n    Type type \u003d typeToken.getType();\n    Class\u003c? super T\u003e rawType \u003d typeToken.getRawType();\n    if (!Map.class.isAssignableFrom(rawType)) {\n        return null;\n    }\n    Class\u003c?\u003e rawTypeOfSrc \u003d $Gson$Types.getRawType(type);\n    Type childGenericType \u003d $Gson$Types.getMapKeyAndValueTypes(type, rawTypeOfSrc)[1];\n    TypeAdapter valueAdapter \u003d context.getAdapter(TypeToken.get(childGenericType));\n    ObjectConstructor\u003cT\u003e constructor \u003d constructorConstructor.getConstructor(typeToken);\n    @SuppressWarnings(\"unchecked\") TypeAdapter\u003cT\u003e result \u003d new Adapter(valueAdapter, constructor);\n    return result;\n}",
          "path": "gson/src/main/java/com/google/gson/internal/bind/MapTypeAdapterFactory.java",
          "functionStartLine": 40,
          "functionName": "create",
          "functionAnnotation": "",
          "functionDoc": "",
          "diff": "@@ -1,22 +1,13 @@\n public \u003cT\u003e TypeAdapter\u003cT\u003e create(MiniGson context, TypeToken\u003cT\u003e typeToken) {\n     Type type \u003d typeToken.getType();\n     Class\u003c? super T\u003e rawType \u003d typeToken.getRawType();\n     if (!Map.class.isAssignableFrom(rawType)) {\n         return null;\n     }\n-    Type childGenericType \u003d Object.class;\n-    if (type instanceof ParameterizedType) {\n-        Class\u003c?\u003e rawTypeOfSrc \u003d $Gson$Types.getRawType(type);\n-        childGenericType \u003d $Gson$Types.getMapKeyAndValueTypes(type, rawTypeOfSrc)[1];\n-    }\n+    Class\u003c?\u003e rawTypeOfSrc \u003d $Gson$Types.getRawType(type);\n+    Type childGenericType \u003d $Gson$Types.getMapKeyAndValueTypes(type, rawTypeOfSrc)[1];\n     TypeAdapter valueAdapter \u003d context.getAdapter(TypeToken.get(childGenericType));\n-    Constructor\u003c?\u003e constructor;\n-    try {\n-        Class\u003c?\u003e constructorType \u003d (rawType \u003d\u003d Map.class) ? LinkedHashMap.class : rawType;\n-        constructor \u003d constructorType.getConstructor();\n-    } catch (NoSuchMethodException e) {\n-        return null;\n-    }\n-    @SuppressWarnings(\"unchecked\") TypeAdapter\u003cT\u003e result \u003d new GsonCompatibleMapTypeAdapter(valueAdapter, constructor);\n+    ObjectConstructor\u003cT\u003e constructor \u003d constructorConstructor.getConstructor(typeToken);\n+    @SuppressWarnings(\"unchecked\") TypeAdapter\u003cT\u003e result \u003d new Adapter(valueAdapter, constructor);\n     return result;\n }\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldPath": "gson/src/main/java/com/google/gson/internal/bind/GsonCompatibleMapTypeAdapter.java",
            "newPath": "gson/src/main/java/com/google/gson/internal/bind/MapTypeAdapterFactory.java",
            "oldMethodName": "create",
            "newMethodName": "create"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "Down to 22 failing tests.\n\nConsolidated all of the different code paths that we use to construct instances. We now have an ObjectConstructor class that knows what type it constructs; this means that we don\u0027t need to ever do reflection to lookup a constructor at construction time.\n\nCleaned up some buggy type adapters, particularly around handling of null.\n\nRemoved dead code for object graph navigation.\n\nMoved some classes into \u0027internal\u0027 so they are visible to the \u0027bind\u0027 subpackage.\n\nTurned some TypeAdapterFactory/TypeAdapter pairs inside out so that the TypeAdapter is now the inner class. This is necessary so that the factories can take parameters.\n\nAdded an API to request the \u0027next\u0027 type adapter for a type. This allows type adapters to compose other type adapters. We\u0027re using this in two places:\n - where the user has excluded a type from serialization but not deserialization, we need to use the \"default\" deserialization but interpose null on serialization. We create a type adapter that delegates for one and returns null for the other.\n - similarly when a DOM type serializer is registered but no deserializer, or vice versa.\nThis is the biggest change to the MiniGson core.\n\nFor backwards compatibility, return null for the empty string.\n\nSimplify JsonSerializationContext/JsonDeserializationContext to simply call through to GSON. SerializeDefault is currently unsupported.\n\nMore useful error messages when calling getAsBoolean on a JsonNull.\n\nRemove currently unused MemoryRefStack. We might need this back again, though wiring it back in will be much more difficult because we don\u0027t interject ourselves between the users\u0027 various type adapters.\n",
          "commitDate": "9/11/11, 12:04 AM",
          "commitName": "25c6ae177b1ca56db7f3c29eb574bdd032a06165",
          "commitAuthor": "Jesse Wilson",
          "commitDateOld": "9/9/11, 1:17 AM",
          "commitNameOld": "cdd5d80b85155c21c61f888fb3e70c65e72edef7",
          "commitAuthorOld": "Jesse Wilson",
          "daysBetweenCommits": 1.95,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "actualSource": "public \u003cT\u003e TypeAdapter\u003cT\u003e create(MiniGson context, TypeToken\u003cT\u003e typeToken) {\n    Type type \u003d typeToken.getType();\n    Class\u003c? super T\u003e rawType \u003d typeToken.getRawType();\n    if (!Map.class.isAssignableFrom(rawType)) {\n        return null;\n    }\n    Class\u003c?\u003e rawTypeOfSrc \u003d $Gson$Types.getRawType(type);\n    Type childGenericType \u003d $Gson$Types.getMapKeyAndValueTypes(type, rawTypeOfSrc)[1];\n    TypeAdapter valueAdapter \u003d context.getAdapter(TypeToken.get(childGenericType));\n    ObjectConstructor\u003cT\u003e constructor \u003d constructorConstructor.getConstructor(typeToken);\n    @SuppressWarnings(\"unchecked\") TypeAdapter\u003cT\u003e result \u003d new Adapter(valueAdapter, constructor);\n    return result;\n}",
          "path": "gson/src/main/java/com/google/gson/internal/bind/MapTypeAdapterFactory.java",
          "functionStartLine": 40,
          "functionName": "create",
          "functionAnnotation": "",
          "functionDoc": "",
          "diff": "@@ -1,22 +1,13 @@\n public \u003cT\u003e TypeAdapter\u003cT\u003e create(MiniGson context, TypeToken\u003cT\u003e typeToken) {\n     Type type \u003d typeToken.getType();\n     Class\u003c? super T\u003e rawType \u003d typeToken.getRawType();\n     if (!Map.class.isAssignableFrom(rawType)) {\n         return null;\n     }\n-    Type childGenericType \u003d Object.class;\n-    if (type instanceof ParameterizedType) {\n-        Class\u003c?\u003e rawTypeOfSrc \u003d $Gson$Types.getRawType(type);\n-        childGenericType \u003d $Gson$Types.getMapKeyAndValueTypes(type, rawTypeOfSrc)[1];\n-    }\n+    Class\u003c?\u003e rawTypeOfSrc \u003d $Gson$Types.getRawType(type);\n+    Type childGenericType \u003d $Gson$Types.getMapKeyAndValueTypes(type, rawTypeOfSrc)[1];\n     TypeAdapter valueAdapter \u003d context.getAdapter(TypeToken.get(childGenericType));\n-    Constructor\u003c?\u003e constructor;\n-    try {\n-        Class\u003c?\u003e constructorType \u003d (rawType \u003d\u003d Map.class) ? LinkedHashMap.class : rawType;\n-        constructor \u003d constructorType.getConstructor();\n-    } catch (NoSuchMethodException e) {\n-        return null;\n-    }\n-    @SuppressWarnings(\"unchecked\") TypeAdapter\u003cT\u003e result \u003d new GsonCompatibleMapTypeAdapter(valueAdapter, constructor);\n+    ObjectConstructor\u003cT\u003e constructor \u003d constructorConstructor.getConstructor(typeToken);\n+    @SuppressWarnings(\"unchecked\") TypeAdapter\u003cT\u003e result \u003d new Adapter(valueAdapter, constructor);\n     return result;\n }\n\\ No newline at end of file\n",
          "extendedDetails": {}
        }
      ]
    },
    "3aeb70e0305a598a9ceddc0390d693874dcc892d": {
      "type": "Yintroduced",
      "commitMessage": "Adapter for Object.class\n",
      "commitDate": "9/8/11, 8:31 PM",
      "commitName": "3aeb70e0305a598a9ceddc0390d693874dcc892d",
      "commitAuthor": "Jesse Wilson",
      "diff": "@@ -0,0 +1,22 @@\n+public \u003cT\u003e TypeAdapter\u003cT\u003e create(MiniGson context, TypeToken\u003cT\u003e typeToken) {\n+    Type type \u003d typeToken.getType();\n+    Class\u003c? super T\u003e rawType \u003d typeToken.getRawType();\n+    if (!Map.class.isAssignableFrom(rawType)) {\n+        return null;\n+    }\n+    Type childGenericType \u003d Object.class;\n+    if (type instanceof ParameterizedType) {\n+        Class\u003c?\u003e rawTypeOfSrc \u003d $Gson$Types.getRawType(type);\n+        childGenericType \u003d $Gson$Types.getMapKeyAndValueTypes(type, rawTypeOfSrc)[1];\n+    }\n+    TypeAdapter valueAdapter \u003d context.getAdapter(TypeToken.get(childGenericType));\n+    Constructor\u003c?\u003e constructor;\n+    try {\n+        Class\u003c?\u003e constructorType \u003d (rawType \u003d\u003d Map.class) ? LinkedHashMap.class : rawType;\n+        constructor \u003d constructorType.getConstructor();\n+    } catch (NoSuchMethodException e) {\n+        return null;\n+    }\n+    @SuppressWarnings(\"unchecked\") TypeAdapter\u003cT\u003e result \u003d new GsonCompatibleMapTypeAdapter(valueAdapter, constructor);\n+    return result;\n+}\n\\ No newline at end of file\n",
      "actualSource": "public \u003cT\u003e TypeAdapter\u003cT\u003e create(MiniGson context, TypeToken\u003cT\u003e typeToken) {\n    Type type \u003d typeToken.getType();\n    Class\u003c? super T\u003e rawType \u003d typeToken.getRawType();\n    if (!Map.class.isAssignableFrom(rawType)) {\n        return null;\n    }\n    Type childGenericType \u003d Object.class;\n    if (type instanceof ParameterizedType) {\n        Class\u003c?\u003e rawTypeOfSrc \u003d $Gson$Types.getRawType(type);\n        childGenericType \u003d $Gson$Types.getMapKeyAndValueTypes(type, rawTypeOfSrc)[1];\n    }\n    TypeAdapter valueAdapter \u003d context.getAdapter(TypeToken.get(childGenericType));\n    Constructor\u003c?\u003e constructor;\n    try {\n        Class\u003c?\u003e constructorType \u003d (rawType \u003d\u003d Map.class) ? LinkedHashMap.class : rawType;\n        constructor \u003d constructorType.getConstructor();\n    } catch (NoSuchMethodException e) {\n        return null;\n    }\n    @SuppressWarnings(\"unchecked\") TypeAdapter\u003cT\u003e result \u003d new GsonCompatibleMapTypeAdapter(valueAdapter, constructor);\n    return result;\n}",
      "path": "gson/src/main/java/com/google/gson/internal/bind/GsonCompatibleMapTypeAdapter.java",
      "functionStartLine": 36,
      "functionName": "create",
      "functionAnnotation": "",
      "functionDoc": ""
    }
  }
}