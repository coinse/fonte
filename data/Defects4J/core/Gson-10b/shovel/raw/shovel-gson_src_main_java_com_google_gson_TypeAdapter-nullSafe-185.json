{
  "origin": "codeshovel",
  "repositoryName": "Gson-10b",
  "repositoryPath": "/tmp/Gson-10b//.git",
  "startCommitName": "HEAD",
  "sourceFileName": "TypeAdapter.java",
  "functionName": "nullSafe",
  "functionId": "nullSafe",
  "sourceFilePath": "gson/src/main/java/com/google/gson/TypeAdapter.java",
  "functionAnnotation": "",
  "functionDoc": "This wrapper method is used to make a type adapter null tolerant. In general, a\ntype adapter is required to handle nulls in write and read methods. Here is how this\nis typically done:\u003cbr\u003e\n\u003cpre\u003e   {@code\n\nGson gson \u003d new GsonBuilder().registerTypeAdapter(Foo.class,\n  new TypeAdapter\u003cFoo\u003e() {\n    public Foo read(JsonReader in) throws IOException {\n      if (in.peek() \u003d\u003d JsonToken.NULL) {\n        in.nextNull();\n        return null;\n      }\n      // read a Foo from in and return it\n    }\n    public void write(JsonWriter out, Foo src) throws IOException {\n      if (src \u003d\u003d null) {\n        out.nullValue();\n        return;\n      }\n      // write src as JSON to out\n    }\n  }).create();\n}\u003c/pre\u003e\nYou can avoid this boilerplate handling of nulls by wrapping your type adapter with\nthis method. Here is how we will rewrite the above example:\n\u003cpre\u003e   {@code\n\nGson gson \u003d new GsonBuilder().registerTypeAdapter(Foo.class,\n  new TypeAdapter\u003cFoo\u003e() {\n    public Foo read(JsonReader in) throws IOException {\n      // read a Foo from in and return it\n    }\n    public void write(JsonWriter out, Foo src) throws IOException {\n      // write src as JSON to out\n    }\n  }.nullSafe()).create();\n}\u003c/pre\u003e\nNote that we didn\u0027t need to check for nulls in our type adapter after we used nullSafe.\n",
  "functionStartLine": 185,
  "functionEndLine": 202,
  "numCommitsSeen": 32,
  "timeTaken": 851,
  "changeHistory": [
    "b28e518c7e19f5ad1f881144c3651e7c3f9c759a",
    "2ef7716209043289880d5f1d5bbb9a658b93f2da",
    "eb2230caf0c8d1e2d9ea67e7c4afce72f1eccc3f",
    "0b734e46e180a452e4bff45878ac60441be6ff74",
    "91be944022883646433237e4c1001747fa0ba955"
  ],
  "changeHistoryShort": {
    "b28e518c7e19f5ad1f881144c3651e7c3f9c759a": "Ymodifierchange",
    "2ef7716209043289880d5f1d5bbb9a658b93f2da": "Ydocchange",
    "eb2230caf0c8d1e2d9ea67e7c4afce72f1eccc3f": "Ybodychange",
    "0b734e46e180a452e4bff45878ac60441be6ff74": "Ymultichange(Yparameterchange,Ymodifierchange,Ybodychange,Ydocchange)",
    "91be944022883646433237e4c1001747fa0ba955": "Yintroduced"
  },
  "changeHistoryDetails": {
    "b28e518c7e19f5ad1f881144c3651e7c3f9c759a": {
      "type": "Ymodifierchange",
      "commitMessage": "Hide toJson/fromJson APIs for the 2.1 release.\n",
      "commitDate": "12/21/11, 1:30 PM",
      "commitName": "b28e518c7e19f5ad1f881144c3651e7c3f9c759a",
      "commitAuthor": "Jesse Wilson",
      "commitDateOld": "12/16/11, 11:00 AM",
      "commitNameOld": "f24da51ca2e47229a403819219986ebf3cd07597",
      "commitAuthorOld": "Jesse Wilson",
      "daysBetweenCommits": 5.1,
      "commitsBetweenForRepo": 4,
      "commitsBetweenForFile": 1,
      "actualSource": "public final TypeAdapter\u003cT\u003e nullSafe() {\n    return new TypeAdapter\u003cT\u003e() {\n\n        @Override\n        public void write(JsonWriter out, T value) throws IOException {\n            if (value \u003d\u003d null) {\n                out.nullValue();\n            } else {\n                TypeAdapter.this.write(out, value);\n            }\n        }\n\n        @Override\n        public T read(JsonReader reader) throws IOException {\n            if (reader.peek() \u003d\u003d JsonToken.NULL) {\n                reader.nextNull();\n                return null;\n            }\n            return TypeAdapter.this.read(reader);\n        }\n    };\n}",
      "path": "gson/src/main/java/com/google/gson/TypeAdapter.java",
      "functionStartLine": 185,
      "functionName": "nullSafe",
      "functionAnnotation": "",
      "functionDoc": "This wrapper method is used to make a type adapter null tolerant. In general, a\ntype adapter is required to handle nulls in write and read methods. Here is how this\nis typically done:\u003cbr\u003e\n\u003cpre\u003e   {@code\n\nGson gson \u003d new GsonBuilder().registerTypeAdapter(Foo.class,\n  new TypeAdapter\u003cFoo\u003e() {\n    public Foo read(JsonReader in) throws IOException {\n      if (in.peek() \u003d\u003d JsonToken.NULL) {\n        in.nextNull();\n        return null;\n      }\n      // read a Foo from in and return it\n    }\n    public void write(JsonWriter out, Foo src) throws IOException {\n      if (src \u003d\u003d null) {\n        out.nullValue();\n        return;\n      }\n      // write src as JSON to out\n    }\n  }).create();\n}\u003c/pre\u003e\nYou can avoid this boilerplate handling of nulls by wrapping your type adapter with\nthis method. Here is how we will rewrite the above example:\n\u003cpre\u003e   {@code\n\nGson gson \u003d new GsonBuilder().registerTypeAdapter(Foo.class,\n  new TypeAdapter\u003cFoo\u003e() {\n    public Foo read(JsonReader in) throws IOException {\n      // read a Foo from in and return it\n    }\n    public void write(JsonWriter out, Foo src) throws IOException {\n      // write src as JSON to out\n    }\n  }.nullSafe()).create();\n}\u003c/pre\u003e\nNote that we didn\u0027t need to check for nulls in our type adapter after we used nullSafe.\n",
      "diff": "@@ -1,22 +1,22 @@\n-public TypeAdapter\u003cT\u003e nullSafe() {\n+public final TypeAdapter\u003cT\u003e nullSafe() {\n     return new TypeAdapter\u003cT\u003e() {\n \n         @Override\n         public void write(JsonWriter out, T value) throws IOException {\n             if (value \u003d\u003d null) {\n                 out.nullValue();\n             } else {\n                 TypeAdapter.this.write(out, value);\n             }\n         }\n \n         @Override\n         public T read(JsonReader reader) throws IOException {\n             if (reader.peek() \u003d\u003d JsonToken.NULL) {\n                 reader.nextNull();\n                 return null;\n             }\n             return TypeAdapter.this.read(reader);\n         }\n     };\n }\n\\ No newline at end of file\n",
      "extendedDetails": {
        "oldValue": "[public]",
        "newValue": "[public, final]"
      }
    },
    "2ef7716209043289880d5f1d5bbb9a658b93f2da": {
      "type": "Ydocchange",
      "commitMessage": "Fix a broken Javadoc link to this.\n",
      "commitDate": "12/15/11, 9:38 PM",
      "commitName": "2ef7716209043289880d5f1d5bbb9a658b93f2da",
      "commitAuthor": "Jesse Wilson",
      "commitDateOld": "12/6/11, 7:35 AM",
      "commitNameOld": "eb2230caf0c8d1e2d9ea67e7c4afce72f1eccc3f",
      "commitAuthorOld": "Jesse Wilson",
      "daysBetweenCommits": 9.59,
      "commitsBetweenForRepo": 12,
      "commitsBetweenForFile": 1,
      "actualSource": "public TypeAdapter\u003cT\u003e nullSafe() {\n    return new TypeAdapter\u003cT\u003e() {\n\n        @Override\n        public void write(JsonWriter out, T value) throws IOException {\n            if (value \u003d\u003d null) {\n                out.nullValue();\n            } else {\n                TypeAdapter.this.write(out, value);\n            }\n        }\n\n        @Override\n        public T read(JsonReader reader) throws IOException {\n            if (reader.peek() \u003d\u003d JsonToken.NULL) {\n                reader.nextNull();\n                return null;\n            }\n            return TypeAdapter.this.read(reader);\n        }\n    };\n}",
      "path": "gson/src/main/java/com/google/gson/TypeAdapter.java",
      "functionStartLine": 184,
      "functionName": "nullSafe",
      "functionAnnotation": "",
      "functionDoc": "This wrapper method is used to make a type adapter null tolerant. In general, a\ntype adapter is required to handle nulls in write and read methods. Here is how this\nis typically done:\u003cbr\u003e\n\u003cpre\u003e   {@code\n\nGson gson \u003d new GsonBuilder().registerTypeAdapter(Foo.class,\n  new TypeAdapter\u003cFoo\u003e() {\n    public Foo read(JsonReader in) throws IOException {\n      if (in.peek() \u003d\u003d JsonToken.NULL) {\n        in.nextNull();\n        return null;\n      }\n      // read a Foo from in and return it\n    }\n    public void write(JsonWriter out, Foo src) throws IOException {\n      if (src \u003d\u003d null) {\n        out.nullValue();\n        return;\n      }\n      // write src as JSON to out\n    }\n  }).create();\n}\u003c/pre\u003e\nYou can avoid this boilerplate handling of nulls by wrapping your type adapter with\nthis method. Here is how we will rewrite the above example:\n\u003cpre\u003e   {@code\n\nGson gson \u003d new GsonBuilder().registerTypeAdapter(Foo.class,\n  new TypeAdapter\u003cFoo\u003e() {\n    public Foo read(JsonReader in) throws IOException {\n      // read a Foo from in and return it\n    }\n    public void write(JsonWriter out, Foo src) throws IOException {\n      // write src as JSON to out\n    }\n  }.nullSafe()).create();\n}\u003c/pre\u003e\nNote that we didn\u0027t need to check for nulls in our type adapter after we used nullSafe.\n",
      "diff": "",
      "extendedDetails": {
        "oldValue": "This wrapper method is used to make a type adapter null tolerant. In general, a\ntype adapter is required to handle nulls in write and read methods. Here is how this\nis typically done:\u003cbr\u003e\n\u003cpre\u003e   {@code\n\nGson gson \u003d new GsonBuilder().registerTypeAdapter(Foo.class,\n  new TypeAdapter\u003cFoo\u003e() {\n    public Foo read(JsonReader in) throws IOException {\n      if (in.peek() \u003d\u003d JsonToken.NULL) {\n        in.nextNull();\n        return null;\n      }\n      // read a Foo from in and return it\n    }\n    public void write(JsonWriter out, Foo src) throws IOException {\n      if (src \u003d\u003d null) {\n        out.nullValue();\n        return;\n      }\n      // write src as JSON to out\n    }\n  }).create();\n}\u003c/pre\u003e\nYou can avoid this boilerplate handling of nulls by wrapping your type adapter with\n{@link #nullSafe(TypeAdapter)} method. Here is how we will rewrite the above example:\n\u003cpre\u003e   {@code\n\nGson gson \u003d new GsonBuilder().registerTypeAdapter(Foo.class,\n  new TypeAdapter\u003cFoo\u003e() {\n    public Foo read(JsonReader in) throws IOException {\n      // read a Foo from in and return it\n    }\n    public void write(JsonWriter out, Foo src) throws IOException {\n      // write src as JSON to out\n    }\n  }.nullSafe()).create();\n}\u003c/pre\u003e\nNote that we didn\u0027t need to check for nulls in our type adapter after we used nullSafe.\n",
        "newValue": "This wrapper method is used to make a type adapter null tolerant. In general, a\ntype adapter is required to handle nulls in write and read methods. Here is how this\nis typically done:\u003cbr\u003e\n\u003cpre\u003e   {@code\n\nGson gson \u003d new GsonBuilder().registerTypeAdapter(Foo.class,\n  new TypeAdapter\u003cFoo\u003e() {\n    public Foo read(JsonReader in) throws IOException {\n      if (in.peek() \u003d\u003d JsonToken.NULL) {\n        in.nextNull();\n        return null;\n      }\n      // read a Foo from in and return it\n    }\n    public void write(JsonWriter out, Foo src) throws IOException {\n      if (src \u003d\u003d null) {\n        out.nullValue();\n        return;\n      }\n      // write src as JSON to out\n    }\n  }).create();\n}\u003c/pre\u003e\nYou can avoid this boilerplate handling of nulls by wrapping your type adapter with\nthis method. Here is how we will rewrite the above example:\n\u003cpre\u003e   {@code\n\nGson gson \u003d new GsonBuilder().registerTypeAdapter(Foo.class,\n  new TypeAdapter\u003cFoo\u003e() {\n    public Foo read(JsonReader in) throws IOException {\n      // read a Foo from in and return it\n    }\n    public void write(JsonWriter out, Foo src) throws IOException {\n      // write src as JSON to out\n    }\n  }.nullSafe()).create();\n}\u003c/pre\u003e\nNote that we didn\u0027t need to check for nulls in our type adapter after we used nullSafe.\n"
      }
    },
    "eb2230caf0c8d1e2d9ea67e7c4afce72f1eccc3f": {
      "type": "Ybodychange",
      "commitMessage": "Fix nullSafe() to not infinitely recurse on non-null input.\n",
      "commitDate": "12/6/11, 7:35 AM",
      "commitName": "eb2230caf0c8d1e2d9ea67e7c4afce72f1eccc3f",
      "commitAuthor": "Jesse Wilson",
      "commitDateOld": "12/6/11, 12:32 AM",
      "commitNameOld": "b19e187bdda7765f008e0fcdcb4fd184bdd87e00",
      "commitAuthorOld": "Inderjeet Singh",
      "daysBetweenCommits": 0.29,
      "commitsBetweenForRepo": 2,
      "commitsBetweenForFile": 1,
      "actualSource": "public TypeAdapter\u003cT\u003e nullSafe() {\n    return new TypeAdapter\u003cT\u003e() {\n\n        @Override\n        public void write(JsonWriter out, T value) throws IOException {\n            if (value \u003d\u003d null) {\n                out.nullValue();\n            } else {\n                TypeAdapter.this.write(out, value);\n            }\n        }\n\n        @Override\n        public T read(JsonReader reader) throws IOException {\n            if (reader.peek() \u003d\u003d JsonToken.NULL) {\n                reader.nextNull();\n                return null;\n            }\n            return TypeAdapter.this.read(reader);\n        }\n    };\n}",
      "path": "gson/src/main/java/com/google/gson/TypeAdapter.java",
      "functionStartLine": 184,
      "functionName": "nullSafe",
      "functionAnnotation": "",
      "functionDoc": "This wrapper method is used to make a type adapter null tolerant. In general, a\ntype adapter is required to handle nulls in write and read methods. Here is how this\nis typically done:\u003cbr\u003e\n\u003cpre\u003e   {@code\n\nGson gson \u003d new GsonBuilder().registerTypeAdapter(Foo.class,\n  new TypeAdapter\u003cFoo\u003e() {\n    public Foo read(JsonReader in) throws IOException {\n      if (in.peek() \u003d\u003d JsonToken.NULL) {\n        in.nextNull();\n        return null;\n      }\n      // read a Foo from in and return it\n    }\n    public void write(JsonWriter out, Foo src) throws IOException {\n      if (src \u003d\u003d null) {\n        out.nullValue();\n        return;\n      }\n      // write src as JSON to out\n    }\n  }).create();\n}\u003c/pre\u003e\nYou can avoid this boilerplate handling of nulls by wrapping your type adapter with\n{@link #nullSafe(TypeAdapter)} method. Here is how we will rewrite the above example:\n\u003cpre\u003e   {@code\n\nGson gson \u003d new GsonBuilder().registerTypeAdapter(Foo.class,\n  new TypeAdapter\u003cFoo\u003e() {\n    public Foo read(JsonReader in) throws IOException {\n      // read a Foo from in and return it\n    }\n    public void write(JsonWriter out, Foo src) throws IOException {\n      // write src as JSON to out\n    }\n  }.nullSafe()).create();\n}\u003c/pre\u003e\nNote that we didn\u0027t need to check for nulls in our type adapter after we used nullSafe.\n",
      "diff": "@@ -1,22 +1,22 @@\n public TypeAdapter\u003cT\u003e nullSafe() {\n     return new TypeAdapter\u003cT\u003e() {\n \n         @Override\n         public void write(JsonWriter out, T value) throws IOException {\n             if (value \u003d\u003d null) {\n                 out.nullValue();\n             } else {\n-                write(out, value);\n+                TypeAdapter.this.write(out, value);\n             }\n         }\n \n         @Override\n         public T read(JsonReader reader) throws IOException {\n             if (reader.peek() \u003d\u003d JsonToken.NULL) {\n                 reader.nextNull();\n                 return null;\n             }\n-            return read(reader);\n+            return TypeAdapter.this.read(reader);\n         }\n     };\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "0b734e46e180a452e4bff45878ac60441be6ff74": {
      "type": "Ymultichange(Yparameterchange,Ymodifierchange,Ybodychange,Ydocchange)",
      "commitMessage": "Incorporated code review comments from r1061. \nMade nullSafe() an instance method instead of a static method.\nUpdated code javadoc to match Guava style. \n",
      "commitDate": "12/6/11, 12:18 AM",
      "commitName": "0b734e46e180a452e4bff45878ac60441be6ff74",
      "commitAuthor": "Inderjeet Singh",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "Incorporated code review comments from r1061. \nMade nullSafe() an instance method instead of a static method.\nUpdated code javadoc to match Guava style. \n",
          "commitDate": "12/6/11, 12:18 AM",
          "commitName": "0b734e46e180a452e4bff45878ac60441be6ff74",
          "commitAuthor": "Inderjeet Singh",
          "commitDateOld": "12/5/11, 8:56 PM",
          "commitNameOld": "296d843afd575a75d7959474aad76ac05afa0706",
          "commitAuthorOld": "Jesse Wilson",
          "daysBetweenCommits": 0.14,
          "commitsBetweenForRepo": 2,
          "commitsBetweenForFile": 1,
          "actualSource": "public TypeAdapter\u003cT\u003e nullSafe() {\n    return new TypeAdapter\u003cT\u003e() {\n\n        @Override\n        public void write(JsonWriter out, T value) throws IOException {\n            if (value \u003d\u003d null) {\n                out.nullValue();\n            } else {\n                write(out, value);\n            }\n        }\n\n        @Override\n        public T read(JsonReader reader) throws IOException {\n            if (reader.peek() \u003d\u003d JsonToken.NULL) {\n                reader.nextNull();\n                return null;\n            }\n            return read(reader);\n        }\n    };\n}",
          "path": "gson/src/main/java/com/google/gson/TypeAdapter.java",
          "functionStartLine": 180,
          "functionName": "nullSafe",
          "functionAnnotation": "",
          "functionDoc": "This wrapper method is used to make a type adapter null tolerant. In general, a\ntype adapter is required to handle nulls in write and read methods. Here is how this\nis typically done:\u003cbr\u003e\n\u003cpre\u003e   {@code\n\nGson gson \u003d new GsonBuilder().registerTypeAdapter(Foo.class,\n  new TypeAdapter\u003cFoo\u003e() {\n    public Foo read(JsonReader in) throws IOException {\n      if (in.peek() \u003d\u003d JsonToken.NULL) {\n        in.nextNull();\n        return null;\n      }\n      // read a Foo from in and return it\n    }\n    public void write(JsonWriter out, Foo src) throws IOException {\n      if (src \u003d\u003d null) {\n        out.nullValue();\n        return;\n      }\n      // write src as JSON to out\n    }\n  }).create();\n}\u003c/pre\u003e\nYou can avoid this boilerplate handling of nulls by wrapping your type adapter with\n{@link #nullSafe(TypeAdapter)} method. Here is how we will rewrite the above example:\n\u003cpre\u003e   {@code\n\nGson gson \u003d new GsonBuilder().registerTypeAdapter(Foo.class,\n  new TypeAdapter\u003cFoo\u003e() {\n    public Foo read(JsonReader in) throws IOException {\n      // read a Foo from in and return it\n    }\n    public void write(JsonWriter out, Foo src) throws IOException {\n      // write src as JSON to out\n    }\n  }.nullSafe()).create();\n}\u003c/pre\u003e\nNote that we didn\u0027t need to check for nulls in our type adapter after we used nullSafe.\n",
          "diff": "@@ -1,22 +1,22 @@\n-public static \u003cT\u003e TypeAdapter\u003cT\u003e nullSafe(final TypeAdapter\u003cT\u003e typeAdapter) {\n+public TypeAdapter\u003cT\u003e nullSafe() {\n     return new TypeAdapter\u003cT\u003e() {\n \n         @Override\n         public void write(JsonWriter out, T value) throws IOException {\n             if (value \u003d\u003d null) {\n                 out.nullValue();\n             } else {\n-                typeAdapter.write(out, value);\n+                write(out, value);\n             }\n         }\n \n         @Override\n         public T read(JsonReader reader) throws IOException {\n             if (reader.peek() \u003d\u003d JsonToken.NULL) {\n                 reader.nextNull();\n                 return null;\n             }\n-            return typeAdapter.read(reader);\n+            return read(reader);\n         }\n     };\n }\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldValue": "[typeAdapter-TypeAdapter\u003cT\u003e(modifiers-final)]",
            "newValue": "[]"
          }
        },
        {
          "type": "Ymodifierchange",
          "commitMessage": "Incorporated code review comments from r1061. \nMade nullSafe() an instance method instead of a static method.\nUpdated code javadoc to match Guava style. \n",
          "commitDate": "12/6/11, 12:18 AM",
          "commitName": "0b734e46e180a452e4bff45878ac60441be6ff74",
          "commitAuthor": "Inderjeet Singh",
          "commitDateOld": "12/5/11, 8:56 PM",
          "commitNameOld": "296d843afd575a75d7959474aad76ac05afa0706",
          "commitAuthorOld": "Jesse Wilson",
          "daysBetweenCommits": 0.14,
          "commitsBetweenForRepo": 2,
          "commitsBetweenForFile": 1,
          "actualSource": "public TypeAdapter\u003cT\u003e nullSafe() {\n    return new TypeAdapter\u003cT\u003e() {\n\n        @Override\n        public void write(JsonWriter out, T value) throws IOException {\n            if (value \u003d\u003d null) {\n                out.nullValue();\n            } else {\n                write(out, value);\n            }\n        }\n\n        @Override\n        public T read(JsonReader reader) throws IOException {\n            if (reader.peek() \u003d\u003d JsonToken.NULL) {\n                reader.nextNull();\n                return null;\n            }\n            return read(reader);\n        }\n    };\n}",
          "path": "gson/src/main/java/com/google/gson/TypeAdapter.java",
          "functionStartLine": 180,
          "functionName": "nullSafe",
          "functionAnnotation": "",
          "functionDoc": "This wrapper method is used to make a type adapter null tolerant. In general, a\ntype adapter is required to handle nulls in write and read methods. Here is how this\nis typically done:\u003cbr\u003e\n\u003cpre\u003e   {@code\n\nGson gson \u003d new GsonBuilder().registerTypeAdapter(Foo.class,\n  new TypeAdapter\u003cFoo\u003e() {\n    public Foo read(JsonReader in) throws IOException {\n      if (in.peek() \u003d\u003d JsonToken.NULL) {\n        in.nextNull();\n        return null;\n      }\n      // read a Foo from in and return it\n    }\n    public void write(JsonWriter out, Foo src) throws IOException {\n      if (src \u003d\u003d null) {\n        out.nullValue();\n        return;\n      }\n      // write src as JSON to out\n    }\n  }).create();\n}\u003c/pre\u003e\nYou can avoid this boilerplate handling of nulls by wrapping your type adapter with\n{@link #nullSafe(TypeAdapter)} method. Here is how we will rewrite the above example:\n\u003cpre\u003e   {@code\n\nGson gson \u003d new GsonBuilder().registerTypeAdapter(Foo.class,\n  new TypeAdapter\u003cFoo\u003e() {\n    public Foo read(JsonReader in) throws IOException {\n      // read a Foo from in and return it\n    }\n    public void write(JsonWriter out, Foo src) throws IOException {\n      // write src as JSON to out\n    }\n  }.nullSafe()).create();\n}\u003c/pre\u003e\nNote that we didn\u0027t need to check for nulls in our type adapter after we used nullSafe.\n",
          "diff": "@@ -1,22 +1,22 @@\n-public static \u003cT\u003e TypeAdapter\u003cT\u003e nullSafe(final TypeAdapter\u003cT\u003e typeAdapter) {\n+public TypeAdapter\u003cT\u003e nullSafe() {\n     return new TypeAdapter\u003cT\u003e() {\n \n         @Override\n         public void write(JsonWriter out, T value) throws IOException {\n             if (value \u003d\u003d null) {\n                 out.nullValue();\n             } else {\n-                typeAdapter.write(out, value);\n+                write(out, value);\n             }\n         }\n \n         @Override\n         public T read(JsonReader reader) throws IOException {\n             if (reader.peek() \u003d\u003d JsonToken.NULL) {\n                 reader.nextNull();\n                 return null;\n             }\n-            return typeAdapter.read(reader);\n+            return read(reader);\n         }\n     };\n }\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldValue": "[public, static]",
            "newValue": "[public]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "Incorporated code review comments from r1061. \nMade nullSafe() an instance method instead of a static method.\nUpdated code javadoc to match Guava style. \n",
          "commitDate": "12/6/11, 12:18 AM",
          "commitName": "0b734e46e180a452e4bff45878ac60441be6ff74",
          "commitAuthor": "Inderjeet Singh",
          "commitDateOld": "12/5/11, 8:56 PM",
          "commitNameOld": "296d843afd575a75d7959474aad76ac05afa0706",
          "commitAuthorOld": "Jesse Wilson",
          "daysBetweenCommits": 0.14,
          "commitsBetweenForRepo": 2,
          "commitsBetweenForFile": 1,
          "actualSource": "public TypeAdapter\u003cT\u003e nullSafe() {\n    return new TypeAdapter\u003cT\u003e() {\n\n        @Override\n        public void write(JsonWriter out, T value) throws IOException {\n            if (value \u003d\u003d null) {\n                out.nullValue();\n            } else {\n                write(out, value);\n            }\n        }\n\n        @Override\n        public T read(JsonReader reader) throws IOException {\n            if (reader.peek() \u003d\u003d JsonToken.NULL) {\n                reader.nextNull();\n                return null;\n            }\n            return read(reader);\n        }\n    };\n}",
          "path": "gson/src/main/java/com/google/gson/TypeAdapter.java",
          "functionStartLine": 180,
          "functionName": "nullSafe",
          "functionAnnotation": "",
          "functionDoc": "This wrapper method is used to make a type adapter null tolerant. In general, a\ntype adapter is required to handle nulls in write and read methods. Here is how this\nis typically done:\u003cbr\u003e\n\u003cpre\u003e   {@code\n\nGson gson \u003d new GsonBuilder().registerTypeAdapter(Foo.class,\n  new TypeAdapter\u003cFoo\u003e() {\n    public Foo read(JsonReader in) throws IOException {\n      if (in.peek() \u003d\u003d JsonToken.NULL) {\n        in.nextNull();\n        return null;\n      }\n      // read a Foo from in and return it\n    }\n    public void write(JsonWriter out, Foo src) throws IOException {\n      if (src \u003d\u003d null) {\n        out.nullValue();\n        return;\n      }\n      // write src as JSON to out\n    }\n  }).create();\n}\u003c/pre\u003e\nYou can avoid this boilerplate handling of nulls by wrapping your type adapter with\n{@link #nullSafe(TypeAdapter)} method. Here is how we will rewrite the above example:\n\u003cpre\u003e   {@code\n\nGson gson \u003d new GsonBuilder().registerTypeAdapter(Foo.class,\n  new TypeAdapter\u003cFoo\u003e() {\n    public Foo read(JsonReader in) throws IOException {\n      // read a Foo from in and return it\n    }\n    public void write(JsonWriter out, Foo src) throws IOException {\n      // write src as JSON to out\n    }\n  }.nullSafe()).create();\n}\u003c/pre\u003e\nNote that we didn\u0027t need to check for nulls in our type adapter after we used nullSafe.\n",
          "diff": "@@ -1,22 +1,22 @@\n-public static \u003cT\u003e TypeAdapter\u003cT\u003e nullSafe(final TypeAdapter\u003cT\u003e typeAdapter) {\n+public TypeAdapter\u003cT\u003e nullSafe() {\n     return new TypeAdapter\u003cT\u003e() {\n \n         @Override\n         public void write(JsonWriter out, T value) throws IOException {\n             if (value \u003d\u003d null) {\n                 out.nullValue();\n             } else {\n-                typeAdapter.write(out, value);\n+                write(out, value);\n             }\n         }\n \n         @Override\n         public T read(JsonReader reader) throws IOException {\n             if (reader.peek() \u003d\u003d JsonToken.NULL) {\n                 reader.nextNull();\n                 return null;\n             }\n-            return typeAdapter.read(reader);\n+            return read(reader);\n         }\n     };\n }\n\\ No newline at end of file\n",
          "extendedDetails": {}
        },
        {
          "type": "Ydocchange",
          "commitMessage": "Incorporated code review comments from r1061. \nMade nullSafe() an instance method instead of a static method.\nUpdated code javadoc to match Guava style. \n",
          "commitDate": "12/6/11, 12:18 AM",
          "commitName": "0b734e46e180a452e4bff45878ac60441be6ff74",
          "commitAuthor": "Inderjeet Singh",
          "commitDateOld": "12/5/11, 8:56 PM",
          "commitNameOld": "296d843afd575a75d7959474aad76ac05afa0706",
          "commitAuthorOld": "Jesse Wilson",
          "daysBetweenCommits": 0.14,
          "commitsBetweenForRepo": 2,
          "commitsBetweenForFile": 1,
          "actualSource": "public TypeAdapter\u003cT\u003e nullSafe() {\n    return new TypeAdapter\u003cT\u003e() {\n\n        @Override\n        public void write(JsonWriter out, T value) throws IOException {\n            if (value \u003d\u003d null) {\n                out.nullValue();\n            } else {\n                write(out, value);\n            }\n        }\n\n        @Override\n        public T read(JsonReader reader) throws IOException {\n            if (reader.peek() \u003d\u003d JsonToken.NULL) {\n                reader.nextNull();\n                return null;\n            }\n            return read(reader);\n        }\n    };\n}",
          "path": "gson/src/main/java/com/google/gson/TypeAdapter.java",
          "functionStartLine": 180,
          "functionName": "nullSafe",
          "functionAnnotation": "",
          "functionDoc": "This wrapper method is used to make a type adapter null tolerant. In general, a\ntype adapter is required to handle nulls in write and read methods. Here is how this\nis typically done:\u003cbr\u003e\n\u003cpre\u003e   {@code\n\nGson gson \u003d new GsonBuilder().registerTypeAdapter(Foo.class,\n  new TypeAdapter\u003cFoo\u003e() {\n    public Foo read(JsonReader in) throws IOException {\n      if (in.peek() \u003d\u003d JsonToken.NULL) {\n        in.nextNull();\n        return null;\n      }\n      // read a Foo from in and return it\n    }\n    public void write(JsonWriter out, Foo src) throws IOException {\n      if (src \u003d\u003d null) {\n        out.nullValue();\n        return;\n      }\n      // write src as JSON to out\n    }\n  }).create();\n}\u003c/pre\u003e\nYou can avoid this boilerplate handling of nulls by wrapping your type adapter with\n{@link #nullSafe(TypeAdapter)} method. Here is how we will rewrite the above example:\n\u003cpre\u003e   {@code\n\nGson gson \u003d new GsonBuilder().registerTypeAdapter(Foo.class,\n  new TypeAdapter\u003cFoo\u003e() {\n    public Foo read(JsonReader in) throws IOException {\n      // read a Foo from in and return it\n    }\n    public void write(JsonWriter out, Foo src) throws IOException {\n      // write src as JSON to out\n    }\n  }.nullSafe()).create();\n}\u003c/pre\u003e\nNote that we didn\u0027t need to check for nulls in our type adapter after we used nullSafe.\n",
          "diff": "@@ -1,22 +1,22 @@\n-public static \u003cT\u003e TypeAdapter\u003cT\u003e nullSafe(final TypeAdapter\u003cT\u003e typeAdapter) {\n+public TypeAdapter\u003cT\u003e nullSafe() {\n     return new TypeAdapter\u003cT\u003e() {\n \n         @Override\n         public void write(JsonWriter out, T value) throws IOException {\n             if (value \u003d\u003d null) {\n                 out.nullValue();\n             } else {\n-                typeAdapter.write(out, value);\n+                write(out, value);\n             }\n         }\n \n         @Override\n         public T read(JsonReader reader) throws IOException {\n             if (reader.peek() \u003d\u003d JsonToken.NULL) {\n                 reader.nextNull();\n                 return null;\n             }\n-            return typeAdapter.read(reader);\n+            return read(reader);\n         }\n     };\n }\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldValue": "This wrapper method is used to make a type adapter null tolerant. In general, a\ntype adapter is required to handle nulls in write and read methods. Here is how this\nis typically done:\u003cbr\u003e\n\u003cpre\u003e{@code\n   Gson gson \u003d new GsonBuilder().registerTypeAdapter(Foo.class,\n    new TypeAdapter\u003cFoo\u003e() {\n      public Foo read(JsonReader in) throws IOException {\n        if (in.peek() \u003d\u003d JsonToken.NULL) {\n          in.nextNull();\n          return null;\n        }\n        // read a Foo from in and return it\n      }\n      public void write(JsonWriter out, Foo src) throws IOException {\n        if (src \u003d\u003d null) {\n          out.nullValue();\n          return;\n        }\n        // write src as JSON to out\n      }\n    ).create();\n}\u003c/pre\u003e\nYou can avoid this boilerplate handling of nulls by wrapping your type adapter with\n{@link #nullSafe(TypeAdapter)} method. Here is how we will rewrite the above example:\n\u003cpre\u003e{@code\n   Gson gson \u003d new GsonBuilder().registerTypeAdapter(Foo.class,\n    TypeAdapter.nullSafe(new TypeAdapter\u003cFoo\u003e() {\n      public Foo read(JsonReader in) throws IOException {\n        // read a Foo from in and return it\n      }\n      public void write(JsonWriter out, Foo src) throws IOException {\n        // write src as JSON to out\n      }\n    )).create();\n}\u003c/pre\u003e\nNote that we didn\u0027t need to check for nulls in our type adapter after we used nullSafe.\n",
            "newValue": "This wrapper method is used to make a type adapter null tolerant. In general, a\ntype adapter is required to handle nulls in write and read methods. Here is how this\nis typically done:\u003cbr\u003e\n\u003cpre\u003e   {@code\n\nGson gson \u003d new GsonBuilder().registerTypeAdapter(Foo.class,\n  new TypeAdapter\u003cFoo\u003e() {\n    public Foo read(JsonReader in) throws IOException {\n      if (in.peek() \u003d\u003d JsonToken.NULL) {\n        in.nextNull();\n        return null;\n      }\n      // read a Foo from in and return it\n    }\n    public void write(JsonWriter out, Foo src) throws IOException {\n      if (src \u003d\u003d null) {\n        out.nullValue();\n        return;\n      }\n      // write src as JSON to out\n    }\n  }).create();\n}\u003c/pre\u003e\nYou can avoid this boilerplate handling of nulls by wrapping your type adapter with\n{@link #nullSafe(TypeAdapter)} method. Here is how we will rewrite the above example:\n\u003cpre\u003e   {@code\n\nGson gson \u003d new GsonBuilder().registerTypeAdapter(Foo.class,\n  new TypeAdapter\u003cFoo\u003e() {\n    public Foo read(JsonReader in) throws IOException {\n      // read a Foo from in and return it\n    }\n    public void write(JsonWriter out, Foo src) throws IOException {\n      // write src as JSON to out\n    }\n  }.nullSafe()).create();\n}\u003c/pre\u003e\nNote that we didn\u0027t need to check for nulls in our type adapter after we used nullSafe.\n"
          }
        }
      ]
    },
    "91be944022883646433237e4c1001747fa0ba955": {
      "type": "Yintroduced",
      "commitMessage": "Added a new API method nullSafe() in TypeAdapter that can be used to avoid boilerplate handling of nulls in a type adapter.\n",
      "commitDate": "12/5/11, 11:50 AM",
      "commitName": "91be944022883646433237e4c1001747fa0ba955",
      "commitAuthor": "Inderjeet Singh",
      "diff": "@@ -0,0 +1,22 @@\n+public static \u003cT\u003e TypeAdapter\u003cT\u003e nullSafe(final TypeAdapter\u003cT\u003e typeAdapter) {\n+    return new TypeAdapter\u003cT\u003e() {\n+\n+        @Override\n+        public void write(JsonWriter out, T value) throws IOException {\n+            if (value \u003d\u003d null) {\n+                out.nullValue();\n+            } else {\n+                typeAdapter.write(out, value);\n+            }\n+        }\n+\n+        @Override\n+        public T read(JsonReader reader) throws IOException {\n+            if (reader.peek() \u003d\u003d JsonToken.NULL) {\n+                reader.nextNull();\n+                return null;\n+            }\n+            return typeAdapter.read(reader);\n+        }\n+    };\n+}\n\\ No newline at end of file\n",
      "actualSource": "public static \u003cT\u003e TypeAdapter\u003cT\u003e nullSafe(final TypeAdapter\u003cT\u003e typeAdapter) {\n    return new TypeAdapter\u003cT\u003e() {\n\n        @Override\n        public void write(JsonWriter out, T value) throws IOException {\n            if (value \u003d\u003d null) {\n                out.nullValue();\n            } else {\n                typeAdapter.write(out, value);\n            }\n        }\n\n        @Override\n        public T read(JsonReader reader) throws IOException {\n            if (reader.peek() \u003d\u003d JsonToken.NULL) {\n                reader.nextNull();\n                return null;\n            }\n            return typeAdapter.read(reader);\n        }\n    };\n}",
      "path": "gson/src/main/java/com/google/gson/TypeAdapter.java",
      "functionStartLine": 178,
      "functionName": "nullSafe",
      "functionAnnotation": "",
      "functionDoc": "This wrapper method is used to make a type adapter null tolerant. In general, a\ntype adapter is required to handle nulls in write and read methods. Here is how this\nis typically done:\u003cbr\u003e\n\u003cpre\u003e{@code\n   Gson gson \u003d new GsonBuilder().registerTypeAdapter(Foo.class,\n    new TypeAdapter\u003cFoo\u003e() {\n      public Foo read(JsonReader in) throws IOException {\n        if (in.peek() \u003d\u003d JsonToken.NULL) {\n          in.nextNull();\n          return null;\n        }\n        // read a Foo from in and return it\n      }\n      public void write(JsonWriter out, Foo src) throws IOException {\n        if (src \u003d\u003d null) {\n          out.nullValue();\n          return;\n        }\n        // write src as JSON to out\n      }\n    ).create();\n}\u003c/pre\u003e\nYou can avoid this boilerplate handling of nulls by wrapping your type adapter with\n{@link #nullSafe(TypeAdapter)} method. Here is how we will rewrite the above example:\n\u003cpre\u003e{@code\n   Gson gson \u003d new GsonBuilder().registerTypeAdapter(Foo.class,\n    TypeAdapter.nullSafe(new TypeAdapter\u003cFoo\u003e() {\n      public Foo read(JsonReader in) throws IOException {\n        // read a Foo from in and return it\n      }\n      public void write(JsonWriter out, Foo src) throws IOException {\n        // write src as JSON to out\n      }\n    )).create();\n}\u003c/pre\u003e\nNote that we didn\u0027t need to check for nulls in our type adapter after we used nullSafe.\n"
    }
  }
}