{
  "origin": "codeshovel",
  "repositoryName": "Gson-10b",
  "repositoryPath": "/tmp/Gson-10b//.git",
  "startCommitName": "HEAD",
  "sourceFileName": "ConstructorConstructor.java",
  "functionName": "get",
  "functionId": "get___typeToken-TypeToken__T__",
  "sourceFilePath": "gson/src/main/java/com/google/gson/internal/ConstructorConstructor.java",
  "functionAnnotation": "",
  "functionDoc": "",
  "functionStartLine": 55,
  "functionEndLine": 95,
  "numCommitsSeen": 24,
  "timeTaken": 1705,
  "changeHistory": [
    "fef43b2aaa4fd7cb8f0dff395980c69f614635af",
    "040bae34d701172375e5aaef7492a5782933d46d",
    "1a4f690335ae1129620079c4b5587a7261206c12",
    "6cca23c172612aded9ee2996a5177cb7b9a84390",
    "1794182a560588973c6ec131e9c24bd39508433d",
    "d391584d48ce87a36c88e804711a5f187e0b9086",
    "4a6c084ef73e5e8a3fca12f9bb829a218fad7a84",
    "25c6ae177b1ca56db7f3c29eb574bdd032a06165"
  ],
  "changeHistoryShort": {
    "fef43b2aaa4fd7cb8f0dff395980c69f614635af": "Ybodychange",
    "040bae34d701172375e5aaef7492a5782933d46d": "Ybodychange",
    "1a4f690335ae1129620079c4b5587a7261206c12": "Ybodychange",
    "6cca23c172612aded9ee2996a5177cb7b9a84390": "Yrename",
    "1794182a560588973c6ec131e9c24bd39508433d": "Ybodychange",
    "d391584d48ce87a36c88e804711a5f187e0b9086": "Ybodychange",
    "4a6c084ef73e5e8a3fca12f9bb829a218fad7a84": "Ybodychange",
    "25c6ae177b1ca56db7f3c29eb574bdd032a06165": "Yintroduced"
  },
  "changeHistoryDetails": {
    "fef43b2aaa4fd7cb8f0dff395980c69f614635af": {
      "type": "Ybodychange",
      "commitMessage": "Added support to serialize/deserialize ConcurrentMap and ConcurrentNavigableMap.\n",
      "commitDate": "11/4/15, 9:25 PM",
      "commitName": "fef43b2aaa4fd7cb8f0dff395980c69f614635af",
      "commitAuthor": "Inderjeet Singh",
      "commitDateOld": "9/27/15, 3:31 AM",
      "commitNameOld": "2ecce944948e63f703e10cd34f4e2f410a7f3921",
      "commitAuthorOld": "dushyant",
      "daysBetweenCommits": 38.79,
      "commitsBetweenForRepo": 25,
      "commitsBetweenForFile": 1,
      "actualSource": "public \u003cT\u003e ObjectConstructor\u003cT\u003e get(TypeToken\u003cT\u003e typeToken) {\n    final Type type \u003d typeToken.getType();\n    final Class\u003c? super T\u003e rawType \u003d typeToken.getRawType();\n    @SuppressWarnings(\"unchecked\") final InstanceCreator\u003cT\u003e typeCreator \u003d (InstanceCreator\u003cT\u003e) instanceCreators.get(type);\n    if (typeCreator !\u003d null) {\n        return new ObjectConstructor\u003cT\u003e() {\n\n            @Override\n            public T construct() {\n                return typeCreator.createInstance(type);\n            }\n        };\n    }\n    @SuppressWarnings(\"unchecked\") final InstanceCreator\u003cT\u003e rawTypeCreator \u003d (InstanceCreator\u003cT\u003e) instanceCreators.get(rawType);\n    if (rawTypeCreator !\u003d null) {\n        return new ObjectConstructor\u003cT\u003e() {\n\n            @Override\n            public T construct() {\n                return rawTypeCreator.createInstance(type);\n            }\n        };\n    }\n    ObjectConstructor\u003cT\u003e defaultConstructor \u003d newDefaultConstructor(rawType);\n    if (defaultConstructor !\u003d null) {\n        return defaultConstructor;\n    }\n    ObjectConstructor\u003cT\u003e defaultImplementation \u003d newDefaultImplementationConstructor(type, rawType);\n    if (defaultImplementation !\u003d null) {\n        return defaultImplementation;\n    }\n    return newUnsafeAllocator(type, rawType);\n}",
      "path": "gson/src/main/java/com/google/gson/internal/ConstructorConstructor.java",
      "functionStartLine": 55,
      "functionName": "get",
      "functionAnnotation": "",
      "functionDoc": "",
      "diff": "@@ -1,31 +1,33 @@\n public \u003cT\u003e ObjectConstructor\u003cT\u003e get(TypeToken\u003cT\u003e typeToken) {\n     final Type type \u003d typeToken.getType();\n     final Class\u003c? super T\u003e rawType \u003d typeToken.getRawType();\n     @SuppressWarnings(\"unchecked\") final InstanceCreator\u003cT\u003e typeCreator \u003d (InstanceCreator\u003cT\u003e) instanceCreators.get(type);\n     if (typeCreator !\u003d null) {\n         return new ObjectConstructor\u003cT\u003e() {\n \n+            @Override\n             public T construct() {\n                 return typeCreator.createInstance(type);\n             }\n         };\n     }\n     @SuppressWarnings(\"unchecked\") final InstanceCreator\u003cT\u003e rawTypeCreator \u003d (InstanceCreator\u003cT\u003e) instanceCreators.get(rawType);\n     if (rawTypeCreator !\u003d null) {\n         return new ObjectConstructor\u003cT\u003e() {\n \n+            @Override\n             public T construct() {\n                 return rawTypeCreator.createInstance(type);\n             }\n         };\n     }\n     ObjectConstructor\u003cT\u003e defaultConstructor \u003d newDefaultConstructor(rawType);\n     if (defaultConstructor !\u003d null) {\n         return defaultConstructor;\n     }\n     ObjectConstructor\u003cT\u003e defaultImplementation \u003d newDefaultImplementationConstructor(type, rawType);\n     if (defaultImplementation !\u003d null) {\n         return defaultImplementation;\n     }\n     return newUnsafeAllocator(type, rawType);\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "040bae34d701172375e5aaef7492a5782933d46d": {
      "type": "Ybodychange",
      "commitMessage": "Allowing instance creators to be registered with the raw type only (without specifying type parameters).\n",
      "commitDate": "10/24/12, 1:40 PM",
      "commitName": "040bae34d701172375e5aaef7492a5782933d46d",
      "commitAuthor": "Joel Leitch",
      "commitDateOld": "10/10/12, 8:15 PM",
      "commitNameOld": "14f16e2d0c3c60338d69a3e0f653b8b876fdc1be",
      "commitAuthorOld": "Joel Leitch",
      "daysBetweenCommits": 13.73,
      "commitsBetweenForRepo": 7,
      "commitsBetweenForFile": 1,
      "actualSource": "public \u003cT\u003e ObjectConstructor\u003cT\u003e get(TypeToken\u003cT\u003e typeToken) {\n    final Type type \u003d typeToken.getType();\n    final Class\u003c? super T\u003e rawType \u003d typeToken.getRawType();\n    @SuppressWarnings(\"unchecked\") final InstanceCreator\u003cT\u003e typeCreator \u003d (InstanceCreator\u003cT\u003e) instanceCreators.get(type);\n    if (typeCreator !\u003d null) {\n        return new ObjectConstructor\u003cT\u003e() {\n\n            public T construct() {\n                return typeCreator.createInstance(type);\n            }\n        };\n    }\n    @SuppressWarnings(\"unchecked\") final InstanceCreator\u003cT\u003e rawTypeCreator \u003d (InstanceCreator\u003cT\u003e) instanceCreators.get(rawType);\n    if (rawTypeCreator !\u003d null) {\n        return new ObjectConstructor\u003cT\u003e() {\n\n            public T construct() {\n                return rawTypeCreator.createInstance(type);\n            }\n        };\n    }\n    ObjectConstructor\u003cT\u003e defaultConstructor \u003d newDefaultConstructor(rawType);\n    if (defaultConstructor !\u003d null) {\n        return defaultConstructor;\n    }\n    ObjectConstructor\u003cT\u003e defaultImplementation \u003d newDefaultImplementationConstructor(type, rawType);\n    if (defaultImplementation !\u003d null) {\n        return defaultImplementation;\n    }\n    return newUnsafeAllocator(type, rawType);\n}",
      "path": "gson/src/main/java/com/google/gson/internal/ConstructorConstructor.java",
      "functionStartLine": 49,
      "functionName": "get",
      "functionAnnotation": "",
      "functionDoc": "",
      "diff": "@@ -1,22 +1,31 @@\n public \u003cT\u003e ObjectConstructor\u003cT\u003e get(TypeToken\u003cT\u003e typeToken) {\n     final Type type \u003d typeToken.getType();\n     final Class\u003c? super T\u003e rawType \u003d typeToken.getRawType();\n-    @SuppressWarnings(\"unchecked\") final InstanceCreator\u003cT\u003e creator \u003d (InstanceCreator\u003cT\u003e) instanceCreators.get(type);\n-    if (creator !\u003d null) {\n+    @SuppressWarnings(\"unchecked\") final InstanceCreator\u003cT\u003e typeCreator \u003d (InstanceCreator\u003cT\u003e) instanceCreators.get(type);\n+    if (typeCreator !\u003d null) {\n         return new ObjectConstructor\u003cT\u003e() {\n \n             public T construct() {\n-                return creator.createInstance(type);\n+                return typeCreator.createInstance(type);\n+            }\n+        };\n+    }\n+    @SuppressWarnings(\"unchecked\") final InstanceCreator\u003cT\u003e rawTypeCreator \u003d (InstanceCreator\u003cT\u003e) instanceCreators.get(rawType);\n+    if (rawTypeCreator !\u003d null) {\n+        return new ObjectConstructor\u003cT\u003e() {\n+\n+            public T construct() {\n+                return rawTypeCreator.createInstance(type);\n             }\n         };\n     }\n     ObjectConstructor\u003cT\u003e defaultConstructor \u003d newDefaultConstructor(rawType);\n     if (defaultConstructor !\u003d null) {\n         return defaultConstructor;\n     }\n     ObjectConstructor\u003cT\u003e defaultImplementation \u003d newDefaultImplementationConstructor(type, rawType);\n     if (defaultImplementation !\u003d null) {\n         return defaultImplementation;\n     }\n     return newUnsafeAllocator(type, rawType);\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "1a4f690335ae1129620079c4b5587a7261206c12": {
      "type": "Ybodychange",
      "commitMessage": "Regretfully enable serialization for StringMap and LazilyParsedNumber.\n\nOne of our favorite users (my employer!) is stuck in a sad situation where they need to serialize objects returned from Gson; this is a workable escape hatch.\n",
      "commitDate": "8/15/12, 7:58 AM",
      "commitName": "1a4f690335ae1129620079c4b5587a7261206c12",
      "commitAuthor": "Jesse Wilson",
      "commitDateOld": "3/11/12, 6:54 AM",
      "commitNameOld": "ad3489f557d951ebd4574d04adf4b0bb4108d05f",
      "commitAuthorOld": "Jesse Wilson",
      "daysBetweenCommits": 157.04,
      "commitsBetweenForRepo": 47,
      "commitsBetweenForFile": 1,
      "actualSource": "public \u003cT\u003e ObjectConstructor\u003cT\u003e get(TypeToken\u003cT\u003e typeToken) {\n    final Type type \u003d typeToken.getType();\n    final Class\u003c? super T\u003e rawType \u003d typeToken.getRawType();\n    @SuppressWarnings(\"unchecked\") final InstanceCreator\u003cT\u003e creator \u003d (InstanceCreator\u003cT\u003e) instanceCreators.get(type);\n    if (creator !\u003d null) {\n        return new ObjectConstructor\u003cT\u003e() {\n\n            public T construct() {\n                return creator.createInstance(type);\n            }\n        };\n    }\n    ObjectConstructor\u003cT\u003e defaultConstructor \u003d newDefaultConstructor(rawType);\n    if (defaultConstructor !\u003d null) {\n        return defaultConstructor;\n    }\n    ObjectConstructor\u003cT\u003e defaultImplementation \u003d newDefaultImplementationConstructor(type, rawType);\n    if (defaultImplementation !\u003d null) {\n        return defaultImplementation;\n    }\n    return newUnsafeAllocator(type, rawType);\n}",
      "path": "gson/src/main/java/com/google/gson/internal/ConstructorConstructor.java",
      "functionStartLine": 51,
      "functionName": "get",
      "functionAnnotation": "",
      "functionDoc": "",
      "diff": "@@ -1,22 +1,22 @@\n public \u003cT\u003e ObjectConstructor\u003cT\u003e get(TypeToken\u003cT\u003e typeToken) {\n     final Type type \u003d typeToken.getType();\n     final Class\u003c? super T\u003e rawType \u003d typeToken.getRawType();\n     @SuppressWarnings(\"unchecked\") final InstanceCreator\u003cT\u003e creator \u003d (InstanceCreator\u003cT\u003e) instanceCreators.get(type);\n     if (creator !\u003d null) {\n         return new ObjectConstructor\u003cT\u003e() {\n \n             public T construct() {\n                 return creator.createInstance(type);\n             }\n         };\n     }\n     ObjectConstructor\u003cT\u003e defaultConstructor \u003d newDefaultConstructor(rawType);\n     if (defaultConstructor !\u003d null) {\n         return defaultConstructor;\n     }\n-    ObjectConstructor\u003cT\u003e defaultImplementation \u003d newDefaultImplementationConstructor(rawType);\n+    ObjectConstructor\u003cT\u003e defaultImplementation \u003d newDefaultImplementationConstructor(type, rawType);\n     if (defaultImplementation !\u003d null) {\n         return defaultImplementation;\n     }\n     return newUnsafeAllocator(type, rawType);\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "6cca23c172612aded9ee2996a5177cb7b9a84390": {
      "type": "Yrename",
      "commitMessage": "Get GraphAdapterBuilder working for serialization and deserialization using InstanceCreators to get a sneak peek at a value under construction.\n",
      "commitDate": "1/1/12, 5:42 AM",
      "commitName": "6cca23c172612aded9ee2996a5177cb7b9a84390",
      "commitAuthor": "Jesse Wilson",
      "commitDateOld": "11/22/11, 10:16 PM",
      "commitNameOld": "1794182a560588973c6ec131e9c24bd39508433d",
      "commitAuthorOld": "Jesse Wilson",
      "daysBetweenCommits": 39.31,
      "commitsBetweenForRepo": 71,
      "commitsBetweenForFile": 1,
      "actualSource": "public \u003cT\u003e ObjectConstructor\u003cT\u003e get(TypeToken\u003cT\u003e typeToken) {\n    final Type type \u003d typeToken.getType();\n    final Class\u003c? super T\u003e rawType \u003d typeToken.getRawType();\n    @SuppressWarnings(\"unchecked\") final InstanceCreator\u003cT\u003e creator \u003d (InstanceCreator\u003cT\u003e) instanceCreators.get(type);\n    if (creator !\u003d null) {\n        return new ObjectConstructor\u003cT\u003e() {\n\n            public T construct() {\n                return creator.createInstance(type);\n            }\n        };\n    }\n    ObjectConstructor\u003cT\u003e defaultConstructor \u003d newDefaultConstructor(rawType);\n    if (defaultConstructor !\u003d null) {\n        return defaultConstructor;\n    }\n    ObjectConstructor\u003cT\u003e defaultImplementation \u003d newDefaultImplementationConstructor(rawType);\n    if (defaultImplementation !\u003d null) {\n        return defaultImplementation;\n    }\n    return newUnsafeAllocator(type, rawType);\n}",
      "path": "gson/src/main/java/com/google/gson/internal/ConstructorConstructor.java",
      "functionStartLine": 50,
      "functionName": "get",
      "functionAnnotation": "",
      "functionDoc": "",
      "diff": "@@ -1,22 +1,22 @@\n-public \u003cT\u003e ObjectConstructor\u003cT\u003e getConstructor(TypeToken\u003cT\u003e typeToken) {\n+public \u003cT\u003e ObjectConstructor\u003cT\u003e get(TypeToken\u003cT\u003e typeToken) {\n     final Type type \u003d typeToken.getType();\n     final Class\u003c? super T\u003e rawType \u003d typeToken.getRawType();\n     @SuppressWarnings(\"unchecked\") final InstanceCreator\u003cT\u003e creator \u003d (InstanceCreator\u003cT\u003e) instanceCreators.get(type);\n     if (creator !\u003d null) {\n         return new ObjectConstructor\u003cT\u003e() {\n \n             public T construct() {\n                 return creator.createInstance(type);\n             }\n         };\n     }\n     ObjectConstructor\u003cT\u003e defaultConstructor \u003d newDefaultConstructor(rawType);\n     if (defaultConstructor !\u003d null) {\n         return defaultConstructor;\n     }\n     ObjectConstructor\u003cT\u003e defaultImplementation \u003d newDefaultImplementationConstructor(rawType);\n     if (defaultImplementation !\u003d null) {\n         return defaultImplementation;\n     }\n     return newUnsafeAllocator(type, rawType);\n }\n\\ No newline at end of file\n",
      "extendedDetails": {
        "oldValue": "getConstructor",
        "newValue": "get"
      }
    },
    "1794182a560588973c6ec131e9c24bd39508433d": {
      "type": "Ybodychange",
      "commitMessage": "Commit to factories as the mechanism to lookup type adapters. This uses factories for type hierarchy adapters. We keep a separate list of factories for tree-style adapters registered with registerTypeHierarchyAdapter to guarantee that these come after the non-hierarchy adapters.\n\nThis drops support for type hierarchy instance creators. I don\u0027t expect this to be a problem. We\u0027ll also detect fewer errors where multiple type adapters can serialize the same type. With APIs like getNextTypeAdapter, I think this might actually be an improvement!\n",
      "commitDate": "11/22/11, 10:16 PM",
      "commitName": "1794182a560588973c6ec131e9c24bd39508433d",
      "commitAuthor": "Jesse Wilson",
      "commitDateOld": "11/20/11, 11:55 AM",
      "commitNameOld": "d391584d48ce87a36c88e804711a5f187e0b9086",
      "commitAuthorOld": "Jesse Wilson",
      "daysBetweenCommits": 2.43,
      "commitsBetweenForRepo": 16,
      "commitsBetweenForFile": 1,
      "actualSource": "public \u003cT\u003e ObjectConstructor\u003cT\u003e getConstructor(TypeToken\u003cT\u003e typeToken) {\n    final Type type \u003d typeToken.getType();\n    final Class\u003c? super T\u003e rawType \u003d typeToken.getRawType();\n    @SuppressWarnings(\"unchecked\") final InstanceCreator\u003cT\u003e creator \u003d (InstanceCreator\u003cT\u003e) instanceCreators.get(type);\n    if (creator !\u003d null) {\n        return new ObjectConstructor\u003cT\u003e() {\n\n            public T construct() {\n                return creator.createInstance(type);\n            }\n        };\n    }\n    ObjectConstructor\u003cT\u003e defaultConstructor \u003d newDefaultConstructor(rawType);\n    if (defaultConstructor !\u003d null) {\n        return defaultConstructor;\n    }\n    ObjectConstructor\u003cT\u003e defaultImplementation \u003d newDefaultImplementationConstructor(rawType);\n    if (defaultImplementation !\u003d null) {\n        return defaultImplementation;\n    }\n    return newUnsafeAllocator(type, rawType);\n}",
      "path": "gson/src/main/java/com/google/gson/internal/ConstructorConstructor.java",
      "functionStartLine": 50,
      "functionName": "getConstructor",
      "functionAnnotation": "",
      "functionDoc": "",
      "diff": "@@ -1,22 +1,22 @@\n public \u003cT\u003e ObjectConstructor\u003cT\u003e getConstructor(TypeToken\u003cT\u003e typeToken) {\n     final Type type \u003d typeToken.getType();\n     final Class\u003c? super T\u003e rawType \u003d typeToken.getRawType();\n-    @SuppressWarnings(\"unchecked\") final InstanceCreator\u003cT\u003e creator \u003d (InstanceCreator\u003cT\u003e) instanceCreators.getHandlerFor(type);\n+    @SuppressWarnings(\"unchecked\") final InstanceCreator\u003cT\u003e creator \u003d (InstanceCreator\u003cT\u003e) instanceCreators.get(type);\n     if (creator !\u003d null) {\n         return new ObjectConstructor\u003cT\u003e() {\n \n             public T construct() {\n                 return creator.createInstance(type);\n             }\n         };\n     }\n     ObjectConstructor\u003cT\u003e defaultConstructor \u003d newDefaultConstructor(rawType);\n     if (defaultConstructor !\u003d null) {\n         return defaultConstructor;\n     }\n     ObjectConstructor\u003cT\u003e defaultImplementation \u003d newDefaultImplementationConstructor(rawType);\n     if (defaultImplementation !\u003d null) {\n         return defaultImplementation;\n     }\n     return newUnsafeAllocator(type, rawType);\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "d391584d48ce87a36c88e804711a5f187e0b9086": {
      "type": "Ybodychange",
      "commitMessage": "Register Gson 1.x tree-style adapters in the TypeAdapter.Factory list rather than in the ParameterizedTypeHandlerMap.\n\nThe motivation for this change is to give tree-style adapters precedence order in registration. This fixes the test I committed earlier today, where registration order was not honored.\n\nThis renamed ParameterizedTypeHandlerMap to the shorter \u0027TypeMap\u0027. For type adapters, this is now only used for type hierarchy. We still need non-hierarchy support in TypeMap for instance creators; I\u0027ll be looking for workarounds to see if further simplification is possible here.\n",
      "commitDate": "11/20/11, 11:55 AM",
      "commitName": "d391584d48ce87a36c88e804711a5f187e0b9086",
      "commitAuthor": "Jesse Wilson",
      "commitDateOld": "10/22/11, 1:22 PM",
      "commitNameOld": "290fb69a5093ce13acad3552e95ce536b6318f28",
      "commitAuthorOld": "Jesse Wilson",
      "daysBetweenCommits": 28.98,
      "commitsBetweenForRepo": 23,
      "commitsBetweenForFile": 1,
      "actualSource": "public \u003cT\u003e ObjectConstructor\u003cT\u003e getConstructor(TypeToken\u003cT\u003e typeToken) {\n    final Type type \u003d typeToken.getType();\n    final Class\u003c? super T\u003e rawType \u003d typeToken.getRawType();\n    @SuppressWarnings(\"unchecked\") final InstanceCreator\u003cT\u003e creator \u003d (InstanceCreator\u003cT\u003e) instanceCreators.getHandlerFor(type);\n    if (creator !\u003d null) {\n        return new ObjectConstructor\u003cT\u003e() {\n\n            public T construct() {\n                return creator.createInstance(type);\n            }\n        };\n    }\n    ObjectConstructor\u003cT\u003e defaultConstructor \u003d newDefaultConstructor(rawType);\n    if (defaultConstructor !\u003d null) {\n        return defaultConstructor;\n    }\n    ObjectConstructor\u003cT\u003e defaultImplementation \u003d newDefaultImplementationConstructor(rawType);\n    if (defaultImplementation !\u003d null) {\n        return defaultImplementation;\n    }\n    return newUnsafeAllocator(type, rawType);\n}",
      "path": "gson/src/main/java/com/google/gson/internal/ConstructorConstructor.java",
      "functionStartLine": 49,
      "functionName": "getConstructor",
      "functionAnnotation": "",
      "functionDoc": "",
      "diff": "@@ -1,22 +1,22 @@\n public \u003cT\u003e ObjectConstructor\u003cT\u003e getConstructor(TypeToken\u003cT\u003e typeToken) {\n     final Type type \u003d typeToken.getType();\n     final Class\u003c? super T\u003e rawType \u003d typeToken.getRawType();\n-    @SuppressWarnings(\"unchecked\") final InstanceCreator\u003cT\u003e creator \u003d (InstanceCreator\u003cT\u003e) instanceCreators.getHandlerFor(type, false);\n+    @SuppressWarnings(\"unchecked\") final InstanceCreator\u003cT\u003e creator \u003d (InstanceCreator\u003cT\u003e) instanceCreators.getHandlerFor(type);\n     if (creator !\u003d null) {\n         return new ObjectConstructor\u003cT\u003e() {\n \n             public T construct() {\n                 return creator.createInstance(type);\n             }\n         };\n     }\n     ObjectConstructor\u003cT\u003e defaultConstructor \u003d newDefaultConstructor(rawType);\n     if (defaultConstructor !\u003d null) {\n         return defaultConstructor;\n     }\n     ObjectConstructor\u003cT\u003e defaultImplementation \u003d newDefaultImplementationConstructor(rawType);\n     if (defaultImplementation !\u003d null) {\n         return defaultImplementation;\n     }\n     return newUnsafeAllocator(type, rawType);\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "4a6c084ef73e5e8a3fca12f9bb829a218fad7a84": {
      "type": "Ybodychange",
      "commitMessage": "removed JDK 1.5 incompatible use of @Overrides annotation on overridden interface methods.\n",
      "commitDate": "9/15/11, 8:27 PM",
      "commitName": "4a6c084ef73e5e8a3fca12f9bb829a218fad7a84",
      "commitAuthor": "Inderjeet Singh",
      "commitDateOld": "9/11/11, 12:04 AM",
      "commitNameOld": "25c6ae177b1ca56db7f3c29eb574bdd032a06165",
      "commitAuthorOld": "Jesse Wilson",
      "daysBetweenCommits": 4.85,
      "commitsBetweenForRepo": 4,
      "commitsBetweenForFile": 1,
      "actualSource": "public \u003cT\u003e ObjectConstructor\u003cT\u003e getConstructor(TypeToken\u003cT\u003e typeToken) {\n    final Type type \u003d typeToken.getType();\n    final Class\u003c? super T\u003e rawType \u003d typeToken.getRawType();\n    @SuppressWarnings(\"unchecked\") final InstanceCreator\u003cT\u003e creator \u003d (InstanceCreator\u003cT\u003e) instanceCreators.getHandlerFor(type, false);\n    if (creator !\u003d null) {\n        return new ObjectConstructor\u003cT\u003e() {\n\n            public T construct() {\n                return creator.createInstance(type);\n            }\n        };\n    }\n    ObjectConstructor\u003cT\u003e defaultConstructor \u003d newDefaultConstructor(rawType);\n    if (defaultConstructor !\u003d null) {\n        return defaultConstructor;\n    }\n    ObjectConstructor\u003cT\u003e defaultImplementation \u003d newDefaultImplementationConstructor(rawType);\n    if (defaultImplementation !\u003d null) {\n        return defaultImplementation;\n    }\n    return newUnsafeAllocator(type, rawType);\n}",
      "path": "gson/src/main/java/com/google/gson/internal/ConstructorConstructor.java",
      "functionStartLine": 49,
      "functionName": "getConstructor",
      "functionAnnotation": "",
      "functionDoc": "",
      "diff": "@@ -1,23 +1,22 @@\n public \u003cT\u003e ObjectConstructor\u003cT\u003e getConstructor(TypeToken\u003cT\u003e typeToken) {\n     final Type type \u003d typeToken.getType();\n     final Class\u003c? super T\u003e rawType \u003d typeToken.getRawType();\n     @SuppressWarnings(\"unchecked\") final InstanceCreator\u003cT\u003e creator \u003d (InstanceCreator\u003cT\u003e) instanceCreators.getHandlerFor(type, false);\n     if (creator !\u003d null) {\n         return new ObjectConstructor\u003cT\u003e() {\n \n-            @Override\n             public T construct() {\n                 return creator.createInstance(type);\n             }\n         };\n     }\n     ObjectConstructor\u003cT\u003e defaultConstructor \u003d newDefaultConstructor(rawType);\n     if (defaultConstructor !\u003d null) {\n         return defaultConstructor;\n     }\n     ObjectConstructor\u003cT\u003e defaultImplementation \u003d newDefaultImplementationConstructor(rawType);\n     if (defaultImplementation !\u003d null) {\n         return defaultImplementation;\n     }\n     return newUnsafeAllocator(type, rawType);\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "25c6ae177b1ca56db7f3c29eb574bdd032a06165": {
      "type": "Yintroduced",
      "commitMessage": "Down to 22 failing tests.\n\nConsolidated all of the different code paths that we use to construct instances. We now have an ObjectConstructor class that knows what type it constructs; this means that we don\u0027t need to ever do reflection to lookup a constructor at construction time.\n\nCleaned up some buggy type adapters, particularly around handling of null.\n\nRemoved dead code for object graph navigation.\n\nMoved some classes into \u0027internal\u0027 so they are visible to the \u0027bind\u0027 subpackage.\n\nTurned some TypeAdapterFactory/TypeAdapter pairs inside out so that the TypeAdapter is now the inner class. This is necessary so that the factories can take parameters.\n\nAdded an API to request the \u0027next\u0027 type adapter for a type. This allows type adapters to compose other type adapters. We\u0027re using this in two places:\n - where the user has excluded a type from serialization but not deserialization, we need to use the \"default\" deserialization but interpose null on serialization. We create a type adapter that delegates for one and returns null for the other.\n - similarly when a DOM type serializer is registered but no deserializer, or vice versa.\nThis is the biggest change to the MiniGson core.\n\nFor backwards compatibility, return null for the empty string.\n\nSimplify JsonSerializationContext/JsonDeserializationContext to simply call through to GSON. SerializeDefault is currently unsupported.\n\nMore useful error messages when calling getAsBoolean on a JsonNull.\n\nRemove currently unused MemoryRefStack. We might need this back again, though wiring it back in will be much more difficult because we don\u0027t interject ourselves between the users\u0027 various type adapters.\n",
      "commitDate": "9/11/11, 12:04 AM",
      "commitName": "25c6ae177b1ca56db7f3c29eb574bdd032a06165",
      "commitAuthor": "Jesse Wilson",
      "diff": "@@ -0,0 +1,23 @@\n+public \u003cT\u003e ObjectConstructor\u003cT\u003e getConstructor(TypeToken\u003cT\u003e typeToken) {\n+    final Type type \u003d typeToken.getType();\n+    final Class\u003c? super T\u003e rawType \u003d typeToken.getRawType();\n+    @SuppressWarnings(\"unchecked\") final InstanceCreator\u003cT\u003e creator \u003d (InstanceCreator\u003cT\u003e) instanceCreators.getHandlerFor(type, false);\n+    if (creator !\u003d null) {\n+        return new ObjectConstructor\u003cT\u003e() {\n+\n+            @Override\n+            public T construct() {\n+                return creator.createInstance(type);\n+            }\n+        };\n+    }\n+    ObjectConstructor\u003cT\u003e defaultConstructor \u003d newDefaultConstructor(rawType);\n+    if (defaultConstructor !\u003d null) {\n+        return defaultConstructor;\n+    }\n+    ObjectConstructor\u003cT\u003e defaultImplementation \u003d newDefaultImplementationConstructor(rawType);\n+    if (defaultImplementation !\u003d null) {\n+        return defaultImplementation;\n+    }\n+    return newUnsafeAllocator(type, rawType);\n+}\n\\ No newline at end of file\n",
      "actualSource": "public \u003cT\u003e ObjectConstructor\u003cT\u003e getConstructor(TypeToken\u003cT\u003e typeToken) {\n    final Type type \u003d typeToken.getType();\n    final Class\u003c? super T\u003e rawType \u003d typeToken.getRawType();\n    @SuppressWarnings(\"unchecked\") final InstanceCreator\u003cT\u003e creator \u003d (InstanceCreator\u003cT\u003e) instanceCreators.getHandlerFor(type, false);\n    if (creator !\u003d null) {\n        return new ObjectConstructor\u003cT\u003e() {\n\n            @Override\n            public T construct() {\n                return creator.createInstance(type);\n            }\n        };\n    }\n    ObjectConstructor\u003cT\u003e defaultConstructor \u003d newDefaultConstructor(rawType);\n    if (defaultConstructor !\u003d null) {\n        return defaultConstructor;\n    }\n    ObjectConstructor\u003cT\u003e defaultImplementation \u003d newDefaultImplementationConstructor(rawType);\n    if (defaultImplementation !\u003d null) {\n        return defaultImplementation;\n    }\n    return newUnsafeAllocator(type, rawType);\n}",
      "path": "gson/src/main/java/com/google/gson/internal/ConstructorConstructor.java",
      "functionStartLine": 49,
      "functionName": "getConstructor",
      "functionAnnotation": "",
      "functionDoc": ""
    }
  }
}