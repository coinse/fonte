{
  "origin": "codeshovel",
  "repositoryName": "Gson-10b",
  "repositoryPath": "/tmp/Gson-10b//.git",
  "startCommitName": "HEAD",
  "sourceFileName": "CollectionTypeAdapterFactory.java",
  "functionName": "create",
  "functionId": "create___gson-Gson__typeToken-TypeToken__T__",
  "sourceFilePath": "gson/src/main/java/com/google/gson/internal/bind/CollectionTypeAdapterFactory.java",
  "functionAnnotation": "@Override",
  "functionDoc": "",
  "functionStartLine": 44,
  "functionEndLine": 59,
  "numCommitsSeen": 31,
  "timeTaken": 1903,
  "changeHistory": [
    "e5b3f6368db33c846b094b0d695d3a1b826e3892",
    "6cca23c172612aded9ee2996a5177cb7b9a84390",
    "26ab404599643fac25442646b829a65a7f86bca1",
    "7e760143fdc8b689daeebdee33ad6ea7d0a62a56",
    "31964507c1caabc9a70e3270fa56aaee29eff6b2",
    "25c6ae177b1ca56db7f3c29eb574bdd032a06165",
    "6f6d3b221e563a1706727fce8bc26e83fee3144a",
    "3aeb70e0305a598a9ceddc0390d693874dcc892d",
    "64dc53ffc40ac80925be50523e3c2cea6ad97da9",
    "60e6ed912d52716f46a1ba71923ef203c4248857",
    "c6bef300579d96fe90e5be8240ee595ae8da66f1",
    "c5f1df10175c254b823fc019832bf1bf7b71e929"
  ],
  "changeHistoryShort": {
    "e5b3f6368db33c846b094b0d695d3a1b826e3892": "Yannotationchange",
    "6cca23c172612aded9ee2996a5177cb7b9a84390": "Ybodychange",
    "26ab404599643fac25442646b829a65a7f86bca1": "Ymultichange(Yparameterchange,Ybodychange)",
    "7e760143fdc8b689daeebdee33ad6ea7d0a62a56": "Yparameterchange",
    "31964507c1caabc9a70e3270fa56aaee29eff6b2": "Ybodychange",
    "25c6ae177b1ca56db7f3c29eb574bdd032a06165": "Ymultichange(Ymovefromfile,Ybodychange)",
    "6f6d3b221e563a1706727fce8bc26e83fee3144a": "Ybodychange",
    "3aeb70e0305a598a9ceddc0390d693874dcc892d": "Ybodychange",
    "64dc53ffc40ac80925be50523e3c2cea6ad97da9": "Ybodychange",
    "60e6ed912d52716f46a1ba71923ef203c4248857": "Yfilerename",
    "c6bef300579d96fe90e5be8240ee595ae8da66f1": "Ybodychange",
    "c5f1df10175c254b823fc019832bf1bf7b71e929": "Yintroduced"
  },
  "changeHistoryDetails": {
    "e5b3f6368db33c846b094b0d695d3a1b826e3892": {
      "type": "Yannotationchange",
      "commitMessage": "updated minimum JDK version to 1.6.\nAdded Overrides for methods implementing an interface.\n",
      "commitDate": "11/4/15, 6:52 PM",
      "commitName": "e5b3f6368db33c846b094b0d695d3a1b826e3892",
      "commitAuthor": "Inderjeet Singh",
      "commitDateOld": "4/12/13, 1:09 PM",
      "commitNameOld": "26016ca66e8cb76ada0a01fa9420a88a8d346f68",
      "commitAuthorOld": "Inderjeet Singh",
      "daysBetweenCommits": 936.28,
      "commitsBetweenForRepo": 141,
      "commitsBetweenForFile": 1,
      "actualSource": "@Override\npublic \u003cT\u003e TypeAdapter\u003cT\u003e create(Gson gson, TypeToken\u003cT\u003e typeToken) {\n    Type type \u003d typeToken.getType();\n    Class\u003c? super T\u003e rawType \u003d typeToken.getRawType();\n    if (!Collection.class.isAssignableFrom(rawType)) {\n        return null;\n    }\n    Type elementType \u003d $Gson$Types.getCollectionElementType(type, rawType);\n    TypeAdapter\u003c?\u003e elementTypeAdapter \u003d gson.getAdapter(TypeToken.get(elementType));\n    ObjectConstructor\u003cT\u003e constructor \u003d constructorConstructor.get(typeToken);\n    @SuppressWarnings({ \"unchecked\", \"rawtypes\" }) TypeAdapter\u003cT\u003e result \u003d new Adapter(gson, elementType, elementTypeAdapter, constructor);\n    return result;\n}",
      "path": "gson/src/main/java/com/google/gson/internal/bind/CollectionTypeAdapterFactory.java",
      "functionStartLine": 44,
      "functionName": "create",
      "functionAnnotation": "@Override",
      "functionDoc": "",
      "diff": "@@ -1,12 +1,13 @@\n+@Override\n public \u003cT\u003e TypeAdapter\u003cT\u003e create(Gson gson, TypeToken\u003cT\u003e typeToken) {\n     Type type \u003d typeToken.getType();\n     Class\u003c? super T\u003e rawType \u003d typeToken.getRawType();\n     if (!Collection.class.isAssignableFrom(rawType)) {\n         return null;\n     }\n     Type elementType \u003d $Gson$Types.getCollectionElementType(type, rawType);\n     TypeAdapter\u003c?\u003e elementTypeAdapter \u003d gson.getAdapter(TypeToken.get(elementType));\n     ObjectConstructor\u003cT\u003e constructor \u003d constructorConstructor.get(typeToken);\n     @SuppressWarnings({ \"unchecked\", \"rawtypes\" }) TypeAdapter\u003cT\u003e result \u003d new Adapter(gson, elementType, elementTypeAdapter, constructor);\n     return result;\n }\n\\ No newline at end of file\n",
      "extendedDetails": {
        "oldValue": "",
        "newValue": "@Override"
      }
    },
    "6cca23c172612aded9ee2996a5177cb7b9a84390": {
      "type": "Ybodychange",
      "commitMessage": "Get GraphAdapterBuilder working for serialization and deserialization using InstanceCreators to get a sneak peek at a value under construction.\n",
      "commitDate": "1/1/12, 5:42 AM",
      "commitName": "6cca23c172612aded9ee2996a5177cb7b9a84390",
      "commitAuthor": "Jesse Wilson",
      "commitDateOld": "1/1/12, 4:42 AM",
      "commitNameOld": "d4a1e49e463091ed3793930815fde75bb766d030",
      "commitAuthorOld": "Jesse Wilson",
      "daysBetweenCommits": 0.04,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "public \u003cT\u003e TypeAdapter\u003cT\u003e create(Gson gson, TypeToken\u003cT\u003e typeToken) {\n    Type type \u003d typeToken.getType();\n    Class\u003c? super T\u003e rawType \u003d typeToken.getRawType();\n    if (!Collection.class.isAssignableFrom(rawType)) {\n        return null;\n    }\n    Type elementType \u003d $Gson$Types.getCollectionElementType(type, rawType);\n    TypeAdapter\u003c?\u003e elementTypeAdapter \u003d gson.getAdapter(TypeToken.get(elementType));\n    ObjectConstructor\u003cT\u003e constructor \u003d constructorConstructor.get(typeToken);\n    @SuppressWarnings({ \"unchecked\", \"rawtypes\" }) TypeAdapter\u003cT\u003e result \u003d new Adapter(gson, elementType, elementTypeAdapter, constructor);\n    return result;\n}",
      "path": "gson/src/main/java/com/google/gson/internal/bind/CollectionTypeAdapterFactory.java",
      "functionStartLine": 43,
      "functionName": "create",
      "functionAnnotation": "",
      "functionDoc": "",
      "diff": "@@ -1,12 +1,12 @@\n public \u003cT\u003e TypeAdapter\u003cT\u003e create(Gson gson, TypeToken\u003cT\u003e typeToken) {\n     Type type \u003d typeToken.getType();\n     Class\u003c? super T\u003e rawType \u003d typeToken.getRawType();\n     if (!Collection.class.isAssignableFrom(rawType)) {\n         return null;\n     }\n     Type elementType \u003d $Gson$Types.getCollectionElementType(type, rawType);\n     TypeAdapter\u003c?\u003e elementTypeAdapter \u003d gson.getAdapter(TypeToken.get(elementType));\n-    ObjectConstructor\u003cT\u003e constructor \u003d constructorConstructor.getConstructor(typeToken);\n+    ObjectConstructor\u003cT\u003e constructor \u003d constructorConstructor.get(typeToken);\n     @SuppressWarnings({ \"unchecked\", \"rawtypes\" }) TypeAdapter\u003cT\u003e result \u003d new Adapter(gson, elementType, elementTypeAdapter, constructor);\n     return result;\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "26ab404599643fac25442646b829a65a7f86bca1": {
      "type": "Ymultichange(Yparameterchange,Ybodychange)",
      "commitMessage": "Cleanup names for TypeAdapters.\n",
      "commitDate": "12/2/11, 2:57 PM",
      "commitName": "26ab404599643fac25442646b829a65a7f86bca1",
      "commitAuthor": "Jesse Wilson",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "Cleanup names for TypeAdapters.\n",
          "commitDate": "12/2/11, 2:57 PM",
          "commitName": "26ab404599643fac25442646b829a65a7f86bca1",
          "commitAuthor": "Jesse Wilson",
          "commitDateOld": "11/20/11, 7:23 AM",
          "commitNameOld": "7e760143fdc8b689daeebdee33ad6ea7d0a62a56",
          "commitAuthorOld": "Jesse Wilson",
          "daysBetweenCommits": 12.32,
          "commitsBetweenForRepo": 30,
          "commitsBetweenForFile": 1,
          "actualSource": "public \u003cT\u003e TypeAdapter\u003cT\u003e create(Gson gson, TypeToken\u003cT\u003e typeToken) {\n    Type type \u003d typeToken.getType();\n    Class\u003c? super T\u003e rawType \u003d typeToken.getRawType();\n    if (!Collection.class.isAssignableFrom(rawType)) {\n        return null;\n    }\n    Type elementType \u003d $Gson$Types.getCollectionElementType(type, rawType);\n    TypeAdapter\u003c?\u003e elementTypeAdapter \u003d gson.getAdapter(TypeToken.get(elementType));\n    ObjectConstructor\u003cT\u003e constructor \u003d constructorConstructor.getConstructor(typeToken);\n    @SuppressWarnings({ \"unchecked\", \"rawtypes\" }) TypeAdapter\u003cT\u003e result \u003d new Adapter(gson, elementType, elementTypeAdapter, constructor);\n    return result;\n}",
          "path": "gson/src/main/java/com/google/gson/internal/bind/CollectionTypeAdapterFactory.java",
          "functionStartLine": 42,
          "functionName": "create",
          "functionAnnotation": "",
          "functionDoc": "",
          "diff": "@@ -1,12 +1,12 @@\n-public \u003cT\u003e TypeAdapter\u003cT\u003e create(Gson context, TypeToken\u003cT\u003e typeToken) {\n+public \u003cT\u003e TypeAdapter\u003cT\u003e create(Gson gson, TypeToken\u003cT\u003e typeToken) {\n     Type type \u003d typeToken.getType();\n     Class\u003c? super T\u003e rawType \u003d typeToken.getRawType();\n     if (!Collection.class.isAssignableFrom(rawType)) {\n         return null;\n     }\n     Type elementType \u003d $Gson$Types.getCollectionElementType(type, rawType);\n-    TypeAdapter\u003c?\u003e elementTypeAdapter \u003d context.getAdapter(TypeToken.get(elementType));\n+    TypeAdapter\u003c?\u003e elementTypeAdapter \u003d gson.getAdapter(TypeToken.get(elementType));\n     ObjectConstructor\u003cT\u003e constructor \u003d constructorConstructor.getConstructor(typeToken);\n-    @SuppressWarnings({ \"unchecked\", \"rawtypes\" }) TypeAdapter\u003cT\u003e result \u003d new Adapter(context, elementType, elementTypeAdapter, constructor);\n+    @SuppressWarnings({ \"unchecked\", \"rawtypes\" }) TypeAdapter\u003cT\u003e result \u003d new Adapter(gson, elementType, elementTypeAdapter, constructor);\n     return result;\n }\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldValue": "[context-Gson, typeToken-TypeToken\u003cT\u003e]",
            "newValue": "[gson-Gson, typeToken-TypeToken\u003cT\u003e]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "Cleanup names for TypeAdapters.\n",
          "commitDate": "12/2/11, 2:57 PM",
          "commitName": "26ab404599643fac25442646b829a65a7f86bca1",
          "commitAuthor": "Jesse Wilson",
          "commitDateOld": "11/20/11, 7:23 AM",
          "commitNameOld": "7e760143fdc8b689daeebdee33ad6ea7d0a62a56",
          "commitAuthorOld": "Jesse Wilson",
          "daysBetweenCommits": 12.32,
          "commitsBetweenForRepo": 30,
          "commitsBetweenForFile": 1,
          "actualSource": "public \u003cT\u003e TypeAdapter\u003cT\u003e create(Gson gson, TypeToken\u003cT\u003e typeToken) {\n    Type type \u003d typeToken.getType();\n    Class\u003c? super T\u003e rawType \u003d typeToken.getRawType();\n    if (!Collection.class.isAssignableFrom(rawType)) {\n        return null;\n    }\n    Type elementType \u003d $Gson$Types.getCollectionElementType(type, rawType);\n    TypeAdapter\u003c?\u003e elementTypeAdapter \u003d gson.getAdapter(TypeToken.get(elementType));\n    ObjectConstructor\u003cT\u003e constructor \u003d constructorConstructor.getConstructor(typeToken);\n    @SuppressWarnings({ \"unchecked\", \"rawtypes\" }) TypeAdapter\u003cT\u003e result \u003d new Adapter(gson, elementType, elementTypeAdapter, constructor);\n    return result;\n}",
          "path": "gson/src/main/java/com/google/gson/internal/bind/CollectionTypeAdapterFactory.java",
          "functionStartLine": 42,
          "functionName": "create",
          "functionAnnotation": "",
          "functionDoc": "",
          "diff": "@@ -1,12 +1,12 @@\n-public \u003cT\u003e TypeAdapter\u003cT\u003e create(Gson context, TypeToken\u003cT\u003e typeToken) {\n+public \u003cT\u003e TypeAdapter\u003cT\u003e create(Gson gson, TypeToken\u003cT\u003e typeToken) {\n     Type type \u003d typeToken.getType();\n     Class\u003c? super T\u003e rawType \u003d typeToken.getRawType();\n     if (!Collection.class.isAssignableFrom(rawType)) {\n         return null;\n     }\n     Type elementType \u003d $Gson$Types.getCollectionElementType(type, rawType);\n-    TypeAdapter\u003c?\u003e elementTypeAdapter \u003d context.getAdapter(TypeToken.get(elementType));\n+    TypeAdapter\u003c?\u003e elementTypeAdapter \u003d gson.getAdapter(TypeToken.get(elementType));\n     ObjectConstructor\u003cT\u003e constructor \u003d constructorConstructor.getConstructor(typeToken);\n-    @SuppressWarnings({ \"unchecked\", \"rawtypes\" }) TypeAdapter\u003cT\u003e result \u003d new Adapter(context, elementType, elementTypeAdapter, constructor);\n+    @SuppressWarnings({ \"unchecked\", \"rawtypes\" }) TypeAdapter\u003cT\u003e result \u003d new Adapter(gson, elementType, elementTypeAdapter, constructor);\n     return result;\n }\n\\ No newline at end of file\n",
          "extendedDetails": {}
        }
      ]
    },
    "7e760143fdc8b689daeebdee33ad6ea7d0a62a56": {
      "type": "Yparameterchange",
      "commitMessage": "Smash together MiniGson and Gson. This changes Gson to be the MiniGson rather than delegating to the MiniGson. It means that the MiniGson objects passed into streaming type adapters are now fully-capable \u0027Gson\u0027 objects. \n\nThe most notable impact of this change is that it adds several new public APIs:\n - The TypeAdapter abstract class\n - The TypeAdapter.Factory interface\n - Four new methods on GsonBuilder to register streaming TypeAdapters (via Factory, via Class, via TypeToken, and as a type hierarchy)\n - Three new methods on Gson to lookup streaming TypeAdapters (by type, by class, and to get the next type adapter) \n\nStill outstanding:\n - Write beautiful prose to document the new APIs above\n - Change GsonBuilder\u0027s precedence so that both old and new-style type adapters are registered in one lot\n",
      "commitDate": "11/20/11, 7:23 AM",
      "commitName": "7e760143fdc8b689daeebdee33ad6ea7d0a62a56",
      "commitAuthor": "Jesse Wilson",
      "commitDateOld": "10/20/11, 2:32 PM",
      "commitNameOld": "31964507c1caabc9a70e3270fa56aaee29eff6b2",
      "commitAuthorOld": "Inderjeet Singh",
      "daysBetweenCommits": 30.74,
      "commitsBetweenForRepo": 25,
      "commitsBetweenForFile": 1,
      "actualSource": "public \u003cT\u003e TypeAdapter\u003cT\u003e create(Gson context, TypeToken\u003cT\u003e typeToken) {\n    Type type \u003d typeToken.getType();\n    Class\u003c? super T\u003e rawType \u003d typeToken.getRawType();\n    if (!Collection.class.isAssignableFrom(rawType)) {\n        return null;\n    }\n    Type elementType \u003d $Gson$Types.getCollectionElementType(type, rawType);\n    TypeAdapter\u003c?\u003e elementTypeAdapter \u003d context.getAdapter(TypeToken.get(elementType));\n    ObjectConstructor\u003cT\u003e constructor \u003d constructorConstructor.getConstructor(typeToken);\n    @SuppressWarnings({ \"unchecked\", \"rawtypes\" }) TypeAdapter\u003cT\u003e result \u003d new Adapter(context, elementType, elementTypeAdapter, constructor);\n    return result;\n}",
      "path": "gson/src/main/java/com/google/gson/internal/bind/CollectionTypeAdapterFactory.java",
      "functionStartLine": 42,
      "functionName": "create",
      "functionAnnotation": "",
      "functionDoc": "",
      "diff": "@@ -1,12 +1,12 @@\n-public \u003cT\u003e TypeAdapter\u003cT\u003e create(MiniGson context, TypeToken\u003cT\u003e typeToken) {\n+public \u003cT\u003e TypeAdapter\u003cT\u003e create(Gson context, TypeToken\u003cT\u003e typeToken) {\n     Type type \u003d typeToken.getType();\n     Class\u003c? super T\u003e rawType \u003d typeToken.getRawType();\n     if (!Collection.class.isAssignableFrom(rawType)) {\n         return null;\n     }\n     Type elementType \u003d $Gson$Types.getCollectionElementType(type, rawType);\n     TypeAdapter\u003c?\u003e elementTypeAdapter \u003d context.getAdapter(TypeToken.get(elementType));\n     ObjectConstructor\u003cT\u003e constructor \u003d constructorConstructor.getConstructor(typeToken);\n     @SuppressWarnings({ \"unchecked\", \"rawtypes\" }) TypeAdapter\u003cT\u003e result \u003d new Adapter(context, elementType, elementTypeAdapter, constructor);\n     return result;\n }\n\\ No newline at end of file\n",
      "extendedDetails": {
        "oldValue": "[context-MiniGson, typeToken-TypeToken\u003cT\u003e]",
        "newValue": "[context-Gson, typeToken-TypeToken\u003cT\u003e]"
      }
    },
    "31964507c1caabc9a70e3270fa56aaee29eff6b2": {
      "type": "Ybodychange",
      "commitMessage": "Updated SuppressWarnings annotations to Eclipse 3.6/3.7 which is unfortunately incompatible with Eclipse 3.5 (rawtypes vs unchecked)\nThis CL eliminates all eclipse warnings.\n",
      "commitDate": "10/20/11, 2:32 PM",
      "commitName": "31964507c1caabc9a70e3270fa56aaee29eff6b2",
      "commitAuthor": "Inderjeet Singh",
      "commitDateOld": "10/13/11, 8:20 PM",
      "commitNameOld": "0e02cbb33ec43b301b6835a99db020a2df3c6f51",
      "commitAuthorOld": "Jesse Wilson",
      "daysBetweenCommits": 6.76,
      "commitsBetweenForRepo": 4,
      "commitsBetweenForFile": 1,
      "actualSource": "public \u003cT\u003e TypeAdapter\u003cT\u003e create(MiniGson context, TypeToken\u003cT\u003e typeToken) {\n    Type type \u003d typeToken.getType();\n    Class\u003c? super T\u003e rawType \u003d typeToken.getRawType();\n    if (!Collection.class.isAssignableFrom(rawType)) {\n        return null;\n    }\n    Type elementType \u003d $Gson$Types.getCollectionElementType(type, rawType);\n    TypeAdapter\u003c?\u003e elementTypeAdapter \u003d context.getAdapter(TypeToken.get(elementType));\n    ObjectConstructor\u003cT\u003e constructor \u003d constructorConstructor.getConstructor(typeToken);\n    @SuppressWarnings({ \"unchecked\", \"rawtypes\" }) TypeAdapter\u003cT\u003e result \u003d new Adapter(context, elementType, elementTypeAdapter, constructor);\n    return result;\n}",
      "path": "gson/src/main/java/com/google/gson/internal/bind/CollectionTypeAdapterFactory.java",
      "functionStartLine": 40,
      "functionName": "create",
      "functionAnnotation": "",
      "functionDoc": "",
      "diff": "@@ -1,12 +1,12 @@\n public \u003cT\u003e TypeAdapter\u003cT\u003e create(MiniGson context, TypeToken\u003cT\u003e typeToken) {\n     Type type \u003d typeToken.getType();\n     Class\u003c? super T\u003e rawType \u003d typeToken.getRawType();\n     if (!Collection.class.isAssignableFrom(rawType)) {\n         return null;\n     }\n     Type elementType \u003d $Gson$Types.getCollectionElementType(type, rawType);\n     TypeAdapter\u003c?\u003e elementTypeAdapter \u003d context.getAdapter(TypeToken.get(elementType));\n     ObjectConstructor\u003cT\u003e constructor \u003d constructorConstructor.getConstructor(typeToken);\n-    @SuppressWarnings(\"unchecked\") TypeAdapter\u003cT\u003e result \u003d new Adapter(context, elementType, elementTypeAdapter, constructor);\n+    @SuppressWarnings({ \"unchecked\", \"rawtypes\" }) TypeAdapter\u003cT\u003e result \u003d new Adapter(context, elementType, elementTypeAdapter, constructor);\n     return result;\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "25c6ae177b1ca56db7f3c29eb574bdd032a06165": {
      "type": "Ymultichange(Ymovefromfile,Ybodychange)",
      "commitMessage": "Down to 22 failing tests.\n\nConsolidated all of the different code paths that we use to construct instances. We now have an ObjectConstructor class that knows what type it constructs; this means that we don\u0027t need to ever do reflection to lookup a constructor at construction time.\n\nCleaned up some buggy type adapters, particularly around handling of null.\n\nRemoved dead code for object graph navigation.\n\nMoved some classes into \u0027internal\u0027 so they are visible to the \u0027bind\u0027 subpackage.\n\nTurned some TypeAdapterFactory/TypeAdapter pairs inside out so that the TypeAdapter is now the inner class. This is necessary so that the factories can take parameters.\n\nAdded an API to request the \u0027next\u0027 type adapter for a type. This allows type adapters to compose other type adapters. We\u0027re using this in two places:\n - where the user has excluded a type from serialization but not deserialization, we need to use the \"default\" deserialization but interpose null on serialization. We create a type adapter that delegates for one and returns null for the other.\n - similarly when a DOM type serializer is registered but no deserializer, or vice versa.\nThis is the biggest change to the MiniGson core.\n\nFor backwards compatibility, return null for the empty string.\n\nSimplify JsonSerializationContext/JsonDeserializationContext to simply call through to GSON. SerializeDefault is currently unsupported.\n\nMore useful error messages when calling getAsBoolean on a JsonNull.\n\nRemove currently unused MemoryRefStack. We might need this back again, though wiring it back in will be much more difficult because we don\u0027t interject ourselves between the users\u0027 various type adapters.\n",
      "commitDate": "9/11/11, 12:04 AM",
      "commitName": "25c6ae177b1ca56db7f3c29eb574bdd032a06165",
      "commitAuthor": "Jesse Wilson",
      "subchanges": [
        {
          "type": "Ymovefromfile",
          "commitMessage": "Down to 22 failing tests.\n\nConsolidated all of the different code paths that we use to construct instances. We now have an ObjectConstructor class that knows what type it constructs; this means that we don\u0027t need to ever do reflection to lookup a constructor at construction time.\n\nCleaned up some buggy type adapters, particularly around handling of null.\n\nRemoved dead code for object graph navigation.\n\nMoved some classes into \u0027internal\u0027 so they are visible to the \u0027bind\u0027 subpackage.\n\nTurned some TypeAdapterFactory/TypeAdapter pairs inside out so that the TypeAdapter is now the inner class. This is necessary so that the factories can take parameters.\n\nAdded an API to request the \u0027next\u0027 type adapter for a type. This allows type adapters to compose other type adapters. We\u0027re using this in two places:\n - where the user has excluded a type from serialization but not deserialization, we need to use the \"default\" deserialization but interpose null on serialization. We create a type adapter that delegates for one and returns null for the other.\n - similarly when a DOM type serializer is registered but no deserializer, or vice versa.\nThis is the biggest change to the MiniGson core.\n\nFor backwards compatibility, return null for the empty string.\n\nSimplify JsonSerializationContext/JsonDeserializationContext to simply call through to GSON. SerializeDefault is currently unsupported.\n\nMore useful error messages when calling getAsBoolean on a JsonNull.\n\nRemove currently unused MemoryRefStack. We might need this back again, though wiring it back in will be much more difficult because we don\u0027t interject ourselves between the users\u0027 various type adapters.\n",
          "commitDate": "9/11/11, 12:04 AM",
          "commitName": "25c6ae177b1ca56db7f3c29eb574bdd032a06165",
          "commitAuthor": "Jesse Wilson",
          "commitDateOld": "9/9/11, 1:17 AM",
          "commitNameOld": "cdd5d80b85155c21c61f888fb3e70c65e72edef7",
          "commitAuthorOld": "Jesse Wilson",
          "daysBetweenCommits": 1.95,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "actualSource": "public \u003cT\u003e TypeAdapter\u003cT\u003e create(MiniGson context, TypeToken\u003cT\u003e typeToken) {\n    Type type \u003d typeToken.getType();\n    Class\u003c? super T\u003e rawType \u003d typeToken.getRawType();\n    if (!Collection.class.isAssignableFrom(rawType)) {\n        return null;\n    }\n    Type elementType \u003d $Gson$Types.getCollectionElementType(type, rawType);\n    TypeAdapter\u003c?\u003e elementTypeAdapter \u003d context.getAdapter(TypeToken.get(elementType));\n    ObjectConstructor\u003cT\u003e constructor \u003d constructorConstructor.getConstructor(typeToken);\n    @SuppressWarnings(\"unchecked\") TypeAdapter\u003cT\u003e result \u003d new Adapter(context, elementType, elementTypeAdapter, constructor);\n    return result;\n}",
          "path": "gson/src/main/java/com/google/gson/internal/bind/CollectionTypeAdapterFactory.java",
          "functionStartLine": 40,
          "functionName": "create",
          "functionAnnotation": "",
          "functionDoc": "",
          "diff": "@@ -1,28 +1,12 @@\n public \u003cT\u003e TypeAdapter\u003cT\u003e create(MiniGson context, TypeToken\u003cT\u003e typeToken) {\n     Type type \u003d typeToken.getType();\n     Class\u003c? super T\u003e rawType \u003d typeToken.getRawType();\n     if (!Collection.class.isAssignableFrom(rawType)) {\n         return null;\n     }\n     Type elementType \u003d $Gson$Types.getCollectionElementType(type, rawType);\n     TypeAdapter\u003c?\u003e elementTypeAdapter \u003d context.getAdapter(TypeToken.get(elementType));\n-    Class\u003c?\u003e constructorType;\n-    if (rawType \u003d\u003d List.class || rawType \u003d\u003d Collection.class) {\n-        constructorType \u003d ArrayList.class;\n-    } else if (rawType \u003d\u003d Set.class) {\n-        constructorType \u003d LinkedHashSet.class;\n-    } else if (rawType \u003d\u003d Queue.class) {\n-        constructorType \u003d LinkedList.class;\n-    } else if (rawType \u003d\u003d SortedSet.class) {\n-        constructorType \u003d TreeSet.class;\n-    } else {\n-        constructorType \u003d rawType;\n-    }\n-    Constructor\u003c?\u003e constructor \u003d null;\n-    try {\n-        constructor \u003d constructorType.getConstructor();\n-    } catch (NoSuchMethodException ignored) {\n-    }\n-    @SuppressWarnings(\"unchecked\") TypeAdapter\u003cT\u003e result \u003d new CollectionTypeAdapter(context, elementType, elementTypeAdapter, constructor);\n+    ObjectConstructor\u003cT\u003e constructor \u003d constructorConstructor.getConstructor(typeToken);\n+    @SuppressWarnings(\"unchecked\") TypeAdapter\u003cT\u003e result \u003d new Adapter(context, elementType, elementTypeAdapter, constructor);\n     return result;\n }\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldPath": "gson/src/main/java/com/google/gson/internal/bind/CollectionTypeAdapter.java",
            "newPath": "gson/src/main/java/com/google/gson/internal/bind/CollectionTypeAdapterFactory.java",
            "oldMethodName": "create",
            "newMethodName": "create"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "Down to 22 failing tests.\n\nConsolidated all of the different code paths that we use to construct instances. We now have an ObjectConstructor class that knows what type it constructs; this means that we don\u0027t need to ever do reflection to lookup a constructor at construction time.\n\nCleaned up some buggy type adapters, particularly around handling of null.\n\nRemoved dead code for object graph navigation.\n\nMoved some classes into \u0027internal\u0027 so they are visible to the \u0027bind\u0027 subpackage.\n\nTurned some TypeAdapterFactory/TypeAdapter pairs inside out so that the TypeAdapter is now the inner class. This is necessary so that the factories can take parameters.\n\nAdded an API to request the \u0027next\u0027 type adapter for a type. This allows type adapters to compose other type adapters. We\u0027re using this in two places:\n - where the user has excluded a type from serialization but not deserialization, we need to use the \"default\" deserialization but interpose null on serialization. We create a type adapter that delegates for one and returns null for the other.\n - similarly when a DOM type serializer is registered but no deserializer, or vice versa.\nThis is the biggest change to the MiniGson core.\n\nFor backwards compatibility, return null for the empty string.\n\nSimplify JsonSerializationContext/JsonDeserializationContext to simply call through to GSON. SerializeDefault is currently unsupported.\n\nMore useful error messages when calling getAsBoolean on a JsonNull.\n\nRemove currently unused MemoryRefStack. We might need this back again, though wiring it back in will be much more difficult because we don\u0027t interject ourselves between the users\u0027 various type adapters.\n",
          "commitDate": "9/11/11, 12:04 AM",
          "commitName": "25c6ae177b1ca56db7f3c29eb574bdd032a06165",
          "commitAuthor": "Jesse Wilson",
          "commitDateOld": "9/9/11, 1:17 AM",
          "commitNameOld": "cdd5d80b85155c21c61f888fb3e70c65e72edef7",
          "commitAuthorOld": "Jesse Wilson",
          "daysBetweenCommits": 1.95,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "actualSource": "public \u003cT\u003e TypeAdapter\u003cT\u003e create(MiniGson context, TypeToken\u003cT\u003e typeToken) {\n    Type type \u003d typeToken.getType();\n    Class\u003c? super T\u003e rawType \u003d typeToken.getRawType();\n    if (!Collection.class.isAssignableFrom(rawType)) {\n        return null;\n    }\n    Type elementType \u003d $Gson$Types.getCollectionElementType(type, rawType);\n    TypeAdapter\u003c?\u003e elementTypeAdapter \u003d context.getAdapter(TypeToken.get(elementType));\n    ObjectConstructor\u003cT\u003e constructor \u003d constructorConstructor.getConstructor(typeToken);\n    @SuppressWarnings(\"unchecked\") TypeAdapter\u003cT\u003e result \u003d new Adapter(context, elementType, elementTypeAdapter, constructor);\n    return result;\n}",
          "path": "gson/src/main/java/com/google/gson/internal/bind/CollectionTypeAdapterFactory.java",
          "functionStartLine": 40,
          "functionName": "create",
          "functionAnnotation": "",
          "functionDoc": "",
          "diff": "@@ -1,28 +1,12 @@\n public \u003cT\u003e TypeAdapter\u003cT\u003e create(MiniGson context, TypeToken\u003cT\u003e typeToken) {\n     Type type \u003d typeToken.getType();\n     Class\u003c? super T\u003e rawType \u003d typeToken.getRawType();\n     if (!Collection.class.isAssignableFrom(rawType)) {\n         return null;\n     }\n     Type elementType \u003d $Gson$Types.getCollectionElementType(type, rawType);\n     TypeAdapter\u003c?\u003e elementTypeAdapter \u003d context.getAdapter(TypeToken.get(elementType));\n-    Class\u003c?\u003e constructorType;\n-    if (rawType \u003d\u003d List.class || rawType \u003d\u003d Collection.class) {\n-        constructorType \u003d ArrayList.class;\n-    } else if (rawType \u003d\u003d Set.class) {\n-        constructorType \u003d LinkedHashSet.class;\n-    } else if (rawType \u003d\u003d Queue.class) {\n-        constructorType \u003d LinkedList.class;\n-    } else if (rawType \u003d\u003d SortedSet.class) {\n-        constructorType \u003d TreeSet.class;\n-    } else {\n-        constructorType \u003d rawType;\n-    }\n-    Constructor\u003c?\u003e constructor \u003d null;\n-    try {\n-        constructor \u003d constructorType.getConstructor();\n-    } catch (NoSuchMethodException ignored) {\n-    }\n-    @SuppressWarnings(\"unchecked\") TypeAdapter\u003cT\u003e result \u003d new CollectionTypeAdapter(context, elementType, elementTypeAdapter, constructor);\n+    ObjectConstructor\u003cT\u003e constructor \u003d constructorConstructor.getConstructor(typeToken);\n+    @SuppressWarnings(\"unchecked\") TypeAdapter\u003cT\u003e result \u003d new Adapter(context, elementType, elementTypeAdapter, constructor);\n     return result;\n }\n\\ No newline at end of file\n",
          "extendedDetails": {}
        }
      ]
    },
    "6f6d3b221e563a1706727fce8bc26e83fee3144a": {
      "type": "Ybodychange",
      "commitMessage": "Added support for constructing Queues and SortedSet while handling collections.\n",
      "commitDate": "9/8/11, 10:49 PM",
      "commitName": "6f6d3b221e563a1706727fce8bc26e83fee3144a",
      "commitAuthor": "Inderjeet Singh",
      "commitDateOld": "9/8/11, 8:31 PM",
      "commitNameOld": "3aeb70e0305a598a9ceddc0390d693874dcc892d",
      "commitAuthorOld": "Jesse Wilson",
      "daysBetweenCommits": 0.1,
      "commitsBetweenForRepo": 15,
      "commitsBetweenForFile": 1,
      "actualSource": "public \u003cT\u003e TypeAdapter\u003cT\u003e create(MiniGson context, TypeToken\u003cT\u003e typeToken) {\n    Type type \u003d typeToken.getType();\n    Class\u003c? super T\u003e rawType \u003d typeToken.getRawType();\n    if (!Collection.class.isAssignableFrom(rawType)) {\n        return null;\n    }\n    Type elementType \u003d $Gson$Types.getCollectionElementType(type, rawType);\n    TypeAdapter\u003c?\u003e elementTypeAdapter \u003d context.getAdapter(TypeToken.get(elementType));\n    Class\u003c?\u003e constructorType;\n    if (rawType \u003d\u003d List.class || rawType \u003d\u003d Collection.class) {\n        constructorType \u003d ArrayList.class;\n    } else if (rawType \u003d\u003d Set.class) {\n        constructorType \u003d LinkedHashSet.class;\n    } else if (rawType \u003d\u003d Queue.class) {\n        constructorType \u003d LinkedList.class;\n    } else if (rawType \u003d\u003d SortedSet.class) {\n        constructorType \u003d TreeSet.class;\n    } else {\n        constructorType \u003d rawType;\n    }\n    Constructor\u003c?\u003e constructor \u003d null;\n    try {\n        constructor \u003d constructorType.getConstructor();\n    } catch (NoSuchMethodException ignored) {\n    }\n    @SuppressWarnings(\"unchecked\") TypeAdapter\u003cT\u003e result \u003d new CollectionTypeAdapter(context, elementType, elementTypeAdapter, constructor);\n    return result;\n}",
      "path": "gson/src/main/java/com/google/gson/internal/bind/CollectionTypeAdapter.java",
      "functionStartLine": 43,
      "functionName": "create",
      "functionAnnotation": "",
      "functionDoc": "",
      "diff": "@@ -1,24 +1,28 @@\n public \u003cT\u003e TypeAdapter\u003cT\u003e create(MiniGson context, TypeToken\u003cT\u003e typeToken) {\n     Type type \u003d typeToken.getType();\n     Class\u003c? super T\u003e rawType \u003d typeToken.getRawType();\n     if (!Collection.class.isAssignableFrom(rawType)) {\n         return null;\n     }\n     Type elementType \u003d $Gson$Types.getCollectionElementType(type, rawType);\n     TypeAdapter\u003c?\u003e elementTypeAdapter \u003d context.getAdapter(TypeToken.get(elementType));\n     Class\u003c?\u003e constructorType;\n     if (rawType \u003d\u003d List.class || rawType \u003d\u003d Collection.class) {\n         constructorType \u003d ArrayList.class;\n     } else if (rawType \u003d\u003d Set.class) {\n         constructorType \u003d LinkedHashSet.class;\n+    } else if (rawType \u003d\u003d Queue.class) {\n+        constructorType \u003d LinkedList.class;\n+    } else if (rawType \u003d\u003d SortedSet.class) {\n+        constructorType \u003d TreeSet.class;\n     } else {\n         constructorType \u003d rawType;\n     }\n     Constructor\u003c?\u003e constructor \u003d null;\n     try {\n         constructor \u003d constructorType.getConstructor();\n     } catch (NoSuchMethodException ignored) {\n     }\n     @SuppressWarnings(\"unchecked\") TypeAdapter\u003cT\u003e result \u003d new CollectionTypeAdapter(context, elementType, elementTypeAdapter, constructor);\n     return result;\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "3aeb70e0305a598a9ceddc0390d693874dcc892d": {
      "type": "Ybodychange",
      "commitMessage": "Adapter for Object.class\n",
      "commitDate": "9/8/11, 8:31 PM",
      "commitName": "3aeb70e0305a598a9ceddc0390d693874dcc892d",
      "commitAuthor": "Jesse Wilson",
      "commitDateOld": "8/4/11, 5:41 PM",
      "commitNameOld": "ad5ff0f2d9c08fb25d821bdc038934642c3c7367",
      "commitAuthorOld": "Inderjeet Singh",
      "daysBetweenCommits": 35.12,
      "commitsBetweenForRepo": 11,
      "commitsBetweenForFile": 1,
      "actualSource": "public \u003cT\u003e TypeAdapter\u003cT\u003e create(MiniGson context, TypeToken\u003cT\u003e typeToken) {\n    Type type \u003d typeToken.getType();\n    Class\u003c? super T\u003e rawType \u003d typeToken.getRawType();\n    if (!Collection.class.isAssignableFrom(rawType)) {\n        return null;\n    }\n    Type elementType \u003d $Gson$Types.getCollectionElementType(type, rawType);\n    TypeAdapter\u003c?\u003e elementTypeAdapter \u003d context.getAdapter(TypeToken.get(elementType));\n    Class\u003c?\u003e constructorType;\n    if (rawType \u003d\u003d List.class || rawType \u003d\u003d Collection.class) {\n        constructorType \u003d ArrayList.class;\n    } else if (rawType \u003d\u003d Set.class) {\n        constructorType \u003d LinkedHashSet.class;\n    } else {\n        constructorType \u003d rawType;\n    }\n    Constructor\u003c?\u003e constructor \u003d null;\n    try {\n        constructor \u003d constructorType.getConstructor();\n    } catch (NoSuchMethodException ignored) {\n    }\n    @SuppressWarnings(\"unchecked\") TypeAdapter\u003cT\u003e result \u003d new CollectionTypeAdapter(context, elementType, elementTypeAdapter, constructor);\n    return result;\n}",
      "path": "gson/src/main/java/com/google/gson/internal/bind/CollectionTypeAdapter.java",
      "functionStartLine": 39,
      "functionName": "create",
      "functionAnnotation": "",
      "functionDoc": "",
      "diff": "@@ -1,25 +1,24 @@\n public \u003cT\u003e TypeAdapter\u003cT\u003e create(MiniGson context, TypeToken\u003cT\u003e typeToken) {\n     Type type \u003d typeToken.getType();\n     Class\u003c? super T\u003e rawType \u003d typeToken.getRawType();\n     if (!Collection.class.isAssignableFrom(rawType)) {\n         return null;\n     }\n     Type elementType \u003d $Gson$Types.getCollectionElementType(type, rawType);\n     TypeAdapter\u003c?\u003e elementTypeAdapter \u003d context.getAdapter(TypeToken.get(elementType));\n     Class\u003c?\u003e constructorType;\n     if (rawType \u003d\u003d List.class || rawType \u003d\u003d Collection.class) {\n         constructorType \u003d ArrayList.class;\n     } else if (rawType \u003d\u003d Set.class) {\n         constructorType \u003d LinkedHashSet.class;\n     } else {\n         constructorType \u003d rawType;\n     }\n-    Constructor\u003c?\u003e constructor;\n+    Constructor\u003c?\u003e constructor \u003d null;\n     try {\n         constructor \u003d constructorType.getConstructor();\n-    } catch (NoSuchMethodException e) {\n-        return null;\n+    } catch (NoSuchMethodException ignored) {\n     }\n     @SuppressWarnings(\"unchecked\") TypeAdapter\u003cT\u003e result \u003d new CollectionTypeAdapter(context, elementType, elementTypeAdapter, constructor);\n     return result;\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "64dc53ffc40ac80925be50523e3c2cea6ad97da9": {
      "type": "Ybodychange",
      "commitMessage": "Added support for runtime type determination while serializing collections and its subclasses.\nThis currently doesn\u0027t work since Gson register a hierarchy type adapter for Collections that takes precedence over this.\n",
      "commitDate": "8/4/11, 4:55 PM",
      "commitName": "64dc53ffc40ac80925be50523e3c2cea6ad97da9",
      "commitAuthor": "Inderjeet Singh",
      "commitDateOld": "8/4/11, 4:02 PM",
      "commitNameOld": "6e3bf0730037fb3cb7aab7fe607fbe61ba5fe5e6",
      "commitAuthorOld": "Inderjeet Singh",
      "daysBetweenCommits": 0.04,
      "commitsBetweenForRepo": 3,
      "commitsBetweenForFile": 1,
      "actualSource": "public \u003cT\u003e TypeAdapter\u003cT\u003e create(MiniGson context, TypeToken\u003cT\u003e typeToken) {\n    Type type \u003d typeToken.getType();\n    Class\u003c? super T\u003e rawType \u003d typeToken.getRawType();\n    if (!Collection.class.isAssignableFrom(rawType)) {\n        return null;\n    }\n    Type elementType \u003d $Gson$Types.getCollectionElementType(type, rawType);\n    TypeAdapter\u003c?\u003e elementTypeAdapter \u003d context.getAdapter(TypeToken.get(elementType));\n    Class\u003c?\u003e constructorType;\n    if (rawType \u003d\u003d List.class || rawType \u003d\u003d Collection.class) {\n        constructorType \u003d ArrayList.class;\n    } else if (rawType \u003d\u003d Set.class) {\n        constructorType \u003d LinkedHashSet.class;\n    } else {\n        constructorType \u003d rawType;\n    }\n    Constructor\u003c?\u003e constructor;\n    try {\n        constructor \u003d constructorType.getConstructor();\n    } catch (NoSuchMethodException e) {\n        return null;\n    }\n    @SuppressWarnings(\"unchecked\") TypeAdapter\u003cT\u003e result \u003d new CollectionTypeAdapter(context, elementType, elementTypeAdapter, constructor);\n    return result;\n}",
      "path": "gson/src/main/java/com/google/gson/internal/bind/CollectionTypeAdapter.java",
      "functionStartLine": 39,
      "functionName": "create",
      "functionAnnotation": "",
      "functionDoc": "",
      "diff": "@@ -1,28 +1,25 @@\n public \u003cT\u003e TypeAdapter\u003cT\u003e create(MiniGson context, TypeToken\u003cT\u003e typeToken) {\n     Type type \u003d typeToken.getType();\n-    if (!(type instanceof ParameterizedType)) {\n-        return null;\n-    }\n     Class\u003c? super T\u003e rawType \u003d typeToken.getRawType();\n     if (!Collection.class.isAssignableFrom(rawType)) {\n         return null;\n     }\n     Type elementType \u003d $Gson$Types.getCollectionElementType(type, rawType);\n     TypeAdapter\u003c?\u003e elementTypeAdapter \u003d context.getAdapter(TypeToken.get(elementType));\n     Class\u003c?\u003e constructorType;\n     if (rawType \u003d\u003d List.class || rawType \u003d\u003d Collection.class) {\n         constructorType \u003d ArrayList.class;\n     } else if (rawType \u003d\u003d Set.class) {\n         constructorType \u003d LinkedHashSet.class;\n     } else {\n         constructorType \u003d rawType;\n     }\n     Constructor\u003c?\u003e constructor;\n     try {\n         constructor \u003d constructorType.getConstructor();\n     } catch (NoSuchMethodException e) {\n         return null;\n     }\n-    @SuppressWarnings(\"unchecked\") TypeAdapter\u003cT\u003e result \u003d new CollectionTypeAdapter(elementTypeAdapter, constructor);\n+    @SuppressWarnings(\"unchecked\") TypeAdapter\u003cT\u003e result \u003d new CollectionTypeAdapter(context, elementType, elementTypeAdapter, constructor);\n     return result;\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "60e6ed912d52716f46a1ba71923ef203c4248857": {
      "type": "Yfilerename",
      "commitMessage": "Promote MiniGson to gson.internal.bind\n",
      "commitDate": "8/2/11, 5:25 PM",
      "commitName": "60e6ed912d52716f46a1ba71923ef203c4248857",
      "commitAuthor": "Jesse Wilson",
      "commitDateOld": "8/2/11, 5:17 PM",
      "commitNameOld": "759eb8ede50f61fd525f5d703dd9fd45ddae1dcd",
      "commitAuthorOld": "Jesse Wilson",
      "daysBetweenCommits": 0.01,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "public \u003cT\u003e TypeAdapter\u003cT\u003e create(MiniGson context, TypeToken\u003cT\u003e typeToken) {\n    Type type \u003d typeToken.getType();\n    if (!(type instanceof ParameterizedType)) {\n        return null;\n    }\n    Class\u003c? super T\u003e rawType \u003d typeToken.getRawType();\n    if (!Collection.class.isAssignableFrom(rawType)) {\n        return null;\n    }\n    Type elementType \u003d $Gson$Types.getCollectionElementType(type, rawType);\n    TypeAdapter\u003c?\u003e elementTypeAdapter \u003d context.getAdapter(TypeToken.get(elementType));\n    Class\u003c?\u003e constructorType;\n    if (rawType \u003d\u003d List.class || rawType \u003d\u003d Collection.class) {\n        constructorType \u003d ArrayList.class;\n    } else if (rawType \u003d\u003d Set.class) {\n        constructorType \u003d LinkedHashSet.class;\n    } else {\n        constructorType \u003d rawType;\n    }\n    Constructor\u003c?\u003e constructor;\n    try {\n        constructor \u003d constructorType.getConstructor();\n    } catch (NoSuchMethodException e) {\n        return null;\n    }\n    @SuppressWarnings(\"unchecked\") TypeAdapter\u003cT\u003e result \u003d new CollectionTypeAdapter(elementTypeAdapter, constructor);\n    return result;\n}",
      "path": "gson/src/main/java/com/google/gson/internal/bind/CollectionTypeAdapter.java",
      "functionStartLine": 39,
      "functionName": "create",
      "functionAnnotation": "",
      "functionDoc": "",
      "diff": "",
      "extendedDetails": {
        "oldPath": "extras/src/main/java/com/google/gson/mini/CollectionTypeAdapter.java",
        "newPath": "gson/src/main/java/com/google/gson/internal/bind/CollectionTypeAdapter.java"
      }
    },
    "c6bef300579d96fe90e5be8240ee595ae8da66f1": {
      "type": "Ybodychange",
      "commitMessage": "Array support.\n",
      "commitDate": "7/11/11, 3:26 PM",
      "commitName": "c6bef300579d96fe90e5be8240ee595ae8da66f1",
      "commitAuthor": "Jesse Wilson",
      "commitDateOld": "7/11/11, 2:45 PM",
      "commitNameOld": "95a345234fb1d51ada03f37d50769cd5198b5af3",
      "commitAuthorOld": "Jesse Wilson",
      "daysBetweenCommits": 0.03,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "public \u003cT\u003e TypeAdapter\u003cT\u003e create(MiniGson context, TypeToken\u003cT\u003e typeToken) {\n    Type type \u003d typeToken.getType();\n    if (!(type instanceof ParameterizedType)) {\n        return null;\n    }\n    Class\u003c? super T\u003e rawType \u003d typeToken.getRawType();\n    if (!Collection.class.isAssignableFrom(rawType)) {\n        return null;\n    }\n    Type elementType \u003d $Gson$Types.getCollectionElementType(type, rawType);\n    TypeAdapter\u003c?\u003e elementTypeAdapter \u003d context.getAdapter(TypeToken.get(elementType));\n    Class\u003c?\u003e constructorType;\n    if (rawType \u003d\u003d List.class || rawType \u003d\u003d Collection.class) {\n        constructorType \u003d ArrayList.class;\n    } else if (rawType \u003d\u003d Set.class) {\n        constructorType \u003d LinkedHashSet.class;\n    } else {\n        constructorType \u003d rawType;\n    }\n    Constructor\u003c?\u003e constructor;\n    try {\n        constructor \u003d constructorType.getConstructor();\n    } catch (NoSuchMethodException e) {\n        return null;\n    }\n    @SuppressWarnings(\"unchecked\") TypeAdapter\u003cT\u003e result \u003d new CollectionTypeAdapter(elementTypeAdapter, constructor);\n    return result;\n}",
      "path": "extras/src/main/java/com/google/gson/mini/CollectionTypeAdapter.java",
      "functionStartLine": 39,
      "functionName": "create",
      "functionAnnotation": "",
      "functionDoc": "",
      "diff": "",
      "extendedDetails": {}
    },
    "c5f1df10175c254b823fc019832bf1bf7b71e929": {
      "type": "Yintroduced",
      "commitMessage": "MiniGSON prototype!\n",
      "commitDate": "7/11/11, 9:46 AM",
      "commitName": "c5f1df10175c254b823fc019832bf1bf7b71e929",
      "commitAuthor": "Jesse Wilson",
      "diff": "@@ -0,0 +1,28 @@\n+public \u003cT\u003e TypeAdapter\u003cT\u003e create(MiniGson context, TypeToken\u003cT\u003e typeToken) {\n+    Type type \u003d typeToken.getType();\n+    if (!(type instanceof ParameterizedType)) {\n+        return null;\n+    }\n+    Class\u003c? super T\u003e rawType \u003d typeToken.getRawType();\n+    if (!Collection.class.isAssignableFrom(rawType)) {\n+        return null;\n+    }\n+    Type elementType \u003d $Gson$Types.getCollectionElementType(type, rawType);\n+    TypeAdapter\u003c?\u003e elementTypeAdapter \u003d context.getAdapter(TypeToken.get(elementType));\n+    Class\u003c?\u003e constructorType;\n+    if (rawType \u003d\u003d List.class || rawType \u003d\u003d Collection.class) {\n+        constructorType \u003d ArrayList.class;\n+    } else if (rawType \u003d\u003d Set.class) {\n+        constructorType \u003d LinkedHashSet.class;\n+    } else {\n+        constructorType \u003d rawType;\n+    }\n+    Constructor\u003c?\u003e constructor;\n+    try {\n+        constructor \u003d constructorType.getConstructor();\n+    } catch (NoSuchMethodException e) {\n+        return null;\n+    }\n+    @SuppressWarnings(\"unchecked\") TypeAdapter\u003cT\u003e result \u003d new CollectionTypeAdapter(elementTypeAdapter, constructor);\n+    return result;\n+}\n\\ No newline at end of file\n",
      "actualSource": "public \u003cT\u003e TypeAdapter\u003cT\u003e create(MiniGson context, TypeToken\u003cT\u003e typeToken) {\n    Type type \u003d typeToken.getType();\n    if (!(type instanceof ParameterizedType)) {\n        return null;\n    }\n    Class\u003c? super T\u003e rawType \u003d typeToken.getRawType();\n    if (!Collection.class.isAssignableFrom(rawType)) {\n        return null;\n    }\n    Type elementType \u003d $Gson$Types.getCollectionElementType(type, rawType);\n    TypeAdapter\u003c?\u003e elementTypeAdapter \u003d context.getAdapter(TypeToken.get(elementType));\n    Class\u003c?\u003e constructorType;\n    if (rawType \u003d\u003d List.class || rawType \u003d\u003d Collection.class) {\n        constructorType \u003d ArrayList.class;\n    } else if (rawType \u003d\u003d Set.class) {\n        constructorType \u003d LinkedHashSet.class;\n    } else {\n        constructorType \u003d rawType;\n    }\n    Constructor\u003c?\u003e constructor;\n    try {\n        constructor \u003d constructorType.getConstructor();\n    } catch (NoSuchMethodException e) {\n        return null;\n    }\n    @SuppressWarnings(\"unchecked\") TypeAdapter\u003cT\u003e result \u003d new CollectionTypeAdapter(elementTypeAdapter, constructor);\n    return result;\n}",
      "path": "extras/src/main/java/com/google/gson/mini/CollectionTypeAdapter.java",
      "functionStartLine": 38,
      "functionName": "create",
      "functionAnnotation": "",
      "functionDoc": ""
    }
  }
}