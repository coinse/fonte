{
  "origin": "codeshovel",
  "repositoryName": "Gson-10b",
  "repositoryPath": "/tmp/Gson-10b//.git",
  "startCommitName": "HEAD",
  "sourceFileName": "ReflectiveTypeAdapterFactory.java",
  "functionName": "getBoundFields",
  "functionId": "getBoundFields___context-Gson__type-TypeToken__?____raw-Class__?__",
  "sourceFilePath": "gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java",
  "functionAnnotation": "",
  "functionDoc": "",
  "functionStartLine": 141,
  "functionEndLine": 177,
  "numCommitsSeen": 55,
  "timeTaken": 2375,
  "changeHistory": [
    "109915d93a2b36c26b49c0fabb1947a5a892cb25",
    "740d03ef0eb329dc7d046b903c985704587be081",
    "aa2f61b7d8defddc2a78de43b8042178241daedb",
    "e23973afec37fd1691f87a8c25dc8307c11b97e9",
    "7e760143fdc8b689daeebdee33ad6ea7d0a62a56",
    "25c6ae177b1ca56db7f3c29eb574bdd032a06165",
    "e04d3fa882e7829fc2b1d174a28e4e3640306696",
    "5c620c7e0a1f3e89dd0b42463aa4611950f282f1",
    "f1f8b666ec665b41446ddb3d68de115d8ce91d2f",
    "b922500c239406c755149e9a9ca1164a2e2e2c90",
    "f276d1382775e962d1a0a4b9e7e3e08496252861",
    "3331dcdab08792f6281ab6343532031a52f54003",
    "60e6ed912d52716f46a1ba71923ef203c4248857",
    "4b042671af018f308c2a261145dc6712e39b96e7",
    "3c4d121dc8736c7359731f9cb99098e2999f8575",
    "c5f1df10175c254b823fc019832bf1bf7b71e929"
  ],
  "changeHistoryShort": {
    "109915d93a2b36c26b49c0fabb1947a5a892cb25": "Ybodychange",
    "740d03ef0eb329dc7d046b903c985704587be081": "Ybodychange",
    "aa2f61b7d8defddc2a78de43b8042178241daedb": "Ybodychange",
    "e23973afec37fd1691f87a8c25dc8307c11b97e9": "Ybodychange",
    "7e760143fdc8b689daeebdee33ad6ea7d0a62a56": "Yparameterchange",
    "25c6ae177b1ca56db7f3c29eb574bdd032a06165": "Ymultichange(Ymovefromfile,Ybodychange)",
    "e04d3fa882e7829fc2b1d174a28e4e3640306696": "Ybodychange",
    "5c620c7e0a1f3e89dd0b42463aa4611950f282f1": "Ybodychange",
    "f1f8b666ec665b41446ddb3d68de115d8ce91d2f": "Ybodychange",
    "b922500c239406c755149e9a9ca1164a2e2e2c90": "Ybodychange",
    "f276d1382775e962d1a0a4b9e7e3e08496252861": "Ybodychange",
    "3331dcdab08792f6281ab6343532031a52f54003": "Ybodychange",
    "60e6ed912d52716f46a1ba71923ef203c4248857": "Yfilerename",
    "4b042671af018f308c2a261145dc6712e39b96e7": "Ymultichange(Yreturntypechange,Ybodychange)",
    "3c4d121dc8736c7359731f9cb99098e2999f8575": "Ybodychange",
    "c5f1df10175c254b823fc019832bf1bf7b71e929": "Yintroduced"
  },
  "changeHistoryDetails": {
    "109915d93a2b36c26b49c0fabb1947a5a892cb25": {
      "type": "Ybodychange",
      "commitMessage": "Implemented support for multiple values for SerializedName annotation.\n",
      "commitDate": "10/3/15, 2:01 AM",
      "commitName": "109915d93a2b36c26b49c0fabb1947a5a892cb25",
      "commitAuthor": "Inderjeet Singh",
      "commitDateOld": "11/16/14, 2:55 PM",
      "commitNameOld": "8d5a41329ec2f4db3aed02c20d379baf92840b37",
      "commitAuthorOld": "Inderjeet Singh",
      "daysBetweenCommits": 320.42,
      "commitsBetweenForRepo": 49,
      "commitsBetweenForFile": 1,
      "actualSource": "private Map\u003cString, BoundField\u003e getBoundFields(Gson context, TypeToken\u003c?\u003e type, Class\u003c?\u003e raw) {\n    Map\u003cString, BoundField\u003e result \u003d new LinkedHashMap\u003cString, BoundField\u003e();\n    if (raw.isInterface()) {\n        return result;\n    }\n    Type declaredType \u003d type.getType();\n    while (raw !\u003d Object.class) {\n        Field[] fields \u003d raw.getDeclaredFields();\n        for (Field field : fields) {\n            boolean serialize \u003d excludeField(field, true);\n            boolean deserialize \u003d excludeField(field, false);\n            if (!serialize \u0026\u0026 !deserialize) {\n                continue;\n            }\n            field.setAccessible(true);\n            Type fieldType \u003d $Gson$Types.resolve(type.getType(), raw, field.getGenericType());\n            List\u003cString\u003e fieldNames \u003d getFieldNames(field);\n            BoundField previous \u003d null;\n            for (int i \u003d 0; i \u003c fieldNames.size(); ++i) {\n                String name \u003d fieldNames.get(i);\n                if (i !\u003d 0)\n                    serialize \u003d false;\n                BoundField boundField \u003d createBoundField(context, field, name, TypeToken.get(fieldType), serialize, deserialize);\n                BoundField replaced \u003d result.put(name, boundField);\n                if (previous \u003d\u003d null)\n                    previous \u003d replaced;\n            }\n            if (previous !\u003d null) {\n                throw new IllegalArgumentException(declaredType + \" declares multiple JSON fields named \" + previous.name);\n            }\n        }\n        type \u003d TypeToken.get($Gson$Types.resolve(type.getType(), raw, raw.getGenericSuperclass()));\n        raw \u003d type.getRawType();\n    }\n    return result;\n}",
      "path": "gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java",
      "functionStartLine": 139,
      "functionName": "getBoundFields",
      "functionAnnotation": "",
      "functionDoc": "",
      "diff": "@@ -1,27 +1,36 @@\n private Map\u003cString, BoundField\u003e getBoundFields(Gson context, TypeToken\u003c?\u003e type, Class\u003c?\u003e raw) {\n     Map\u003cString, BoundField\u003e result \u003d new LinkedHashMap\u003cString, BoundField\u003e();\n     if (raw.isInterface()) {\n         return result;\n     }\n     Type declaredType \u003d type.getType();\n     while (raw !\u003d Object.class) {\n         Field[] fields \u003d raw.getDeclaredFields();\n         for (Field field : fields) {\n             boolean serialize \u003d excludeField(field, true);\n             boolean deserialize \u003d excludeField(field, false);\n             if (!serialize \u0026\u0026 !deserialize) {\n                 continue;\n             }\n             field.setAccessible(true);\n             Type fieldType \u003d $Gson$Types.resolve(type.getType(), raw, field.getGenericType());\n-            BoundField boundField \u003d createBoundField(context, field, getFieldName(field), TypeToken.get(fieldType), serialize, deserialize);\n-            BoundField previous \u003d result.put(boundField.name, boundField);\n+            List\u003cString\u003e fieldNames \u003d getFieldNames(field);\n+            BoundField previous \u003d null;\n+            for (int i \u003d 0; i \u003c fieldNames.size(); ++i) {\n+                String name \u003d fieldNames.get(i);\n+                if (i !\u003d 0)\n+                    serialize \u003d false;\n+                BoundField boundField \u003d createBoundField(context, field, name, TypeToken.get(fieldType), serialize, deserialize);\n+                BoundField replaced \u003d result.put(name, boundField);\n+                if (previous \u003d\u003d null)\n+                    previous \u003d replaced;\n+            }\n             if (previous !\u003d null) {\n                 throw new IllegalArgumentException(declaredType + \" declares multiple JSON fields named \" + previous.name);\n             }\n         }\n         type \u003d TypeToken.get($Gson$Types.resolve(type.getType(), raw, raw.getGenericSuperclass()));\n         raw \u003d type.getRawType();\n     }\n     return result;\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "740d03ef0eb329dc7d046b903c985704587be081": {
      "type": "Ybodychange",
      "commitMessage": "Don\u0027t call setAccessible(true) on fields we won\u0027t be setting or getting.\n\nFixes bug 191.\n",
      "commitDate": "12/28/11, 11:11 PM",
      "commitName": "740d03ef0eb329dc7d046b903c985704587be081",
      "commitAuthor": "Jesse Wilson",
      "commitDateOld": "12/23/11, 10:27 AM",
      "commitNameOld": "d7fbac03844aa86dbb1c65a8ba50ac364c4b2050",
      "commitAuthorOld": "Jesse Wilson",
      "daysBetweenCommits": 5.53,
      "commitsBetweenForRepo": 2,
      "commitsBetweenForFile": 1,
      "actualSource": "private Map\u003cString, BoundField\u003e getBoundFields(Gson context, TypeToken\u003c?\u003e type, Class\u003c?\u003e raw) {\n    Map\u003cString, BoundField\u003e result \u003d new LinkedHashMap\u003cString, BoundField\u003e();\n    if (raw.isInterface()) {\n        return result;\n    }\n    Type declaredType \u003d type.getType();\n    while (raw !\u003d Object.class) {\n        Field[] fields \u003d raw.getDeclaredFields();\n        for (Field field : fields) {\n            boolean serialize \u003d excludeField(field, true);\n            boolean deserialize \u003d excludeField(field, false);\n            if (!serialize \u0026\u0026 !deserialize) {\n                continue;\n            }\n            field.setAccessible(true);\n            Type fieldType \u003d $Gson$Types.resolve(type.getType(), raw, field.getGenericType());\n            BoundField boundField \u003d createBoundField(context, field, getFieldName(field), TypeToken.get(fieldType), serialize, deserialize);\n            BoundField previous \u003d result.put(boundField.name, boundField);\n            if (previous !\u003d null) {\n                throw new IllegalArgumentException(declaredType + \" declares multiple JSON fields named \" + previous.name);\n            }\n        }\n        type \u003d TypeToken.get($Gson$Types.resolve(type.getType(), raw, raw.getGenericSuperclass()));\n        raw \u003d type.getRawType();\n    }\n    return result;\n}",
      "path": "gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java",
      "functionStartLine": 102,
      "functionName": "getBoundFields",
      "functionAnnotation": "",
      "functionDoc": "",
      "diff": "@@ -1,27 +1,27 @@\n private Map\u003cString, BoundField\u003e getBoundFields(Gson context, TypeToken\u003c?\u003e type, Class\u003c?\u003e raw) {\n     Map\u003cString, BoundField\u003e result \u003d new LinkedHashMap\u003cString, BoundField\u003e();\n     if (raw.isInterface()) {\n         return result;\n     }\n     Type declaredType \u003d type.getType();\n     while (raw !\u003d Object.class) {\n         Field[] fields \u003d raw.getDeclaredFields();\n-        AccessibleObject.setAccessible(fields, true);\n         for (Field field : fields) {\n             boolean serialize \u003d excludeField(field, true);\n             boolean deserialize \u003d excludeField(field, false);\n             if (!serialize \u0026\u0026 !deserialize) {\n                 continue;\n             }\n+            field.setAccessible(true);\n             Type fieldType \u003d $Gson$Types.resolve(type.getType(), raw, field.getGenericType());\n             BoundField boundField \u003d createBoundField(context, field, getFieldName(field), TypeToken.get(fieldType), serialize, deserialize);\n             BoundField previous \u003d result.put(boundField.name, boundField);\n             if (previous !\u003d null) {\n                 throw new IllegalArgumentException(declaredType + \" declares multiple JSON fields named \" + previous.name);\n             }\n         }\n         type \u003d TypeToken.get($Gson$Types.resolve(type.getType(), raw, raw.getGenericSuperclass()));\n         raw \u003d type.getRawType();\n     }\n     return result;\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "aa2f61b7d8defddc2a78de43b8042178241daedb": {
      "type": "Ybodychange",
      "commitMessage": "Rename GsonExclusionStrategy to Excluder. The new class is its own factory, which simplifies its caller in GsonBuilder. It no longer implements ExclusionStrategy, which allows the callers to pass in a boolean for serialize/deserialize. This allows us to use one excluder for both code paths. The delegate ExclusionStrategy instances might end up not being shared so it has two lists internally.\n",
      "commitDate": "11/21/11, 11:37 PM",
      "commitName": "aa2f61b7d8defddc2a78de43b8042178241daedb",
      "commitAuthor": "Jesse Wilson",
      "commitDateOld": "11/20/11, 9:42 PM",
      "commitNameOld": "e23973afec37fd1691f87a8c25dc8307c11b97e9",
      "commitAuthorOld": "Jesse Wilson",
      "daysBetweenCommits": 1.08,
      "commitsBetweenForRepo": 5,
      "commitsBetweenForFile": 1,
      "actualSource": "private Map\u003cString, BoundField\u003e getBoundFields(Gson context, TypeToken\u003c?\u003e type, Class\u003c?\u003e raw) {\n    Map\u003cString, BoundField\u003e result \u003d new LinkedHashMap\u003cString, BoundField\u003e();\n    if (raw.isInterface()) {\n        return result;\n    }\n    Type declaredType \u003d type.getType();\n    while (raw !\u003d Object.class) {\n        Field[] fields \u003d raw.getDeclaredFields();\n        AccessibleObject.setAccessible(fields, true);\n        for (Field field : fields) {\n            boolean serialize \u003d excludeField(field, true);\n            boolean deserialize \u003d excludeField(field, false);\n            if (!serialize \u0026\u0026 !deserialize) {\n                continue;\n            }\n            Type fieldType \u003d $Gson$Types.resolve(type.getType(), raw, field.getGenericType());\n            BoundField boundField \u003d createBoundField(context, field, getFieldName(field), TypeToken.get(fieldType), serialize, deserialize);\n            BoundField previous \u003d result.put(boundField.name, boundField);\n            if (previous !\u003d null) {\n                throw new IllegalArgumentException(declaredType + \" declares multiple JSON fields named \" + previous.name);\n            }\n        }\n        type \u003d TypeToken.get($Gson$Types.resolve(type.getType(), raw, raw.getGenericSuperclass()));\n        raw \u003d type.getRawType();\n    }\n    return result;\n}",
      "path": "gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java",
      "functionStartLine": 101,
      "functionName": "getBoundFields",
      "functionAnnotation": "",
      "functionDoc": "",
      "diff": "@@ -1,27 +1,27 @@\n private Map\u003cString, BoundField\u003e getBoundFields(Gson context, TypeToken\u003c?\u003e type, Class\u003c?\u003e raw) {\n     Map\u003cString, BoundField\u003e result \u003d new LinkedHashMap\u003cString, BoundField\u003e();\n     if (raw.isInterface()) {\n         return result;\n     }\n     Type declaredType \u003d type.getType();\n     while (raw !\u003d Object.class) {\n         Field[] fields \u003d raw.getDeclaredFields();\n         AccessibleObject.setAccessible(fields, true);\n         for (Field field : fields) {\n-            boolean serialize \u003d serializeField(field);\n-            boolean deserialize \u003d deserializeField(field);\n+            boolean serialize \u003d excludeField(field, true);\n+            boolean deserialize \u003d excludeField(field, false);\n             if (!serialize \u0026\u0026 !deserialize) {\n                 continue;\n             }\n             Type fieldType \u003d $Gson$Types.resolve(type.getType(), raw, field.getGenericType());\n             BoundField boundField \u003d createBoundField(context, field, getFieldName(field), TypeToken.get(fieldType), serialize, deserialize);\n             BoundField previous \u003d result.put(boundField.name, boundField);\n             if (previous !\u003d null) {\n                 throw new IllegalArgumentException(declaredType + \" declares multiple JSON fields named \" + previous.name);\n             }\n         }\n         type \u003d TypeToken.get($Gson$Types.resolve(type.getType(), raw, raw.getGenericSuperclass()));\n         raw \u003d type.getRawType();\n     }\n     return result;\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "e23973afec37fd1691f87a8c25dc8307c11b97e9": {
      "type": "Ybodychange",
      "commitMessage": "Smash together ReflectiveTypeAdapterFactory and its subclass. The separation was useful earlier when we were contemplating keeping Gson and MiniGson separate.\n",
      "commitDate": "11/20/11, 9:42 PM",
      "commitName": "e23973afec37fd1691f87a8c25dc8307c11b97e9",
      "commitAuthor": "Jesse Wilson",
      "commitDateOld": "11/20/11, 7:23 AM",
      "commitNameOld": "7e760143fdc8b689daeebdee33ad6ea7d0a62a56",
      "commitAuthorOld": "Jesse Wilson",
      "daysBetweenCommits": 0.6,
      "commitsBetweenForRepo": 10,
      "commitsBetweenForFile": 1,
      "actualSource": "private Map\u003cString, BoundField\u003e getBoundFields(Gson context, TypeToken\u003c?\u003e type, Class\u003c?\u003e raw) {\n    Map\u003cString, BoundField\u003e result \u003d new LinkedHashMap\u003cString, BoundField\u003e();\n    if (raw.isInterface()) {\n        return result;\n    }\n    Type declaredType \u003d type.getType();\n    while (raw !\u003d Object.class) {\n        Field[] fields \u003d raw.getDeclaredFields();\n        AccessibleObject.setAccessible(fields, true);\n        for (Field field : fields) {\n            boolean serialize \u003d serializeField(field);\n            boolean deserialize \u003d deserializeField(field);\n            if (!serialize \u0026\u0026 !deserialize) {\n                continue;\n            }\n            Type fieldType \u003d $Gson$Types.resolve(type.getType(), raw, field.getGenericType());\n            BoundField boundField \u003d createBoundField(context, field, getFieldName(field), TypeToken.get(fieldType), serialize, deserialize);\n            BoundField previous \u003d result.put(boundField.name, boundField);\n            if (previous !\u003d null) {\n                throw new IllegalArgumentException(declaredType + \" declares multiple JSON fields named \" + previous.name);\n            }\n        }\n        type \u003d TypeToken.get($Gson$Types.resolve(type.getType(), raw, raw.getGenericSuperclass()));\n        raw \u003d type.getRawType();\n    }\n    return result;\n}",
      "path": "gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java",
      "functionStartLine": 111,
      "functionName": "getBoundFields",
      "functionAnnotation": "",
      "functionDoc": "",
      "diff": "@@ -1,27 +1,27 @@\n private Map\u003cString, BoundField\u003e getBoundFields(Gson context, TypeToken\u003c?\u003e type, Class\u003c?\u003e raw) {\n     Map\u003cString, BoundField\u003e result \u003d new LinkedHashMap\u003cString, BoundField\u003e();\n     if (raw.isInterface()) {\n         return result;\n     }\n     Type declaredType \u003d type.getType();\n     while (raw !\u003d Object.class) {\n         Field[] fields \u003d raw.getDeclaredFields();\n         AccessibleObject.setAccessible(fields, true);\n         for (Field field : fields) {\n-            boolean serialize \u003d serializeField(raw, field, declaredType);\n-            boolean deserialize \u003d deserializeField(raw, field, declaredType);\n+            boolean serialize \u003d serializeField(field);\n+            boolean deserialize \u003d deserializeField(field);\n             if (!serialize \u0026\u0026 !deserialize) {\n                 continue;\n             }\n             Type fieldType \u003d $Gson$Types.resolve(type.getType(), raw, field.getGenericType());\n-            BoundField boundField \u003d createBoundField(context, field, getFieldName(raw, field, declaredType), TypeToken.get(fieldType), serialize, deserialize);\n+            BoundField boundField \u003d createBoundField(context, field, getFieldName(field), TypeToken.get(fieldType), serialize, deserialize);\n             BoundField previous \u003d result.put(boundField.name, boundField);\n             if (previous !\u003d null) {\n                 throw new IllegalArgumentException(declaredType + \" declares multiple JSON fields named \" + previous.name);\n             }\n         }\n         type \u003d TypeToken.get($Gson$Types.resolve(type.getType(), raw, raw.getGenericSuperclass()));\n         raw \u003d type.getRawType();\n     }\n     return result;\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "7e760143fdc8b689daeebdee33ad6ea7d0a62a56": {
      "type": "Yparameterchange",
      "commitMessage": "Smash together MiniGson and Gson. This changes Gson to be the MiniGson rather than delegating to the MiniGson. It means that the MiniGson objects passed into streaming type adapters are now fully-capable \u0027Gson\u0027 objects. \n\nThe most notable impact of this change is that it adds several new public APIs:\n - The TypeAdapter abstract class\n - The TypeAdapter.Factory interface\n - Four new methods on GsonBuilder to register streaming TypeAdapters (via Factory, via Class, via TypeToken, and as a type hierarchy)\n - Three new methods on Gson to lookup streaming TypeAdapters (by type, by class, and to get the next type adapter) \n\nStill outstanding:\n - Write beautiful prose to document the new APIs above\n - Change GsonBuilder\u0027s precedence so that both old and new-style type adapters are registered in one lot\n",
      "commitDate": "11/20/11, 7:23 AM",
      "commitName": "7e760143fdc8b689daeebdee33ad6ea7d0a62a56",
      "commitAuthor": "Jesse Wilson",
      "commitDateOld": "10/20/11, 2:32 PM",
      "commitNameOld": "31964507c1caabc9a70e3270fa56aaee29eff6b2",
      "commitAuthorOld": "Inderjeet Singh",
      "daysBetweenCommits": 30.74,
      "commitsBetweenForRepo": 25,
      "commitsBetweenForFile": 1,
      "actualSource": "private Map\u003cString, BoundField\u003e getBoundFields(Gson context, TypeToken\u003c?\u003e type, Class\u003c?\u003e raw) {\n    Map\u003cString, BoundField\u003e result \u003d new LinkedHashMap\u003cString, BoundField\u003e();\n    if (raw.isInterface()) {\n        return result;\n    }\n    Type declaredType \u003d type.getType();\n    while (raw !\u003d Object.class) {\n        Field[] fields \u003d raw.getDeclaredFields();\n        AccessibleObject.setAccessible(fields, true);\n        for (Field field : fields) {\n            boolean serialize \u003d serializeField(raw, field, declaredType);\n            boolean deserialize \u003d deserializeField(raw, field, declaredType);\n            if (!serialize \u0026\u0026 !deserialize) {\n                continue;\n            }\n            Type fieldType \u003d $Gson$Types.resolve(type.getType(), raw, field.getGenericType());\n            BoundField boundField \u003d createBoundField(context, field, getFieldName(raw, field, declaredType), TypeToken.get(fieldType), serialize, deserialize);\n            BoundField previous \u003d result.put(boundField.name, boundField);\n            if (previous !\u003d null) {\n                throw new IllegalArgumentException(declaredType + \" declares multiple JSON fields named \" + previous.name);\n            }\n        }\n        type \u003d TypeToken.get($Gson$Types.resolve(type.getType(), raw, raw.getGenericSuperclass()));\n        raw \u003d type.getRawType();\n    }\n    return result;\n}",
      "path": "gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java",
      "functionStartLine": 96,
      "functionName": "getBoundFields",
      "functionAnnotation": "",
      "functionDoc": "",
      "diff": "@@ -1,27 +1,27 @@\n-private Map\u003cString, BoundField\u003e getBoundFields(MiniGson context, TypeToken\u003c?\u003e type, Class\u003c?\u003e raw) {\n+private Map\u003cString, BoundField\u003e getBoundFields(Gson context, TypeToken\u003c?\u003e type, Class\u003c?\u003e raw) {\n     Map\u003cString, BoundField\u003e result \u003d new LinkedHashMap\u003cString, BoundField\u003e();\n     if (raw.isInterface()) {\n         return result;\n     }\n     Type declaredType \u003d type.getType();\n     while (raw !\u003d Object.class) {\n         Field[] fields \u003d raw.getDeclaredFields();\n         AccessibleObject.setAccessible(fields, true);\n         for (Field field : fields) {\n             boolean serialize \u003d serializeField(raw, field, declaredType);\n             boolean deserialize \u003d deserializeField(raw, field, declaredType);\n             if (!serialize \u0026\u0026 !deserialize) {\n                 continue;\n             }\n             Type fieldType \u003d $Gson$Types.resolve(type.getType(), raw, field.getGenericType());\n             BoundField boundField \u003d createBoundField(context, field, getFieldName(raw, field, declaredType), TypeToken.get(fieldType), serialize, deserialize);\n             BoundField previous \u003d result.put(boundField.name, boundField);\n             if (previous !\u003d null) {\n                 throw new IllegalArgumentException(declaredType + \" declares multiple JSON fields named \" + previous.name);\n             }\n         }\n         type \u003d TypeToken.get($Gson$Types.resolve(type.getType(), raw, raw.getGenericSuperclass()));\n         raw \u003d type.getRawType();\n     }\n     return result;\n }\n\\ No newline at end of file\n",
      "extendedDetails": {
        "oldValue": "[context-MiniGson, type-TypeToken\u003c?\u003e, raw-Class\u003c?\u003e]",
        "newValue": "[context-Gson, type-TypeToken\u003c?\u003e, raw-Class\u003c?\u003e]"
      }
    },
    "25c6ae177b1ca56db7f3c29eb574bdd032a06165": {
      "type": "Ymultichange(Ymovefromfile,Ybodychange)",
      "commitMessage": "Down to 22 failing tests.\n\nConsolidated all of the different code paths that we use to construct instances. We now have an ObjectConstructor class that knows what type it constructs; this means that we don\u0027t need to ever do reflection to lookup a constructor at construction time.\n\nCleaned up some buggy type adapters, particularly around handling of null.\n\nRemoved dead code for object graph navigation.\n\nMoved some classes into \u0027internal\u0027 so they are visible to the \u0027bind\u0027 subpackage.\n\nTurned some TypeAdapterFactory/TypeAdapter pairs inside out so that the TypeAdapter is now the inner class. This is necessary so that the factories can take parameters.\n\nAdded an API to request the \u0027next\u0027 type adapter for a type. This allows type adapters to compose other type adapters. We\u0027re using this in two places:\n - where the user has excluded a type from serialization but not deserialization, we need to use the \"default\" deserialization but interpose null on serialization. We create a type adapter that delegates for one and returns null for the other.\n - similarly when a DOM type serializer is registered but no deserializer, or vice versa.\nThis is the biggest change to the MiniGson core.\n\nFor backwards compatibility, return null for the empty string.\n\nSimplify JsonSerializationContext/JsonDeserializationContext to simply call through to GSON. SerializeDefault is currently unsupported.\n\nMore useful error messages when calling getAsBoolean on a JsonNull.\n\nRemove currently unused MemoryRefStack. We might need this back again, though wiring it back in will be much more difficult because we don\u0027t interject ourselves between the users\u0027 various type adapters.\n",
      "commitDate": "9/11/11, 12:04 AM",
      "commitName": "25c6ae177b1ca56db7f3c29eb574bdd032a06165",
      "commitAuthor": "Jesse Wilson",
      "subchanges": [
        {
          "type": "Ymovefromfile",
          "commitMessage": "Down to 22 failing tests.\n\nConsolidated all of the different code paths that we use to construct instances. We now have an ObjectConstructor class that knows what type it constructs; this means that we don\u0027t need to ever do reflection to lookup a constructor at construction time.\n\nCleaned up some buggy type adapters, particularly around handling of null.\n\nRemoved dead code for object graph navigation.\n\nMoved some classes into \u0027internal\u0027 so they are visible to the \u0027bind\u0027 subpackage.\n\nTurned some TypeAdapterFactory/TypeAdapter pairs inside out so that the TypeAdapter is now the inner class. This is necessary so that the factories can take parameters.\n\nAdded an API to request the \u0027next\u0027 type adapter for a type. This allows type adapters to compose other type adapters. We\u0027re using this in two places:\n - where the user has excluded a type from serialization but not deserialization, we need to use the \"default\" deserialization but interpose null on serialization. We create a type adapter that delegates for one and returns null for the other.\n - similarly when a DOM type serializer is registered but no deserializer, or vice versa.\nThis is the biggest change to the MiniGson core.\n\nFor backwards compatibility, return null for the empty string.\n\nSimplify JsonSerializationContext/JsonDeserializationContext to simply call through to GSON. SerializeDefault is currently unsupported.\n\nMore useful error messages when calling getAsBoolean on a JsonNull.\n\nRemove currently unused MemoryRefStack. We might need this back again, though wiring it back in will be much more difficult because we don\u0027t interject ourselves between the users\u0027 various type adapters.\n",
          "commitDate": "9/11/11, 12:04 AM",
          "commitName": "25c6ae177b1ca56db7f3c29eb574bdd032a06165",
          "commitAuthor": "Jesse Wilson",
          "commitDateOld": "9/9/11, 1:17 AM",
          "commitNameOld": "cdd5d80b85155c21c61f888fb3e70c65e72edef7",
          "commitAuthorOld": "Jesse Wilson",
          "daysBetweenCommits": 1.95,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "actualSource": "private Map\u003cString, BoundField\u003e getBoundFields(MiniGson context, TypeToken\u003c?\u003e type, Class\u003c?\u003e raw) {\n    Map\u003cString, BoundField\u003e result \u003d new LinkedHashMap\u003cString, BoundField\u003e();\n    if (raw.isInterface()) {\n        return result;\n    }\n    Type declaredType \u003d type.getType();\n    while (raw !\u003d Object.class) {\n        Field[] fields \u003d raw.getDeclaredFields();\n        AccessibleObject.setAccessible(fields, true);\n        for (Field field : fields) {\n            boolean serialize \u003d serializeField(raw, field, declaredType);\n            boolean deserialize \u003d deserializeField(raw, field, declaredType);\n            if (!serialize \u0026\u0026 !deserialize) {\n                continue;\n            }\n            Type fieldType \u003d $Gson$Types.resolve(type.getType(), raw, field.getGenericType());\n            BoundField boundField \u003d createBoundField(context, field, getFieldName(raw, field, declaredType), TypeToken.get(fieldType), serialize, deserialize);\n            BoundField previous \u003d result.put(boundField.name, boundField);\n            if (previous !\u003d null) {\n                throw new IllegalArgumentException(declaredType + \" declares multiple JSON fields named \" + previous.name);\n            }\n        }\n        type \u003d TypeToken.get($Gson$Types.resolve(type.getType(), raw, raw.getGenericSuperclass()));\n        raw \u003d type.getRawType();\n    }\n    return result;\n}",
          "path": "gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java",
          "functionStartLine": 96,
          "functionName": "getBoundFields",
          "functionAnnotation": "",
          "functionDoc": "",
          "diff": "@@ -1,26 +1,27 @@\n private Map\u003cString, BoundField\u003e getBoundFields(MiniGson context, TypeToken\u003c?\u003e type, Class\u003c?\u003e raw) {\n     Map\u003cString, BoundField\u003e result \u003d new LinkedHashMap\u003cString, BoundField\u003e();\n     if (raw.isInterface()) {\n         return result;\n     }\n     Type declaredType \u003d type.getType();\n     while (raw !\u003d Object.class) {\n         Field[] fields \u003d raw.getDeclaredFields();\n         AccessibleObject.setAccessible(fields, true);\n         for (Field field : fields) {\n             boolean serialize \u003d serializeField(raw, field, declaredType);\n             boolean deserialize \u003d deserializeField(raw, field, declaredType);\n-            if (serialize || deserialize) {\n-                Type fieldType \u003d $Gson$Types.resolve(type.getType(), raw, field.getGenericType());\n-                BoundField boundField \u003d createBoundField(context, field, getFieldName(raw, field, declaredType), TypeToken.get(fieldType), serialize, deserialize);\n-                BoundField previous \u003d result.put(boundField.name, boundField);\n-                if (previous !\u003d null) {\n-                    throw new IllegalArgumentException(declaredType + \" declares multiple JSON fields named \" + previous.name);\n-                }\n+            if (!serialize \u0026\u0026 !deserialize) {\n+                continue;\n+            }\n+            Type fieldType \u003d $Gson$Types.resolve(type.getType(), raw, field.getGenericType());\n+            BoundField boundField \u003d createBoundField(context, field, getFieldName(raw, field, declaredType), TypeToken.get(fieldType), serialize, deserialize);\n+            BoundField previous \u003d result.put(boundField.name, boundField);\n+            if (previous !\u003d null) {\n+                throw new IllegalArgumentException(declaredType + \" declares multiple JSON fields named \" + previous.name);\n             }\n         }\n         type \u003d TypeToken.get($Gson$Types.resolve(type.getType(), raw, raw.getGenericSuperclass()));\n         raw \u003d type.getRawType();\n     }\n     return result;\n }\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldPath": "gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapter.java",
            "newPath": "gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java",
            "oldMethodName": "getBoundFields",
            "newMethodName": "getBoundFields"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "Down to 22 failing tests.\n\nConsolidated all of the different code paths that we use to construct instances. We now have an ObjectConstructor class that knows what type it constructs; this means that we don\u0027t need to ever do reflection to lookup a constructor at construction time.\n\nCleaned up some buggy type adapters, particularly around handling of null.\n\nRemoved dead code for object graph navigation.\n\nMoved some classes into \u0027internal\u0027 so they are visible to the \u0027bind\u0027 subpackage.\n\nTurned some TypeAdapterFactory/TypeAdapter pairs inside out so that the TypeAdapter is now the inner class. This is necessary so that the factories can take parameters.\n\nAdded an API to request the \u0027next\u0027 type adapter for a type. This allows type adapters to compose other type adapters. We\u0027re using this in two places:\n - where the user has excluded a type from serialization but not deserialization, we need to use the \"default\" deserialization but interpose null on serialization. We create a type adapter that delegates for one and returns null for the other.\n - similarly when a DOM type serializer is registered but no deserializer, or vice versa.\nThis is the biggest change to the MiniGson core.\n\nFor backwards compatibility, return null for the empty string.\n\nSimplify JsonSerializationContext/JsonDeserializationContext to simply call through to GSON. SerializeDefault is currently unsupported.\n\nMore useful error messages when calling getAsBoolean on a JsonNull.\n\nRemove currently unused MemoryRefStack. We might need this back again, though wiring it back in will be much more difficult because we don\u0027t interject ourselves between the users\u0027 various type adapters.\n",
          "commitDate": "9/11/11, 12:04 AM",
          "commitName": "25c6ae177b1ca56db7f3c29eb574bdd032a06165",
          "commitAuthor": "Jesse Wilson",
          "commitDateOld": "9/9/11, 1:17 AM",
          "commitNameOld": "cdd5d80b85155c21c61f888fb3e70c65e72edef7",
          "commitAuthorOld": "Jesse Wilson",
          "daysBetweenCommits": 1.95,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "actualSource": "private Map\u003cString, BoundField\u003e getBoundFields(MiniGson context, TypeToken\u003c?\u003e type, Class\u003c?\u003e raw) {\n    Map\u003cString, BoundField\u003e result \u003d new LinkedHashMap\u003cString, BoundField\u003e();\n    if (raw.isInterface()) {\n        return result;\n    }\n    Type declaredType \u003d type.getType();\n    while (raw !\u003d Object.class) {\n        Field[] fields \u003d raw.getDeclaredFields();\n        AccessibleObject.setAccessible(fields, true);\n        for (Field field : fields) {\n            boolean serialize \u003d serializeField(raw, field, declaredType);\n            boolean deserialize \u003d deserializeField(raw, field, declaredType);\n            if (!serialize \u0026\u0026 !deserialize) {\n                continue;\n            }\n            Type fieldType \u003d $Gson$Types.resolve(type.getType(), raw, field.getGenericType());\n            BoundField boundField \u003d createBoundField(context, field, getFieldName(raw, field, declaredType), TypeToken.get(fieldType), serialize, deserialize);\n            BoundField previous \u003d result.put(boundField.name, boundField);\n            if (previous !\u003d null) {\n                throw new IllegalArgumentException(declaredType + \" declares multiple JSON fields named \" + previous.name);\n            }\n        }\n        type \u003d TypeToken.get($Gson$Types.resolve(type.getType(), raw, raw.getGenericSuperclass()));\n        raw \u003d type.getRawType();\n    }\n    return result;\n}",
          "path": "gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java",
          "functionStartLine": 96,
          "functionName": "getBoundFields",
          "functionAnnotation": "",
          "functionDoc": "",
          "diff": "@@ -1,26 +1,27 @@\n private Map\u003cString, BoundField\u003e getBoundFields(MiniGson context, TypeToken\u003c?\u003e type, Class\u003c?\u003e raw) {\n     Map\u003cString, BoundField\u003e result \u003d new LinkedHashMap\u003cString, BoundField\u003e();\n     if (raw.isInterface()) {\n         return result;\n     }\n     Type declaredType \u003d type.getType();\n     while (raw !\u003d Object.class) {\n         Field[] fields \u003d raw.getDeclaredFields();\n         AccessibleObject.setAccessible(fields, true);\n         for (Field field : fields) {\n             boolean serialize \u003d serializeField(raw, field, declaredType);\n             boolean deserialize \u003d deserializeField(raw, field, declaredType);\n-            if (serialize || deserialize) {\n-                Type fieldType \u003d $Gson$Types.resolve(type.getType(), raw, field.getGenericType());\n-                BoundField boundField \u003d createBoundField(context, field, getFieldName(raw, field, declaredType), TypeToken.get(fieldType), serialize, deserialize);\n-                BoundField previous \u003d result.put(boundField.name, boundField);\n-                if (previous !\u003d null) {\n-                    throw new IllegalArgumentException(declaredType + \" declares multiple JSON fields named \" + previous.name);\n-                }\n+            if (!serialize \u0026\u0026 !deserialize) {\n+                continue;\n+            }\n+            Type fieldType \u003d $Gson$Types.resolve(type.getType(), raw, field.getGenericType());\n+            BoundField boundField \u003d createBoundField(context, field, getFieldName(raw, field, declaredType), TypeToken.get(fieldType), serialize, deserialize);\n+            BoundField previous \u003d result.put(boundField.name, boundField);\n+            if (previous !\u003d null) {\n+                throw new IllegalArgumentException(declaredType + \" declares multiple JSON fields named \" + previous.name);\n             }\n         }\n         type \u003d TypeToken.get($Gson$Types.resolve(type.getType(), raw, raw.getGenericSuperclass()));\n         raw \u003d type.getRawType();\n     }\n     return result;\n }\n\\ No newline at end of file\n",
          "extendedDetails": {}
        }
      ]
    },
    "e04d3fa882e7829fc2b1d174a28e4e3640306696": {
      "type": "Ybodychange",
      "commitMessage": "Don\u0027t look for instance fields on interfaces.\n",
      "commitDate": "8/4/11, 4:53 PM",
      "commitName": "e04d3fa882e7829fc2b1d174a28e4e3640306696",
      "commitAuthor": "Jesse Wilson",
      "commitDateOld": "8/4/11, 4:02 PM",
      "commitNameOld": "6e3bf0730037fb3cb7aab7fe607fbe61ba5fe5e6",
      "commitAuthorOld": "Inderjeet Singh",
      "daysBetweenCommits": 0.04,
      "commitsBetweenForRepo": 2,
      "commitsBetweenForFile": 1,
      "actualSource": "private Map\u003cString, BoundField\u003e getBoundFields(MiniGson context, TypeToken\u003c?\u003e type, Class\u003c?\u003e raw) {\n    Map\u003cString, BoundField\u003e result \u003d new LinkedHashMap\u003cString, BoundField\u003e();\n    if (raw.isInterface()) {\n        return result;\n    }\n    Type declaredType \u003d type.getType();\n    while (raw !\u003d Object.class) {\n        Field[] fields \u003d raw.getDeclaredFields();\n        AccessibleObject.setAccessible(fields, true);\n        for (Field field : fields) {\n            boolean serialize \u003d serializeField(raw, field, declaredType);\n            boolean deserialize \u003d deserializeField(raw, field, declaredType);\n            if (serialize || deserialize) {\n                Type fieldType \u003d $Gson$Types.resolve(type.getType(), raw, field.getGenericType());\n                BoundField boundField \u003d createBoundField(context, field, getFieldName(raw, field, declaredType), TypeToken.get(fieldType), serialize, deserialize);\n                BoundField previous \u003d result.put(boundField.name, boundField);\n                if (previous !\u003d null) {\n                    throw new IllegalArgumentException(declaredType + \" declares multiple JSON fields named \" + previous.name);\n                }\n            }\n        }\n        type \u003d TypeToken.get($Gson$Types.resolve(type.getType(), raw, raw.getGenericSuperclass()));\n        raw \u003d type.getRawType();\n    }\n    return result;\n}",
      "path": "gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapter.java",
      "functionStartLine": 166,
      "functionName": "getBoundFields",
      "functionAnnotation": "",
      "functionDoc": "",
      "diff": "@@ -1,23 +1,26 @@\n private Map\u003cString, BoundField\u003e getBoundFields(MiniGson context, TypeToken\u003c?\u003e type, Class\u003c?\u003e raw) {\n     Map\u003cString, BoundField\u003e result \u003d new LinkedHashMap\u003cString, BoundField\u003e();\n+    if (raw.isInterface()) {\n+        return result;\n+    }\n     Type declaredType \u003d type.getType();\n     while (raw !\u003d Object.class) {\n         Field[] fields \u003d raw.getDeclaredFields();\n         AccessibleObject.setAccessible(fields, true);\n         for (Field field : fields) {\n             boolean serialize \u003d serializeField(raw, field, declaredType);\n             boolean deserialize \u003d deserializeField(raw, field, declaredType);\n             if (serialize || deserialize) {\n                 Type fieldType \u003d $Gson$Types.resolve(type.getType(), raw, field.getGenericType());\n                 BoundField boundField \u003d createBoundField(context, field, getFieldName(raw, field, declaredType), TypeToken.get(fieldType), serialize, deserialize);\n                 BoundField previous \u003d result.put(boundField.name, boundField);\n                 if (previous !\u003d null) {\n                     throw new IllegalArgumentException(declaredType + \" declares multiple JSON fields named \" + previous.name);\n                 }\n             }\n         }\n         type \u003d TypeToken.get($Gson$Types.resolve(type.getType(), raw, raw.getGenericSuperclass()));\n         raw \u003d type.getRawType();\n     }\n     return result;\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "5c620c7e0a1f3e89dd0b42463aa4611950f282f1": {
      "type": "Ybodychange",
      "commitMessage": "Changed Gson behavior to reject duplicate fields in a class.\n",
      "commitDate": "8/2/11, 8:05 PM",
      "commitName": "5c620c7e0a1f3e89dd0b42463aa4611950f282f1",
      "commitAuthor": "Inderjeet Singh",
      "commitDateOld": "8/2/11, 7:51 PM",
      "commitNameOld": "f1f8b666ec665b41446ddb3d68de115d8ce91d2f",
      "commitAuthorOld": "Inderjeet Singh",
      "daysBetweenCommits": 0.01,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "private Map\u003cString, BoundField\u003e getBoundFields(MiniGson context, TypeToken\u003c?\u003e type, Class\u003c?\u003e raw) {\n    Map\u003cString, BoundField\u003e result \u003d new LinkedHashMap\u003cString, BoundField\u003e();\n    Type declaredType \u003d type.getType();\n    while (raw !\u003d Object.class) {\n        Field[] fields \u003d raw.getDeclaredFields();\n        AccessibleObject.setAccessible(fields, true);\n        for (Field field : fields) {\n            boolean serialize \u003d serializeField(raw, field, declaredType);\n            boolean deserialize \u003d deserializeField(raw, field, declaredType);\n            if (serialize || deserialize) {\n                Type fieldType \u003d $Gson$Types.resolve(type.getType(), raw, field.getGenericType());\n                BoundField boundField \u003d createBoundField(context, field, getFieldName(raw, field, declaredType), TypeToken.get(fieldType), serialize, deserialize);\n                BoundField previous \u003d result.put(boundField.name, boundField);\n                if (previous !\u003d null) {\n                    throw new IllegalArgumentException(declaredType + \" declares multiple JSON fields named \" + previous.name);\n                }\n            }\n        }\n        type \u003d TypeToken.get($Gson$Types.resolve(type.getType(), raw, raw.getGenericSuperclass()));\n        raw \u003d type.getRawType();\n    }\n    return result;\n}",
      "path": "gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapter.java",
      "functionStartLine": 163,
      "functionName": "getBoundFields",
      "functionAnnotation": "",
      "functionDoc": "",
      "diff": "@@ -1,20 +1,23 @@\n private Map\u003cString, BoundField\u003e getBoundFields(MiniGson context, TypeToken\u003c?\u003e type, Class\u003c?\u003e raw) {\n     Map\u003cString, BoundField\u003e result \u003d new LinkedHashMap\u003cString, BoundField\u003e();\n     Type declaredType \u003d type.getType();\n     while (raw !\u003d Object.class) {\n         Field[] fields \u003d raw.getDeclaredFields();\n         AccessibleObject.setAccessible(fields, true);\n         for (Field field : fields) {\n             boolean serialize \u003d serializeField(raw, field, declaredType);\n             boolean deserialize \u003d deserializeField(raw, field, declaredType);\n             if (serialize || deserialize) {\n                 Type fieldType \u003d $Gson$Types.resolve(type.getType(), raw, field.getGenericType());\n                 BoundField boundField \u003d createBoundField(context, field, getFieldName(raw, field, declaredType), TypeToken.get(fieldType), serialize, deserialize);\n-                result.put(boundField.name, boundField);\n+                BoundField previous \u003d result.put(boundField.name, boundField);\n+                if (previous !\u003d null) {\n+                    throw new IllegalArgumentException(declaredType + \" declares multiple JSON fields named \" + previous.name);\n+                }\n             }\n         }\n         type \u003d TypeToken.get($Gson$Types.resolve(type.getType(), raw, raw.getGenericSuperclass()));\n         raw \u003d type.getRawType();\n     }\n     return result;\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "f1f8b666ec665b41446ddb3d68de115d8ce91d2f": {
      "type": "Ybodychange",
      "commitMessage": "Implemented support for FieldNamingPolicy with MiniGson.\n",
      "commitDate": "8/2/11, 7:51 PM",
      "commitName": "f1f8b666ec665b41446ddb3d68de115d8ce91d2f",
      "commitAuthor": "Inderjeet Singh",
      "commitDateOld": "8/2/11, 6:25 PM",
      "commitNameOld": "98aa12458904cd8cb74ca40a905ddc790e14501b",
      "commitAuthorOld": "Jesse Wilson",
      "daysBetweenCommits": 0.06,
      "commitsBetweenForRepo": 3,
      "commitsBetweenForFile": 1,
      "actualSource": "private Map\u003cString, BoundField\u003e getBoundFields(MiniGson context, TypeToken\u003c?\u003e type, Class\u003c?\u003e raw) {\n    Map\u003cString, BoundField\u003e result \u003d new LinkedHashMap\u003cString, BoundField\u003e();\n    Type declaredType \u003d type.getType();\n    while (raw !\u003d Object.class) {\n        Field[] fields \u003d raw.getDeclaredFields();\n        AccessibleObject.setAccessible(fields, true);\n        for (Field field : fields) {\n            boolean serialize \u003d serializeField(raw, field, declaredType);\n            boolean deserialize \u003d deserializeField(raw, field, declaredType);\n            if (serialize || deserialize) {\n                Type fieldType \u003d $Gson$Types.resolve(type.getType(), raw, field.getGenericType());\n                BoundField boundField \u003d createBoundField(context, field, getFieldName(raw, field, declaredType), TypeToken.get(fieldType), serialize, deserialize);\n                result.put(boundField.name, boundField);\n            }\n        }\n        type \u003d TypeToken.get($Gson$Types.resolve(type.getType(), raw, raw.getGenericSuperclass()));\n        raw \u003d type.getRawType();\n    }\n    return result;\n}",
      "path": "gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapter.java",
      "functionStartLine": 163,
      "functionName": "getBoundFields",
      "functionAnnotation": "",
      "functionDoc": "",
      "diff": "@@ -1,20 +1,20 @@\n private Map\u003cString, BoundField\u003e getBoundFields(MiniGson context, TypeToken\u003c?\u003e type, Class\u003c?\u003e raw) {\n     Map\u003cString, BoundField\u003e result \u003d new LinkedHashMap\u003cString, BoundField\u003e();\n     Type declaredType \u003d type.getType();\n     while (raw !\u003d Object.class) {\n         Field[] fields \u003d raw.getDeclaredFields();\n         AccessibleObject.setAccessible(fields, true);\n         for (Field field : fields) {\n             boolean serialize \u003d serializeField(raw, field, declaredType);\n             boolean deserialize \u003d deserializeField(raw, field, declaredType);\n             if (serialize || deserialize) {\n                 Type fieldType \u003d $Gson$Types.resolve(type.getType(), raw, field.getGenericType());\n-                BoundField boundField \u003d createBoundField(context, field, TypeToken.get(fieldType), serialize, deserialize);\n+                BoundField boundField \u003d createBoundField(context, field, getFieldName(raw, field, declaredType), TypeToken.get(fieldType), serialize, deserialize);\n                 result.put(boundField.name, boundField);\n             }\n         }\n         type \u003d TypeToken.get($Gson$Types.resolve(type.getType(), raw, raw.getGenericSuperclass()));\n         raw \u003d type.getRawType();\n     }\n     return result;\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "b922500c239406c755149e9a9ca1164a2e2e2c90": {
      "type": "Ybodychange",
      "commitMessage": "For efficiency, calling setAccessible on all fields of a class in one method call instead of doing it individually.\n",
      "commitDate": "8/2/11, 6:25 PM",
      "commitName": "b922500c239406c755149e9a9ca1164a2e2e2c90",
      "commitAuthor": "Inderjeet Singh",
      "commitDateOld": "8/2/11, 6:19 PM",
      "commitNameOld": "f276d1382775e962d1a0a4b9e7e3e08496252861",
      "commitAuthorOld": "Inderjeet Singh",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "private Map\u003cString, BoundField\u003e getBoundFields(MiniGson context, TypeToken\u003c?\u003e type, Class\u003c?\u003e raw) {\n    Map\u003cString, BoundField\u003e result \u003d new LinkedHashMap\u003cString, BoundField\u003e();\n    Type declaredType \u003d type.getType();\n    while (raw !\u003d Object.class) {\n        Field[] fields \u003d raw.getDeclaredFields();\n        AccessibleObject.setAccessible(fields, true);\n        for (Field field : fields) {\n            boolean serialize \u003d serializeField(raw, field, declaredType);\n            boolean deserialize \u003d deserializeField(raw, field, declaredType);\n            if (serialize || deserialize) {\n                Type fieldType \u003d $Gson$Types.resolve(type.getType(), raw, field.getGenericType());\n                BoundField boundField \u003d createBoundField(context, field, TypeToken.get(fieldType), serialize, deserialize);\n                result.put(boundField.name, boundField);\n            }\n        }\n        type \u003d TypeToken.get($Gson$Types.resolve(type.getType(), raw, raw.getGenericSuperclass()));\n        raw \u003d type.getRawType();\n    }\n    return result;\n}",
      "path": "gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapter.java",
      "functionStartLine": 142,
      "functionName": "getBoundFields",
      "functionAnnotation": "",
      "functionDoc": "",
      "diff": "@@ -1,19 +1,20 @@\n private Map\u003cString, BoundField\u003e getBoundFields(MiniGson context, TypeToken\u003c?\u003e type, Class\u003c?\u003e raw) {\n     Map\u003cString, BoundField\u003e result \u003d new LinkedHashMap\u003cString, BoundField\u003e();\n     Type declaredType \u003d type.getType();\n     while (raw !\u003d Object.class) {\n-        for (Field field : raw.getDeclaredFields()) {\n+        Field[] fields \u003d raw.getDeclaredFields();\n+        AccessibleObject.setAccessible(fields, true);\n+        for (Field field : fields) {\n             boolean serialize \u003d serializeField(raw, field, declaredType);\n             boolean deserialize \u003d deserializeField(raw, field, declaredType);\n             if (serialize || deserialize) {\n-                field.setAccessible(true);\n                 Type fieldType \u003d $Gson$Types.resolve(type.getType(), raw, field.getGenericType());\n                 BoundField boundField \u003d createBoundField(context, field, TypeToken.get(fieldType), serialize, deserialize);\n                 result.put(boundField.name, boundField);\n             }\n         }\n         type \u003d TypeToken.get($Gson$Types.resolve(type.getType(), raw, raw.getGenericSuperclass()));\n         raw \u003d type.getRawType();\n     }\n     return result;\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "f276d1382775e962d1a0a4b9e7e3e08496252861": {
      "type": "Ybodychange",
      "commitMessage": "Added support for deserialization exclusion strategy.\n",
      "commitDate": "8/2/11, 6:19 PM",
      "commitName": "f276d1382775e962d1a0a4b9e7e3e08496252861",
      "commitAuthor": "Inderjeet Singh",
      "commitDateOld": "8/2/11, 5:47 PM",
      "commitNameOld": "3331dcdab08792f6281ab6343532031a52f54003",
      "commitAuthorOld": "Inderjeet Singh",
      "daysBetweenCommits": 0.02,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "private Map\u003cString, BoundField\u003e getBoundFields(MiniGson context, TypeToken\u003c?\u003e type, Class\u003c?\u003e raw) {\n    Map\u003cString, BoundField\u003e result \u003d new LinkedHashMap\u003cString, BoundField\u003e();\n    Type declaredType \u003d type.getType();\n    while (raw !\u003d Object.class) {\n        for (Field field : raw.getDeclaredFields()) {\n            boolean serialize \u003d serializeField(raw, field, declaredType);\n            boolean deserialize \u003d deserializeField(raw, field, declaredType);\n            if (serialize || deserialize) {\n                field.setAccessible(true);\n                Type fieldType \u003d $Gson$Types.resolve(type.getType(), raw, field.getGenericType());\n                BoundField boundField \u003d createBoundField(context, field, TypeToken.get(fieldType), serialize, deserialize);\n                result.put(boundField.name, boundField);\n            }\n        }\n        type \u003d TypeToken.get($Gson$Types.resolve(type.getType(), raw, raw.getGenericSuperclass()));\n        raw \u003d type.getRawType();\n    }\n    return result;\n}",
      "path": "gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapter.java",
      "functionStartLine": 141,
      "functionName": "getBoundFields",
      "functionAnnotation": "",
      "functionDoc": "",
      "diff": "@@ -1,18 +1,19 @@\n private Map\u003cString, BoundField\u003e getBoundFields(MiniGson context, TypeToken\u003c?\u003e type, Class\u003c?\u003e raw) {\n     Map\u003cString, BoundField\u003e result \u003d new LinkedHashMap\u003cString, BoundField\u003e();\n     Type declaredType \u003d type.getType();\n     while (raw !\u003d Object.class) {\n         for (Field field : raw.getDeclaredFields()) {\n-            if (skipField(raw, field, declaredType)) {\n-                continue;\n+            boolean serialize \u003d serializeField(raw, field, declaredType);\n+            boolean deserialize \u003d deserializeField(raw, field, declaredType);\n+            if (serialize || deserialize) {\n+                field.setAccessible(true);\n+                Type fieldType \u003d $Gson$Types.resolve(type.getType(), raw, field.getGenericType());\n+                BoundField boundField \u003d createBoundField(context, field, TypeToken.get(fieldType), serialize, deserialize);\n+                result.put(boundField.name, boundField);\n             }\n-            field.setAccessible(true);\n-            Type fieldType \u003d $Gson$Types.resolve(type.getType(), raw, field.getGenericType());\n-            BoundField boundField \u003d createBoundField(context, field, TypeToken.get(fieldType));\n-            result.put(boundField.name, boundField);\n         }\n         type \u003d TypeToken.get($Gson$Types.resolve(type.getType(), raw, raw.getGenericSuperclass()));\n         raw \u003d type.getRawType();\n     }\n     return result;\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "3331dcdab08792f6281ab6343532031a52f54003": {
      "type": "Ybodychange",
      "commitMessage": "Using serializationExclusionStrategy while navigating through fields to decide which ones to skip.\n",
      "commitDate": "8/2/11, 5:47 PM",
      "commitName": "3331dcdab08792f6281ab6343532031a52f54003",
      "commitAuthor": "Inderjeet Singh",
      "commitDateOld": "8/2/11, 5:25 PM",
      "commitNameOld": "60e6ed912d52716f46a1ba71923ef203c4248857",
      "commitAuthorOld": "Jesse Wilson",
      "daysBetweenCommits": 0.02,
      "commitsBetweenForRepo": 2,
      "commitsBetweenForFile": 1,
      "actualSource": "private Map\u003cString, BoundField\u003e getBoundFields(MiniGson context, TypeToken\u003c?\u003e type, Class\u003c?\u003e raw) {\n    Map\u003cString, BoundField\u003e result \u003d new LinkedHashMap\u003cString, BoundField\u003e();\n    Type declaredType \u003d type.getType();\n    while (raw !\u003d Object.class) {\n        for (Field field : raw.getDeclaredFields()) {\n            if (skipField(raw, field, declaredType)) {\n                continue;\n            }\n            field.setAccessible(true);\n            Type fieldType \u003d $Gson$Types.resolve(type.getType(), raw, field.getGenericType());\n            BoundField boundField \u003d createBoundField(context, field, TypeToken.get(fieldType));\n            result.put(boundField.name, boundField);\n        }\n        type \u003d TypeToken.get($Gson$Types.resolve(type.getType(), raw, raw.getGenericSuperclass()));\n        raw \u003d type.getRawType();\n    }\n    return result;\n}",
      "path": "gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapter.java",
      "functionStartLine": 136,
      "functionName": "getBoundFields",
      "functionAnnotation": "",
      "functionDoc": "",
      "diff": "@@ -1,14 +1,18 @@\n private Map\u003cString, BoundField\u003e getBoundFields(MiniGson context, TypeToken\u003c?\u003e type, Class\u003c?\u003e raw) {\n     Map\u003cString, BoundField\u003e result \u003d new LinkedHashMap\u003cString, BoundField\u003e();\n+    Type declaredType \u003d type.getType();\n     while (raw !\u003d Object.class) {\n         for (Field field : raw.getDeclaredFields()) {\n+            if (skipField(raw, field, declaredType)) {\n+                continue;\n+            }\n             field.setAccessible(true);\n             Type fieldType \u003d $Gson$Types.resolve(type.getType(), raw, field.getGenericType());\n             BoundField boundField \u003d createBoundField(context, field, TypeToken.get(fieldType));\n             result.put(boundField.name, boundField);\n         }\n         type \u003d TypeToken.get($Gson$Types.resolve(type.getType(), raw, raw.getGenericSuperclass()));\n         raw \u003d type.getRawType();\n     }\n     return result;\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "60e6ed912d52716f46a1ba71923ef203c4248857": {
      "type": "Yfilerename",
      "commitMessage": "Promote MiniGson to gson.internal.bind\n",
      "commitDate": "8/2/11, 5:25 PM",
      "commitName": "60e6ed912d52716f46a1ba71923ef203c4248857",
      "commitAuthor": "Jesse Wilson",
      "commitDateOld": "8/2/11, 5:17 PM",
      "commitNameOld": "759eb8ede50f61fd525f5d703dd9fd45ddae1dcd",
      "commitAuthorOld": "Jesse Wilson",
      "daysBetweenCommits": 0.01,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "private Map\u003cString, BoundField\u003e getBoundFields(MiniGson context, TypeToken\u003c?\u003e type, Class\u003c?\u003e raw) {\n    Map\u003cString, BoundField\u003e result \u003d new LinkedHashMap\u003cString, BoundField\u003e();\n    while (raw !\u003d Object.class) {\n        for (Field field : raw.getDeclaredFields()) {\n            field.setAccessible(true);\n            Type fieldType \u003d $Gson$Types.resolve(type.getType(), raw, field.getGenericType());\n            BoundField boundField \u003d createBoundField(context, field, TypeToken.get(fieldType));\n            result.put(boundField.name, boundField);\n        }\n        type \u003d TypeToken.get($Gson$Types.resolve(type.getType(), raw, raw.getGenericSuperclass()));\n        raw \u003d type.getRawType();\n    }\n    return result;\n}",
      "path": "gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapter.java",
      "functionStartLine": 54,
      "functionName": "getBoundFields",
      "functionAnnotation": "",
      "functionDoc": "",
      "diff": "",
      "extendedDetails": {
        "oldPath": "extras/src/main/java/com/google/gson/mini/ReflectiveTypeAdapter.java",
        "newPath": "gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapter.java"
      }
    },
    "4b042671af018f308c2a261145dc6712e39b96e7": {
      "type": "Ymultichange(Yreturntypechange,Ybodychange)",
      "commitMessage": "Cleanup after experimenting with specializing BoundField by type (ie. Field.setInt() to avoid autoboxing)\n",
      "commitDate": "7/15/11, 7:37 AM",
      "commitName": "4b042671af018f308c2a261145dc6712e39b96e7",
      "commitAuthor": "Jesse Wilson",
      "subchanges": [
        {
          "type": "Yreturntypechange",
          "commitMessage": "Cleanup after experimenting with specializing BoundField by type (ie. Field.setInt() to avoid autoboxing)\n",
          "commitDate": "7/15/11, 7:37 AM",
          "commitName": "4b042671af018f308c2a261145dc6712e39b96e7",
          "commitAuthor": "Jesse Wilson",
          "commitDateOld": "7/15/11, 6:43 AM",
          "commitNameOld": "3c4d121dc8736c7359731f9cb99098e2999f8575",
          "commitAuthorOld": "Jesse Wilson",
          "daysBetweenCommits": 0.04,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "actualSource": "private Map\u003cString, BoundField\u003e getBoundFields(MiniGson context, TypeToken\u003c?\u003e type, Class\u003c?\u003e raw) {\n    Map\u003cString, BoundField\u003e result \u003d new LinkedHashMap\u003cString, BoundField\u003e();\n    while (raw !\u003d Object.class) {\n        for (Field field : raw.getDeclaredFields()) {\n            field.setAccessible(true);\n            Type fieldType \u003d $Gson$Types.resolve(type.getType(), raw, field.getGenericType());\n            BoundField boundField \u003d createBoundField(context, field, TypeToken.get(fieldType));\n            result.put(boundField.name, boundField);\n        }\n        type \u003d TypeToken.get($Gson$Types.resolve(type.getType(), raw, raw.getGenericSuperclass()));\n        raw \u003d type.getRawType();\n    }\n    return result;\n}",
          "path": "extras/src/main/java/com/google/gson/mini/ReflectiveTypeAdapter.java",
          "functionStartLine": 54,
          "functionName": "getBoundFields",
          "functionAnnotation": "",
          "functionDoc": "",
          "diff": "@@ -1,14 +1,14 @@\n-private Map\u003cString, BoundField\u003c?\u003e\u003e getBoundFields(MiniGson context, TypeToken\u003c?\u003e type, Class\u003c?\u003e raw) {\n-    Map\u003cString, BoundField\u003c?\u003e\u003e result \u003d new LinkedHashMap\u003cString, BoundField\u003c?\u003e\u003e();\n+private Map\u003cString, BoundField\u003e getBoundFields(MiniGson context, TypeToken\u003c?\u003e type, Class\u003c?\u003e raw) {\n+    Map\u003cString, BoundField\u003e result \u003d new LinkedHashMap\u003cString, BoundField\u003e();\n     while (raw !\u003d Object.class) {\n         for (Field field : raw.getDeclaredFields()) {\n             field.setAccessible(true);\n             Type fieldType \u003d $Gson$Types.resolve(type.getType(), raw, field.getGenericType());\n-            BoundField\u003c?\u003e boundField \u003d BoundField.create(context, field, TypeToken.get(fieldType));\n+            BoundField boundField \u003d createBoundField(context, field, TypeToken.get(fieldType));\n             result.put(boundField.name, boundField);\n         }\n         type \u003d TypeToken.get($Gson$Types.resolve(type.getType(), raw, raw.getGenericSuperclass()));\n         raw \u003d type.getRawType();\n     }\n     return result;\n }\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldValue": "Map\u003cString,BoundField\u003c?\u003e\u003e",
            "newValue": "Map\u003cString,BoundField\u003e"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "Cleanup after experimenting with specializing BoundField by type (ie. Field.setInt() to avoid autoboxing)\n",
          "commitDate": "7/15/11, 7:37 AM",
          "commitName": "4b042671af018f308c2a261145dc6712e39b96e7",
          "commitAuthor": "Jesse Wilson",
          "commitDateOld": "7/15/11, 6:43 AM",
          "commitNameOld": "3c4d121dc8736c7359731f9cb99098e2999f8575",
          "commitAuthorOld": "Jesse Wilson",
          "daysBetweenCommits": 0.04,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "actualSource": "private Map\u003cString, BoundField\u003e getBoundFields(MiniGson context, TypeToken\u003c?\u003e type, Class\u003c?\u003e raw) {\n    Map\u003cString, BoundField\u003e result \u003d new LinkedHashMap\u003cString, BoundField\u003e();\n    while (raw !\u003d Object.class) {\n        for (Field field : raw.getDeclaredFields()) {\n            field.setAccessible(true);\n            Type fieldType \u003d $Gson$Types.resolve(type.getType(), raw, field.getGenericType());\n            BoundField boundField \u003d createBoundField(context, field, TypeToken.get(fieldType));\n            result.put(boundField.name, boundField);\n        }\n        type \u003d TypeToken.get($Gson$Types.resolve(type.getType(), raw, raw.getGenericSuperclass()));\n        raw \u003d type.getRawType();\n    }\n    return result;\n}",
          "path": "extras/src/main/java/com/google/gson/mini/ReflectiveTypeAdapter.java",
          "functionStartLine": 54,
          "functionName": "getBoundFields",
          "functionAnnotation": "",
          "functionDoc": "",
          "diff": "@@ -1,14 +1,14 @@\n-private Map\u003cString, BoundField\u003c?\u003e\u003e getBoundFields(MiniGson context, TypeToken\u003c?\u003e type, Class\u003c?\u003e raw) {\n-    Map\u003cString, BoundField\u003c?\u003e\u003e result \u003d new LinkedHashMap\u003cString, BoundField\u003c?\u003e\u003e();\n+private Map\u003cString, BoundField\u003e getBoundFields(MiniGson context, TypeToken\u003c?\u003e type, Class\u003c?\u003e raw) {\n+    Map\u003cString, BoundField\u003e result \u003d new LinkedHashMap\u003cString, BoundField\u003e();\n     while (raw !\u003d Object.class) {\n         for (Field field : raw.getDeclaredFields()) {\n             field.setAccessible(true);\n             Type fieldType \u003d $Gson$Types.resolve(type.getType(), raw, field.getGenericType());\n-            BoundField\u003c?\u003e boundField \u003d BoundField.create(context, field, TypeToken.get(fieldType));\n+            BoundField boundField \u003d createBoundField(context, field, TypeToken.get(fieldType));\n             result.put(boundField.name, boundField);\n         }\n         type \u003d TypeToken.get($Gson$Types.resolve(type.getType(), raw, raw.getGenericSuperclass()));\n         raw \u003d type.getRawType();\n     }\n     return result;\n }\n\\ No newline at end of file\n",
          "extendedDetails": {}
        }
      ]
    },
    "3c4d121dc8736c7359731f9cb99098e2999f8575": {
      "type": "Ybodychange",
      "commitMessage": "Fix integration tests that fell out from some benchmarking.\n",
      "commitDate": "7/15/11, 6:43 AM",
      "commitName": "3c4d121dc8736c7359731f9cb99098e2999f8575",
      "commitAuthor": "Jesse Wilson",
      "commitDateOld": "7/11/11, 2:45 PM",
      "commitNameOld": "95a345234fb1d51ada03f37d50769cd5198b5af3",
      "commitAuthorOld": "Jesse Wilson",
      "daysBetweenCommits": 3.67,
      "commitsBetweenForRepo": 6,
      "commitsBetweenForFile": 1,
      "actualSource": "private Map\u003cString, BoundField\u003c?\u003e\u003e getBoundFields(MiniGson context, TypeToken\u003c?\u003e type, Class\u003c?\u003e raw) {\n    Map\u003cString, BoundField\u003c?\u003e\u003e result \u003d new LinkedHashMap\u003cString, BoundField\u003c?\u003e\u003e();\n    while (raw !\u003d Object.class) {\n        for (Field field : raw.getDeclaredFields()) {\n            field.setAccessible(true);\n            Type fieldType \u003d $Gson$Types.resolve(type.getType(), raw, field.getGenericType());\n            BoundField\u003c?\u003e boundField \u003d BoundField.create(context, field, TypeToken.get(fieldType));\n            result.put(boundField.name, boundField);\n        }\n        type \u003d TypeToken.get($Gson$Types.resolve(type.getType(), raw, raw.getGenericSuperclass()));\n        raw \u003d type.getRawType();\n    }\n    return result;\n}",
      "path": "extras/src/main/java/com/google/gson/mini/ReflectiveTypeAdapter.java",
      "functionStartLine": 54,
      "functionName": "getBoundFields",
      "functionAnnotation": "",
      "functionDoc": "",
      "diff": "@@ -1,13 +1,14 @@\n private Map\u003cString, BoundField\u003c?\u003e\u003e getBoundFields(MiniGson context, TypeToken\u003c?\u003e type, Class\u003c?\u003e raw) {\n     Map\u003cString, BoundField\u003c?\u003e\u003e result \u003d new LinkedHashMap\u003cString, BoundField\u003c?\u003e\u003e();\n     while (raw !\u003d Object.class) {\n         for (Field field : raw.getDeclaredFields()) {\n+            field.setAccessible(true);\n             Type fieldType \u003d $Gson$Types.resolve(type.getType(), raw, field.getGenericType());\n             BoundField\u003c?\u003e boundField \u003d BoundField.create(context, field, TypeToken.get(fieldType));\n             result.put(boundField.name, boundField);\n         }\n         type \u003d TypeToken.get($Gson$Types.resolve(type.getType(), raw, raw.getGenericSuperclass()));\n         raw \u003d type.getRawType();\n     }\n     return result;\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "c5f1df10175c254b823fc019832bf1bf7b71e929": {
      "type": "Yintroduced",
      "commitMessage": "MiniGSON prototype!\n",
      "commitDate": "7/11/11, 9:46 AM",
      "commitName": "c5f1df10175c254b823fc019832bf1bf7b71e929",
      "commitAuthor": "Jesse Wilson",
      "diff": "@@ -0,0 +1,13 @@\n+private Map\u003cString, BoundField\u003c?\u003e\u003e getBoundFields(MiniGson context, TypeToken\u003c?\u003e type, Class\u003c?\u003e raw) {\n+    Map\u003cString, BoundField\u003c?\u003e\u003e result \u003d new LinkedHashMap\u003cString, BoundField\u003c?\u003e\u003e();\n+    while (raw !\u003d Object.class) {\n+        for (Field field : raw.getDeclaredFields()) {\n+            Type fieldType \u003d $Gson$Types.resolve(type.getType(), raw, field.getGenericType());\n+            BoundField\u003c?\u003e boundField \u003d BoundField.create(context, field, TypeToken.get(fieldType));\n+            result.put(boundField.name, boundField);\n+        }\n+        type \u003d TypeToken.get($Gson$Types.resolve(type.getType(), raw, raw.getGenericSuperclass()));\n+        raw \u003d type.getRawType();\n+    }\n+    return result;\n+}\n\\ No newline at end of file\n",
      "actualSource": "private Map\u003cString, BoundField\u003c?\u003e\u003e getBoundFields(MiniGson context, TypeToken\u003c?\u003e type, Class\u003c?\u003e raw) {\n    Map\u003cString, BoundField\u003c?\u003e\u003e result \u003d new LinkedHashMap\u003cString, BoundField\u003c?\u003e\u003e();\n    while (raw !\u003d Object.class) {\n        for (Field field : raw.getDeclaredFields()) {\n            Type fieldType \u003d $Gson$Types.resolve(type.getType(), raw, field.getGenericType());\n            BoundField\u003c?\u003e boundField \u003d BoundField.create(context, field, TypeToken.get(fieldType));\n            result.put(boundField.name, boundField);\n        }\n        type \u003d TypeToken.get($Gson$Types.resolve(type.getType(), raw, raw.getGenericSuperclass()));\n        raw \u003d type.getRawType();\n    }\n    return result;\n}",
      "path": "extras/src/main/java/com/google/gson/mini/ReflectiveTypeAdapter.java",
      "functionStartLine": 54,
      "functionName": "getBoundFields",
      "functionAnnotation": "",
      "functionDoc": ""
    }
  }
}