{
  "origin": "codeshovel",
  "repositoryName": "Gson-10b",
  "repositoryPath": "/tmp/Gson-10b//.git",
  "startCommitName": "HEAD",
  "sourceFileName": "ReflectiveTypeAdapterFactory.java",
  "functionName": "write",
  "functionId": "$write___out-JsonWriter__value-T",
  "sourceFilePath": "gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java",
  "functionAnnotation": "@Override",
  "functionDoc": "",
  "functionStartLine": 231,
  "functionEndLine": 249,
  "numCommitsSeen": 59,
  "timeTaken": 2114,
  "changeHistory": [
    "c935f89b23c69e7c9d6d98df87f81635b3eb3700",
    "8d5a41329ec2f4db3aed02c20d379baf92840b37",
    "d4a1e49e463091ed3793930815fde75bb766d030",
    "f602bce9f536df971b8bfa01b7ffb111e2896c97",
    "8b21c7770b85dae64fa6da181546a73378158a13",
    "b90b43ea474cd32f1aa6d68aeb4fbe19e1e7ca9d",
    "25c6ae177b1ca56db7f3c29eb574bdd032a06165",
    "f276d1382775e962d1a0a4b9e7e3e08496252861",
    "60e6ed912d52716f46a1ba71923ef203c4248857",
    "4b042671af018f308c2a261145dc6712e39b96e7",
    "95a345234fb1d51ada03f37d50769cd5198b5af3",
    "c5f1df10175c254b823fc019832bf1bf7b71e929"
  ],
  "changeHistoryShort": {
    "c935f89b23c69e7c9d6d98df87f81635b3eb3700": "Ybodychange",
    "8d5a41329ec2f4db3aed02c20d379baf92840b37": "Ybodychange",
    "d4a1e49e463091ed3793930815fde75bb766d030": "Ybodychange",
    "f602bce9f536df971b8bfa01b7ffb111e2896c97": "Ymultichange(Yparameterchange,Ybodychange)",
    "8b21c7770b85dae64fa6da181546a73378158a13": "Ybodychange",
    "b90b43ea474cd32f1aa6d68aeb4fbe19e1e7ca9d": "Ymultichange(Ybodychange,Yannotationchange)",
    "25c6ae177b1ca56db7f3c29eb574bdd032a06165": "Ymultichange(Ymovefromfile,Ybodychange)",
    "f276d1382775e962d1a0a4b9e7e3e08496252861": "Ybodychange",
    "60e6ed912d52716f46a1ba71923ef203c4248857": "Yfilerename",
    "4b042671af018f308c2a261145dc6712e39b96e7": "Ybodychange",
    "95a345234fb1d51ada03f37d50769cd5198b5af3": "Ybodychange",
    "c5f1df10175c254b823fc019832bf1bf7b71e929": "Yintroduced"
  },
  "changeHistoryDetails": {
    "c935f89b23c69e7c9d6d98df87f81635b3eb3700": {
      "type": "Ybodychange",
      "commitMessage": "Added the cause to Assertions\n",
      "commitDate": "11/16/15, 9:16 AM",
      "commitName": "c935f89b23c69e7c9d6d98df87f81635b3eb3700",
      "commitAuthor": "Inderjeet Singh",
      "commitDateOld": "11/4/15, 6:52 PM",
      "commitNameOld": "e5b3f6368db33c846b094b0d695d3a1b826e3892",
      "commitAuthorOld": "Inderjeet Singh",
      "daysBetweenCommits": 11.6,
      "commitsBetweenForRepo": 10,
      "commitsBetweenForFile": 1,
      "actualSource": "@Override\npublic void write(JsonWriter out, T value) throws IOException {\n    if (value \u003d\u003d null) {\n        out.nullValue();\n        return;\n    }\n    out.beginObject();\n    try {\n        for (BoundField boundField : boundFields.values()) {\n            if (boundField.writeField(value)) {\n                out.name(boundField.name);\n                boundField.write(out, value);\n            }\n        }\n    } catch (IllegalAccessException e) {\n        throw new AssertionError(e);\n    }\n    out.endObject();\n}",
      "path": "gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java",
      "functionStartLine": 229,
      "functionName": "write",
      "functionAnnotation": "@Override",
      "functionDoc": "",
      "diff": "@@ -1,19 +1,19 @@\n @Override\n public void write(JsonWriter out, T value) throws IOException {\n     if (value \u003d\u003d null) {\n         out.nullValue();\n         return;\n     }\n     out.beginObject();\n     try {\n         for (BoundField boundField : boundFields.values()) {\n             if (boundField.writeField(value)) {\n                 out.name(boundField.name);\n                 boundField.write(out, value);\n             }\n         }\n     } catch (IllegalAccessException e) {\n-        throw new AssertionError();\n+        throw new AssertionError(e);\n     }\n     out.endObject();\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "8d5a41329ec2f4db3aed02c20d379baf92840b37": {
      "type": "Ybodychange",
      "commitMessage": "added tests for Throwable. Revised ReflectiveTypeAdapterFactory to ignore self-referencing fields.\n",
      "commitDate": "11/16/14, 2:55 PM",
      "commitName": "8d5a41329ec2f4db3aed02c20d379baf92840b37",
      "commitAuthor": "Inderjeet Singh",
      "commitDateOld": "11/16/14, 2:25 PM",
      "commitNameOld": "b6a625fb6cb7e46a01938fef79ac6ea26c93a8dc",
      "commitAuthorOld": "Inderjeet Singh",
      "daysBetweenCommits": 0.02,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "@Override\npublic void write(JsonWriter out, T value) throws IOException {\n    if (value \u003d\u003d null) {\n        out.nullValue();\n        return;\n    }\n    out.beginObject();\n    try {\n        for (BoundField boundField : boundFields.values()) {\n            if (boundField.writeField(value)) {\n                out.name(boundField.name);\n                boundField.write(out, value);\n            }\n        }\n    } catch (IllegalAccessException e) {\n        throw new AssertionError();\n    }\n    out.endObject();\n}",
      "path": "gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java",
      "functionStartLine": 208,
      "functionName": "write",
      "functionAnnotation": "@Override",
      "functionDoc": "",
      "diff": "@@ -1,19 +1,19 @@\n @Override\n public void write(JsonWriter out, T value) throws IOException {\n     if (value \u003d\u003d null) {\n         out.nullValue();\n         return;\n     }\n     out.beginObject();\n     try {\n         for (BoundField boundField : boundFields.values()) {\n-            if (boundField.serialized) {\n+            if (boundField.writeField(value)) {\n                 out.name(boundField.name);\n                 boundField.write(out, value);\n             }\n         }\n     } catch (IllegalAccessException e) {\n         throw new AssertionError();\n     }\n     out.endObject();\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "d4a1e49e463091ed3793930815fde75bb766d030": {
      "type": "Ybodychange",
      "commitMessage": "Delete some obsolete TODOs\n",
      "commitDate": "1/1/12, 4:42 AM",
      "commitName": "d4a1e49e463091ed3793930815fde75bb766d030",
      "commitAuthor": "Jesse Wilson",
      "commitDateOld": "12/30/11, 12:27 AM",
      "commitNameOld": "4057b98babf5ecb7ad1583d23a90abe7b7fede12",
      "commitAuthorOld": "Jesse Wilson",
      "daysBetweenCommits": 2.18,
      "commitsBetweenForRepo": 13,
      "commitsBetweenForFile": 1,
      "actualSource": "@Override\npublic void write(JsonWriter out, T value) throws IOException {\n    if (value \u003d\u003d null) {\n        out.nullValue();\n        return;\n    }\n    out.beginObject();\n    try {\n        for (BoundField boundField : boundFields.values()) {\n            if (boundField.serialized) {\n                out.name(boundField.name);\n                boundField.write(out, value);\n            }\n        }\n    } catch (IllegalAccessException e) {\n        throw new AssertionError();\n    }\n    out.endObject();\n}",
      "path": "gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java",
      "functionStartLine": 184,
      "functionName": "write",
      "functionAnnotation": "@Override",
      "functionDoc": "",
      "diff": "",
      "extendedDetails": {}
    },
    "f602bce9f536df971b8bfa01b7ffb111e2896c97": {
      "type": "Ymultichange(Yparameterchange,Ybodychange)",
      "commitMessage": "Nice documentation for TypeAdapter.\n",
      "commitDate": "12/3/11, 11:46 AM",
      "commitName": "f602bce9f536df971b8bfa01b7ffb111e2896c97",
      "commitAuthor": "Jesse Wilson",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "Nice documentation for TypeAdapter.\n",
          "commitDate": "12/3/11, 11:46 AM",
          "commitName": "f602bce9f536df971b8bfa01b7ffb111e2896c97",
          "commitAuthor": "Jesse Wilson",
          "commitDateOld": "12/2/11, 2:57 PM",
          "commitNameOld": "26ab404599643fac25442646b829a65a7f86bca1",
          "commitAuthorOld": "Jesse Wilson",
          "daysBetweenCommits": 0.87,
          "commitsBetweenForRepo": 4,
          "commitsBetweenForFile": 1,
          "actualSource": "@Override\npublic void write(JsonWriter out, T value) throws IOException {\n    if (value \u003d\u003d null) {\n        out.nullValue();\n        return;\n    }\n    out.beginObject();\n    try {\n        for (BoundField boundField : boundFields.values()) {\n            if (boundField.serialized) {\n                out.name(boundField.name);\n                boundField.write(out, value);\n            }\n        }\n    } catch (IllegalAccessException e) {\n        throw new AssertionError();\n    }\n    out.endObject();\n}",
          "path": "gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java",
          "functionStartLine": 189,
          "functionName": "write",
          "functionAnnotation": "@Override",
          "functionDoc": "",
          "diff": "@@ -1,19 +1,19 @@\n @Override\n-public void write(JsonWriter writer, T value) throws IOException {\n+public void write(JsonWriter out, T value) throws IOException {\n     if (value \u003d\u003d null) {\n-        writer.nullValue();\n+        out.nullValue();\n         return;\n     }\n-    writer.beginObject();\n+    out.beginObject();\n     try {\n         for (BoundField boundField : boundFields.values()) {\n             if (boundField.serialized) {\n-                writer.name(boundField.name);\n-                boundField.write(writer, value);\n+                out.name(boundField.name);\n+                boundField.write(out, value);\n             }\n         }\n     } catch (IllegalAccessException e) {\n         throw new AssertionError();\n     }\n-    writer.endObject();\n+    out.endObject();\n }\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldValue": "[writer-JsonWriter, value-T]",
            "newValue": "[out-JsonWriter, value-T]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "Nice documentation for TypeAdapter.\n",
          "commitDate": "12/3/11, 11:46 AM",
          "commitName": "f602bce9f536df971b8bfa01b7ffb111e2896c97",
          "commitAuthor": "Jesse Wilson",
          "commitDateOld": "12/2/11, 2:57 PM",
          "commitNameOld": "26ab404599643fac25442646b829a65a7f86bca1",
          "commitAuthorOld": "Jesse Wilson",
          "daysBetweenCommits": 0.87,
          "commitsBetweenForRepo": 4,
          "commitsBetweenForFile": 1,
          "actualSource": "@Override\npublic void write(JsonWriter out, T value) throws IOException {\n    if (value \u003d\u003d null) {\n        out.nullValue();\n        return;\n    }\n    out.beginObject();\n    try {\n        for (BoundField boundField : boundFields.values()) {\n            if (boundField.serialized) {\n                out.name(boundField.name);\n                boundField.write(out, value);\n            }\n        }\n    } catch (IllegalAccessException e) {\n        throw new AssertionError();\n    }\n    out.endObject();\n}",
          "path": "gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java",
          "functionStartLine": 189,
          "functionName": "write",
          "functionAnnotation": "@Override",
          "functionDoc": "",
          "diff": "@@ -1,19 +1,19 @@\n @Override\n-public void write(JsonWriter writer, T value) throws IOException {\n+public void write(JsonWriter out, T value) throws IOException {\n     if (value \u003d\u003d null) {\n-        writer.nullValue();\n+        out.nullValue();\n         return;\n     }\n-    writer.beginObject();\n+    out.beginObject();\n     try {\n         for (BoundField boundField : boundFields.values()) {\n             if (boundField.serialized) {\n-                writer.name(boundField.name);\n-                boundField.write(writer, value);\n+                out.name(boundField.name);\n+                boundField.write(out, value);\n             }\n         }\n     } catch (IllegalAccessException e) {\n         throw new AssertionError();\n     }\n-    writer.endObject();\n+    out.endObject();\n }\n\\ No newline at end of file\n",
          "extendedDetails": {}
        }
      ]
    },
    "8b21c7770b85dae64fa6da181546a73378158a13": {
      "type": "Ybodychange",
      "commitMessage": "Use the same behavior in all situations when an InstanceCreator returns a subclass.\n\nPreviously we would set the field if the created instance is being assigned to a field of another object. We wouldn\u0027t set it when the created instance is a collection element or the top-level object.\n",
      "commitDate": "9/29/11, 9:38 AM",
      "commitName": "8b21c7770b85dae64fa6da181546a73378158a13",
      "commitAuthor": "Jesse Wilson",
      "commitDateOld": "9/15/11, 9:55 PM",
      "commitNameOld": "b90b43ea474cd32f1aa6d68aeb4fbe19e1e7ca9d",
      "commitAuthorOld": "Joel Leitch",
      "daysBetweenCommits": 13.49,
      "commitsBetweenForRepo": 22,
      "commitsBetweenForFile": 1,
      "actualSource": "@Override\npublic void write(JsonWriter writer, T value) throws IOException {\n    if (value \u003d\u003d null) {\n        writer.nullValue();\n        return;\n    }\n    writer.beginObject();\n    try {\n        for (BoundField boundField : boundFields.values()) {\n            if (boundField.serialized) {\n                writer.name(boundField.name);\n                boundField.write(writer, value);\n            }\n        }\n    } catch (IllegalAccessException e) {\n        throw new AssertionError();\n    }\n    writer.endObject();\n}",
      "path": "gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java",
      "functionStartLine": 183,
      "functionName": "write",
      "functionAnnotation": "@Override",
      "functionDoc": "",
      "diff": "",
      "extendedDetails": {}
    },
    "b90b43ea474cd32f1aa6d68aeb4fbe19e1e7ca9d": {
      "type": "Ymultichange(Ybodychange,Yannotationchange)",
      "commitMessage": "A few minor fixes and one incompatible Java 1.6 API call.\n",
      "commitDate": "9/15/11, 9:55 PM",
      "commitName": "b90b43ea474cd32f1aa6d68aeb4fbe19e1e7ca9d",
      "commitAuthor": "Joel Leitch",
      "subchanges": [
        {
          "type": "Ybodychange",
          "commitMessage": "A few minor fixes and one incompatible Java 1.6 API call.\n",
          "commitDate": "9/15/11, 9:55 PM",
          "commitName": "b90b43ea474cd32f1aa6d68aeb4fbe19e1e7ca9d",
          "commitAuthor": "Joel Leitch",
          "commitDateOld": "9/11/11, 12:04 AM",
          "commitNameOld": "25c6ae177b1ca56db7f3c29eb574bdd032a06165",
          "commitAuthorOld": "Jesse Wilson",
          "daysBetweenCommits": 4.91,
          "commitsBetweenForRepo": 6,
          "commitsBetweenForFile": 1,
          "actualSource": "@Override\npublic void write(JsonWriter writer, T value) throws IOException {\n    if (value \u003d\u003d null) {\n        writer.nullValue();\n        return;\n    }\n    writer.beginObject();\n    try {\n        for (BoundField boundField : boundFields.values()) {\n            if (boundField.serialized) {\n                writer.name(boundField.name);\n                boundField.write(writer, value);\n            }\n        }\n    } catch (IllegalAccessException e) {\n        throw new AssertionError();\n    }\n    writer.endObject();\n}",
          "path": "gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java",
          "functionStartLine": 191,
          "functionName": "write",
          "functionAnnotation": "@Override",
          "functionDoc": "",
          "diff": "@@ -1,26 +1,19 @@\n+@Override\n public void write(JsonWriter writer, T value) throws IOException {\n     if (value \u003d\u003d null) {\n         writer.nullValue();\n         return;\n     }\n-    if (false) {\n-        Class\u003c?\u003e runtimeType \u003d value.getClass();\n-        if (runtimeType !\u003d type.getRawType()) {\n-            TypeAdapter\u003c?\u003e adapter \u003d context.getAdapter(runtimeType);\n-            ((TypeAdapter) adapter).write(writer, value);\n-            return;\n-        }\n-    }\n     writer.beginObject();\n     try {\n         for (BoundField boundField : boundFields.values()) {\n             if (boundField.serialized) {\n                 writer.name(boundField.name);\n                 boundField.write(writer, value);\n             }\n         }\n     } catch (IllegalAccessException e) {\n         throw new AssertionError();\n     }\n     writer.endObject();\n }\n\\ No newline at end of file\n",
          "extendedDetails": {}
        },
        {
          "type": "Yannotationchange",
          "commitMessage": "A few minor fixes and one incompatible Java 1.6 API call.\n",
          "commitDate": "9/15/11, 9:55 PM",
          "commitName": "b90b43ea474cd32f1aa6d68aeb4fbe19e1e7ca9d",
          "commitAuthor": "Joel Leitch",
          "commitDateOld": "9/11/11, 12:04 AM",
          "commitNameOld": "25c6ae177b1ca56db7f3c29eb574bdd032a06165",
          "commitAuthorOld": "Jesse Wilson",
          "daysBetweenCommits": 4.91,
          "commitsBetweenForRepo": 6,
          "commitsBetweenForFile": 1,
          "actualSource": "@Override\npublic void write(JsonWriter writer, T value) throws IOException {\n    if (value \u003d\u003d null) {\n        writer.nullValue();\n        return;\n    }\n    writer.beginObject();\n    try {\n        for (BoundField boundField : boundFields.values()) {\n            if (boundField.serialized) {\n                writer.name(boundField.name);\n                boundField.write(writer, value);\n            }\n        }\n    } catch (IllegalAccessException e) {\n        throw new AssertionError();\n    }\n    writer.endObject();\n}",
          "path": "gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java",
          "functionStartLine": 191,
          "functionName": "write",
          "functionAnnotation": "@Override",
          "functionDoc": "",
          "diff": "@@ -1,26 +1,19 @@\n+@Override\n public void write(JsonWriter writer, T value) throws IOException {\n     if (value \u003d\u003d null) {\n         writer.nullValue();\n         return;\n     }\n-    if (false) {\n-        Class\u003c?\u003e runtimeType \u003d value.getClass();\n-        if (runtimeType !\u003d type.getRawType()) {\n-            TypeAdapter\u003c?\u003e adapter \u003d context.getAdapter(runtimeType);\n-            ((TypeAdapter) adapter).write(writer, value);\n-            return;\n-        }\n-    }\n     writer.beginObject();\n     try {\n         for (BoundField boundField : boundFields.values()) {\n             if (boundField.serialized) {\n                 writer.name(boundField.name);\n                 boundField.write(writer, value);\n             }\n         }\n     } catch (IllegalAccessException e) {\n         throw new AssertionError();\n     }\n     writer.endObject();\n }\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldValue": "",
            "newValue": "@Override"
          }
        }
      ]
    },
    "25c6ae177b1ca56db7f3c29eb574bdd032a06165": {
      "type": "Ymultichange(Ymovefromfile,Ybodychange)",
      "commitMessage": "Down to 22 failing tests.\n\nConsolidated all of the different code paths that we use to construct instances. We now have an ObjectConstructor class that knows what type it constructs; this means that we don\u0027t need to ever do reflection to lookup a constructor at construction time.\n\nCleaned up some buggy type adapters, particularly around handling of null.\n\nRemoved dead code for object graph navigation.\n\nMoved some classes into \u0027internal\u0027 so they are visible to the \u0027bind\u0027 subpackage.\n\nTurned some TypeAdapterFactory/TypeAdapter pairs inside out so that the TypeAdapter is now the inner class. This is necessary so that the factories can take parameters.\n\nAdded an API to request the \u0027next\u0027 type adapter for a type. This allows type adapters to compose other type adapters. We\u0027re using this in two places:\n - where the user has excluded a type from serialization but not deserialization, we need to use the \"default\" deserialization but interpose null on serialization. We create a type adapter that delegates for one and returns null for the other.\n - similarly when a DOM type serializer is registered but no deserializer, or vice versa.\nThis is the biggest change to the MiniGson core.\n\nFor backwards compatibility, return null for the empty string.\n\nSimplify JsonSerializationContext/JsonDeserializationContext to simply call through to GSON. SerializeDefault is currently unsupported.\n\nMore useful error messages when calling getAsBoolean on a JsonNull.\n\nRemove currently unused MemoryRefStack. We might need this back again, though wiring it back in will be much more difficult because we don\u0027t interject ourselves between the users\u0027 various type adapters.\n",
      "commitDate": "9/11/11, 12:04 AM",
      "commitName": "25c6ae177b1ca56db7f3c29eb574bdd032a06165",
      "commitAuthor": "Jesse Wilson",
      "subchanges": [
        {
          "type": "Ymovefromfile",
          "commitMessage": "Down to 22 failing tests.\n\nConsolidated all of the different code paths that we use to construct instances. We now have an ObjectConstructor class that knows what type it constructs; this means that we don\u0027t need to ever do reflection to lookup a constructor at construction time.\n\nCleaned up some buggy type adapters, particularly around handling of null.\n\nRemoved dead code for object graph navigation.\n\nMoved some classes into \u0027internal\u0027 so they are visible to the \u0027bind\u0027 subpackage.\n\nTurned some TypeAdapterFactory/TypeAdapter pairs inside out so that the TypeAdapter is now the inner class. This is necessary so that the factories can take parameters.\n\nAdded an API to request the \u0027next\u0027 type adapter for a type. This allows type adapters to compose other type adapters. We\u0027re using this in two places:\n - where the user has excluded a type from serialization but not deserialization, we need to use the \"default\" deserialization but interpose null on serialization. We create a type adapter that delegates for one and returns null for the other.\n - similarly when a DOM type serializer is registered but no deserializer, or vice versa.\nThis is the biggest change to the MiniGson core.\n\nFor backwards compatibility, return null for the empty string.\n\nSimplify JsonSerializationContext/JsonDeserializationContext to simply call through to GSON. SerializeDefault is currently unsupported.\n\nMore useful error messages when calling getAsBoolean on a JsonNull.\n\nRemove currently unused MemoryRefStack. We might need this back again, though wiring it back in will be much more difficult because we don\u0027t interject ourselves between the users\u0027 various type adapters.\n",
          "commitDate": "9/11/11, 12:04 AM",
          "commitName": "25c6ae177b1ca56db7f3c29eb574bdd032a06165",
          "commitAuthor": "Jesse Wilson",
          "commitDateOld": "9/9/11, 1:17 AM",
          "commitNameOld": "cdd5d80b85155c21c61f888fb3e70c65e72edef7",
          "commitAuthorOld": "Jesse Wilson",
          "daysBetweenCommits": 1.95,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "actualSource": "public void write(JsonWriter writer, T value) throws IOException {\n    if (value \u003d\u003d null) {\n        writer.nullValue();\n        return;\n    }\n    if (false) {\n        Class\u003c?\u003e runtimeType \u003d value.getClass();\n        if (runtimeType !\u003d type.getRawType()) {\n            TypeAdapter\u003c?\u003e adapter \u003d context.getAdapter(runtimeType);\n            ((TypeAdapter) adapter).write(writer, value);\n            return;\n        }\n    }\n    writer.beginObject();\n    try {\n        for (BoundField boundField : boundFields.values()) {\n            if (boundField.serialized) {\n                writer.name(boundField.name);\n                boundField.write(writer, value);\n            }\n        }\n    } catch (IllegalAccessException e) {\n        throw new AssertionError();\n    }\n    writer.endObject();\n}",
          "path": "gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java",
          "functionStartLine": 189,
          "functionName": "write",
          "functionAnnotation": "",
          "functionDoc": "",
          "diff": "@@ -1,18 +1,26 @@\n public void write(JsonWriter writer, T value) throws IOException {\n     if (value \u003d\u003d null) {\n         writer.nullValue();\n         return;\n     }\n+    if (false) {\n+        Class\u003c?\u003e runtimeType \u003d value.getClass();\n+        if (runtimeType !\u003d type.getRawType()) {\n+            TypeAdapter\u003c?\u003e adapter \u003d context.getAdapter(runtimeType);\n+            ((TypeAdapter) adapter).write(writer, value);\n+            return;\n+        }\n+    }\n     writer.beginObject();\n     try {\n-        for (BoundField boundField : boundFields) {\n+        for (BoundField boundField : boundFields.values()) {\n             if (boundField.serialized) {\n                 writer.name(boundField.name);\n                 boundField.write(writer, value);\n             }\n         }\n     } catch (IllegalAccessException e) {\n         throw new AssertionError();\n     }\n     writer.endObject();\n }\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldPath": "gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapter.java",
            "newPath": "gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java",
            "oldMethodName": "write",
            "newMethodName": "write"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "Down to 22 failing tests.\n\nConsolidated all of the different code paths that we use to construct instances. We now have an ObjectConstructor class that knows what type it constructs; this means that we don\u0027t need to ever do reflection to lookup a constructor at construction time.\n\nCleaned up some buggy type adapters, particularly around handling of null.\n\nRemoved dead code for object graph navigation.\n\nMoved some classes into \u0027internal\u0027 so they are visible to the \u0027bind\u0027 subpackage.\n\nTurned some TypeAdapterFactory/TypeAdapter pairs inside out so that the TypeAdapter is now the inner class. This is necessary so that the factories can take parameters.\n\nAdded an API to request the \u0027next\u0027 type adapter for a type. This allows type adapters to compose other type adapters. We\u0027re using this in two places:\n - where the user has excluded a type from serialization but not deserialization, we need to use the \"default\" deserialization but interpose null on serialization. We create a type adapter that delegates for one and returns null for the other.\n - similarly when a DOM type serializer is registered but no deserializer, or vice versa.\nThis is the biggest change to the MiniGson core.\n\nFor backwards compatibility, return null for the empty string.\n\nSimplify JsonSerializationContext/JsonDeserializationContext to simply call through to GSON. SerializeDefault is currently unsupported.\n\nMore useful error messages when calling getAsBoolean on a JsonNull.\n\nRemove currently unused MemoryRefStack. We might need this back again, though wiring it back in will be much more difficult because we don\u0027t interject ourselves between the users\u0027 various type adapters.\n",
          "commitDate": "9/11/11, 12:04 AM",
          "commitName": "25c6ae177b1ca56db7f3c29eb574bdd032a06165",
          "commitAuthor": "Jesse Wilson",
          "commitDateOld": "9/9/11, 1:17 AM",
          "commitNameOld": "cdd5d80b85155c21c61f888fb3e70c65e72edef7",
          "commitAuthorOld": "Jesse Wilson",
          "daysBetweenCommits": 1.95,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "actualSource": "public void write(JsonWriter writer, T value) throws IOException {\n    if (value \u003d\u003d null) {\n        writer.nullValue();\n        return;\n    }\n    if (false) {\n        Class\u003c?\u003e runtimeType \u003d value.getClass();\n        if (runtimeType !\u003d type.getRawType()) {\n            TypeAdapter\u003c?\u003e adapter \u003d context.getAdapter(runtimeType);\n            ((TypeAdapter) adapter).write(writer, value);\n            return;\n        }\n    }\n    writer.beginObject();\n    try {\n        for (BoundField boundField : boundFields.values()) {\n            if (boundField.serialized) {\n                writer.name(boundField.name);\n                boundField.write(writer, value);\n            }\n        }\n    } catch (IllegalAccessException e) {\n        throw new AssertionError();\n    }\n    writer.endObject();\n}",
          "path": "gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java",
          "functionStartLine": 189,
          "functionName": "write",
          "functionAnnotation": "",
          "functionDoc": "",
          "diff": "@@ -1,18 +1,26 @@\n public void write(JsonWriter writer, T value) throws IOException {\n     if (value \u003d\u003d null) {\n         writer.nullValue();\n         return;\n     }\n+    if (false) {\n+        Class\u003c?\u003e runtimeType \u003d value.getClass();\n+        if (runtimeType !\u003d type.getRawType()) {\n+            TypeAdapter\u003c?\u003e adapter \u003d context.getAdapter(runtimeType);\n+            ((TypeAdapter) adapter).write(writer, value);\n+            return;\n+        }\n+    }\n     writer.beginObject();\n     try {\n-        for (BoundField boundField : boundFields) {\n+        for (BoundField boundField : boundFields.values()) {\n             if (boundField.serialized) {\n                 writer.name(boundField.name);\n                 boundField.write(writer, value);\n             }\n         }\n     } catch (IllegalAccessException e) {\n         throw new AssertionError();\n     }\n     writer.endObject();\n }\n\\ No newline at end of file\n",
          "extendedDetails": {}
        }
      ]
    },
    "f276d1382775e962d1a0a4b9e7e3e08496252861": {
      "type": "Ybodychange",
      "commitMessage": "Added support for deserialization exclusion strategy.\n",
      "commitDate": "8/2/11, 6:19 PM",
      "commitName": "f276d1382775e962d1a0a4b9e7e3e08496252861",
      "commitAuthor": "Inderjeet Singh",
      "commitDateOld": "8/2/11, 5:47 PM",
      "commitNameOld": "3331dcdab08792f6281ab6343532031a52f54003",
      "commitAuthorOld": "Inderjeet Singh",
      "daysBetweenCommits": 0.02,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "public void write(JsonWriter writer, T value) throws IOException {\n    if (value \u003d\u003d null) {\n        writer.nullValue();\n        return;\n    }\n    writer.beginObject();\n    try {\n        for (BoundField boundField : boundFields) {\n            if (boundField.serialized) {\n                writer.name(boundField.name);\n                boundField.write(writer, value);\n            }\n        }\n    } catch (IllegalAccessException e) {\n        throw new AssertionError();\n    }\n    writer.endObject();\n}",
      "path": "gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapter.java",
      "functionStartLine": 77,
      "functionName": "write",
      "functionAnnotation": "",
      "functionDoc": "",
      "diff": "@@ -1,16 +1,18 @@\n public void write(JsonWriter writer, T value) throws IOException {\n     if (value \u003d\u003d null) {\n         writer.nullValue();\n         return;\n     }\n     writer.beginObject();\n     try {\n         for (BoundField boundField : boundFields) {\n-            writer.name(boundField.name);\n-            boundField.write(writer, value);\n+            if (boundField.serialized) {\n+                writer.name(boundField.name);\n+                boundField.write(writer, value);\n+            }\n         }\n     } catch (IllegalAccessException e) {\n         throw new AssertionError();\n     }\n     writer.endObject();\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "60e6ed912d52716f46a1ba71923ef203c4248857": {
      "type": "Yfilerename",
      "commitMessage": "Promote MiniGson to gson.internal.bind\n",
      "commitDate": "8/2/11, 5:25 PM",
      "commitName": "60e6ed912d52716f46a1ba71923ef203c4248857",
      "commitAuthor": "Jesse Wilson",
      "commitDateOld": "8/2/11, 5:17 PM",
      "commitNameOld": "759eb8ede50f61fd525f5d703dd9fd45ddae1dcd",
      "commitAuthorOld": "Jesse Wilson",
      "daysBetweenCommits": 0.01,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "public void write(JsonWriter writer, T value) throws IOException {\n    if (value \u003d\u003d null) {\n        writer.nullValue();\n        return;\n    }\n    writer.beginObject();\n    try {\n        for (BoundField boundField : boundFields) {\n            writer.name(boundField.name);\n            boundField.write(writer, value);\n        }\n    } catch (IllegalAccessException e) {\n        throw new AssertionError();\n    }\n    writer.endObject();\n}",
      "path": "gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapter.java",
      "functionStartLine": 111,
      "functionName": "write",
      "functionAnnotation": "",
      "functionDoc": "",
      "diff": "",
      "extendedDetails": {
        "oldPath": "extras/src/main/java/com/google/gson/mini/ReflectiveTypeAdapter.java",
        "newPath": "gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapter.java"
      }
    },
    "4b042671af018f308c2a261145dc6712e39b96e7": {
      "type": "Ybodychange",
      "commitMessage": "Cleanup after experimenting with specializing BoundField by type (ie. Field.setInt() to avoid autoboxing)\n",
      "commitDate": "7/15/11, 7:37 AM",
      "commitName": "4b042671af018f308c2a261145dc6712e39b96e7",
      "commitAuthor": "Jesse Wilson",
      "commitDateOld": "7/15/11, 6:43 AM",
      "commitNameOld": "3c4d121dc8736c7359731f9cb99098e2999f8575",
      "commitAuthorOld": "Jesse Wilson",
      "daysBetweenCommits": 0.04,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "public void write(JsonWriter writer, T value) throws IOException {\n    if (value \u003d\u003d null) {\n        writer.nullValue();\n        return;\n    }\n    writer.beginObject();\n    try {\n        for (BoundField boundField : boundFields) {\n            writer.name(boundField.name);\n            boundField.write(writer, value);\n        }\n    } catch (IllegalAccessException e) {\n        throw new AssertionError();\n    }\n    writer.endObject();\n}",
      "path": "extras/src/main/java/com/google/gson/mini/ReflectiveTypeAdapter.java",
      "functionStartLine": 111,
      "functionName": "write",
      "functionAnnotation": "",
      "functionDoc": "",
      "diff": "@@ -1,12 +1,16 @@\n public void write(JsonWriter writer, T value) throws IOException {\n     if (value \u003d\u003d null) {\n         writer.nullValue();\n         return;\n     }\n     writer.beginObject();\n-    for (BoundField\u003c?\u003e boundField : boundFields) {\n-        writer.name(boundField.name);\n-        boundField.write(writer, value);\n+    try {\n+        for (BoundField boundField : boundFields) {\n+            writer.name(boundField.name);\n+            boundField.write(writer, value);\n+        }\n+    } catch (IllegalAccessException e) {\n+        throw new AssertionError();\n     }\n     writer.endObject();\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "95a345234fb1d51ada03f37d50769cd5198b5af3": {
      "type": "Ybodychange",
      "commitMessage": "MiniGSON Map adapters and support for nulls.\n",
      "commitDate": "7/11/11, 2:45 PM",
      "commitName": "95a345234fb1d51ada03f37d50769cd5198b5af3",
      "commitAuthor": "Jesse Wilson",
      "commitDateOld": "7/11/11, 9:46 AM",
      "commitNameOld": "c5f1df10175c254b823fc019832bf1bf7b71e929",
      "commitAuthorOld": "Jesse Wilson",
      "daysBetweenCommits": 0.21,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "public void write(JsonWriter writer, T value) throws IOException {\n    if (value \u003d\u003d null) {\n        writer.nullValue();\n        return;\n    }\n    writer.beginObject();\n    for (BoundField\u003c?\u003e boundField : boundFields) {\n        writer.name(boundField.name);\n        boundField.write(writer, value);\n    }\n    writer.endObject();\n}",
      "path": "extras/src/main/java/com/google/gson/mini/ReflectiveTypeAdapter.java",
      "functionStartLine": 106,
      "functionName": "write",
      "functionAnnotation": "",
      "functionDoc": "",
      "diff": "@@ -1,8 +1,12 @@\n public void write(JsonWriter writer, T value) throws IOException {\n+    if (value \u003d\u003d null) {\n+        writer.nullValue();\n+        return;\n+    }\n     writer.beginObject();\n     for (BoundField\u003c?\u003e boundField : boundFields) {\n         writer.name(boundField.name);\n         boundField.write(writer, value);\n     }\n     writer.endObject();\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "c5f1df10175c254b823fc019832bf1bf7b71e929": {
      "type": "Yintroduced",
      "commitMessage": "MiniGSON prototype!\n",
      "commitDate": "7/11/11, 9:46 AM",
      "commitName": "c5f1df10175c254b823fc019832bf1bf7b71e929",
      "commitAuthor": "Jesse Wilson",
      "diff": "@@ -0,0 +1,8 @@\n+public void write(JsonWriter writer, T value) throws IOException {\n+    writer.beginObject();\n+    for (BoundField\u003c?\u003e boundField : boundFields) {\n+        writer.name(boundField.name);\n+        boundField.write(writer, value);\n+    }\n+    writer.endObject();\n+}\n\\ No newline at end of file\n",
      "actualSource": "public void write(JsonWriter writer, T value) throws IOException {\n    writer.beginObject();\n    for (BoundField\u003c?\u003e boundField : boundFields) {\n        writer.name(boundField.name);\n        boundField.write(writer, value);\n    }\n    writer.endObject();\n}",
      "path": "extras/src/main/java/com/google/gson/mini/ReflectiveTypeAdapter.java",
      "functionStartLine": 100,
      "functionName": "write",
      "functionAnnotation": "",
      "functionDoc": ""
    }
  }
}