{
  "origin": "codeshovel",
  "repositoryName": "Gson-10b",
  "repositoryPath": "/tmp/Gson-10b//.git",
  "startCommitName": "HEAD",
  "sourceFileName": "ReflectiveTypeAdapterFactory.java",
  "functionName": "createBoundField",
  "functionId": "createBoundField___context-Gson(modifiers-final)__field-Field(modifiers-final)__name-String(modifiers-final)__fieldType-TypeToken__?__(modifiers-final)__serialize-boolean__deserialize-boolean",
  "sourceFilePath": "gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java",
  "functionAnnotation": "",
  "functionDoc": "",
  "functionStartLine": 102,
  "functionEndLine": 130,
  "numCommitsSeen": 62,
  "timeTaken": 2703,
  "changeHistory": [
    "e5b3f6368db33c846b094b0d695d3a1b826e3892",
    "8d5a41329ec2f4db3aed02c20d379baf92840b37",
    "bf549f0589105a42f159c78a621fc28087561d16",
    "af4879dbb782bb13fd95e3b406a55d80272ddff3",
    "fd4fbe41322c39329245b6a1311ae42bd10827ad",
    "7e760143fdc8b689daeebdee33ad6ea7d0a62a56",
    "31964507c1caabc9a70e3270fa56aaee29eff6b2",
    "25c6ae177b1ca56db7f3c29eb574bdd032a06165",
    "ad5ff0f2d9c08fb25d821bdc038934642c3c7367",
    "e9a971f6806e5bebd2f6e677c3b126efad68a01c",
    "6e3bf0730037fb3cb7aab7fe607fbe61ba5fe5e6",
    "2813385c33c34c3758f4bba863526551add0c58e",
    "f1f8b666ec665b41446ddb3d68de115d8ce91d2f",
    "f276d1382775e962d1a0a4b9e7e3e08496252861",
    "60e6ed912d52716f46a1ba71923ef203c4248857",
    "4b042671af018f308c2a261145dc6712e39b96e7"
  ],
  "changeHistoryShort": {
    "e5b3f6368db33c846b094b0d695d3a1b826e3892": "Ybodychange",
    "8d5a41329ec2f4db3aed02c20d379baf92840b37": "Ybodychange",
    "bf549f0589105a42f159c78a621fc28087561d16": "Ybodychange",
    "af4879dbb782bb13fd95e3b406a55d80272ddff3": "Ybodychange",
    "fd4fbe41322c39329245b6a1311ae42bd10827ad": "Ybodychange",
    "7e760143fdc8b689daeebdee33ad6ea7d0a62a56": "Yparameterchange",
    "31964507c1caabc9a70e3270fa56aaee29eff6b2": "Ybodychange",
    "25c6ae177b1ca56db7f3c29eb574bdd032a06165": "Ymultichange(Ymovefromfile,Yreturntypechange,Ymodifierchange,Ybodychange)",
    "ad5ff0f2d9c08fb25d821bdc038934642c3c7367": "Ybodychange",
    "e9a971f6806e5bebd2f6e677c3b126efad68a01c": "Ybodychange",
    "6e3bf0730037fb3cb7aab7fe607fbe61ba5fe5e6": "Ybodychange",
    "2813385c33c34c3758f4bba863526551add0c58e": "Ybodychange",
    "f1f8b666ec665b41446ddb3d68de115d8ce91d2f": "Ymultichange(Yparameterchange,Ybodychange)",
    "f276d1382775e962d1a0a4b9e7e3e08496252861": "Ymultichange(Yparameterchange,Ybodychange)",
    "60e6ed912d52716f46a1ba71923ef203c4248857": "Yfilerename",
    "4b042671af018f308c2a261145dc6712e39b96e7": "Yintroduced"
  },
  "changeHistoryDetails": {
    "e5b3f6368db33c846b094b0d695d3a1b826e3892": {
      "type": "Ybodychange",
      "commitMessage": "updated minimum JDK version to 1.6.\nAdded Overrides for methods implementing an interface.\n",
      "commitDate": "11/4/15, 6:52 PM",
      "commitName": "e5b3f6368db33c846b094b0d695d3a1b826e3892",
      "commitAuthor": "Inderjeet Singh",
      "commitDateOld": "10/3/15, 2:01 AM",
      "commitNameOld": "109915d93a2b36c26b49c0fabb1947a5a892cb25",
      "commitAuthorOld": "Inderjeet Singh",
      "daysBetweenCommits": 32.74,
      "commitsBetweenForRepo": 21,
      "commitsBetweenForFile": 1,
      "actualSource": "private ReflectiveTypeAdapterFactory.BoundField createBoundField(final Gson context, final Field field, final String name, final TypeToken\u003c?\u003e fieldType, boolean serialize, boolean deserialize) {\n    final boolean isPrimitive \u003d Primitives.isPrimitive(fieldType.getRawType());\n    return new ReflectiveTypeAdapterFactory.BoundField(name, serialize, deserialize) {\n\n        final TypeAdapter\u003c?\u003e typeAdapter \u003d getFieldAdapter(context, field, fieldType);\n\n        @SuppressWarnings({ \"unchecked\", \"rawtypes\" })\n        @Override\n        void write(JsonWriter writer, Object value) throws IOException, IllegalAccessException {\n            Object fieldValue \u003d field.get(value);\n            TypeAdapter t \u003d new TypeAdapterRuntimeTypeWrapper(context, this.typeAdapter, fieldType.getType());\n            t.write(writer, fieldValue);\n        }\n\n        @Override\n        void read(JsonReader reader, Object value) throws IOException, IllegalAccessException {\n            Object fieldValue \u003d typeAdapter.read(reader);\n            if (fieldValue !\u003d null || !isPrimitive) {\n                field.set(value, fieldValue);\n            }\n        }\n\n        @Override\n        public boolean writeField(Object value) throws IOException, IllegalAccessException {\n            if (!serialized)\n                return false;\n            Object fieldValue \u003d field.get(value);\n            return fieldValue !\u003d value;\n        }\n    };\n}",
      "path": "gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java",
      "functionStartLine": 100,
      "functionName": "createBoundField",
      "functionAnnotation": "",
      "functionDoc": "",
      "diff": "@@ -1,30 +1,31 @@\n private ReflectiveTypeAdapterFactory.BoundField createBoundField(final Gson context, final Field field, final String name, final TypeToken\u003c?\u003e fieldType, boolean serialize, boolean deserialize) {\n     final boolean isPrimitive \u003d Primitives.isPrimitive(fieldType.getRawType());\n     return new ReflectiveTypeAdapterFactory.BoundField(name, serialize, deserialize) {\n \n         final TypeAdapter\u003c?\u003e typeAdapter \u003d getFieldAdapter(context, field, fieldType);\n \n         @SuppressWarnings({ \"unchecked\", \"rawtypes\" })\n         @Override\n         void write(JsonWriter writer, Object value) throws IOException, IllegalAccessException {\n             Object fieldValue \u003d field.get(value);\n             TypeAdapter t \u003d new TypeAdapterRuntimeTypeWrapper(context, this.typeAdapter, fieldType.getType());\n             t.write(writer, fieldValue);\n         }\n \n         @Override\n         void read(JsonReader reader, Object value) throws IOException, IllegalAccessException {\n             Object fieldValue \u003d typeAdapter.read(reader);\n             if (fieldValue !\u003d null || !isPrimitive) {\n                 field.set(value, fieldValue);\n             }\n         }\n \n+        @Override\n         public boolean writeField(Object value) throws IOException, IllegalAccessException {\n             if (!serialized)\n                 return false;\n             Object fieldValue \u003d field.get(value);\n             return fieldValue !\u003d value;\n         }\n     };\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "8d5a41329ec2f4db3aed02c20d379baf92840b37": {
      "type": "Ybodychange",
      "commitMessage": "added tests for Throwable. Revised ReflectiveTypeAdapterFactory to ignore self-referencing fields.\n",
      "commitDate": "11/16/14, 2:55 PM",
      "commitName": "8d5a41329ec2f4db3aed02c20d379baf92840b37",
      "commitAuthor": "Inderjeet Singh",
      "commitDateOld": "11/16/14, 2:25 PM",
      "commitNameOld": "b6a625fb6cb7e46a01938fef79ac6ea26c93a8dc",
      "commitAuthorOld": "Inderjeet Singh",
      "daysBetweenCommits": 0.02,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "private ReflectiveTypeAdapterFactory.BoundField createBoundField(final Gson context, final Field field, final String name, final TypeToken\u003c?\u003e fieldType, boolean serialize, boolean deserialize) {\n    final boolean isPrimitive \u003d Primitives.isPrimitive(fieldType.getRawType());\n    return new ReflectiveTypeAdapterFactory.BoundField(name, serialize, deserialize) {\n\n        final TypeAdapter\u003c?\u003e typeAdapter \u003d getFieldAdapter(context, field, fieldType);\n\n        @SuppressWarnings({ \"unchecked\", \"rawtypes\" })\n        @Override\n        void write(JsonWriter writer, Object value) throws IOException, IllegalAccessException {\n            Object fieldValue \u003d field.get(value);\n            TypeAdapter t \u003d new TypeAdapterRuntimeTypeWrapper(context, this.typeAdapter, fieldType.getType());\n            t.write(writer, fieldValue);\n        }\n\n        @Override\n        void read(JsonReader reader, Object value) throws IOException, IllegalAccessException {\n            Object fieldValue \u003d typeAdapter.read(reader);\n            if (fieldValue !\u003d null || !isPrimitive) {\n                field.set(value, fieldValue);\n            }\n        }\n\n        public boolean writeField(Object value) throws IOException, IllegalAccessException {\n            if (!serialized)\n                return false;\n            Object fieldValue \u003d field.get(value);\n            return fieldValue !\u003d value;\n        }\n    };\n}",
      "path": "gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java",
      "functionStartLine": 86,
      "functionName": "createBoundField",
      "functionAnnotation": "",
      "functionDoc": "",
      "diff": "@@ -1,23 +1,30 @@\n private ReflectiveTypeAdapterFactory.BoundField createBoundField(final Gson context, final Field field, final String name, final TypeToken\u003c?\u003e fieldType, boolean serialize, boolean deserialize) {\n     final boolean isPrimitive \u003d Primitives.isPrimitive(fieldType.getRawType());\n     return new ReflectiveTypeAdapterFactory.BoundField(name, serialize, deserialize) {\n \n         final TypeAdapter\u003c?\u003e typeAdapter \u003d getFieldAdapter(context, field, fieldType);\n \n         @SuppressWarnings({ \"unchecked\", \"rawtypes\" })\n         @Override\n         void write(JsonWriter writer, Object value) throws IOException, IllegalAccessException {\n             Object fieldValue \u003d field.get(value);\n             TypeAdapter t \u003d new TypeAdapterRuntimeTypeWrapper(context, this.typeAdapter, fieldType.getType());\n             t.write(writer, fieldValue);\n         }\n \n         @Override\n         void read(JsonReader reader, Object value) throws IOException, IllegalAccessException {\n             Object fieldValue \u003d typeAdapter.read(reader);\n             if (fieldValue !\u003d null || !isPrimitive) {\n                 field.set(value, fieldValue);\n             }\n         }\n+\n+        public boolean writeField(Object value) throws IOException, IllegalAccessException {\n+            if (!serialized)\n+                return false;\n+            Object fieldValue \u003d field.get(value);\n+            return fieldValue !\u003d value;\n+        }\n     };\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "bf549f0589105a42f159c78a621fc28087561d16": {
      "type": "Ybodychange",
      "commitMessage": "Added support for JsonAdapter annotation on fields\n",
      "commitDate": "3/8/14, 11:28 PM",
      "commitName": "bf549f0589105a42f159c78a621fc28087561d16",
      "commitAuthor": "Inderjeet Singh",
      "commitDateOld": "4/12/13, 1:20 PM",
      "commitNameOld": "6f0a6a4662c2cc692faddacd3f59fc3addc01a68",
      "commitAuthorOld": "Inderjeet Singh",
      "daysBetweenCommits": 330.46,
      "commitsBetweenForRepo": 26,
      "commitsBetweenForFile": 1,
      "actualSource": "private ReflectiveTypeAdapterFactory.BoundField createBoundField(final Gson context, final Field field, final String name, final TypeToken\u003c?\u003e fieldType, boolean serialize, boolean deserialize) {\n    final boolean isPrimitive \u003d Primitives.isPrimitive(fieldType.getRawType());\n    return new ReflectiveTypeAdapterFactory.BoundField(name, serialize, deserialize) {\n\n        final TypeAdapter\u003c?\u003e typeAdapter \u003d getFieldAdapter(context, field, fieldType);\n\n        @SuppressWarnings({ \"unchecked\", \"rawtypes\" })\n        @Override\n        void write(JsonWriter writer, Object value) throws IOException, IllegalAccessException {\n            Object fieldValue \u003d field.get(value);\n            TypeAdapter t \u003d new TypeAdapterRuntimeTypeWrapper(context, this.typeAdapter, fieldType.getType());\n            t.write(writer, fieldValue);\n        }\n\n        @Override\n        void read(JsonReader reader, Object value) throws IOException, IllegalAccessException {\n            Object fieldValue \u003d typeAdapter.read(reader);\n            if (fieldValue !\u003d null || !isPrimitive) {\n                field.set(value, fieldValue);\n            }\n        }\n    };\n}",
      "path": "gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java",
      "functionStartLine": 77,
      "functionName": "createBoundField",
      "functionAnnotation": "",
      "functionDoc": "",
      "diff": "@@ -1,23 +1,23 @@\n private ReflectiveTypeAdapterFactory.BoundField createBoundField(final Gson context, final Field field, final String name, final TypeToken\u003c?\u003e fieldType, boolean serialize, boolean deserialize) {\n     final boolean isPrimitive \u003d Primitives.isPrimitive(fieldType.getRawType());\n     return new ReflectiveTypeAdapterFactory.BoundField(name, serialize, deserialize) {\n \n-        final TypeAdapter\u003c?\u003e typeAdapter \u003d context.getAdapter(fieldType);\n+        final TypeAdapter\u003c?\u003e typeAdapter \u003d getFieldAdapter(context, field, fieldType);\n \n         @SuppressWarnings({ \"unchecked\", \"rawtypes\" })\n         @Override\n         void write(JsonWriter writer, Object value) throws IOException, IllegalAccessException {\n             Object fieldValue \u003d field.get(value);\n             TypeAdapter t \u003d new TypeAdapterRuntimeTypeWrapper(context, this.typeAdapter, fieldType.getType());\n             t.write(writer, fieldValue);\n         }\n \n         @Override\n         void read(JsonReader reader, Object value) throws IOException, IllegalAccessException {\n             Object fieldValue \u003d typeAdapter.read(reader);\n             if (fieldValue !\u003d null || !isPrimitive) {\n                 field.set(value, fieldValue);\n             }\n         }\n     };\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "af4879dbb782bb13fd95e3b406a55d80272ddff3": {
      "type": "Ybodychange",
      "commitMessage": "Move interceptors from \u0027alpha\u0027 to \u0027extras\u0027.\n\nThis makes the feature less risky to use! It now uses our\nTypeAdapterFactory infrastructure rather than relying on\nparallel infrastructure.\n\n",
      "commitDate": "10/23/12, 10:36 AM",
      "commitName": "af4879dbb782bb13fd95e3b406a55d80272ddff3",
      "commitAuthor": "Jesse Wilson",
      "commitDateOld": "10/17/12, 7:37 PM",
      "commitNameOld": "fd4fbe41322c39329245b6a1311ae42bd10827ad",
      "commitAuthorOld": "Inderjeet Singh",
      "daysBetweenCommits": 5.62,
      "commitsBetweenForRepo": 3,
      "commitsBetweenForFile": 1,
      "actualSource": "private ReflectiveTypeAdapterFactory.BoundField createBoundField(final Gson context, final Field field, final String name, final TypeToken\u003c?\u003e fieldType, boolean serialize, boolean deserialize) {\n    final boolean isPrimitive \u003d Primitives.isPrimitive(fieldType.getRawType());\n    return new ReflectiveTypeAdapterFactory.BoundField(name, serialize, deserialize) {\n\n        final TypeAdapter\u003c?\u003e typeAdapter \u003d context.getAdapter(fieldType);\n\n        @SuppressWarnings({ \"unchecked\", \"rawtypes\" })\n        @Override\n        void write(JsonWriter writer, Object value) throws IOException, IllegalAccessException {\n            Object fieldValue \u003d field.get(value);\n            TypeAdapter t \u003d new TypeAdapterRuntimeTypeWrapper(context, this.typeAdapter, fieldType.getType());\n            t.write(writer, fieldValue);\n        }\n\n        @Override\n        void read(JsonReader reader, Object value) throws IOException, IllegalAccessException {\n            Object fieldValue \u003d typeAdapter.read(reader);\n            if (fieldValue !\u003d null || !isPrimitive) {\n                field.set(value, fieldValue);\n            }\n        }\n    };\n}",
      "path": "gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java",
      "functionStartLine": 75,
      "functionName": "createBoundField",
      "functionAnnotation": "",
      "functionDoc": "",
      "diff": "@@ -1,24 +1,23 @@\n private ReflectiveTypeAdapterFactory.BoundField createBoundField(final Gson context, final Field field, final String name, final TypeToken\u003c?\u003e fieldType, boolean serialize, boolean deserialize) {\n     final boolean isPrimitive \u003d Primitives.isPrimitive(fieldType.getRawType());\n     return new ReflectiveTypeAdapterFactory.BoundField(name, serialize, deserialize) {\n \n         final TypeAdapter\u003c?\u003e typeAdapter \u003d context.getAdapter(fieldType);\n \n         @SuppressWarnings({ \"unchecked\", \"rawtypes\" })\n         @Override\n         void write(JsonWriter writer, Object value) throws IOException, IllegalAccessException {\n             Object fieldValue \u003d field.get(value);\n             TypeAdapter t \u003d new TypeAdapterRuntimeTypeWrapper(context, this.typeAdapter, fieldType.getType());\n             t.write(writer, fieldValue);\n         }\n \n         @Override\n         void read(JsonReader reader, Object value) throws IOException, IllegalAccessException {\n             Object fieldValue \u003d typeAdapter.read(reader);\n-            Gson.$Internal$Access.invokeInterceptor(context, fieldValue, fieldType.getRawType());\n             if (fieldValue !\u003d null || !isPrimitive) {\n                 field.set(value, fieldValue);\n             }\n         }\n     };\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "fd4fbe41322c39329245b6a1311ae42bd10827ad": {
      "type": "Ybodychange",
      "commitMessage": "Added support for collections, maps, and arbitrary depth of type adapters for Intercept annotation.\nAdded more tests for the features.\n",
      "commitDate": "10/17/12, 7:37 PM",
      "commitName": "fd4fbe41322c39329245b6a1311ae42bd10827ad",
      "commitAuthor": "Inderjeet Singh",
      "commitDateOld": "1/1/12, 5:42 AM",
      "commitNameOld": "6cca23c172612aded9ee2996a5177cb7b9a84390",
      "commitAuthorOld": "Jesse Wilson",
      "daysBetweenCommits": 290.54,
      "commitsBetweenForRepo": 93,
      "commitsBetweenForFile": 1,
      "actualSource": "private ReflectiveTypeAdapterFactory.BoundField createBoundField(final Gson context, final Field field, final String name, final TypeToken\u003c?\u003e fieldType, boolean serialize, boolean deserialize) {\n    final boolean isPrimitive \u003d Primitives.isPrimitive(fieldType.getRawType());\n    return new ReflectiveTypeAdapterFactory.BoundField(name, serialize, deserialize) {\n\n        final TypeAdapter\u003c?\u003e typeAdapter \u003d context.getAdapter(fieldType);\n\n        @SuppressWarnings({ \"unchecked\", \"rawtypes\" })\n        @Override\n        void write(JsonWriter writer, Object value) throws IOException, IllegalAccessException {\n            Object fieldValue \u003d field.get(value);\n            TypeAdapter t \u003d new TypeAdapterRuntimeTypeWrapper(context, this.typeAdapter, fieldType.getType());\n            t.write(writer, fieldValue);\n        }\n\n        @Override\n        void read(JsonReader reader, Object value) throws IOException, IllegalAccessException {\n            Object fieldValue \u003d typeAdapter.read(reader);\n            Gson.$Internal$Access.invokeInterceptor(context, fieldValue, fieldType.getRawType());\n            if (fieldValue !\u003d null || !isPrimitive) {\n                field.set(value, fieldValue);\n            }\n        }\n    };\n}",
      "path": "gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java",
      "functionStartLine": 75,
      "functionName": "createBoundField",
      "functionAnnotation": "",
      "functionDoc": "",
      "diff": "@@ -1,23 +1,24 @@\n private ReflectiveTypeAdapterFactory.BoundField createBoundField(final Gson context, final Field field, final String name, final TypeToken\u003c?\u003e fieldType, boolean serialize, boolean deserialize) {\n     final boolean isPrimitive \u003d Primitives.isPrimitive(fieldType.getRawType());\n     return new ReflectiveTypeAdapterFactory.BoundField(name, serialize, deserialize) {\n \n         final TypeAdapter\u003c?\u003e typeAdapter \u003d context.getAdapter(fieldType);\n \n         @SuppressWarnings({ \"unchecked\", \"rawtypes\" })\n         @Override\n         void write(JsonWriter writer, Object value) throws IOException, IllegalAccessException {\n             Object fieldValue \u003d field.get(value);\n             TypeAdapter t \u003d new TypeAdapterRuntimeTypeWrapper(context, this.typeAdapter, fieldType.getType());\n             t.write(writer, fieldValue);\n         }\n \n         @Override\n         void read(JsonReader reader, Object value) throws IOException, IllegalAccessException {\n             Object fieldValue \u003d typeAdapter.read(reader);\n+            Gson.$Internal$Access.invokeInterceptor(context, fieldValue, fieldType.getRawType());\n             if (fieldValue !\u003d null || !isPrimitive) {\n                 field.set(value, fieldValue);\n             }\n         }\n     };\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "7e760143fdc8b689daeebdee33ad6ea7d0a62a56": {
      "type": "Yparameterchange",
      "commitMessage": "Smash together MiniGson and Gson. This changes Gson to be the MiniGson rather than delegating to the MiniGson. It means that the MiniGson objects passed into streaming type adapters are now fully-capable \u0027Gson\u0027 objects. \n\nThe most notable impact of this change is that it adds several new public APIs:\n - The TypeAdapter abstract class\n - The TypeAdapter.Factory interface\n - Four new methods on GsonBuilder to register streaming TypeAdapters (via Factory, via Class, via TypeToken, and as a type hierarchy)\n - Three new methods on Gson to lookup streaming TypeAdapters (by type, by class, and to get the next type adapter) \n\nStill outstanding:\n - Write beautiful prose to document the new APIs above\n - Change GsonBuilder\u0027s precedence so that both old and new-style type adapters are registered in one lot\n",
      "commitDate": "11/20/11, 7:23 AM",
      "commitName": "7e760143fdc8b689daeebdee33ad6ea7d0a62a56",
      "commitAuthor": "Jesse Wilson",
      "commitDateOld": "10/20/11, 2:32 PM",
      "commitNameOld": "31964507c1caabc9a70e3270fa56aaee29eff6b2",
      "commitAuthorOld": "Inderjeet Singh",
      "daysBetweenCommits": 30.74,
      "commitsBetweenForRepo": 25,
      "commitsBetweenForFile": 1,
      "actualSource": "private ReflectiveTypeAdapterFactory.BoundField createBoundField(final Gson context, final Field field, final String name, final TypeToken\u003c?\u003e fieldType, boolean serialize, boolean deserialize) {\n    final boolean isPrimitive \u003d Primitives.isPrimitive(fieldType.getRawType());\n    return new ReflectiveTypeAdapterFactory.BoundField(name, serialize, deserialize) {\n\n        final TypeAdapter\u003c?\u003e typeAdapter \u003d context.getAdapter(fieldType);\n\n        @SuppressWarnings({ \"unchecked\", \"rawtypes\" })\n        @Override\n        void write(JsonWriter writer, Object value) throws IOException, IllegalAccessException {\n            Object fieldValue \u003d field.get(value);\n            TypeAdapter t \u003d new TypeAdapterRuntimeTypeWrapper(context, this.typeAdapter, fieldType.getType());\n            t.write(writer, fieldValue);\n        }\n\n        @Override\n        void read(JsonReader reader, Object value) throws IOException, IllegalAccessException {\n            Object fieldValue \u003d typeAdapter.read(reader);\n            if (fieldValue !\u003d null || !isPrimitive) {\n                field.set(value, fieldValue);\n            }\n        }\n    };\n}",
      "path": "gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java",
      "functionStartLine": 70,
      "functionName": "createBoundField",
      "functionAnnotation": "",
      "functionDoc": "",
      "diff": "@@ -1,23 +1,23 @@\n-private ReflectiveTypeAdapterFactory.BoundField createBoundField(final MiniGson context, final Field field, final String name, final TypeToken\u003c?\u003e fieldType, boolean serialize, boolean deserialize) {\n+private ReflectiveTypeAdapterFactory.BoundField createBoundField(final Gson context, final Field field, final String name, final TypeToken\u003c?\u003e fieldType, boolean serialize, boolean deserialize) {\n     final boolean isPrimitive \u003d Primitives.isPrimitive(fieldType.getRawType());\n     return new ReflectiveTypeAdapterFactory.BoundField(name, serialize, deserialize) {\n \n         final TypeAdapter\u003c?\u003e typeAdapter \u003d context.getAdapter(fieldType);\n \n         @SuppressWarnings({ \"unchecked\", \"rawtypes\" })\n         @Override\n         void write(JsonWriter writer, Object value) throws IOException, IllegalAccessException {\n             Object fieldValue \u003d field.get(value);\n             TypeAdapter t \u003d new TypeAdapterRuntimeTypeWrapper(context, this.typeAdapter, fieldType.getType());\n             t.write(writer, fieldValue);\n         }\n \n         @Override\n         void read(JsonReader reader, Object value) throws IOException, IllegalAccessException {\n             Object fieldValue \u003d typeAdapter.read(reader);\n             if (fieldValue !\u003d null || !isPrimitive) {\n                 field.set(value, fieldValue);\n             }\n         }\n     };\n }\n\\ No newline at end of file\n",
      "extendedDetails": {
        "oldValue": "[context-MiniGson(modifiers-final), field-Field(modifiers-final), name-String(modifiers-final), fieldType-TypeToken\u003c?\u003e(modifiers-final), serialize-boolean, deserialize-boolean]",
        "newValue": "[context-Gson(modifiers-final), field-Field(modifiers-final), name-String(modifiers-final), fieldType-TypeToken\u003c?\u003e(modifiers-final), serialize-boolean, deserialize-boolean]"
      }
    },
    "31964507c1caabc9a70e3270fa56aaee29eff6b2": {
      "type": "Ybodychange",
      "commitMessage": "Updated SuppressWarnings annotations to Eclipse 3.6/3.7 which is unfortunately incompatible with Eclipse 3.5 (rawtypes vs unchecked)\nThis CL eliminates all eclipse warnings.\n",
      "commitDate": "10/20/11, 2:32 PM",
      "commitName": "31964507c1caabc9a70e3270fa56aaee29eff6b2",
      "commitAuthor": "Inderjeet Singh",
      "commitDateOld": "10/13/11, 8:20 PM",
      "commitNameOld": "0e02cbb33ec43b301b6835a99db020a2df3c6f51",
      "commitAuthorOld": "Jesse Wilson",
      "daysBetweenCommits": 6.76,
      "commitsBetweenForRepo": 4,
      "commitsBetweenForFile": 1,
      "actualSource": "private ReflectiveTypeAdapterFactory.BoundField createBoundField(final MiniGson context, final Field field, final String name, final TypeToken\u003c?\u003e fieldType, boolean serialize, boolean deserialize) {\n    final boolean isPrimitive \u003d Primitives.isPrimitive(fieldType.getRawType());\n    return new ReflectiveTypeAdapterFactory.BoundField(name, serialize, deserialize) {\n\n        final TypeAdapter\u003c?\u003e typeAdapter \u003d context.getAdapter(fieldType);\n\n        @SuppressWarnings({ \"unchecked\", \"rawtypes\" })\n        @Override\n        void write(JsonWriter writer, Object value) throws IOException, IllegalAccessException {\n            Object fieldValue \u003d field.get(value);\n            TypeAdapter t \u003d new TypeAdapterRuntimeTypeWrapper(context, this.typeAdapter, fieldType.getType());\n            t.write(writer, fieldValue);\n        }\n\n        @Override\n        void read(JsonReader reader, Object value) throws IOException, IllegalAccessException {\n            Object fieldValue \u003d typeAdapter.read(reader);\n            if (fieldValue !\u003d null || !isPrimitive) {\n                field.set(value, fieldValue);\n            }\n        }\n    };\n}",
      "path": "gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java",
      "functionStartLine": 68,
      "functionName": "createBoundField",
      "functionAnnotation": "",
      "functionDoc": "",
      "diff": "@@ -1,23 +1,23 @@\n private ReflectiveTypeAdapterFactory.BoundField createBoundField(final MiniGson context, final Field field, final String name, final TypeToken\u003c?\u003e fieldType, boolean serialize, boolean deserialize) {\n     final boolean isPrimitive \u003d Primitives.isPrimitive(fieldType.getRawType());\n     return new ReflectiveTypeAdapterFactory.BoundField(name, serialize, deserialize) {\n \n         final TypeAdapter\u003c?\u003e typeAdapter \u003d context.getAdapter(fieldType);\n \n-        @SuppressWarnings(\"unchecked\")\n+        @SuppressWarnings({ \"unchecked\", \"rawtypes\" })\n         @Override\n         void write(JsonWriter writer, Object value) throws IOException, IllegalAccessException {\n             Object fieldValue \u003d field.get(value);\n             TypeAdapter t \u003d new TypeAdapterRuntimeTypeWrapper(context, this.typeAdapter, fieldType.getType());\n             t.write(writer, fieldValue);\n         }\n \n         @Override\n         void read(JsonReader reader, Object value) throws IOException, IllegalAccessException {\n             Object fieldValue \u003d typeAdapter.read(reader);\n             if (fieldValue !\u003d null || !isPrimitive) {\n                 field.set(value, fieldValue);\n             }\n         }\n     };\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "25c6ae177b1ca56db7f3c29eb574bdd032a06165": {
      "type": "Ymultichange(Ymovefromfile,Yreturntypechange,Ymodifierchange,Ybodychange)",
      "commitMessage": "Down to 22 failing tests.\n\nConsolidated all of the different code paths that we use to construct instances. We now have an ObjectConstructor class that knows what type it constructs; this means that we don\u0027t need to ever do reflection to lookup a constructor at construction time.\n\nCleaned up some buggy type adapters, particularly around handling of null.\n\nRemoved dead code for object graph navigation.\n\nMoved some classes into \u0027internal\u0027 so they are visible to the \u0027bind\u0027 subpackage.\n\nTurned some TypeAdapterFactory/TypeAdapter pairs inside out so that the TypeAdapter is now the inner class. This is necessary so that the factories can take parameters.\n\nAdded an API to request the \u0027next\u0027 type adapter for a type. This allows type adapters to compose other type adapters. We\u0027re using this in two places:\n - where the user has excluded a type from serialization but not deserialization, we need to use the \"default\" deserialization but interpose null on serialization. We create a type adapter that delegates for one and returns null for the other.\n - similarly when a DOM type serializer is registered but no deserializer, or vice versa.\nThis is the biggest change to the MiniGson core.\n\nFor backwards compatibility, return null for the empty string.\n\nSimplify JsonSerializationContext/JsonDeserializationContext to simply call through to GSON. SerializeDefault is currently unsupported.\n\nMore useful error messages when calling getAsBoolean on a JsonNull.\n\nRemove currently unused MemoryRefStack. We might need this back again, though wiring it back in will be much more difficult because we don\u0027t interject ourselves between the users\u0027 various type adapters.\n",
      "commitDate": "9/11/11, 12:04 AM",
      "commitName": "25c6ae177b1ca56db7f3c29eb574bdd032a06165",
      "commitAuthor": "Jesse Wilson",
      "subchanges": [
        {
          "type": "Ymovefromfile",
          "commitMessage": "Down to 22 failing tests.\n\nConsolidated all of the different code paths that we use to construct instances. We now have an ObjectConstructor class that knows what type it constructs; this means that we don\u0027t need to ever do reflection to lookup a constructor at construction time.\n\nCleaned up some buggy type adapters, particularly around handling of null.\n\nRemoved dead code for object graph navigation.\n\nMoved some classes into \u0027internal\u0027 so they are visible to the \u0027bind\u0027 subpackage.\n\nTurned some TypeAdapterFactory/TypeAdapter pairs inside out so that the TypeAdapter is now the inner class. This is necessary so that the factories can take parameters.\n\nAdded an API to request the \u0027next\u0027 type adapter for a type. This allows type adapters to compose other type adapters. We\u0027re using this in two places:\n - where the user has excluded a type from serialization but not deserialization, we need to use the \"default\" deserialization but interpose null on serialization. We create a type adapter that delegates for one and returns null for the other.\n - similarly when a DOM type serializer is registered but no deserializer, or vice versa.\nThis is the biggest change to the MiniGson core.\n\nFor backwards compatibility, return null for the empty string.\n\nSimplify JsonSerializationContext/JsonDeserializationContext to simply call through to GSON. SerializeDefault is currently unsupported.\n\nMore useful error messages when calling getAsBoolean on a JsonNull.\n\nRemove currently unused MemoryRefStack. We might need this back again, though wiring it back in will be much more difficult because we don\u0027t interject ourselves between the users\u0027 various type adapters.\n",
          "commitDate": "9/11/11, 12:04 AM",
          "commitName": "25c6ae177b1ca56db7f3c29eb574bdd032a06165",
          "commitAuthor": "Jesse Wilson",
          "commitDateOld": "9/9/11, 1:17 AM",
          "commitNameOld": "cdd5d80b85155c21c61f888fb3e70c65e72edef7",
          "commitAuthorOld": "Jesse Wilson",
          "daysBetweenCommits": 1.95,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "actualSource": "private ReflectiveTypeAdapterFactory.BoundField createBoundField(final MiniGson context, final Field field, final String name, final TypeToken\u003c?\u003e fieldType, boolean serialize, boolean deserialize) {\n    final boolean isPrimitive \u003d Primitives.isPrimitive(fieldType.getRawType());\n    return new ReflectiveTypeAdapterFactory.BoundField(name, serialize, deserialize) {\n\n        final TypeAdapter\u003c?\u003e typeAdapter \u003d context.getAdapter(fieldType);\n\n        @SuppressWarnings(\"unchecked\")\n        @Override\n        void write(JsonWriter writer, Object value) throws IOException, IllegalAccessException {\n            Object fieldValue \u003d field.get(value);\n            TypeAdapter t \u003d new TypeAdapterRuntimeTypeWrapper(context, this.typeAdapter, fieldType.getType());\n            t.write(writer, fieldValue);\n        }\n\n        @Override\n        void read(JsonReader reader, Object value) throws IOException, IllegalAccessException {\n            Object fieldValue \u003d typeAdapter.read(reader);\n            if (fieldValue !\u003d null || !isPrimitive) {\n                field.set(value, fieldValue);\n            }\n        }\n    };\n}",
          "path": "gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java",
          "functionStartLine": 70,
          "functionName": "createBoundField",
          "functionAnnotation": "",
          "functionDoc": "",
          "diff": "@@ -1,20 +1,23 @@\n-static BoundField createBoundField(final MiniGson context, final Field field, final String name, final TypeToken\u003c?\u003e fieldType, boolean serialize, boolean deserialize) {\n-    return new BoundField(name, serialize, deserialize) {\n+private ReflectiveTypeAdapterFactory.BoundField createBoundField(final MiniGson context, final Field field, final String name, final TypeToken\u003c?\u003e fieldType, boolean serialize, boolean deserialize) {\n+    final boolean isPrimitive \u003d Primitives.isPrimitive(fieldType.getRawType());\n+    return new ReflectiveTypeAdapterFactory.BoundField(name, serialize, deserialize) {\n \n         final TypeAdapter\u003c?\u003e typeAdapter \u003d context.getAdapter(fieldType);\n \n         @SuppressWarnings(\"unchecked\")\n         @Override\n         void write(JsonWriter writer, Object value) throws IOException, IllegalAccessException {\n             Object fieldValue \u003d field.get(value);\n             TypeAdapter t \u003d new TypeAdapterRuntimeTypeWrapper(context, this.typeAdapter, fieldType.getType());\n             t.write(writer, fieldValue);\n         }\n \n         @Override\n         void read(JsonReader reader, Object value) throws IOException, IllegalAccessException {\n             Object fieldValue \u003d typeAdapter.read(reader);\n-            field.set(value, fieldValue);\n+            if (fieldValue !\u003d null || !isPrimitive) {\n+                field.set(value, fieldValue);\n+            }\n         }\n     };\n }\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldPath": "gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapter.java",
            "newPath": "gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java",
            "oldMethodName": "createBoundField",
            "newMethodName": "createBoundField"
          }
        },
        {
          "type": "Yreturntypechange",
          "commitMessage": "Down to 22 failing tests.\n\nConsolidated all of the different code paths that we use to construct instances. We now have an ObjectConstructor class that knows what type it constructs; this means that we don\u0027t need to ever do reflection to lookup a constructor at construction time.\n\nCleaned up some buggy type adapters, particularly around handling of null.\n\nRemoved dead code for object graph navigation.\n\nMoved some classes into \u0027internal\u0027 so they are visible to the \u0027bind\u0027 subpackage.\n\nTurned some TypeAdapterFactory/TypeAdapter pairs inside out so that the TypeAdapter is now the inner class. This is necessary so that the factories can take parameters.\n\nAdded an API to request the \u0027next\u0027 type adapter for a type. This allows type adapters to compose other type adapters. We\u0027re using this in two places:\n - where the user has excluded a type from serialization but not deserialization, we need to use the \"default\" deserialization but interpose null on serialization. We create a type adapter that delegates for one and returns null for the other.\n - similarly when a DOM type serializer is registered but no deserializer, or vice versa.\nThis is the biggest change to the MiniGson core.\n\nFor backwards compatibility, return null for the empty string.\n\nSimplify JsonSerializationContext/JsonDeserializationContext to simply call through to GSON. SerializeDefault is currently unsupported.\n\nMore useful error messages when calling getAsBoolean on a JsonNull.\n\nRemove currently unused MemoryRefStack. We might need this back again, though wiring it back in will be much more difficult because we don\u0027t interject ourselves between the users\u0027 various type adapters.\n",
          "commitDate": "9/11/11, 12:04 AM",
          "commitName": "25c6ae177b1ca56db7f3c29eb574bdd032a06165",
          "commitAuthor": "Jesse Wilson",
          "commitDateOld": "9/9/11, 1:17 AM",
          "commitNameOld": "cdd5d80b85155c21c61f888fb3e70c65e72edef7",
          "commitAuthorOld": "Jesse Wilson",
          "daysBetweenCommits": 1.95,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "actualSource": "private ReflectiveTypeAdapterFactory.BoundField createBoundField(final MiniGson context, final Field field, final String name, final TypeToken\u003c?\u003e fieldType, boolean serialize, boolean deserialize) {\n    final boolean isPrimitive \u003d Primitives.isPrimitive(fieldType.getRawType());\n    return new ReflectiveTypeAdapterFactory.BoundField(name, serialize, deserialize) {\n\n        final TypeAdapter\u003c?\u003e typeAdapter \u003d context.getAdapter(fieldType);\n\n        @SuppressWarnings(\"unchecked\")\n        @Override\n        void write(JsonWriter writer, Object value) throws IOException, IllegalAccessException {\n            Object fieldValue \u003d field.get(value);\n            TypeAdapter t \u003d new TypeAdapterRuntimeTypeWrapper(context, this.typeAdapter, fieldType.getType());\n            t.write(writer, fieldValue);\n        }\n\n        @Override\n        void read(JsonReader reader, Object value) throws IOException, IllegalAccessException {\n            Object fieldValue \u003d typeAdapter.read(reader);\n            if (fieldValue !\u003d null || !isPrimitive) {\n                field.set(value, fieldValue);\n            }\n        }\n    };\n}",
          "path": "gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java",
          "functionStartLine": 70,
          "functionName": "createBoundField",
          "functionAnnotation": "",
          "functionDoc": "",
          "diff": "@@ -1,20 +1,23 @@\n-static BoundField createBoundField(final MiniGson context, final Field field, final String name, final TypeToken\u003c?\u003e fieldType, boolean serialize, boolean deserialize) {\n-    return new BoundField(name, serialize, deserialize) {\n+private ReflectiveTypeAdapterFactory.BoundField createBoundField(final MiniGson context, final Field field, final String name, final TypeToken\u003c?\u003e fieldType, boolean serialize, boolean deserialize) {\n+    final boolean isPrimitive \u003d Primitives.isPrimitive(fieldType.getRawType());\n+    return new ReflectiveTypeAdapterFactory.BoundField(name, serialize, deserialize) {\n \n         final TypeAdapter\u003c?\u003e typeAdapter \u003d context.getAdapter(fieldType);\n \n         @SuppressWarnings(\"unchecked\")\n         @Override\n         void write(JsonWriter writer, Object value) throws IOException, IllegalAccessException {\n             Object fieldValue \u003d field.get(value);\n             TypeAdapter t \u003d new TypeAdapterRuntimeTypeWrapper(context, this.typeAdapter, fieldType.getType());\n             t.write(writer, fieldValue);\n         }\n \n         @Override\n         void read(JsonReader reader, Object value) throws IOException, IllegalAccessException {\n             Object fieldValue \u003d typeAdapter.read(reader);\n-            field.set(value, fieldValue);\n+            if (fieldValue !\u003d null || !isPrimitive) {\n+                field.set(value, fieldValue);\n+            }\n         }\n     };\n }\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldValue": "BoundField",
            "newValue": "ReflectiveTypeAdapterFactory.BoundField"
          }
        },
        {
          "type": "Ymodifierchange",
          "commitMessage": "Down to 22 failing tests.\n\nConsolidated all of the different code paths that we use to construct instances. We now have an ObjectConstructor class that knows what type it constructs; this means that we don\u0027t need to ever do reflection to lookup a constructor at construction time.\n\nCleaned up some buggy type adapters, particularly around handling of null.\n\nRemoved dead code for object graph navigation.\n\nMoved some classes into \u0027internal\u0027 so they are visible to the \u0027bind\u0027 subpackage.\n\nTurned some TypeAdapterFactory/TypeAdapter pairs inside out so that the TypeAdapter is now the inner class. This is necessary so that the factories can take parameters.\n\nAdded an API to request the \u0027next\u0027 type adapter for a type. This allows type adapters to compose other type adapters. We\u0027re using this in two places:\n - where the user has excluded a type from serialization but not deserialization, we need to use the \"default\" deserialization but interpose null on serialization. We create a type adapter that delegates for one and returns null for the other.\n - similarly when a DOM type serializer is registered but no deserializer, or vice versa.\nThis is the biggest change to the MiniGson core.\n\nFor backwards compatibility, return null for the empty string.\n\nSimplify JsonSerializationContext/JsonDeserializationContext to simply call through to GSON. SerializeDefault is currently unsupported.\n\nMore useful error messages when calling getAsBoolean on a JsonNull.\n\nRemove currently unused MemoryRefStack. We might need this back again, though wiring it back in will be much more difficult because we don\u0027t interject ourselves between the users\u0027 various type adapters.\n",
          "commitDate": "9/11/11, 12:04 AM",
          "commitName": "25c6ae177b1ca56db7f3c29eb574bdd032a06165",
          "commitAuthor": "Jesse Wilson",
          "commitDateOld": "9/9/11, 1:17 AM",
          "commitNameOld": "cdd5d80b85155c21c61f888fb3e70c65e72edef7",
          "commitAuthorOld": "Jesse Wilson",
          "daysBetweenCommits": 1.95,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "actualSource": "private ReflectiveTypeAdapterFactory.BoundField createBoundField(final MiniGson context, final Field field, final String name, final TypeToken\u003c?\u003e fieldType, boolean serialize, boolean deserialize) {\n    final boolean isPrimitive \u003d Primitives.isPrimitive(fieldType.getRawType());\n    return new ReflectiveTypeAdapterFactory.BoundField(name, serialize, deserialize) {\n\n        final TypeAdapter\u003c?\u003e typeAdapter \u003d context.getAdapter(fieldType);\n\n        @SuppressWarnings(\"unchecked\")\n        @Override\n        void write(JsonWriter writer, Object value) throws IOException, IllegalAccessException {\n            Object fieldValue \u003d field.get(value);\n            TypeAdapter t \u003d new TypeAdapterRuntimeTypeWrapper(context, this.typeAdapter, fieldType.getType());\n            t.write(writer, fieldValue);\n        }\n\n        @Override\n        void read(JsonReader reader, Object value) throws IOException, IllegalAccessException {\n            Object fieldValue \u003d typeAdapter.read(reader);\n            if (fieldValue !\u003d null || !isPrimitive) {\n                field.set(value, fieldValue);\n            }\n        }\n    };\n}",
          "path": "gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java",
          "functionStartLine": 70,
          "functionName": "createBoundField",
          "functionAnnotation": "",
          "functionDoc": "",
          "diff": "@@ -1,20 +1,23 @@\n-static BoundField createBoundField(final MiniGson context, final Field field, final String name, final TypeToken\u003c?\u003e fieldType, boolean serialize, boolean deserialize) {\n-    return new BoundField(name, serialize, deserialize) {\n+private ReflectiveTypeAdapterFactory.BoundField createBoundField(final MiniGson context, final Field field, final String name, final TypeToken\u003c?\u003e fieldType, boolean serialize, boolean deserialize) {\n+    final boolean isPrimitive \u003d Primitives.isPrimitive(fieldType.getRawType());\n+    return new ReflectiveTypeAdapterFactory.BoundField(name, serialize, deserialize) {\n \n         final TypeAdapter\u003c?\u003e typeAdapter \u003d context.getAdapter(fieldType);\n \n         @SuppressWarnings(\"unchecked\")\n         @Override\n         void write(JsonWriter writer, Object value) throws IOException, IllegalAccessException {\n             Object fieldValue \u003d field.get(value);\n             TypeAdapter t \u003d new TypeAdapterRuntimeTypeWrapper(context, this.typeAdapter, fieldType.getType());\n             t.write(writer, fieldValue);\n         }\n \n         @Override\n         void read(JsonReader reader, Object value) throws IOException, IllegalAccessException {\n             Object fieldValue \u003d typeAdapter.read(reader);\n-            field.set(value, fieldValue);\n+            if (fieldValue !\u003d null || !isPrimitive) {\n+                field.set(value, fieldValue);\n+            }\n         }\n     };\n }\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldValue": "[static]",
            "newValue": "[private]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "Down to 22 failing tests.\n\nConsolidated all of the different code paths that we use to construct instances. We now have an ObjectConstructor class that knows what type it constructs; this means that we don\u0027t need to ever do reflection to lookup a constructor at construction time.\n\nCleaned up some buggy type adapters, particularly around handling of null.\n\nRemoved dead code for object graph navigation.\n\nMoved some classes into \u0027internal\u0027 so they are visible to the \u0027bind\u0027 subpackage.\n\nTurned some TypeAdapterFactory/TypeAdapter pairs inside out so that the TypeAdapter is now the inner class. This is necessary so that the factories can take parameters.\n\nAdded an API to request the \u0027next\u0027 type adapter for a type. This allows type adapters to compose other type adapters. We\u0027re using this in two places:\n - where the user has excluded a type from serialization but not deserialization, we need to use the \"default\" deserialization but interpose null on serialization. We create a type adapter that delegates for one and returns null for the other.\n - similarly when a DOM type serializer is registered but no deserializer, or vice versa.\nThis is the biggest change to the MiniGson core.\n\nFor backwards compatibility, return null for the empty string.\n\nSimplify JsonSerializationContext/JsonDeserializationContext to simply call through to GSON. SerializeDefault is currently unsupported.\n\nMore useful error messages when calling getAsBoolean on a JsonNull.\n\nRemove currently unused MemoryRefStack. We might need this back again, though wiring it back in will be much more difficult because we don\u0027t interject ourselves between the users\u0027 various type adapters.\n",
          "commitDate": "9/11/11, 12:04 AM",
          "commitName": "25c6ae177b1ca56db7f3c29eb574bdd032a06165",
          "commitAuthor": "Jesse Wilson",
          "commitDateOld": "9/9/11, 1:17 AM",
          "commitNameOld": "cdd5d80b85155c21c61f888fb3e70c65e72edef7",
          "commitAuthorOld": "Jesse Wilson",
          "daysBetweenCommits": 1.95,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "actualSource": "private ReflectiveTypeAdapterFactory.BoundField createBoundField(final MiniGson context, final Field field, final String name, final TypeToken\u003c?\u003e fieldType, boolean serialize, boolean deserialize) {\n    final boolean isPrimitive \u003d Primitives.isPrimitive(fieldType.getRawType());\n    return new ReflectiveTypeAdapterFactory.BoundField(name, serialize, deserialize) {\n\n        final TypeAdapter\u003c?\u003e typeAdapter \u003d context.getAdapter(fieldType);\n\n        @SuppressWarnings(\"unchecked\")\n        @Override\n        void write(JsonWriter writer, Object value) throws IOException, IllegalAccessException {\n            Object fieldValue \u003d field.get(value);\n            TypeAdapter t \u003d new TypeAdapterRuntimeTypeWrapper(context, this.typeAdapter, fieldType.getType());\n            t.write(writer, fieldValue);\n        }\n\n        @Override\n        void read(JsonReader reader, Object value) throws IOException, IllegalAccessException {\n            Object fieldValue \u003d typeAdapter.read(reader);\n            if (fieldValue !\u003d null || !isPrimitive) {\n                field.set(value, fieldValue);\n            }\n        }\n    };\n}",
          "path": "gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java",
          "functionStartLine": 70,
          "functionName": "createBoundField",
          "functionAnnotation": "",
          "functionDoc": "",
          "diff": "@@ -1,20 +1,23 @@\n-static BoundField createBoundField(final MiniGson context, final Field field, final String name, final TypeToken\u003c?\u003e fieldType, boolean serialize, boolean deserialize) {\n-    return new BoundField(name, serialize, deserialize) {\n+private ReflectiveTypeAdapterFactory.BoundField createBoundField(final MiniGson context, final Field field, final String name, final TypeToken\u003c?\u003e fieldType, boolean serialize, boolean deserialize) {\n+    final boolean isPrimitive \u003d Primitives.isPrimitive(fieldType.getRawType());\n+    return new ReflectiveTypeAdapterFactory.BoundField(name, serialize, deserialize) {\n \n         final TypeAdapter\u003c?\u003e typeAdapter \u003d context.getAdapter(fieldType);\n \n         @SuppressWarnings(\"unchecked\")\n         @Override\n         void write(JsonWriter writer, Object value) throws IOException, IllegalAccessException {\n             Object fieldValue \u003d field.get(value);\n             TypeAdapter t \u003d new TypeAdapterRuntimeTypeWrapper(context, this.typeAdapter, fieldType.getType());\n             t.write(writer, fieldValue);\n         }\n \n         @Override\n         void read(JsonReader reader, Object value) throws IOException, IllegalAccessException {\n             Object fieldValue \u003d typeAdapter.read(reader);\n-            field.set(value, fieldValue);\n+            if (fieldValue !\u003d null || !isPrimitive) {\n+                field.set(value, fieldValue);\n+            }\n         }\n     };\n }\n\\ No newline at end of file\n",
          "extendedDetails": {}
        }
      ]
    },
    "ad5ff0f2d9c08fb25d821bdc038934642c3c7367": {
      "type": "Ybodychange",
      "commitMessage": "Created a wrapper for runtime type determination.\n",
      "commitDate": "8/4/11, 5:41 PM",
      "commitName": "ad5ff0f2d9c08fb25d821bdc038934642c3c7367",
      "commitAuthor": "Inderjeet Singh",
      "commitDateOld": "8/4/11, 5:13 PM",
      "commitNameOld": "e9a971f6806e5bebd2f6e677c3b126efad68a01c",
      "commitAuthorOld": "Inderjeet Singh",
      "daysBetweenCommits": 0.02,
      "commitsBetweenForRepo": 2,
      "commitsBetweenForFile": 1,
      "actualSource": "static BoundField createBoundField(final MiniGson context, final Field field, final String name, final TypeToken\u003c?\u003e fieldType, boolean serialize, boolean deserialize) {\n    return new BoundField(name, serialize, deserialize) {\n\n        final TypeAdapter\u003c?\u003e typeAdapter \u003d context.getAdapter(fieldType);\n\n        @SuppressWarnings(\"unchecked\")\n        @Override\n        void write(JsonWriter writer, Object value) throws IOException, IllegalAccessException {\n            Object fieldValue \u003d field.get(value);\n            TypeAdapter t \u003d new TypeAdapterRuntimeTypeWrapper(context, this.typeAdapter, fieldType.getType());\n            t.write(writer, fieldValue);\n        }\n\n        @Override\n        void read(JsonReader reader, Object value) throws IOException, IllegalAccessException {\n            Object fieldValue \u003d typeAdapter.read(reader);\n            field.set(value, fieldValue);\n        }\n    };\n}",
      "path": "gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapter.java",
      "functionStartLine": 114,
      "functionName": "createBoundField",
      "functionAnnotation": "",
      "functionDoc": "",
      "diff": "@@ -1,22 +1,20 @@\n static BoundField createBoundField(final MiniGson context, final Field field, final String name, final TypeToken\u003c?\u003e fieldType, boolean serialize, boolean deserialize) {\n     return new BoundField(name, serialize, deserialize) {\n \n         final TypeAdapter\u003c?\u003e typeAdapter \u003d context.getAdapter(fieldType);\n \n         @SuppressWarnings(\"unchecked\")\n         @Override\n         void write(JsonWriter writer, Object value) throws IOException, IllegalAccessException {\n             Object fieldValue \u003d field.get(value);\n-            Type declaredTypeOfField \u003d fieldType.getType();\n-            Type resolvedTypeOfField \u003d Reflection.getRuntimeTypeIfMoreSpecific(declaredTypeOfField, fieldValue);\n-            TypeAdapter t \u003d resolvedTypeOfField !\u003d declaredTypeOfField ? context.getAdapter(TypeToken.get(resolvedTypeOfField)) : this.typeAdapter;\n+            TypeAdapter t \u003d new TypeAdapterRuntimeTypeWrapper(context, this.typeAdapter, fieldType.getType());\n             t.write(writer, fieldValue);\n         }\n \n         @Override\n         void read(JsonReader reader, Object value) throws IOException, IllegalAccessException {\n             Object fieldValue \u003d typeAdapter.read(reader);\n             field.set(value, fieldValue);\n         }\n     };\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "e9a971f6806e5bebd2f6e677c3b126efad68a01c": {
      "type": "Ybodychange",
      "commitMessage": "Revised getRuntimeTypeIfMoreSpecific to ignore the parent and just focus on the value.\nAll uses of this method have already made a determination about the parent.\n",
      "commitDate": "8/4/11, 5:13 PM",
      "commitName": "e9a971f6806e5bebd2f6e677c3b126efad68a01c",
      "commitAuthor": "Inderjeet Singh",
      "commitDateOld": "8/4/11, 4:53 PM",
      "commitNameOld": "e04d3fa882e7829fc2b1d174a28e4e3640306696",
      "commitAuthorOld": "Jesse Wilson",
      "daysBetweenCommits": 0.01,
      "commitsBetweenForRepo": 2,
      "commitsBetweenForFile": 1,
      "actualSource": "static BoundField createBoundField(final MiniGson context, final Field field, final String name, final TypeToken\u003c?\u003e fieldType, boolean serialize, boolean deserialize) {\n    return new BoundField(name, serialize, deserialize) {\n\n        final TypeAdapter\u003c?\u003e typeAdapter \u003d context.getAdapter(fieldType);\n\n        @SuppressWarnings(\"unchecked\")\n        @Override\n        void write(JsonWriter writer, Object value) throws IOException, IllegalAccessException {\n            Object fieldValue \u003d field.get(value);\n            Type declaredTypeOfField \u003d fieldType.getType();\n            Type resolvedTypeOfField \u003d Reflection.getRuntimeTypeIfMoreSpecific(declaredTypeOfField, fieldValue);\n            TypeAdapter t \u003d resolvedTypeOfField !\u003d declaredTypeOfField ? context.getAdapter(TypeToken.get(resolvedTypeOfField)) : this.typeAdapter;\n            t.write(writer, fieldValue);\n        }\n\n        @Override\n        void read(JsonReader reader, Object value) throws IOException, IllegalAccessException {\n            Object fieldValue \u003d typeAdapter.read(reader);\n            field.set(value, fieldValue);\n        }\n    };\n}",
      "path": "gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapter.java",
      "functionStartLine": 114,
      "functionName": "createBoundField",
      "functionAnnotation": "",
      "functionDoc": "",
      "diff": "@@ -1,22 +1,22 @@\n static BoundField createBoundField(final MiniGson context, final Field field, final String name, final TypeToken\u003c?\u003e fieldType, boolean serialize, boolean deserialize) {\n     return new BoundField(name, serialize, deserialize) {\n \n         final TypeAdapter\u003c?\u003e typeAdapter \u003d context.getAdapter(fieldType);\n \n         @SuppressWarnings(\"unchecked\")\n         @Override\n         void write(JsonWriter writer, Object value) throws IOException, IllegalAccessException {\n             Object fieldValue \u003d field.get(value);\n             Type declaredTypeOfField \u003d fieldType.getType();\n-            Type resolvedTypeOfField \u003d Reflection.getRuntimeTypeIfMoreSpecific(declaredTypeOfField, value, fieldValue);\n+            Type resolvedTypeOfField \u003d Reflection.getRuntimeTypeIfMoreSpecific(declaredTypeOfField, fieldValue);\n             TypeAdapter t \u003d resolvedTypeOfField !\u003d declaredTypeOfField ? context.getAdapter(TypeToken.get(resolvedTypeOfField)) : this.typeAdapter;\n             t.write(writer, fieldValue);\n         }\n \n         @Override\n         void read(JsonReader reader, Object value) throws IOException, IllegalAccessException {\n             Object fieldValue \u003d typeAdapter.read(reader);\n             field.set(value, fieldValue);\n         }\n     };\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "6e3bf0730037fb3cb7aab7fe607fbe61ba5fe5e6": {
      "type": "Ybodychange",
      "commitMessage": "Added support for runtime type determination while serializing array elements.\nCreated a utility class Reflection to hold methods to find Runtime type and creating new Instances.\n",
      "commitDate": "8/4/11, 4:02 PM",
      "commitName": "6e3bf0730037fb3cb7aab7fe607fbe61ba5fe5e6",
      "commitAuthor": "Inderjeet Singh",
      "commitDateOld": "8/4/11, 3:27 PM",
      "commitNameOld": "5fc2db9e7266701959129e88aa7ed8baeb493adc",
      "commitAuthorOld": "Inderjeet Singh",
      "daysBetweenCommits": 0.02,
      "commitsBetweenForRepo": 2,
      "commitsBetweenForFile": 1,
      "actualSource": "static BoundField createBoundField(final MiniGson context, final Field field, final String name, final TypeToken\u003c?\u003e fieldType, boolean serialize, boolean deserialize) {\n    return new BoundField(name, serialize, deserialize) {\n\n        final TypeAdapter\u003c?\u003e typeAdapter \u003d context.getAdapter(fieldType);\n\n        @SuppressWarnings(\"unchecked\")\n        @Override\n        void write(JsonWriter writer, Object value) throws IOException, IllegalAccessException {\n            Object fieldValue \u003d field.get(value);\n            Type declaredTypeOfField \u003d fieldType.getType();\n            Type resolvedTypeOfField \u003d Reflection.getRuntimeTypeIfMoreSpecific(declaredTypeOfField, value, fieldValue);\n            TypeAdapter t \u003d resolvedTypeOfField !\u003d declaredTypeOfField ? context.getAdapter(TypeToken.get(resolvedTypeOfField)) : this.typeAdapter;\n            t.write(writer, fieldValue);\n        }\n\n        @Override\n        void read(JsonReader reader, Object value) throws IOException, IllegalAccessException {\n            Object fieldValue \u003d typeAdapter.read(reader);\n            field.set(value, fieldValue);\n        }\n    };\n}",
      "path": "gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapter.java",
      "functionStartLine": 114,
      "functionName": "createBoundField",
      "functionAnnotation": "",
      "functionDoc": "",
      "diff": "@@ -1,22 +1,22 @@\n static BoundField createBoundField(final MiniGson context, final Field field, final String name, final TypeToken\u003c?\u003e fieldType, boolean serialize, boolean deserialize) {\n     return new BoundField(name, serialize, deserialize) {\n \n         final TypeAdapter\u003c?\u003e typeAdapter \u003d context.getAdapter(fieldType);\n \n         @SuppressWarnings(\"unchecked\")\n         @Override\n         void write(JsonWriter writer, Object value) throws IOException, IllegalAccessException {\n             Object fieldValue \u003d field.get(value);\n             Type declaredTypeOfField \u003d fieldType.getType();\n-            Type resolvedTypeOfField \u003d getMoreSpecificType(declaredTypeOfField, value, fieldValue);\n+            Type resolvedTypeOfField \u003d Reflection.getRuntimeTypeIfMoreSpecific(declaredTypeOfField, value, fieldValue);\n             TypeAdapter t \u003d resolvedTypeOfField !\u003d declaredTypeOfField ? context.getAdapter(TypeToken.get(resolvedTypeOfField)) : this.typeAdapter;\n             t.write(writer, fieldValue);\n         }\n \n         @Override\n         void read(JsonReader reader, Object value) throws IOException, IllegalAccessException {\n             Object fieldValue \u003d typeAdapter.read(reader);\n             field.set(value, fieldValue);\n         }\n     };\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "2813385c33c34c3758f4bba863526551add0c58e": {
      "type": "Ybodychange",
      "commitMessage": "Parity with Gson behavior where we use runtime type of an object while serializing instead of the declared type of the field.\n",
      "commitDate": "8/2/11, 8:19 PM",
      "commitName": "2813385c33c34c3758f4bba863526551add0c58e",
      "commitAuthor": "Inderjeet Singh",
      "commitDateOld": "8/2/11, 8:05 PM",
      "commitNameOld": "5c620c7e0a1f3e89dd0b42463aa4611950f282f1",
      "commitAuthorOld": "Inderjeet Singh",
      "daysBetweenCommits": 0.01,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "static BoundField createBoundField(final MiniGson context, final Field field, final String name, final TypeToken\u003c?\u003e fieldType, boolean serialize, boolean deserialize) {\n    return new BoundField(name, serialize, deserialize) {\n\n        final TypeAdapter\u003c?\u003e typeAdapter \u003d context.getAdapter(fieldType);\n\n        @SuppressWarnings(\"unchecked\")\n        @Override\n        void write(JsonWriter writer, Object value) throws IOException, IllegalAccessException {\n            Object fieldValue \u003d field.get(value);\n            Type declaredTypeOfField \u003d fieldType.getType();\n            Type resolvedTypeOfField \u003d getMoreSpecificType(declaredTypeOfField, value, fieldValue);\n            TypeAdapter t \u003d resolvedTypeOfField !\u003d declaredTypeOfField ? context.getAdapter(TypeToken.get(resolvedTypeOfField)) : this.typeAdapter;\n            t.write(writer, fieldValue);\n        }\n\n        @Override\n        void read(JsonReader reader, Object value) throws IOException, IllegalAccessException {\n            Object fieldValue \u003d typeAdapter.read(reader);\n            field.set(value, fieldValue);\n        }\n    };\n}",
      "path": "gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapter.java",
      "functionStartLine": 116,
      "functionName": "createBoundField",
      "functionAnnotation": "",
      "functionDoc": "",
      "diff": "@@ -1,19 +1,22 @@\n static BoundField createBoundField(final MiniGson context, final Field field, final String name, final TypeToken\u003c?\u003e fieldType, boolean serialize, boolean deserialize) {\n     return new BoundField(name, serialize, deserialize) {\n \n         final TypeAdapter\u003c?\u003e typeAdapter \u003d context.getAdapter(fieldType);\n \n         @SuppressWarnings(\"unchecked\")\n         @Override\n         void write(JsonWriter writer, Object value) throws IOException, IllegalAccessException {\n             Object fieldValue \u003d field.get(value);\n-            ((TypeAdapter) typeAdapter).write(writer, fieldValue);\n+            Type declaredTypeOfField \u003d fieldType.getType();\n+            Type resolvedTypeOfField \u003d getMoreSpecificType(declaredTypeOfField, value, fieldValue);\n+            TypeAdapter t \u003d resolvedTypeOfField !\u003d declaredTypeOfField ? context.getAdapter(TypeToken.get(resolvedTypeOfField)) : this.typeAdapter;\n+            t.write(writer, fieldValue);\n         }\n \n         @Override\n         void read(JsonReader reader, Object value) throws IOException, IllegalAccessException {\n             Object fieldValue \u003d typeAdapter.read(reader);\n             field.set(value, fieldValue);\n         }\n     };\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "f1f8b666ec665b41446ddb3d68de115d8ce91d2f": {
      "type": "Ymultichange(Yparameterchange,Ybodychange)",
      "commitMessage": "Implemented support for FieldNamingPolicy with MiniGson.\n",
      "commitDate": "8/2/11, 7:51 PM",
      "commitName": "f1f8b666ec665b41446ddb3d68de115d8ce91d2f",
      "commitAuthor": "Inderjeet Singh",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "Implemented support for FieldNamingPolicy with MiniGson.\n",
          "commitDate": "8/2/11, 7:51 PM",
          "commitName": "f1f8b666ec665b41446ddb3d68de115d8ce91d2f",
          "commitAuthor": "Inderjeet Singh",
          "commitDateOld": "8/2/11, 6:25 PM",
          "commitNameOld": "98aa12458904cd8cb74ca40a905ddc790e14501b",
          "commitAuthorOld": "Jesse Wilson",
          "daysBetweenCommits": 0.06,
          "commitsBetweenForRepo": 3,
          "commitsBetweenForFile": 1,
          "actualSource": "static BoundField createBoundField(final MiniGson context, final Field field, final String name, final TypeToken\u003c?\u003e fieldType, boolean serialize, boolean deserialize) {\n    return new BoundField(name, serialize, deserialize) {\n\n        final TypeAdapter\u003c?\u003e typeAdapter \u003d context.getAdapter(fieldType);\n\n        @SuppressWarnings(\"unchecked\")\n        @Override\n        void write(JsonWriter writer, Object value) throws IOException, IllegalAccessException {\n            Object fieldValue \u003d field.get(value);\n            ((TypeAdapter) typeAdapter).write(writer, fieldValue);\n        }\n\n        @Override\n        void read(JsonReader reader, Object value) throws IOException, IllegalAccessException {\n            Object fieldValue \u003d typeAdapter.read(reader);\n            field.set(value, fieldValue);\n        }\n    };\n}",
          "path": "gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapter.java",
          "functionStartLine": 115,
          "functionName": "createBoundField",
          "functionAnnotation": "",
          "functionDoc": "",
          "diff": "@@ -1,19 +1,19 @@\n-static BoundField createBoundField(final MiniGson context, final Field field, final TypeToken\u003c?\u003e fieldType, boolean serialize, boolean deserialize) {\n-    return new BoundField(field.getName(), serialize, deserialize) {\n+static BoundField createBoundField(final MiniGson context, final Field field, final String name, final TypeToken\u003c?\u003e fieldType, boolean serialize, boolean deserialize) {\n+    return new BoundField(name, serialize, deserialize) {\n \n         final TypeAdapter\u003c?\u003e typeAdapter \u003d context.getAdapter(fieldType);\n \n         @SuppressWarnings(\"unchecked\")\n         @Override\n         void write(JsonWriter writer, Object value) throws IOException, IllegalAccessException {\n             Object fieldValue \u003d field.get(value);\n             ((TypeAdapter) typeAdapter).write(writer, fieldValue);\n         }\n \n         @Override\n         void read(JsonReader reader, Object value) throws IOException, IllegalAccessException {\n             Object fieldValue \u003d typeAdapter.read(reader);\n             field.set(value, fieldValue);\n         }\n     };\n }\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldValue": "[context-MiniGson(modifiers-final), field-Field(modifiers-final), fieldType-TypeToken\u003c?\u003e(modifiers-final), serialize-boolean, deserialize-boolean]",
            "newValue": "[context-MiniGson(modifiers-final), field-Field(modifiers-final), name-String(modifiers-final), fieldType-TypeToken\u003c?\u003e(modifiers-final), serialize-boolean, deserialize-boolean]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "Implemented support for FieldNamingPolicy with MiniGson.\n",
          "commitDate": "8/2/11, 7:51 PM",
          "commitName": "f1f8b666ec665b41446ddb3d68de115d8ce91d2f",
          "commitAuthor": "Inderjeet Singh",
          "commitDateOld": "8/2/11, 6:25 PM",
          "commitNameOld": "98aa12458904cd8cb74ca40a905ddc790e14501b",
          "commitAuthorOld": "Jesse Wilson",
          "daysBetweenCommits": 0.06,
          "commitsBetweenForRepo": 3,
          "commitsBetweenForFile": 1,
          "actualSource": "static BoundField createBoundField(final MiniGson context, final Field field, final String name, final TypeToken\u003c?\u003e fieldType, boolean serialize, boolean deserialize) {\n    return new BoundField(name, serialize, deserialize) {\n\n        final TypeAdapter\u003c?\u003e typeAdapter \u003d context.getAdapter(fieldType);\n\n        @SuppressWarnings(\"unchecked\")\n        @Override\n        void write(JsonWriter writer, Object value) throws IOException, IllegalAccessException {\n            Object fieldValue \u003d field.get(value);\n            ((TypeAdapter) typeAdapter).write(writer, fieldValue);\n        }\n\n        @Override\n        void read(JsonReader reader, Object value) throws IOException, IllegalAccessException {\n            Object fieldValue \u003d typeAdapter.read(reader);\n            field.set(value, fieldValue);\n        }\n    };\n}",
          "path": "gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapter.java",
          "functionStartLine": 115,
          "functionName": "createBoundField",
          "functionAnnotation": "",
          "functionDoc": "",
          "diff": "@@ -1,19 +1,19 @@\n-static BoundField createBoundField(final MiniGson context, final Field field, final TypeToken\u003c?\u003e fieldType, boolean serialize, boolean deserialize) {\n-    return new BoundField(field.getName(), serialize, deserialize) {\n+static BoundField createBoundField(final MiniGson context, final Field field, final String name, final TypeToken\u003c?\u003e fieldType, boolean serialize, boolean deserialize) {\n+    return new BoundField(name, serialize, deserialize) {\n \n         final TypeAdapter\u003c?\u003e typeAdapter \u003d context.getAdapter(fieldType);\n \n         @SuppressWarnings(\"unchecked\")\n         @Override\n         void write(JsonWriter writer, Object value) throws IOException, IllegalAccessException {\n             Object fieldValue \u003d field.get(value);\n             ((TypeAdapter) typeAdapter).write(writer, fieldValue);\n         }\n \n         @Override\n         void read(JsonReader reader, Object value) throws IOException, IllegalAccessException {\n             Object fieldValue \u003d typeAdapter.read(reader);\n             field.set(value, fieldValue);\n         }\n     };\n }\n\\ No newline at end of file\n",
          "extendedDetails": {}
        }
      ]
    },
    "f276d1382775e962d1a0a4b9e7e3e08496252861": {
      "type": "Ymultichange(Yparameterchange,Ybodychange)",
      "commitMessage": "Added support for deserialization exclusion strategy.\n",
      "commitDate": "8/2/11, 6:19 PM",
      "commitName": "f276d1382775e962d1a0a4b9e7e3e08496252861",
      "commitAuthor": "Inderjeet Singh",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "Added support for deserialization exclusion strategy.\n",
          "commitDate": "8/2/11, 6:19 PM",
          "commitName": "f276d1382775e962d1a0a4b9e7e3e08496252861",
          "commitAuthor": "Inderjeet Singh",
          "commitDateOld": "8/2/11, 5:47 PM",
          "commitNameOld": "3331dcdab08792f6281ab6343532031a52f54003",
          "commitAuthorOld": "Inderjeet Singh",
          "daysBetweenCommits": 0.02,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "actualSource": "static BoundField createBoundField(final MiniGson context, final Field field, final TypeToken\u003c?\u003e fieldType, boolean serialize, boolean deserialize) {\n    return new BoundField(field.getName(), serialize, deserialize) {\n\n        final TypeAdapter\u003c?\u003e typeAdapter \u003d context.getAdapter(fieldType);\n\n        @SuppressWarnings(\"unchecked\")\n        @Override\n        void write(JsonWriter writer, Object value) throws IOException, IllegalAccessException {\n            Object fieldValue \u003d field.get(value);\n            ((TypeAdapter) typeAdapter).write(writer, fieldValue);\n        }\n\n        @Override\n        void read(JsonReader reader, Object value) throws IOException, IllegalAccessException {\n            Object fieldValue \u003d typeAdapter.read(reader);\n            field.set(value, fieldValue);\n        }\n    };\n}",
          "path": "gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapter.java",
          "functionStartLine": 97,
          "functionName": "createBoundField",
          "functionAnnotation": "",
          "functionDoc": "",
          "diff": "@@ -1,19 +1,19 @@\n-static BoundField createBoundField(final MiniGson context, final Field field, final TypeToken\u003c?\u003e fieldType) {\n-    return new BoundField(field.getName()) {\n+static BoundField createBoundField(final MiniGson context, final Field field, final TypeToken\u003c?\u003e fieldType, boolean serialize, boolean deserialize) {\n+    return new BoundField(field.getName(), serialize, deserialize) {\n \n         final TypeAdapter\u003c?\u003e typeAdapter \u003d context.getAdapter(fieldType);\n \n         @SuppressWarnings(\"unchecked\")\n         @Override\n         void write(JsonWriter writer, Object value) throws IOException, IllegalAccessException {\n             Object fieldValue \u003d field.get(value);\n             ((TypeAdapter) typeAdapter).write(writer, fieldValue);\n         }\n \n         @Override\n         void read(JsonReader reader, Object value) throws IOException, IllegalAccessException {\n             Object fieldValue \u003d typeAdapter.read(reader);\n             field.set(value, fieldValue);\n         }\n     };\n }\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldValue": "[context-MiniGson(modifiers-final), field-Field(modifiers-final), fieldType-TypeToken\u003c?\u003e(modifiers-final)]",
            "newValue": "[context-MiniGson(modifiers-final), field-Field(modifiers-final), fieldType-TypeToken\u003c?\u003e(modifiers-final), serialize-boolean, deserialize-boolean]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "Added support for deserialization exclusion strategy.\n",
          "commitDate": "8/2/11, 6:19 PM",
          "commitName": "f276d1382775e962d1a0a4b9e7e3e08496252861",
          "commitAuthor": "Inderjeet Singh",
          "commitDateOld": "8/2/11, 5:47 PM",
          "commitNameOld": "3331dcdab08792f6281ab6343532031a52f54003",
          "commitAuthorOld": "Inderjeet Singh",
          "daysBetweenCommits": 0.02,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "actualSource": "static BoundField createBoundField(final MiniGson context, final Field field, final TypeToken\u003c?\u003e fieldType, boolean serialize, boolean deserialize) {\n    return new BoundField(field.getName(), serialize, deserialize) {\n\n        final TypeAdapter\u003c?\u003e typeAdapter \u003d context.getAdapter(fieldType);\n\n        @SuppressWarnings(\"unchecked\")\n        @Override\n        void write(JsonWriter writer, Object value) throws IOException, IllegalAccessException {\n            Object fieldValue \u003d field.get(value);\n            ((TypeAdapter) typeAdapter).write(writer, fieldValue);\n        }\n\n        @Override\n        void read(JsonReader reader, Object value) throws IOException, IllegalAccessException {\n            Object fieldValue \u003d typeAdapter.read(reader);\n            field.set(value, fieldValue);\n        }\n    };\n}",
          "path": "gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapter.java",
          "functionStartLine": 97,
          "functionName": "createBoundField",
          "functionAnnotation": "",
          "functionDoc": "",
          "diff": "@@ -1,19 +1,19 @@\n-static BoundField createBoundField(final MiniGson context, final Field field, final TypeToken\u003c?\u003e fieldType) {\n-    return new BoundField(field.getName()) {\n+static BoundField createBoundField(final MiniGson context, final Field field, final TypeToken\u003c?\u003e fieldType, boolean serialize, boolean deserialize) {\n+    return new BoundField(field.getName(), serialize, deserialize) {\n \n         final TypeAdapter\u003c?\u003e typeAdapter \u003d context.getAdapter(fieldType);\n \n         @SuppressWarnings(\"unchecked\")\n         @Override\n         void write(JsonWriter writer, Object value) throws IOException, IllegalAccessException {\n             Object fieldValue \u003d field.get(value);\n             ((TypeAdapter) typeAdapter).write(writer, fieldValue);\n         }\n \n         @Override\n         void read(JsonReader reader, Object value) throws IOException, IllegalAccessException {\n             Object fieldValue \u003d typeAdapter.read(reader);\n             field.set(value, fieldValue);\n         }\n     };\n }\n\\ No newline at end of file\n",
          "extendedDetails": {}
        }
      ]
    },
    "60e6ed912d52716f46a1ba71923ef203c4248857": {
      "type": "Yfilerename",
      "commitMessage": "Promote MiniGson to gson.internal.bind\n",
      "commitDate": "8/2/11, 5:25 PM",
      "commitName": "60e6ed912d52716f46a1ba71923ef203c4248857",
      "commitAuthor": "Jesse Wilson",
      "commitDateOld": "8/2/11, 5:17 PM",
      "commitNameOld": "759eb8ede50f61fd525f5d703dd9fd45ddae1dcd",
      "commitAuthorOld": "Jesse Wilson",
      "daysBetweenCommits": 0.01,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "static BoundField createBoundField(final MiniGson context, final Field field, final TypeToken\u003c?\u003e fieldType) {\n    return new BoundField(field.getName()) {\n\n        final TypeAdapter\u003c?\u003e typeAdapter \u003d context.getAdapter(fieldType);\n\n        @SuppressWarnings(\"unchecked\")\n        @Override\n        void write(JsonWriter writer, Object value) throws IOException, IllegalAccessException {\n            Object fieldValue \u003d field.get(value);\n            ((TypeAdapter) typeAdapter).write(writer, fieldValue);\n        }\n\n        @Override\n        void read(JsonReader reader, Object value) throws IOException, IllegalAccessException {\n            Object fieldValue \u003d typeAdapter.read(reader);\n            field.set(value, fieldValue);\n        }\n    };\n}",
      "path": "gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapter.java",
      "functionStartLine": 129,
      "functionName": "createBoundField",
      "functionAnnotation": "",
      "functionDoc": "",
      "diff": "",
      "extendedDetails": {
        "oldPath": "extras/src/main/java/com/google/gson/mini/ReflectiveTypeAdapter.java",
        "newPath": "gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapter.java"
      }
    },
    "4b042671af018f308c2a261145dc6712e39b96e7": {
      "type": "Yintroduced",
      "commitMessage": "Cleanup after experimenting with specializing BoundField by type (ie. Field.setInt() to avoid autoboxing)\n",
      "commitDate": "7/15/11, 7:37 AM",
      "commitName": "4b042671af018f308c2a261145dc6712e39b96e7",
      "commitAuthor": "Jesse Wilson",
      "diff": "@@ -0,0 +1,19 @@\n+static BoundField createBoundField(final MiniGson context, final Field field, final TypeToken\u003c?\u003e fieldType) {\n+    return new BoundField(field.getName()) {\n+\n+        final TypeAdapter\u003c?\u003e typeAdapter \u003d context.getAdapter(fieldType);\n+\n+        @SuppressWarnings(\"unchecked\")\n+        @Override\n+        void write(JsonWriter writer, Object value) throws IOException, IllegalAccessException {\n+            Object fieldValue \u003d field.get(value);\n+            ((TypeAdapter) typeAdapter).write(writer, fieldValue);\n+        }\n+\n+        @Override\n+        void read(JsonReader reader, Object value) throws IOException, IllegalAccessException {\n+            Object fieldValue \u003d typeAdapter.read(reader);\n+            field.set(value, fieldValue);\n+        }\n+    };\n+}\n\\ No newline at end of file\n",
      "actualSource": "static BoundField createBoundField(final MiniGson context, final Field field, final TypeToken\u003c?\u003e fieldType) {\n    return new BoundField(field.getName()) {\n\n        final TypeAdapter\u003c?\u003e typeAdapter \u003d context.getAdapter(fieldType);\n\n        @SuppressWarnings(\"unchecked\")\n        @Override\n        void write(JsonWriter writer, Object value) throws IOException, IllegalAccessException {\n            Object fieldValue \u003d field.get(value);\n            ((TypeAdapter) typeAdapter).write(writer, fieldValue);\n        }\n\n        @Override\n        void read(JsonReader reader, Object value) throws IOException, IllegalAccessException {\n            Object fieldValue \u003d typeAdapter.read(reader);\n            field.set(value, fieldValue);\n        }\n    };\n}",
      "path": "extras/src/main/java/com/google/gson/mini/ReflectiveTypeAdapter.java",
      "functionStartLine": 129,
      "functionName": "createBoundField",
      "functionAnnotation": "",
      "functionDoc": ""
    }
  }
}