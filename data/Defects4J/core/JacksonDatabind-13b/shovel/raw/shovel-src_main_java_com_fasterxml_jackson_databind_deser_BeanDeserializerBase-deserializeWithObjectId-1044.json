{
  "origin": "codeshovel",
  "repositoryName": "JacksonDatabind-13b",
  "repositoryPath": "/tmp/JacksonDatabind-13b//.git",
  "startCommitName": "HEAD",
  "sourceFileName": "BeanDeserializerBase.java",
  "functionName": "deserializeWithObjectId",
  "functionId": "deserializeWithObjectId___jp-JsonParser__ctxt-DeserializationContext",
  "sourceFilePath": "src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializerBase.java",
  "functionAnnotation": "",
  "functionDoc": "Alternative deserialization method used when we expect to see Object Id;\nif so, we will need to ensure that the Id is seen before anything\nelse, to ensure that it is available for solving references,\neven if JSON itself is not ordered that way. This may require\nbuffering in some cases, but usually just a simple lookup to ensure\nthat ordering is correct.\n",
  "functionStartLine": 1044,
  "functionEndLine": 1046,
  "numCommitsSeen": 128,
  "timeTaken": 5047,
  "changeHistory": [
    "c7906ba19b9d69c62b29fd648e921c853bc2655f",
    "5abbb53fa2da96a7548d4bf25d5954d5f58e8105",
    "6932e0706954018d3674604ff73cea0ba1365f97",
    "767ecb29a5a79f799113d13eb137389ff5a4c2c5",
    "e05e352f53245160fe761b88665f11f67cef9d43",
    "54d47c1b3dd0a3597cda3366add9cbd49a57b51f",
    "0e114114d330caaf6a56e63ab4d8a3ee1ba3e350",
    "60e30f499e9318b2b18c3cbac4edc2bfcf6d6d66"
  ],
  "changeHistoryShort": {
    "c7906ba19b9d69c62b29fd648e921c853bc2655f": "Yexceptionschange",
    "5abbb53fa2da96a7548d4bf25d5954d5f58e8105": "Ymultichange(Ybodychange,Yannotationchange)",
    "6932e0706954018d3674604ff73cea0ba1365f97": "Ybodychange",
    "767ecb29a5a79f799113d13eb137389ff5a4c2c5": "Ybodychange",
    "e05e352f53245160fe761b88665f11f67cef9d43": "Ybodychange",
    "54d47c1b3dd0a3597cda3366add9cbd49a57b51f": "Ymovefromfile",
    "0e114114d330caaf6a56e63ab4d8a3ee1ba3e350": "Yannotationchange",
    "60e30f499e9318b2b18c3cbac4edc2bfcf6d6d66": "Yintroduced"
  },
  "changeHistoryDetails": {
    "c7906ba19b9d69c62b29fd648e921c853bc2655f": {
      "type": "Yexceptionschange",
      "commitMessage": "Fixing #486\n",
      "commitDate": "8/7/14, 11:27 PM",
      "commitName": "c7906ba19b9d69c62b29fd648e921c853bc2655f",
      "commitAuthor": "Tatu Saloranta",
      "commitDateOld": "7/24/14, 10:33 PM",
      "commitNameOld": "9e080e298d8c0cfd7d77a56eb93d85a5da322555",
      "commitAuthorOld": "Tatu Saloranta",
      "daysBetweenCommits": 14.04,
      "commitsBetweenForRepo": 3,
      "commitsBetweenForFile": 1,
      "actualSource": "protected Object deserializeWithObjectId(JsonParser jp, DeserializationContext ctxt) throws IOException {\n    return deserializeFromObject(jp, ctxt);\n}",
      "path": "src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializerBase.java",
      "functionStartLine": 1026,
      "functionName": "deserializeWithObjectId",
      "functionAnnotation": "",
      "functionDoc": "Alternative deserialization method used when we expect to see Object Id;\nif so, we will need to ensure that the Id is seen before anything\nelse, to ensure that it is available for solving references,\neven if JSON itself is not ordered that way. This may require\nbuffering in some cases, but usually just a simple lookup to ensure\nthat ordering is correct.\n",
      "diff": "@@ -1,3 +1,3 @@\n-protected Object deserializeWithObjectId(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException {\n+protected Object deserializeWithObjectId(JsonParser jp, DeserializationContext ctxt) throws IOException {\n     return deserializeFromObject(jp, ctxt);\n }\n\\ No newline at end of file\n",
      "extendedDetails": {
        "oldValue": "[IOException, JsonProcessingException]",
        "newValue": "[IOException]"
      }
    },
    "5abbb53fa2da96a7548d4bf25d5954d5f58e8105": {
      "type": "Ymultichange(Ybodychange,Yannotationchange)",
      "commitMessage": "Removed buffering during object id resolution, no longer needed. Fixes FasterXML/jackson-dataformat-xml#104\n",
      "commitDate": "2/17/14, 11:14 AM",
      "commitName": "5abbb53fa2da96a7548d4bf25d5954d5f58e8105",
      "commitAuthor": "Pascal Gélinas",
      "subchanges": [
        {
          "type": "Ybodychange",
          "commitMessage": "Removed buffering during object id resolution, no longer needed. Fixes FasterXML/jackson-dataformat-xml#104\n",
          "commitDate": "2/17/14, 11:14 AM",
          "commitName": "5abbb53fa2da96a7548d4bf25d5954d5f58e8105",
          "commitAuthor": "Pascal Gélinas",
          "commitDateOld": "1/13/14, 7:07 AM",
          "commitNameOld": "d823407ab82164afdd14832fe5159c44d42d89ef",
          "commitAuthorOld": "Pascal Gélinas",
          "daysBetweenCommits": 35.17,
          "commitsBetweenForRepo": 36,
          "commitsBetweenForFile": 1,
          "actualSource": "protected Object deserializeWithObjectId(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException {\n    return deserializeFromObject(jp, ctxt);\n}",
          "path": "src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializerBase.java",
          "functionStartLine": 1017,
          "functionName": "deserializeWithObjectId",
          "functionAnnotation": "",
          "functionDoc": "Alternative deserialization method used when we expect to see Object Id;\nif so, we will need to ensure that the Id is seen before anything\nelse, to ensure that it is available for solving references,\neven if JSON itself is not ordered that way. This may require\nbuffering in some cases, but usually just a simple lookup to ensure\nthat ordering is correct.\n",
          "diff": "@@ -1,35 +1,3 @@\n-@SuppressWarnings(\"resource\")\n protected Object deserializeWithObjectId(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException {\n-    final String idPropName \u003d _objectIdReader.propertyName.getSimpleName();\n-    if (idPropName.equals(jp.getCurrentName()) || jp.canReadObjectId()) {\n-        return deserializeFromObject(jp, ctxt);\n-    }\n-    TokenBuffer tmpBuffer \u003d new TokenBuffer(jp);\n-    TokenBuffer mergedBuffer \u003d null;\n-    for (; jp.getCurrentToken() !\u003d JsonToken.END_OBJECT; jp.nextToken()) {\n-        String propName \u003d jp.getCurrentName();\n-        if (mergedBuffer \u003d\u003d null) {\n-            if (idPropName.equals(propName)) {\n-                mergedBuffer \u003d new TokenBuffer(jp);\n-                mergedBuffer.writeFieldName(propName);\n-                jp.nextToken();\n-                mergedBuffer.copyCurrentStructure(jp);\n-                mergedBuffer.append(tmpBuffer);\n-                tmpBuffer \u003d null;\n-            } else {\n-                tmpBuffer.writeFieldName(propName);\n-                jp.nextToken();\n-                tmpBuffer.copyCurrentStructure(jp);\n-            }\n-        } else {\n-            mergedBuffer.writeFieldName(propName);\n-            jp.nextToken();\n-            mergedBuffer.copyCurrentStructure(jp);\n-        }\n-    }\n-    TokenBuffer buffer \u003d (mergedBuffer \u003d\u003d null) ? tmpBuffer : mergedBuffer;\n-    buffer.writeEndObject();\n-    JsonParser mergedParser \u003d buffer.asParser();\n-    mergedParser.nextToken();\n-    return deserializeFromObject(mergedParser, ctxt);\n+    return deserializeFromObject(jp, ctxt);\n }\n\\ No newline at end of file\n",
          "extendedDetails": {}
        },
        {
          "type": "Yannotationchange",
          "commitMessage": "Removed buffering during object id resolution, no longer needed. Fixes FasterXML/jackson-dataformat-xml#104\n",
          "commitDate": "2/17/14, 11:14 AM",
          "commitName": "5abbb53fa2da96a7548d4bf25d5954d5f58e8105",
          "commitAuthor": "Pascal Gélinas",
          "commitDateOld": "1/13/14, 7:07 AM",
          "commitNameOld": "d823407ab82164afdd14832fe5159c44d42d89ef",
          "commitAuthorOld": "Pascal Gélinas",
          "daysBetweenCommits": 35.17,
          "commitsBetweenForRepo": 36,
          "commitsBetweenForFile": 1,
          "actualSource": "protected Object deserializeWithObjectId(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException {\n    return deserializeFromObject(jp, ctxt);\n}",
          "path": "src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializerBase.java",
          "functionStartLine": 1017,
          "functionName": "deserializeWithObjectId",
          "functionAnnotation": "",
          "functionDoc": "Alternative deserialization method used when we expect to see Object Id;\nif so, we will need to ensure that the Id is seen before anything\nelse, to ensure that it is available for solving references,\neven if JSON itself is not ordered that way. This may require\nbuffering in some cases, but usually just a simple lookup to ensure\nthat ordering is correct.\n",
          "diff": "@@ -1,35 +1,3 @@\n-@SuppressWarnings(\"resource\")\n protected Object deserializeWithObjectId(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException {\n-    final String idPropName \u003d _objectIdReader.propertyName.getSimpleName();\n-    if (idPropName.equals(jp.getCurrentName()) || jp.canReadObjectId()) {\n-        return deserializeFromObject(jp, ctxt);\n-    }\n-    TokenBuffer tmpBuffer \u003d new TokenBuffer(jp);\n-    TokenBuffer mergedBuffer \u003d null;\n-    for (; jp.getCurrentToken() !\u003d JsonToken.END_OBJECT; jp.nextToken()) {\n-        String propName \u003d jp.getCurrentName();\n-        if (mergedBuffer \u003d\u003d null) {\n-            if (idPropName.equals(propName)) {\n-                mergedBuffer \u003d new TokenBuffer(jp);\n-                mergedBuffer.writeFieldName(propName);\n-                jp.nextToken();\n-                mergedBuffer.copyCurrentStructure(jp);\n-                mergedBuffer.append(tmpBuffer);\n-                tmpBuffer \u003d null;\n-            } else {\n-                tmpBuffer.writeFieldName(propName);\n-                jp.nextToken();\n-                tmpBuffer.copyCurrentStructure(jp);\n-            }\n-        } else {\n-            mergedBuffer.writeFieldName(propName);\n-            jp.nextToken();\n-            mergedBuffer.copyCurrentStructure(jp);\n-        }\n-    }\n-    TokenBuffer buffer \u003d (mergedBuffer \u003d\u003d null) ? tmpBuffer : mergedBuffer;\n-    buffer.writeEndObject();\n-    JsonParser mergedParser \u003d buffer.asParser();\n-    mergedParser.nextToken();\n-    return deserializeFromObject(mergedParser, ctxt);\n+    return deserializeFromObject(jp, ctxt);\n }\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldValue": "@SuppressWarnings(\"resource\")",
            "newValue": ""
          }
        }
      ]
    },
    "6932e0706954018d3674604ff73cea0ba1365f97": {
      "type": "Ybodychange",
      "commitMessage": "More support for reading native Object Ids\n",
      "commitDate": "8/5/13, 9:28 PM",
      "commitName": "6932e0706954018d3674604ff73cea0ba1365f97",
      "commitAuthor": "Tatu Saloranta",
      "commitDateOld": "8/5/13, 8:29 PM",
      "commitNameOld": "9e649069d9f2309f4556b2c7d510fd5d33984018",
      "commitAuthorOld": "Tatu Saloranta",
      "daysBetweenCommits": 0.04,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "@SuppressWarnings(\"resource\")\nprotected Object deserializeWithObjectId(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException {\n    final String idPropName \u003d _objectIdReader.propertyName.getSimpleName();\n    if (idPropName.equals(jp.getCurrentName()) || jp.canReadObjectId()) {\n        return deserializeFromObject(jp, ctxt);\n    }\n    TokenBuffer tmpBuffer \u003d new TokenBuffer(jp);\n    TokenBuffer mergedBuffer \u003d null;\n    for (; jp.getCurrentToken() !\u003d JsonToken.END_OBJECT; jp.nextToken()) {\n        String propName \u003d jp.getCurrentName();\n        if (mergedBuffer \u003d\u003d null) {\n            if (idPropName.equals(propName)) {\n                mergedBuffer \u003d new TokenBuffer(jp);\n                mergedBuffer.writeFieldName(propName);\n                jp.nextToken();\n                mergedBuffer.copyCurrentStructure(jp);\n                mergedBuffer.append(tmpBuffer);\n                tmpBuffer \u003d null;\n            } else {\n                tmpBuffer.writeFieldName(propName);\n                jp.nextToken();\n                tmpBuffer.copyCurrentStructure(jp);\n            }\n        } else {\n            mergedBuffer.writeFieldName(propName);\n            jp.nextToken();\n            mergedBuffer.copyCurrentStructure(jp);\n        }\n    }\n    TokenBuffer buffer \u003d (mergedBuffer \u003d\u003d null) ? tmpBuffer : mergedBuffer;\n    buffer.writeEndObject();\n    JsonParser mergedParser \u003d buffer.asParser();\n    mergedParser.nextToken();\n    return deserializeFromObject(mergedParser, ctxt);\n}",
      "path": "src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializerBase.java",
      "functionStartLine": 919,
      "functionName": "deserializeWithObjectId",
      "functionAnnotation": "@SuppressWarnings(\"resource\")",
      "functionDoc": "Alternative deserialization method used when we expect to see Object Id;\nif so, we will need to ensure that the Id is seen before anything\nelse, to ensure that it is available for solving references,\neven if JSON itself is not ordered that way. This may require\nbuffering in some cases, but usually just a simple lookup to ensure\nthat ordering is correct.\n",
      "diff": "@@ -1,35 +1,35 @@\n @SuppressWarnings(\"resource\")\n protected Object deserializeWithObjectId(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException {\n     final String idPropName \u003d _objectIdReader.propertyName.getSimpleName();\n-    if (idPropName.equals(jp.getCurrentName())) {\n+    if (idPropName.equals(jp.getCurrentName()) || jp.canReadObjectId()) {\n         return deserializeFromObject(jp, ctxt);\n     }\n     TokenBuffer tmpBuffer \u003d new TokenBuffer(jp);\n     TokenBuffer mergedBuffer \u003d null;\n     for (; jp.getCurrentToken() !\u003d JsonToken.END_OBJECT; jp.nextToken()) {\n         String propName \u003d jp.getCurrentName();\n         if (mergedBuffer \u003d\u003d null) {\n             if (idPropName.equals(propName)) {\n                 mergedBuffer \u003d new TokenBuffer(jp);\n                 mergedBuffer.writeFieldName(propName);\n                 jp.nextToken();\n                 mergedBuffer.copyCurrentStructure(jp);\n                 mergedBuffer.append(tmpBuffer);\n                 tmpBuffer \u003d null;\n             } else {\n                 tmpBuffer.writeFieldName(propName);\n                 jp.nextToken();\n                 tmpBuffer.copyCurrentStructure(jp);\n             }\n         } else {\n             mergedBuffer.writeFieldName(propName);\n             jp.nextToken();\n             mergedBuffer.copyCurrentStructure(jp);\n         }\n     }\n     TokenBuffer buffer \u003d (mergedBuffer \u003d\u003d null) ? tmpBuffer : mergedBuffer;\n     buffer.writeEndObject();\n     JsonParser mergedParser \u003d buffer.asParser();\n     mergedParser.nextToken();\n     return deserializeFromObject(mergedParser, ctxt);\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "767ecb29a5a79f799113d13eb137389ff5a4c2c5": {
      "type": "Ybodychange",
      "commitMessage": "Try to add support for retaining type ids via TokenBuffer\n",
      "commitDate": "8/4/13, 5:17 PM",
      "commitName": "767ecb29a5a79f799113d13eb137389ff5a4c2c5",
      "commitAuthor": "Tatu Saloranta",
      "commitDateOld": "7/26/13, 4:18 PM",
      "commitNameOld": "8bdd49b36c8c05483669f6bd50b3839016f78983",
      "commitAuthorOld": "Tatu Saloranta",
      "daysBetweenCommits": 9.04,
      "commitsBetweenForRepo": 10,
      "commitsBetweenForFile": 1,
      "actualSource": "@SuppressWarnings(\"resource\")\nprotected Object deserializeWithObjectId(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException {\n    final String idPropName \u003d _objectIdReader.propertyName.getSimpleName();\n    if (idPropName.equals(jp.getCurrentName())) {\n        return deserializeFromObject(jp, ctxt);\n    }\n    TokenBuffer tmpBuffer \u003d new TokenBuffer(jp);\n    TokenBuffer mergedBuffer \u003d null;\n    for (; jp.getCurrentToken() !\u003d JsonToken.END_OBJECT; jp.nextToken()) {\n        String propName \u003d jp.getCurrentName();\n        if (mergedBuffer \u003d\u003d null) {\n            if (idPropName.equals(propName)) {\n                mergedBuffer \u003d new TokenBuffer(jp);\n                mergedBuffer.writeFieldName(propName);\n                jp.nextToken();\n                mergedBuffer.copyCurrentStructure(jp);\n                mergedBuffer.append(tmpBuffer);\n                tmpBuffer \u003d null;\n            } else {\n                tmpBuffer.writeFieldName(propName);\n                jp.nextToken();\n                tmpBuffer.copyCurrentStructure(jp);\n            }\n        } else {\n            mergedBuffer.writeFieldName(propName);\n            jp.nextToken();\n            mergedBuffer.copyCurrentStructure(jp);\n        }\n    }\n    TokenBuffer buffer \u003d (mergedBuffer \u003d\u003d null) ? tmpBuffer : mergedBuffer;\n    buffer.writeEndObject();\n    JsonParser mergedParser \u003d buffer.asParser();\n    mergedParser.nextToken();\n    return deserializeFromObject(mergedParser, ctxt);\n}",
      "path": "src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializerBase.java",
      "functionStartLine": 894,
      "functionName": "deserializeWithObjectId",
      "functionAnnotation": "@SuppressWarnings(\"resource\")",
      "functionDoc": "Alternative deserialization method used when we expect to see Object Id;\nif so, we will need to ensure that the Id is seen before anything\nelse, to ensure that it is available for solving references,\neven if JSON itself is not ordered that way. This may require\nbuffering in some cases, but usually just a simple lookup to ensure\nthat ordering is correct.\n",
      "diff": "@@ -1,35 +1,35 @@\n @SuppressWarnings(\"resource\")\n protected Object deserializeWithObjectId(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException {\n     final String idPropName \u003d _objectIdReader.propertyName.getSimpleName();\n     if (idPropName.equals(jp.getCurrentName())) {\n         return deserializeFromObject(jp, ctxt);\n     }\n-    TokenBuffer tmpBuffer \u003d new TokenBuffer(jp.getCodec());\n+    TokenBuffer tmpBuffer \u003d new TokenBuffer(jp);\n     TokenBuffer mergedBuffer \u003d null;\n     for (; jp.getCurrentToken() !\u003d JsonToken.END_OBJECT; jp.nextToken()) {\n         String propName \u003d jp.getCurrentName();\n         if (mergedBuffer \u003d\u003d null) {\n             if (idPropName.equals(propName)) {\n-                mergedBuffer \u003d new TokenBuffer(jp.getCodec());\n+                mergedBuffer \u003d new TokenBuffer(jp);\n                 mergedBuffer.writeFieldName(propName);\n                 jp.nextToken();\n                 mergedBuffer.copyCurrentStructure(jp);\n                 mergedBuffer.append(tmpBuffer);\n                 tmpBuffer \u003d null;\n             } else {\n                 tmpBuffer.writeFieldName(propName);\n                 jp.nextToken();\n                 tmpBuffer.copyCurrentStructure(jp);\n             }\n         } else {\n             mergedBuffer.writeFieldName(propName);\n             jp.nextToken();\n             mergedBuffer.copyCurrentStructure(jp);\n         }\n     }\n     TokenBuffer buffer \u003d (mergedBuffer \u003d\u003d null) ? tmpBuffer : mergedBuffer;\n     buffer.writeEndObject();\n     JsonParser mergedParser \u003d buffer.asParser();\n     mergedParser.nextToken();\n     return deserializeFromObject(mergedParser, ctxt);\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "e05e352f53245160fe761b88665f11f67cef9d43": {
      "type": "Ybodychange",
      "commitMessage": "Start making changes to support full PropertyName passing, not just String name\n",
      "commitDate": "7/25/13, 11:05 PM",
      "commitName": "e05e352f53245160fe761b88665f11f67cef9d43",
      "commitAuthor": "Tatu Saloranta",
      "commitDateOld": "7/25/13, 10:12 PM",
      "commitNameOld": "a455b53c75d4649461ba3e7fdcc625f2cd223202",
      "commitAuthorOld": "Tatu Saloranta",
      "daysBetweenCommits": 0.04,
      "commitsBetweenForRepo": 5,
      "commitsBetweenForFile": 1,
      "actualSource": "@SuppressWarnings(\"resource\")\nprotected Object deserializeWithObjectId(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException {\n    final String idPropName \u003d _objectIdReader.propertyName.getSimpleName();\n    if (idPropName.equals(jp.getCurrentName())) {\n        return deserializeFromObject(jp, ctxt);\n    }\n    TokenBuffer tmpBuffer \u003d new TokenBuffer(jp.getCodec());\n    TokenBuffer mergedBuffer \u003d null;\n    for (; jp.getCurrentToken() !\u003d JsonToken.END_OBJECT; jp.nextToken()) {\n        String propName \u003d jp.getCurrentName();\n        if (mergedBuffer \u003d\u003d null) {\n            if (idPropName.equals(propName)) {\n                mergedBuffer \u003d new TokenBuffer(jp.getCodec());\n                mergedBuffer.writeFieldName(propName);\n                jp.nextToken();\n                mergedBuffer.copyCurrentStructure(jp);\n                mergedBuffer.append(tmpBuffer);\n                tmpBuffer \u003d null;\n            } else {\n                tmpBuffer.writeFieldName(propName);\n                jp.nextToken();\n                tmpBuffer.copyCurrentStructure(jp);\n            }\n        } else {\n            mergedBuffer.writeFieldName(propName);\n            jp.nextToken();\n            mergedBuffer.copyCurrentStructure(jp);\n        }\n    }\n    TokenBuffer buffer \u003d (mergedBuffer \u003d\u003d null) ? tmpBuffer : mergedBuffer;\n    buffer.writeEndObject();\n    JsonParser mergedParser \u003d buffer.asParser();\n    mergedParser.nextToken();\n    return deserializeFromObject(mergedParser, ctxt);\n}",
      "path": "src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializerBase.java",
      "functionStartLine": 891,
      "functionName": "deserializeWithObjectId",
      "functionAnnotation": "@SuppressWarnings(\"resource\")",
      "functionDoc": "Alternative deserialization method used when we expect to see Object Id;\nif so, we will need to ensure that the Id is seen before anything\nelse, to ensure that it is available for solving references,\neven if JSON itself is not ordered that way. This may require\nbuffering in some cases, but usually just a simple lookup to ensure\nthat ordering is correct.\n",
      "diff": "@@ -1,35 +1,35 @@\n @SuppressWarnings(\"resource\")\n protected Object deserializeWithObjectId(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException {\n-    final String idPropName \u003d _objectIdReader.propertyName;\n+    final String idPropName \u003d _objectIdReader.propertyName.getSimpleName();\n     if (idPropName.equals(jp.getCurrentName())) {\n         return deserializeFromObject(jp, ctxt);\n     }\n     TokenBuffer tmpBuffer \u003d new TokenBuffer(jp.getCodec());\n     TokenBuffer mergedBuffer \u003d null;\n     for (; jp.getCurrentToken() !\u003d JsonToken.END_OBJECT; jp.nextToken()) {\n         String propName \u003d jp.getCurrentName();\n         if (mergedBuffer \u003d\u003d null) {\n             if (idPropName.equals(propName)) {\n                 mergedBuffer \u003d new TokenBuffer(jp.getCodec());\n                 mergedBuffer.writeFieldName(propName);\n                 jp.nextToken();\n                 mergedBuffer.copyCurrentStructure(jp);\n                 mergedBuffer.append(tmpBuffer);\n                 tmpBuffer \u003d null;\n             } else {\n                 tmpBuffer.writeFieldName(propName);\n                 jp.nextToken();\n                 tmpBuffer.copyCurrentStructure(jp);\n             }\n         } else {\n             mergedBuffer.writeFieldName(propName);\n             jp.nextToken();\n             mergedBuffer.copyCurrentStructure(jp);\n         }\n     }\n     TokenBuffer buffer \u003d (mergedBuffer \u003d\u003d null) ? tmpBuffer : mergedBuffer;\n     buffer.writeEndObject();\n     JsonParser mergedParser \u003d buffer.asParser();\n     mergedParser.nextToken();\n     return deserializeFromObject(mergedParser, ctxt);\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "54d47c1b3dd0a3597cda3366add9cbd49a57b51f": {
      "type": "Ymovefromfile",
      "commitMessage": "demoting deserializeWithObjectId()\n",
      "commitDate": "11/17/12, 11:11 AM",
      "commitName": "54d47c1b3dd0a3597cda3366add9cbd49a57b51f",
      "commitAuthor": "Tatu Saloranta",
      "commitDateOld": "11/17/12, 11:06 AM",
      "commitNameOld": "a20ba9fcac9cc9e8e0bde875d12511046892be2e",
      "commitAuthorOld": "Tatu Saloranta",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "@SuppressWarnings(\"resource\")\nprotected Object deserializeWithObjectId(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException {\n    final String idPropName \u003d _objectIdReader.propertyName;\n    if (idPropName.equals(jp.getCurrentName())) {\n        return deserializeFromObject(jp, ctxt);\n    }\n    TokenBuffer tmpBuffer \u003d new TokenBuffer(jp.getCodec());\n    TokenBuffer mergedBuffer \u003d null;\n    for (; jp.getCurrentToken() !\u003d JsonToken.END_OBJECT; jp.nextToken()) {\n        String propName \u003d jp.getCurrentName();\n        if (mergedBuffer \u003d\u003d null) {\n            if (idPropName.equals(propName)) {\n                mergedBuffer \u003d new TokenBuffer(jp.getCodec());\n                mergedBuffer.writeFieldName(propName);\n                jp.nextToken();\n                mergedBuffer.copyCurrentStructure(jp);\n                mergedBuffer.append(tmpBuffer);\n                tmpBuffer \u003d null;\n            } else {\n                tmpBuffer.writeFieldName(propName);\n                jp.nextToken();\n                tmpBuffer.copyCurrentStructure(jp);\n            }\n        } else {\n            mergedBuffer.writeFieldName(propName);\n            jp.nextToken();\n            mergedBuffer.copyCurrentStructure(jp);\n        }\n    }\n    TokenBuffer buffer \u003d (mergedBuffer \u003d\u003d null) ? tmpBuffer : mergedBuffer;\n    buffer.writeEndObject();\n    JsonParser mergedParser \u003d buffer.asParser();\n    mergedParser.nextToken();\n    return deserializeFromObject(mergedParser, ctxt);\n}",
      "path": "src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializerBase.java",
      "functionStartLine": 870,
      "functionName": "deserializeWithObjectId",
      "functionAnnotation": "@SuppressWarnings(\"resource\")",
      "functionDoc": "Alternative deserialization method used when we expect to see Object Id;\nif so, we will need to ensure that the Id is seen before anything\nelse, to ensure that it is available for solving references,\neven if JSON itself is not ordered that way. This may require\nbuffering in some cases, but usually just a simple lookup to ensure\nthat ordering is correct.\n",
      "diff": "",
      "extendedDetails": {
        "oldPath": "src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializer.java",
        "newPath": "src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializerBase.java",
        "oldMethodName": "deserializeWithObjectId",
        "newMethodName": "deserializeWithObjectId"
      }
    },
    "0e114114d330caaf6a56e63ab4d8a3ee1ba3e350": {
      "type": "Yannotationchange",
      "commitMessage": "Furious JDK-serialization-support code surge continuing...\n",
      "commitDate": "10/6/12, 10:45 AM",
      "commitName": "0e114114d330caaf6a56e63ab4d8a3ee1ba3e350",
      "commitAuthor": "Tatu Saloranta",
      "commitDateOld": "10/5/12, 11:51 PM",
      "commitNameOld": "65d186e7f2561b6e3fedce1869546b2443036b50",
      "commitAuthorOld": "Tatu Saloranta",
      "daysBetweenCommits": 0.45,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "@SuppressWarnings(\"resource\")\nprotected Object deserializeWithObjectId(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException {\n    final String idPropName \u003d _objectIdReader.propertyName;\n    if (idPropName.equals(jp.getCurrentName())) {\n        return deserializeFromObject(jp, ctxt);\n    }\n    TokenBuffer tmpBuffer \u003d new TokenBuffer(jp.getCodec());\n    TokenBuffer mergedBuffer \u003d null;\n    for (; jp.getCurrentToken() !\u003d JsonToken.END_OBJECT; jp.nextToken()) {\n        String propName \u003d jp.getCurrentName();\n        if (mergedBuffer \u003d\u003d null) {\n            if (idPropName.equals(propName)) {\n                mergedBuffer \u003d new TokenBuffer(jp.getCodec());\n                mergedBuffer.writeFieldName(propName);\n                jp.nextToken();\n                mergedBuffer.copyCurrentStructure(jp);\n                mergedBuffer.append(tmpBuffer);\n                tmpBuffer \u003d null;\n            } else {\n                tmpBuffer.writeFieldName(propName);\n                jp.nextToken();\n                tmpBuffer.copyCurrentStructure(jp);\n            }\n        } else {\n            mergedBuffer.writeFieldName(propName);\n            jp.nextToken();\n            mergedBuffer.copyCurrentStructure(jp);\n        }\n    }\n    TokenBuffer buffer \u003d (mergedBuffer \u003d\u003d null) ? tmpBuffer : mergedBuffer;\n    buffer.writeEndObject();\n    JsonParser mergedParser \u003d buffer.asParser();\n    mergedParser.nextToken();\n    return deserializeFromObject(mergedParser, ctxt);\n}",
      "path": "src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializer.java",
      "functionStartLine": 343,
      "functionName": "deserializeWithObjectId",
      "functionAnnotation": "@SuppressWarnings(\"resource\")",
      "functionDoc": "Alternative deserialization method used when we expect to see Object Id;\nif so, we will need to ensure that the Id is seen before anything\nelse, to ensure that it is available for solving references,\neven if JSON itself is not ordered that way. This may require\nbuffering in some cases, but usually just a simple lookup to ensure\nthat ordering is correct.\n",
      "diff": "@@ -1,34 +1,35 @@\n+@SuppressWarnings(\"resource\")\n protected Object deserializeWithObjectId(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException {\n     final String idPropName \u003d _objectIdReader.propertyName;\n     if (idPropName.equals(jp.getCurrentName())) {\n         return deserializeFromObject(jp, ctxt);\n     }\n     TokenBuffer tmpBuffer \u003d new TokenBuffer(jp.getCodec());\n     TokenBuffer mergedBuffer \u003d null;\n     for (; jp.getCurrentToken() !\u003d JsonToken.END_OBJECT; jp.nextToken()) {\n         String propName \u003d jp.getCurrentName();\n         if (mergedBuffer \u003d\u003d null) {\n             if (idPropName.equals(propName)) {\n                 mergedBuffer \u003d new TokenBuffer(jp.getCodec());\n                 mergedBuffer.writeFieldName(propName);\n                 jp.nextToken();\n                 mergedBuffer.copyCurrentStructure(jp);\n                 mergedBuffer.append(tmpBuffer);\n                 tmpBuffer \u003d null;\n             } else {\n                 tmpBuffer.writeFieldName(propName);\n                 jp.nextToken();\n                 tmpBuffer.copyCurrentStructure(jp);\n             }\n         } else {\n             mergedBuffer.writeFieldName(propName);\n             jp.nextToken();\n             mergedBuffer.copyCurrentStructure(jp);\n         }\n     }\n     TokenBuffer buffer \u003d (mergedBuffer \u003d\u003d null) ? tmpBuffer : mergedBuffer;\n     buffer.writeEndObject();\n     JsonParser mergedParser \u003d buffer.asParser();\n     mergedParser.nextToken();\n     return deserializeFromObject(mergedParser, ctxt);\n }\n\\ No newline at end of file\n",
      "extendedDetails": {
        "oldValue": "",
        "newValue": "@SuppressWarnings(\"resource\")"
      }
    },
    "60e30f499e9318b2b18c3cbac4edc2bfcf6d6d66": {
      "type": "Yintroduced",
      "commitMessage": "Implement [JACKSON-792]; can now handle Object Id forward references correctly\n",
      "commitDate": "3/5/12, 10:34 PM",
      "commitName": "60e30f499e9318b2b18c3cbac4edc2bfcf6d6d66",
      "commitAuthor": "Tatu Saloranta",
      "diff": "@@ -0,0 +1,34 @@\n+protected Object deserializeWithObjectId(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException {\n+    final String idPropName \u003d _objectIdReader.propertyName;\n+    if (idPropName.equals(jp.getCurrentName())) {\n+        return deserializeFromObject(jp, ctxt);\n+    }\n+    TokenBuffer tmpBuffer \u003d new TokenBuffer(jp.getCodec());\n+    TokenBuffer mergedBuffer \u003d null;\n+    for (; jp.getCurrentToken() !\u003d JsonToken.END_OBJECT; jp.nextToken()) {\n+        String propName \u003d jp.getCurrentName();\n+        if (mergedBuffer \u003d\u003d null) {\n+            if (idPropName.equals(propName)) {\n+                mergedBuffer \u003d new TokenBuffer(jp.getCodec());\n+                mergedBuffer.writeFieldName(propName);\n+                jp.nextToken();\n+                mergedBuffer.copyCurrentStructure(jp);\n+                mergedBuffer.append(tmpBuffer);\n+                tmpBuffer \u003d null;\n+            } else {\n+                tmpBuffer.writeFieldName(propName);\n+                jp.nextToken();\n+                tmpBuffer.copyCurrentStructure(jp);\n+            }\n+        } else {\n+            mergedBuffer.writeFieldName(propName);\n+            jp.nextToken();\n+            mergedBuffer.copyCurrentStructure(jp);\n+        }\n+    }\n+    TokenBuffer buffer \u003d (mergedBuffer \u003d\u003d null) ? tmpBuffer : mergedBuffer;\n+    buffer.writeEndObject();\n+    JsonParser mergedParser \u003d buffer.asParser();\n+    mergedParser.nextToken();\n+    return deserializeFromObject(mergedParser, ctxt);\n+}\n\\ No newline at end of file\n",
      "actualSource": "protected Object deserializeWithObjectId(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException {\n    final String idPropName \u003d _objectIdReader.propertyName;\n    if (idPropName.equals(jp.getCurrentName())) {\n        return deserializeFromObject(jp, ctxt);\n    }\n    TokenBuffer tmpBuffer \u003d new TokenBuffer(jp.getCodec());\n    TokenBuffer mergedBuffer \u003d null;\n    for (; jp.getCurrentToken() !\u003d JsonToken.END_OBJECT; jp.nextToken()) {\n        String propName \u003d jp.getCurrentName();\n        if (mergedBuffer \u003d\u003d null) {\n            if (idPropName.equals(propName)) {\n                mergedBuffer \u003d new TokenBuffer(jp.getCodec());\n                mergedBuffer.writeFieldName(propName);\n                jp.nextToken();\n                mergedBuffer.copyCurrentStructure(jp);\n                mergedBuffer.append(tmpBuffer);\n                tmpBuffer \u003d null;\n            } else {\n                tmpBuffer.writeFieldName(propName);\n                jp.nextToken();\n                tmpBuffer.copyCurrentStructure(jp);\n            }\n        } else {\n            mergedBuffer.writeFieldName(propName);\n            jp.nextToken();\n            mergedBuffer.copyCurrentStructure(jp);\n        }\n    }\n    TokenBuffer buffer \u003d (mergedBuffer \u003d\u003d null) ? tmpBuffer : mergedBuffer;\n    buffer.writeEndObject();\n    JsonParser mergedParser \u003d buffer.asParser();\n    mergedParser.nextToken();\n    return deserializeFromObject(mergedParser, ctxt);\n}",
      "path": "src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializer.java",
      "functionStartLine": 324,
      "functionName": "deserializeWithObjectId",
      "functionAnnotation": "",
      "functionDoc": "Alternative deserialization method used when we expect to see Object Id;\nif so, we will need to ensure that the Id is seen before anything\nelse, to ensure that it is available for solving references,\neven if JSON itself is not ordered that way. This may require\nbuffering in some cases, but usually just a simple lookup to ensure\nthat ordering is correct.\n"
    }
  }
}