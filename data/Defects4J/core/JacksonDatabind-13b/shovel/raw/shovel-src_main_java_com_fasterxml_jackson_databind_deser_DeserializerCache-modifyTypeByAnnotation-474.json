{
  "origin": "codeshovel",
  "repositoryName": "JacksonDatabind-13b",
  "repositoryPath": "/tmp/JacksonDatabind-13b//.git",
  "startCommitName": "HEAD",
  "sourceFileName": "DeserializerCache.java",
  "functionName": "modifyTypeByAnnotation",
  "functionId": "modifyTypeByAnnotation___ctxt-DeserializationContext__a-Annotated__type-JavaType",
  "sourceFilePath": "src/main/java/com/fasterxml/jackson/databind/deser/DeserializerCache.java",
  "functionAnnotation": "",
  "functionDoc": "Method called to see if given method has annotations that indicate\na more specific type than what the argument specifies.\nIf annotations are present, they must specify compatible Class;\ninstance of which can be assigned using the method. This means\nthat the Class has to be raw class of type, or its sub-class\n(or, implementing class if original Class instance is an interface).\n\n@param a Method or field that the type is associated with\n@param type Type derived from the setter argument\n@return Original type if no annotations are present; or a more\n  specific type derived from it if type annotation(s) was found\n@throws JsonMappingException if invalid annotation is found\n",
  "functionStartLine": 474,
  "functionEndLine": 549,
  "numCommitsSeen": 85,
  "timeTaken": 2934,
  "changeHistory": [
    "82b474d51545919cb38a49485f56fd29d6ed199b",
    "060ce11a33baa8a1c951cb5b7a857d5d81db09ef",
    "d0bb3152ceec7c33c700d21454b34700968a526a",
    "c3a73d02ac74b9f0011b2fb8c5f4a764344a60ce",
    "2e5121ee9a521fe27e9caeaa91349183548a8820",
    "b37ff33bbc7885f21a208bee4f42126468f55d41",
    "bf355caa0821e58968df3bf6c12f612639224e47",
    "a03e0ebf5825d587230093436b6db53f368185a0",
    "d1e678e660f50c66113da7d03e4ffb52fef45fc0",
    "e4f23bb6779d434d88a7c4335f92d13ea639b373"
  ],
  "changeHistoryShort": {
    "82b474d51545919cb38a49485f56fd29d6ed199b": "Yfilerename",
    "060ce11a33baa8a1c951cb5b7a857d5d81db09ef": "Yfilerename",
    "d0bb3152ceec7c33c700d21454b34700968a526a": "Ybodychange",
    "c3a73d02ac74b9f0011b2fb8c5f4a764344a60ce": "Ymultichange(Yparameterchange,Ybodychange,Ydocchange)",
    "2e5121ee9a521fe27e9caeaa91349183548a8820": "Ybodychange",
    "b37ff33bbc7885f21a208bee4f42126468f55d41": "Ymultichange(Yparameterchange,Ybodychange,Ydocchange)",
    "bf355caa0821e58968df3bf6c12f612639224e47": "Ymultichange(Ymovefromfile,Yreturntypechange,Ymodifierchange,Ybodychange,Yannotationchange,Yparameterchange)",
    "a03e0ebf5825d587230093436b6db53f368185a0": "Ybodychange",
    "d1e678e660f50c66113da7d03e4ffb52fef45fc0": "Ymultichange(Ybodychange,Yannotationchange)",
    "e4f23bb6779d434d88a7c4335f92d13ea639b373": "Yintroduced"
  },
  "changeHistoryDetails": {
    "82b474d51545919cb38a49485f56fd29d6ed199b": {
      "type": "Yfilerename",
      "commitMessage": "Fix 3 unit test failures\n",
      "commitDate": "2/2/12, 5:33 PM",
      "commitName": "82b474d51545919cb38a49485f56fd29d6ed199b",
      "commitAuthor": "Tatu",
      "commitDateOld": "2/2/12, 1:00 PM",
      "commitNameOld": "69afdff1fac0fc4a472a0b04d5bc01df49a427c5",
      "commitAuthorOld": "Tatu",
      "daysBetweenCommits": 0.19,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "private JavaType modifyTypeByAnnotation(DeserializationContext ctxt, Annotated a, JavaType type) throws JsonMappingException {\n    AnnotationIntrospector intr \u003d ctxt.getAnnotationIntrospector();\n    Class\u003c?\u003e subclass \u003d intr.findDeserializationType(a, type);\n    if (subclass !\u003d null) {\n        try {\n            type \u003d type.narrowBy(subclass);\n        } catch (IllegalArgumentException iae) {\n            throw new JsonMappingException(\"Failed to narrow type \" + type + \" with concrete-type annotation (value \" + subclass.getName() + \"), method \u0027\" + a.getName() + \"\u0027: \" + iae.getMessage(), null, iae);\n        }\n    }\n    if (type.isContainerType()) {\n        Class\u003c?\u003e keyClass \u003d intr.findDeserializationKeyType(a, type.getKeyType());\n        if (keyClass !\u003d null) {\n            if (!(type instanceof MapLikeType)) {\n                throw new JsonMappingException(\"Illegal key-type annotation: type \" + type + \" is not a Map(-like) type\");\n            }\n            try {\n                type \u003d ((MapLikeType) type).narrowKey(keyClass);\n            } catch (IllegalArgumentException iae) {\n                throw new JsonMappingException(\"Failed to narrow key type \" + type + \" with key-type annotation (\" + keyClass.getName() + \"): \" + iae.getMessage(), null, iae);\n            }\n        }\n        JavaType keyType \u003d type.getKeyType();\n        if (keyType !\u003d null \u0026\u0026 keyType.getValueHandler() \u003d\u003d null) {\n            Object kdDef \u003d intr.findKeyDeserializer(a);\n            if (kdDef !\u003d null) {\n                KeyDeserializer kd \u003d ctxt.keyDeserializerInstance(a, kdDef);\n                if (kd !\u003d null) {\n                    type \u003d ((MapLikeType) type).withKeyValueHandler(kd);\n                    keyType \u003d type.getKeyType();\n                }\n            }\n        }\n        Class\u003c?\u003e cc \u003d intr.findDeserializationContentType(a, type.getContentType());\n        if (cc !\u003d null) {\n            try {\n                type \u003d type.narrowContentsBy(cc);\n            } catch (IllegalArgumentException iae) {\n                throw new JsonMappingException(\"Failed to narrow content type \" + type + \" with content-type annotation (\" + cc.getName() + \"): \" + iae.getMessage(), null, iae);\n            }\n        }\n        JavaType contentType \u003d type.getContentType();\n        if (contentType.getValueHandler() \u003d\u003d null) {\n            Object cdDef \u003d intr.findContentDeserializer(a);\n            if (cdDef !\u003d null) {\n                JsonDeserializer\u003c?\u003e cd \u003d null;\n                if (cdDef instanceof JsonDeserializer\u003c?\u003e) {\n                    cdDef \u003d (JsonDeserializer\u003c?\u003e) cdDef;\n                } else {\n                    Class\u003c?\u003e cdClass \u003d _verifyAsClass(cdDef, \"findContentDeserializer\", JsonDeserializer.None.class);\n                    if (cdClass !\u003d null) {\n                        cd \u003d ctxt.deserializerInstance(a, cdClass);\n                    }\n                }\n                if (cd !\u003d null) {\n                    type \u003d type.withContentValueHandler(cd);\n                }\n            }\n        }\n    }\n    return type;\n}",
      "path": "src/main/java/com/fasterxml/jackson/databind/deser/DeserializerCache.java",
      "functionStartLine": 395,
      "functionName": "modifyTypeByAnnotation",
      "functionAnnotation": "",
      "functionDoc": "Method called to see if given method has annotations that indicate\na more specific type than what the argument specifies.\nIf annotations are present, they must specify compatible Class;\ninstance of which can be assigned using the method. This means\nthat the Class has to be raw class of type, or its sub-class\n(or, implementing class if original Class instance is an interface).\n\n@param a Method or field that the type is associated with\n@param type Type derived from the setter argument\n@return Original type if no annotations are present; or a more\n  specific type derived from it if type annotation(s) was found\n@throws JsonMappingException if invalid annotation is found\n",
      "diff": "",
      "extendedDetails": {
        "oldPath": "src/main/java/com/fasterxml/jackson/databind/deser/impl/DeserializerCache.java",
        "newPath": "src/main/java/com/fasterxml/jackson/databind/deser/DeserializerCache.java"
      }
    },
    "060ce11a33baa8a1c951cb5b7a857d5d81db09ef": {
      "type": "Yfilerename",
      "commitMessage": "Implemented [JACKSON-776], refactoring of DeserializationContext\n",
      "commitDate": "2/1/12, 10:18 PM",
      "commitName": "060ce11a33baa8a1c951cb5b7a857d5d81db09ef",
      "commitAuthor": "Tatu Saloranta",
      "commitDateOld": "2/1/12, 8:01 PM",
      "commitNameOld": "334892f4c5c0f346248eb6ebae306330e6512d93",
      "commitAuthorOld": "Tatu Saloranta",
      "daysBetweenCommits": 0.09,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "private JavaType modifyTypeByAnnotation(DeserializationContext ctxt, Annotated a, JavaType type) throws JsonMappingException {\n    AnnotationIntrospector intr \u003d ctxt.getAnnotationIntrospector();\n    Class\u003c?\u003e subclass \u003d intr.findDeserializationType(a, type);\n    if (subclass !\u003d null) {\n        try {\n            type \u003d type.narrowBy(subclass);\n        } catch (IllegalArgumentException iae) {\n            throw new JsonMappingException(\"Failed to narrow type \" + type + \" with concrete-type annotation (value \" + subclass.getName() + \"), method \u0027\" + a.getName() + \"\u0027: \" + iae.getMessage(), null, iae);\n        }\n    }\n    if (type.isContainerType()) {\n        Class\u003c?\u003e keyClass \u003d intr.findDeserializationKeyType(a, type.getKeyType());\n        if (keyClass !\u003d null) {\n            if (!(type instanceof MapLikeType)) {\n                throw new JsonMappingException(\"Illegal key-type annotation: type \" + type + \" is not a Map(-like) type\");\n            }\n            try {\n                type \u003d ((MapLikeType) type).narrowKey(keyClass);\n            } catch (IllegalArgumentException iae) {\n                throw new JsonMappingException(\"Failed to narrow key type \" + type + \" with key-type annotation (\" + keyClass.getName() + \"): \" + iae.getMessage(), null, iae);\n            }\n        }\n        JavaType keyType \u003d type.getKeyType();\n        if (keyType !\u003d null \u0026\u0026 keyType.getValueHandler() \u003d\u003d null) {\n            Object kdDef \u003d intr.findKeyDeserializer(a);\n            if (kdDef !\u003d null) {\n                KeyDeserializer kd \u003d ctxt.keyDeserializerInstance(a, kdDef);\n                if (kd !\u003d null) {\n                    type \u003d ((MapLikeType) type).withKeyValueHandler(kd);\n                    keyType \u003d type.getKeyType();\n                }\n            }\n        }\n        Class\u003c?\u003e cc \u003d intr.findDeserializationContentType(a, type.getContentType());\n        if (cc !\u003d null) {\n            try {\n                type \u003d type.narrowContentsBy(cc);\n            } catch (IllegalArgumentException iae) {\n                throw new JsonMappingException(\"Failed to narrow content type \" + type + \" with content-type annotation (\" + cc.getName() + \"): \" + iae.getMessage(), null, iae);\n            }\n        }\n        JavaType contentType \u003d type.getContentType();\n        if (contentType.getValueHandler() \u003d\u003d null) {\n            Object cdDef \u003d intr.findContentDeserializer(a);\n            if (cdDef !\u003d null) {\n                JsonDeserializer\u003c?\u003e cd \u003d null;\n                if (cdDef instanceof JsonDeserializer\u003c?\u003e) {\n                    cdDef \u003d (JsonDeserializer\u003c?\u003e) cdDef;\n                } else {\n                    Class\u003c?\u003e cdClass \u003d _verifyAsClass(cdDef, \"findContentDeserializer\", JsonDeserializer.None.class);\n                    if (cdClass !\u003d null) {\n                        cd \u003d ctxt.deserializerInstance(a, cdClass);\n                    }\n                }\n                if (cd !\u003d null) {\n                    type \u003d type.withContentValueHandler(cd);\n                }\n            }\n        }\n    }\n    return type;\n}",
      "path": "src/main/java/com/fasterxml/jackson/databind/deser/impl/DeserializerCache.java",
      "functionStartLine": 397,
      "functionName": "modifyTypeByAnnotation",
      "functionAnnotation": "",
      "functionDoc": "Method called to see if given method has annotations that indicate\na more specific type than what the argument specifies.\nIf annotations are present, they must specify compatible Class;\ninstance of which can be assigned using the method. This means\nthat the Class has to be raw class of type, or its sub-class\n(or, implementing class if original Class instance is an interface).\n\n@param a Method or field that the type is associated with\n@param type Type derived from the setter argument\n@return Original type if no annotations are present; or a more\n  specific type derived from it if type annotation(s) was found\n@throws JsonMappingException if invalid annotation is found\n",
      "diff": "",
      "extendedDetails": {
        "oldPath": "src/main/java/com/fasterxml/jackson/databind/deser/DeserializerCache.java",
        "newPath": "src/main/java/com/fasterxml/jackson/databind/deser/impl/DeserializerCache.java"
      }
    },
    "d0bb3152ceec7c33c700d21454b34700968a526a": {
      "type": "Ybodychange",
      "commitMessage": "Removing BeanProperty from TypeDeserializer handling as well\n",
      "commitDate": "1/31/12, 1:04 PM",
      "commitName": "d0bb3152ceec7c33c700d21454b34700968a526a",
      "commitAuthor": "Tatu",
      "commitDateOld": "1/31/12, 12:45 PM",
      "commitNameOld": "c3a73d02ac74b9f0011b2fb8c5f4a764344a60ce",
      "commitAuthorOld": "Tatu",
      "daysBetweenCommits": 0.01,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "private JavaType modifyTypeByAnnotation(DeserializationContext ctxt, Annotated a, JavaType type) throws JsonMappingException {\n    AnnotationIntrospector intr \u003d ctxt.getAnnotationIntrospector();\n    Class\u003c?\u003e subclass \u003d intr.findDeserializationType(a, type);\n    if (subclass !\u003d null) {\n        try {\n            type \u003d type.narrowBy(subclass);\n        } catch (IllegalArgumentException iae) {\n            throw new JsonMappingException(\"Failed to narrow type \" + type + \" with concrete-type annotation (value \" + subclass.getName() + \"), method \u0027\" + a.getName() + \"\u0027: \" + iae.getMessage(), null, iae);\n        }\n    }\n    if (type.isContainerType()) {\n        Class\u003c?\u003e keyClass \u003d intr.findDeserializationKeyType(a, type.getKeyType());\n        if (keyClass !\u003d null) {\n            if (!(type instanceof MapLikeType)) {\n                throw new JsonMappingException(\"Illegal key-type annotation: type \" + type + \" is not a Map(-like) type\");\n            }\n            try {\n                type \u003d ((MapLikeType) type).narrowKey(keyClass);\n            } catch (IllegalArgumentException iae) {\n                throw new JsonMappingException(\"Failed to narrow key type \" + type + \" with key-type annotation (\" + keyClass.getName() + \"): \" + iae.getMessage(), null, iae);\n            }\n        }\n        JavaType keyType \u003d type.getKeyType();\n        if (keyType !\u003d null \u0026\u0026 keyType.getValueHandler() \u003d\u003d null) {\n            Object kdDef \u003d intr.findKeyDeserializer(a);\n            if (kdDef !\u003d null) {\n                KeyDeserializer kd \u003d ctxt.keyDeserializerInstance(a, kdDef);\n                if (kd !\u003d null) {\n                    type \u003d ((MapLikeType) type).withKeyValueHandler(kd);\n                    keyType \u003d type.getKeyType();\n                }\n            }\n        }\n        Class\u003c?\u003e cc \u003d intr.findDeserializationContentType(a, type.getContentType());\n        if (cc !\u003d null) {\n            try {\n                type \u003d type.narrowContentsBy(cc);\n            } catch (IllegalArgumentException iae) {\n                throw new JsonMappingException(\"Failed to narrow content type \" + type + \" with content-type annotation (\" + cc.getName() + \"): \" + iae.getMessage(), null, iae);\n            }\n        }\n        JavaType contentType \u003d type.getContentType();\n        if (contentType.getValueHandler() \u003d\u003d null) {\n            Object cdDef \u003d intr.findContentDeserializer(a);\n            if (cdDef !\u003d null) {\n                JsonDeserializer\u003c?\u003e cd \u003d null;\n                if (cdDef instanceof JsonDeserializer\u003c?\u003e) {\n                    cdDef \u003d (JsonDeserializer\u003c?\u003e) cdDef;\n                } else {\n                    Class\u003c?\u003e cdClass \u003d _verifyAsClass(cdDef, \"findContentDeserializer\", JsonDeserializer.None.class);\n                    if (cdClass !\u003d null) {\n                        cd \u003d ctxt.deserializerInstance(a, cdClass);\n                    }\n                }\n                if (cd !\u003d null) {\n                    type \u003d type.withContentValueHandler(cd);\n                }\n            }\n        }\n    }\n    return type;\n}",
      "path": "src/main/java/com/fasterxml/jackson/databind/deser/DeserializerCache.java",
      "functionStartLine": 455,
      "functionName": "modifyTypeByAnnotation",
      "functionAnnotation": "",
      "functionDoc": "Method called to see if given method has annotations that indicate\na more specific type than what the argument specifies.\nIf annotations are present, they must specify compatible Class;\ninstance of which can be assigned using the method. This means\nthat the Class has to be raw class of type, or its sub-class\n(or, implementing class if original Class instance is an interface).\n\n@param a Method or field that the type is associated with\n@param type Type derived from the setter argument\n@return Original type if no annotations are present; or a more\n  specific type derived from it if type annotation(s) was found\n@throws JsonMappingException if invalid annotation is found\n",
      "diff": "@@ -1,62 +1,62 @@\n private JavaType modifyTypeByAnnotation(DeserializationContext ctxt, Annotated a, JavaType type) throws JsonMappingException {\n     AnnotationIntrospector intr \u003d ctxt.getAnnotationIntrospector();\n     Class\u003c?\u003e subclass \u003d intr.findDeserializationType(a, type);\n     if (subclass !\u003d null) {\n         try {\n             type \u003d type.narrowBy(subclass);\n         } catch (IllegalArgumentException iae) {\n             throw new JsonMappingException(\"Failed to narrow type \" + type + \" with concrete-type annotation (value \" + subclass.getName() + \"), method \u0027\" + a.getName() + \"\u0027: \" + iae.getMessage(), null, iae);\n         }\n     }\n     if (type.isContainerType()) {\n         Class\u003c?\u003e keyClass \u003d intr.findDeserializationKeyType(a, type.getKeyType());\n         if (keyClass !\u003d null) {\n             if (!(type instanceof MapLikeType)) {\n                 throw new JsonMappingException(\"Illegal key-type annotation: type \" + type + \" is not a Map(-like) type\");\n             }\n             try {\n                 type \u003d ((MapLikeType) type).narrowKey(keyClass);\n             } catch (IllegalArgumentException iae) {\n                 throw new JsonMappingException(\"Failed to narrow key type \" + type + \" with key-type annotation (\" + keyClass.getName() + \"): \" + iae.getMessage(), null, iae);\n             }\n         }\n         JavaType keyType \u003d type.getKeyType();\n         if (keyType !\u003d null \u0026\u0026 keyType.getValueHandler() \u003d\u003d null) {\n             Object kdDef \u003d intr.findKeyDeserializer(a);\n             if (kdDef !\u003d null) {\n-                KeyDeserializer kd \u003d ctxt.keyDeserializerInstance(a, null, kdDef);\n+                KeyDeserializer kd \u003d ctxt.keyDeserializerInstance(a, kdDef);\n                 if (kd !\u003d null) {\n                     type \u003d ((MapLikeType) type).withKeyValueHandler(kd);\n                     keyType \u003d type.getKeyType();\n                 }\n             }\n         }\n         Class\u003c?\u003e cc \u003d intr.findDeserializationContentType(a, type.getContentType());\n         if (cc !\u003d null) {\n             try {\n                 type \u003d type.narrowContentsBy(cc);\n             } catch (IllegalArgumentException iae) {\n                 throw new JsonMappingException(\"Failed to narrow content type \" + type + \" with content-type annotation (\" + cc.getName() + \"): \" + iae.getMessage(), null, iae);\n             }\n         }\n         JavaType contentType \u003d type.getContentType();\n         if (contentType.getValueHandler() \u003d\u003d null) {\n             Object cdDef \u003d intr.findContentDeserializer(a);\n             if (cdDef !\u003d null) {\n                 JsonDeserializer\u003c?\u003e cd \u003d null;\n                 if (cdDef instanceof JsonDeserializer\u003c?\u003e) {\n                     cdDef \u003d (JsonDeserializer\u003c?\u003e) cdDef;\n                 } else {\n                     Class\u003c?\u003e cdClass \u003d _verifyAsClass(cdDef, \"findContentDeserializer\", JsonDeserializer.None.class);\n                     if (cdClass !\u003d null) {\n                         cd \u003d ctxt.deserializerInstance(a, cdClass);\n                     }\n                 }\n                 if (cd !\u003d null) {\n                     type \u003d type.withContentValueHandler(cd);\n                 }\n             }\n         }\n     }\n     return type;\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "c3a73d02ac74b9f0011b2fb8c5f4a764344a60ce": {
      "type": "Ymultichange(Yparameterchange,Ybodychange,Ydocchange)",
      "commitMessage": "More elimination of BeanProperty passing, getting close: one new (transient) unit test failure to fix\n",
      "commitDate": "1/31/12, 12:45 PM",
      "commitName": "c3a73d02ac74b9f0011b2fb8c5f4a764344a60ce",
      "commitAuthor": "Tatu",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "More elimination of BeanProperty passing, getting close: one new (transient) unit test failure to fix\n",
          "commitDate": "1/31/12, 12:45 PM",
          "commitName": "c3a73d02ac74b9f0011b2fb8c5f4a764344a60ce",
          "commitAuthor": "Tatu",
          "commitDateOld": "1/30/12, 10:13 PM",
          "commitNameOld": "49b712169c432100297164f6b5102f3578bd636c",
          "commitAuthorOld": "Tatu Saloranta",
          "daysBetweenCommits": 0.61,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "actualSource": "private JavaType modifyTypeByAnnotation(DeserializationContext ctxt, Annotated a, JavaType type) throws JsonMappingException {\n    AnnotationIntrospector intr \u003d ctxt.getAnnotationIntrospector();\n    Class\u003c?\u003e subclass \u003d intr.findDeserializationType(a, type);\n    if (subclass !\u003d null) {\n        try {\n            type \u003d type.narrowBy(subclass);\n        } catch (IllegalArgumentException iae) {\n            throw new JsonMappingException(\"Failed to narrow type \" + type + \" with concrete-type annotation (value \" + subclass.getName() + \"), method \u0027\" + a.getName() + \"\u0027: \" + iae.getMessage(), null, iae);\n        }\n    }\n    if (type.isContainerType()) {\n        Class\u003c?\u003e keyClass \u003d intr.findDeserializationKeyType(a, type.getKeyType());\n        if (keyClass !\u003d null) {\n            if (!(type instanceof MapLikeType)) {\n                throw new JsonMappingException(\"Illegal key-type annotation: type \" + type + \" is not a Map(-like) type\");\n            }\n            try {\n                type \u003d ((MapLikeType) type).narrowKey(keyClass);\n            } catch (IllegalArgumentException iae) {\n                throw new JsonMappingException(\"Failed to narrow key type \" + type + \" with key-type annotation (\" + keyClass.getName() + \"): \" + iae.getMessage(), null, iae);\n            }\n        }\n        JavaType keyType \u003d type.getKeyType();\n        if (keyType !\u003d null \u0026\u0026 keyType.getValueHandler() \u003d\u003d null) {\n            Object kdDef \u003d intr.findKeyDeserializer(a);\n            if (kdDef !\u003d null) {\n                KeyDeserializer kd \u003d ctxt.keyDeserializerInstance(a, null, kdDef);\n                if (kd !\u003d null) {\n                    type \u003d ((MapLikeType) type).withKeyValueHandler(kd);\n                    keyType \u003d type.getKeyType();\n                }\n            }\n        }\n        Class\u003c?\u003e cc \u003d intr.findDeserializationContentType(a, type.getContentType());\n        if (cc !\u003d null) {\n            try {\n                type \u003d type.narrowContentsBy(cc);\n            } catch (IllegalArgumentException iae) {\n                throw new JsonMappingException(\"Failed to narrow content type \" + type + \" with content-type annotation (\" + cc.getName() + \"): \" + iae.getMessage(), null, iae);\n            }\n        }\n        JavaType contentType \u003d type.getContentType();\n        if (contentType.getValueHandler() \u003d\u003d null) {\n            Object cdDef \u003d intr.findContentDeserializer(a);\n            if (cdDef !\u003d null) {\n                JsonDeserializer\u003c?\u003e cd \u003d null;\n                if (cdDef instanceof JsonDeserializer\u003c?\u003e) {\n                    cdDef \u003d (JsonDeserializer\u003c?\u003e) cdDef;\n                } else {\n                    Class\u003c?\u003e cdClass \u003d _verifyAsClass(cdDef, \"findContentDeserializer\", JsonDeserializer.None.class);\n                    if (cdClass !\u003d null) {\n                        cd \u003d ctxt.deserializerInstance(a, cdClass);\n                    }\n                }\n                if (cd !\u003d null) {\n                    type \u003d type.withContentValueHandler(cd);\n                }\n            }\n        }\n    }\n    return type;\n}",
          "path": "src/main/java/com/fasterxml/jackson/databind/deser/DeserializerCache.java",
          "functionStartLine": 459,
          "functionName": "modifyTypeByAnnotation",
          "functionAnnotation": "",
          "functionDoc": "Method called to see if given method has annotations that indicate\na more specific type than what the argument specifies.\nIf annotations are present, they must specify compatible Class;\ninstance of which can be assigned using the method. This means\nthat the Class has to be raw class of type, or its sub-class\n(or, implementing class if original Class instance is an interface).\n\n@param a Method or field that the type is associated with\n@param type Type derived from the setter argument\n@return Original type if no annotations are present; or a more\n  specific type derived from it if type annotation(s) was found\n@throws JsonMappingException if invalid annotation is found\n",
          "diff": "@@ -1,62 +1,62 @@\n-private JavaType modifyTypeByAnnotation(DeserializationContext ctxt, Annotated a, JavaType type, BeanProperty prop) throws JsonMappingException {\n+private JavaType modifyTypeByAnnotation(DeserializationContext ctxt, Annotated a, JavaType type) throws JsonMappingException {\n     AnnotationIntrospector intr \u003d ctxt.getAnnotationIntrospector();\n     Class\u003c?\u003e subclass \u003d intr.findDeserializationType(a, type);\n     if (subclass !\u003d null) {\n         try {\n             type \u003d type.narrowBy(subclass);\n         } catch (IllegalArgumentException iae) {\n             throw new JsonMappingException(\"Failed to narrow type \" + type + \" with concrete-type annotation (value \" + subclass.getName() + \"), method \u0027\" + a.getName() + \"\u0027: \" + iae.getMessage(), null, iae);\n         }\n     }\n     if (type.isContainerType()) {\n         Class\u003c?\u003e keyClass \u003d intr.findDeserializationKeyType(a, type.getKeyType());\n         if (keyClass !\u003d null) {\n             if (!(type instanceof MapLikeType)) {\n                 throw new JsonMappingException(\"Illegal key-type annotation: type \" + type + \" is not a Map(-like) type\");\n             }\n             try {\n                 type \u003d ((MapLikeType) type).narrowKey(keyClass);\n             } catch (IllegalArgumentException iae) {\n                 throw new JsonMappingException(\"Failed to narrow key type \" + type + \" with key-type annotation (\" + keyClass.getName() + \"): \" + iae.getMessage(), null, iae);\n             }\n         }\n         JavaType keyType \u003d type.getKeyType();\n         if (keyType !\u003d null \u0026\u0026 keyType.getValueHandler() \u003d\u003d null) {\n             Object kdDef \u003d intr.findKeyDeserializer(a);\n             if (kdDef !\u003d null) {\n-                KeyDeserializer kd \u003d ctxt.keyDeserializerInstance(a, prop, kdDef);\n+                KeyDeserializer kd \u003d ctxt.keyDeserializerInstance(a, null, kdDef);\n                 if (kd !\u003d null) {\n                     type \u003d ((MapLikeType) type).withKeyValueHandler(kd);\n                     keyType \u003d type.getKeyType();\n                 }\n             }\n         }\n         Class\u003c?\u003e cc \u003d intr.findDeserializationContentType(a, type.getContentType());\n         if (cc !\u003d null) {\n             try {\n                 type \u003d type.narrowContentsBy(cc);\n             } catch (IllegalArgumentException iae) {\n                 throw new JsonMappingException(\"Failed to narrow content type \" + type + \" with content-type annotation (\" + cc.getName() + \"): \" + iae.getMessage(), null, iae);\n             }\n         }\n         JavaType contentType \u003d type.getContentType();\n         if (contentType.getValueHandler() \u003d\u003d null) {\n             Object cdDef \u003d intr.findContentDeserializer(a);\n             if (cdDef !\u003d null) {\n                 JsonDeserializer\u003c?\u003e cd \u003d null;\n                 if (cdDef instanceof JsonDeserializer\u003c?\u003e) {\n                     cdDef \u003d (JsonDeserializer\u003c?\u003e) cdDef;\n                 } else {\n                     Class\u003c?\u003e cdClass \u003d _verifyAsClass(cdDef, \"findContentDeserializer\", JsonDeserializer.None.class);\n                     if (cdClass !\u003d null) {\n-                        cd \u003d ctxt.deserializerInstance(a, prop, cdClass);\n+                        cd \u003d ctxt.deserializerInstance(a, cdClass);\n                     }\n                 }\n                 if (cd !\u003d null) {\n                     type \u003d type.withContentValueHandler(cd);\n                 }\n             }\n         }\n     }\n     return type;\n }\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldValue": "[ctxt-DeserializationContext, a-Annotated, type-JavaType, prop-BeanProperty]",
            "newValue": "[ctxt-DeserializationContext, a-Annotated, type-JavaType]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "More elimination of BeanProperty passing, getting close: one new (transient) unit test failure to fix\n",
          "commitDate": "1/31/12, 12:45 PM",
          "commitName": "c3a73d02ac74b9f0011b2fb8c5f4a764344a60ce",
          "commitAuthor": "Tatu",
          "commitDateOld": "1/30/12, 10:13 PM",
          "commitNameOld": "49b712169c432100297164f6b5102f3578bd636c",
          "commitAuthorOld": "Tatu Saloranta",
          "daysBetweenCommits": 0.61,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "actualSource": "private JavaType modifyTypeByAnnotation(DeserializationContext ctxt, Annotated a, JavaType type) throws JsonMappingException {\n    AnnotationIntrospector intr \u003d ctxt.getAnnotationIntrospector();\n    Class\u003c?\u003e subclass \u003d intr.findDeserializationType(a, type);\n    if (subclass !\u003d null) {\n        try {\n            type \u003d type.narrowBy(subclass);\n        } catch (IllegalArgumentException iae) {\n            throw new JsonMappingException(\"Failed to narrow type \" + type + \" with concrete-type annotation (value \" + subclass.getName() + \"), method \u0027\" + a.getName() + \"\u0027: \" + iae.getMessage(), null, iae);\n        }\n    }\n    if (type.isContainerType()) {\n        Class\u003c?\u003e keyClass \u003d intr.findDeserializationKeyType(a, type.getKeyType());\n        if (keyClass !\u003d null) {\n            if (!(type instanceof MapLikeType)) {\n                throw new JsonMappingException(\"Illegal key-type annotation: type \" + type + \" is not a Map(-like) type\");\n            }\n            try {\n                type \u003d ((MapLikeType) type).narrowKey(keyClass);\n            } catch (IllegalArgumentException iae) {\n                throw new JsonMappingException(\"Failed to narrow key type \" + type + \" with key-type annotation (\" + keyClass.getName() + \"): \" + iae.getMessage(), null, iae);\n            }\n        }\n        JavaType keyType \u003d type.getKeyType();\n        if (keyType !\u003d null \u0026\u0026 keyType.getValueHandler() \u003d\u003d null) {\n            Object kdDef \u003d intr.findKeyDeserializer(a);\n            if (kdDef !\u003d null) {\n                KeyDeserializer kd \u003d ctxt.keyDeserializerInstance(a, null, kdDef);\n                if (kd !\u003d null) {\n                    type \u003d ((MapLikeType) type).withKeyValueHandler(kd);\n                    keyType \u003d type.getKeyType();\n                }\n            }\n        }\n        Class\u003c?\u003e cc \u003d intr.findDeserializationContentType(a, type.getContentType());\n        if (cc !\u003d null) {\n            try {\n                type \u003d type.narrowContentsBy(cc);\n            } catch (IllegalArgumentException iae) {\n                throw new JsonMappingException(\"Failed to narrow content type \" + type + \" with content-type annotation (\" + cc.getName() + \"): \" + iae.getMessage(), null, iae);\n            }\n        }\n        JavaType contentType \u003d type.getContentType();\n        if (contentType.getValueHandler() \u003d\u003d null) {\n            Object cdDef \u003d intr.findContentDeserializer(a);\n            if (cdDef !\u003d null) {\n                JsonDeserializer\u003c?\u003e cd \u003d null;\n                if (cdDef instanceof JsonDeserializer\u003c?\u003e) {\n                    cdDef \u003d (JsonDeserializer\u003c?\u003e) cdDef;\n                } else {\n                    Class\u003c?\u003e cdClass \u003d _verifyAsClass(cdDef, \"findContentDeserializer\", JsonDeserializer.None.class);\n                    if (cdClass !\u003d null) {\n                        cd \u003d ctxt.deserializerInstance(a, cdClass);\n                    }\n                }\n                if (cd !\u003d null) {\n                    type \u003d type.withContentValueHandler(cd);\n                }\n            }\n        }\n    }\n    return type;\n}",
          "path": "src/main/java/com/fasterxml/jackson/databind/deser/DeserializerCache.java",
          "functionStartLine": 459,
          "functionName": "modifyTypeByAnnotation",
          "functionAnnotation": "",
          "functionDoc": "Method called to see if given method has annotations that indicate\na more specific type than what the argument specifies.\nIf annotations are present, they must specify compatible Class;\ninstance of which can be assigned using the method. This means\nthat the Class has to be raw class of type, or its sub-class\n(or, implementing class if original Class instance is an interface).\n\n@param a Method or field that the type is associated with\n@param type Type derived from the setter argument\n@return Original type if no annotations are present; or a more\n  specific type derived from it if type annotation(s) was found\n@throws JsonMappingException if invalid annotation is found\n",
          "diff": "@@ -1,62 +1,62 @@\n-private JavaType modifyTypeByAnnotation(DeserializationContext ctxt, Annotated a, JavaType type, BeanProperty prop) throws JsonMappingException {\n+private JavaType modifyTypeByAnnotation(DeserializationContext ctxt, Annotated a, JavaType type) throws JsonMappingException {\n     AnnotationIntrospector intr \u003d ctxt.getAnnotationIntrospector();\n     Class\u003c?\u003e subclass \u003d intr.findDeserializationType(a, type);\n     if (subclass !\u003d null) {\n         try {\n             type \u003d type.narrowBy(subclass);\n         } catch (IllegalArgumentException iae) {\n             throw new JsonMappingException(\"Failed to narrow type \" + type + \" with concrete-type annotation (value \" + subclass.getName() + \"), method \u0027\" + a.getName() + \"\u0027: \" + iae.getMessage(), null, iae);\n         }\n     }\n     if (type.isContainerType()) {\n         Class\u003c?\u003e keyClass \u003d intr.findDeserializationKeyType(a, type.getKeyType());\n         if (keyClass !\u003d null) {\n             if (!(type instanceof MapLikeType)) {\n                 throw new JsonMappingException(\"Illegal key-type annotation: type \" + type + \" is not a Map(-like) type\");\n             }\n             try {\n                 type \u003d ((MapLikeType) type).narrowKey(keyClass);\n             } catch (IllegalArgumentException iae) {\n                 throw new JsonMappingException(\"Failed to narrow key type \" + type + \" with key-type annotation (\" + keyClass.getName() + \"): \" + iae.getMessage(), null, iae);\n             }\n         }\n         JavaType keyType \u003d type.getKeyType();\n         if (keyType !\u003d null \u0026\u0026 keyType.getValueHandler() \u003d\u003d null) {\n             Object kdDef \u003d intr.findKeyDeserializer(a);\n             if (kdDef !\u003d null) {\n-                KeyDeserializer kd \u003d ctxt.keyDeserializerInstance(a, prop, kdDef);\n+                KeyDeserializer kd \u003d ctxt.keyDeserializerInstance(a, null, kdDef);\n                 if (kd !\u003d null) {\n                     type \u003d ((MapLikeType) type).withKeyValueHandler(kd);\n                     keyType \u003d type.getKeyType();\n                 }\n             }\n         }\n         Class\u003c?\u003e cc \u003d intr.findDeserializationContentType(a, type.getContentType());\n         if (cc !\u003d null) {\n             try {\n                 type \u003d type.narrowContentsBy(cc);\n             } catch (IllegalArgumentException iae) {\n                 throw new JsonMappingException(\"Failed to narrow content type \" + type + \" with content-type annotation (\" + cc.getName() + \"): \" + iae.getMessage(), null, iae);\n             }\n         }\n         JavaType contentType \u003d type.getContentType();\n         if (contentType.getValueHandler() \u003d\u003d null) {\n             Object cdDef \u003d intr.findContentDeserializer(a);\n             if (cdDef !\u003d null) {\n                 JsonDeserializer\u003c?\u003e cd \u003d null;\n                 if (cdDef instanceof JsonDeserializer\u003c?\u003e) {\n                     cdDef \u003d (JsonDeserializer\u003c?\u003e) cdDef;\n                 } else {\n                     Class\u003c?\u003e cdClass \u003d _verifyAsClass(cdDef, \"findContentDeserializer\", JsonDeserializer.None.class);\n                     if (cdClass !\u003d null) {\n-                        cd \u003d ctxt.deserializerInstance(a, prop, cdClass);\n+                        cd \u003d ctxt.deserializerInstance(a, cdClass);\n                     }\n                 }\n                 if (cd !\u003d null) {\n                     type \u003d type.withContentValueHandler(cd);\n                 }\n             }\n         }\n     }\n     return type;\n }\n\\ No newline at end of file\n",
          "extendedDetails": {}
        },
        {
          "type": "Ydocchange",
          "commitMessage": "More elimination of BeanProperty passing, getting close: one new (transient) unit test failure to fix\n",
          "commitDate": "1/31/12, 12:45 PM",
          "commitName": "c3a73d02ac74b9f0011b2fb8c5f4a764344a60ce",
          "commitAuthor": "Tatu",
          "commitDateOld": "1/30/12, 10:13 PM",
          "commitNameOld": "49b712169c432100297164f6b5102f3578bd636c",
          "commitAuthorOld": "Tatu Saloranta",
          "daysBetweenCommits": 0.61,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "actualSource": "private JavaType modifyTypeByAnnotation(DeserializationContext ctxt, Annotated a, JavaType type) throws JsonMappingException {\n    AnnotationIntrospector intr \u003d ctxt.getAnnotationIntrospector();\n    Class\u003c?\u003e subclass \u003d intr.findDeserializationType(a, type);\n    if (subclass !\u003d null) {\n        try {\n            type \u003d type.narrowBy(subclass);\n        } catch (IllegalArgumentException iae) {\n            throw new JsonMappingException(\"Failed to narrow type \" + type + \" with concrete-type annotation (value \" + subclass.getName() + \"), method \u0027\" + a.getName() + \"\u0027: \" + iae.getMessage(), null, iae);\n        }\n    }\n    if (type.isContainerType()) {\n        Class\u003c?\u003e keyClass \u003d intr.findDeserializationKeyType(a, type.getKeyType());\n        if (keyClass !\u003d null) {\n            if (!(type instanceof MapLikeType)) {\n                throw new JsonMappingException(\"Illegal key-type annotation: type \" + type + \" is not a Map(-like) type\");\n            }\n            try {\n                type \u003d ((MapLikeType) type).narrowKey(keyClass);\n            } catch (IllegalArgumentException iae) {\n                throw new JsonMappingException(\"Failed to narrow key type \" + type + \" with key-type annotation (\" + keyClass.getName() + \"): \" + iae.getMessage(), null, iae);\n            }\n        }\n        JavaType keyType \u003d type.getKeyType();\n        if (keyType !\u003d null \u0026\u0026 keyType.getValueHandler() \u003d\u003d null) {\n            Object kdDef \u003d intr.findKeyDeserializer(a);\n            if (kdDef !\u003d null) {\n                KeyDeserializer kd \u003d ctxt.keyDeserializerInstance(a, null, kdDef);\n                if (kd !\u003d null) {\n                    type \u003d ((MapLikeType) type).withKeyValueHandler(kd);\n                    keyType \u003d type.getKeyType();\n                }\n            }\n        }\n        Class\u003c?\u003e cc \u003d intr.findDeserializationContentType(a, type.getContentType());\n        if (cc !\u003d null) {\n            try {\n                type \u003d type.narrowContentsBy(cc);\n            } catch (IllegalArgumentException iae) {\n                throw new JsonMappingException(\"Failed to narrow content type \" + type + \" with content-type annotation (\" + cc.getName() + \"): \" + iae.getMessage(), null, iae);\n            }\n        }\n        JavaType contentType \u003d type.getContentType();\n        if (contentType.getValueHandler() \u003d\u003d null) {\n            Object cdDef \u003d intr.findContentDeserializer(a);\n            if (cdDef !\u003d null) {\n                JsonDeserializer\u003c?\u003e cd \u003d null;\n                if (cdDef instanceof JsonDeserializer\u003c?\u003e) {\n                    cdDef \u003d (JsonDeserializer\u003c?\u003e) cdDef;\n                } else {\n                    Class\u003c?\u003e cdClass \u003d _verifyAsClass(cdDef, \"findContentDeserializer\", JsonDeserializer.None.class);\n                    if (cdClass !\u003d null) {\n                        cd \u003d ctxt.deserializerInstance(a, cdClass);\n                    }\n                }\n                if (cd !\u003d null) {\n                    type \u003d type.withContentValueHandler(cd);\n                }\n            }\n        }\n    }\n    return type;\n}",
          "path": "src/main/java/com/fasterxml/jackson/databind/deser/DeserializerCache.java",
          "functionStartLine": 459,
          "functionName": "modifyTypeByAnnotation",
          "functionAnnotation": "",
          "functionDoc": "Method called to see if given method has annotations that indicate\na more specific type than what the argument specifies.\nIf annotations are present, they must specify compatible Class;\ninstance of which can be assigned using the method. This means\nthat the Class has to be raw class of type, or its sub-class\n(or, implementing class if original Class instance is an interface).\n\n@param a Method or field that the type is associated with\n@param type Type derived from the setter argument\n@return Original type if no annotations are present; or a more\n  specific type derived from it if type annotation(s) was found\n@throws JsonMappingException if invalid annotation is found\n",
          "diff": "@@ -1,62 +1,62 @@\n-private JavaType modifyTypeByAnnotation(DeserializationContext ctxt, Annotated a, JavaType type, BeanProperty prop) throws JsonMappingException {\n+private JavaType modifyTypeByAnnotation(DeserializationContext ctxt, Annotated a, JavaType type) throws JsonMappingException {\n     AnnotationIntrospector intr \u003d ctxt.getAnnotationIntrospector();\n     Class\u003c?\u003e subclass \u003d intr.findDeserializationType(a, type);\n     if (subclass !\u003d null) {\n         try {\n             type \u003d type.narrowBy(subclass);\n         } catch (IllegalArgumentException iae) {\n             throw new JsonMappingException(\"Failed to narrow type \" + type + \" with concrete-type annotation (value \" + subclass.getName() + \"), method \u0027\" + a.getName() + \"\u0027: \" + iae.getMessage(), null, iae);\n         }\n     }\n     if (type.isContainerType()) {\n         Class\u003c?\u003e keyClass \u003d intr.findDeserializationKeyType(a, type.getKeyType());\n         if (keyClass !\u003d null) {\n             if (!(type instanceof MapLikeType)) {\n                 throw new JsonMappingException(\"Illegal key-type annotation: type \" + type + \" is not a Map(-like) type\");\n             }\n             try {\n                 type \u003d ((MapLikeType) type).narrowKey(keyClass);\n             } catch (IllegalArgumentException iae) {\n                 throw new JsonMappingException(\"Failed to narrow key type \" + type + \" with key-type annotation (\" + keyClass.getName() + \"): \" + iae.getMessage(), null, iae);\n             }\n         }\n         JavaType keyType \u003d type.getKeyType();\n         if (keyType !\u003d null \u0026\u0026 keyType.getValueHandler() \u003d\u003d null) {\n             Object kdDef \u003d intr.findKeyDeserializer(a);\n             if (kdDef !\u003d null) {\n-                KeyDeserializer kd \u003d ctxt.keyDeserializerInstance(a, prop, kdDef);\n+                KeyDeserializer kd \u003d ctxt.keyDeserializerInstance(a, null, kdDef);\n                 if (kd !\u003d null) {\n                     type \u003d ((MapLikeType) type).withKeyValueHandler(kd);\n                     keyType \u003d type.getKeyType();\n                 }\n             }\n         }\n         Class\u003c?\u003e cc \u003d intr.findDeserializationContentType(a, type.getContentType());\n         if (cc !\u003d null) {\n             try {\n                 type \u003d type.narrowContentsBy(cc);\n             } catch (IllegalArgumentException iae) {\n                 throw new JsonMappingException(\"Failed to narrow content type \" + type + \" with content-type annotation (\" + cc.getName() + \"): \" + iae.getMessage(), null, iae);\n             }\n         }\n         JavaType contentType \u003d type.getContentType();\n         if (contentType.getValueHandler() \u003d\u003d null) {\n             Object cdDef \u003d intr.findContentDeserializer(a);\n             if (cdDef !\u003d null) {\n                 JsonDeserializer\u003c?\u003e cd \u003d null;\n                 if (cdDef instanceof JsonDeserializer\u003c?\u003e) {\n                     cdDef \u003d (JsonDeserializer\u003c?\u003e) cdDef;\n                 } else {\n                     Class\u003c?\u003e cdClass \u003d _verifyAsClass(cdDef, \"findContentDeserializer\", JsonDeserializer.None.class);\n                     if (cdClass !\u003d null) {\n-                        cd \u003d ctxt.deserializerInstance(a, prop, cdClass);\n+                        cd \u003d ctxt.deserializerInstance(a, cdClass);\n                     }\n                 }\n                 if (cd !\u003d null) {\n                     type \u003d type.withContentValueHandler(cd);\n                 }\n             }\n         }\n     }\n     return type;\n }\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldValue": "Method called to see if given method has annotations that indicate\na more specific type than what the argument specifies.\nIf annotations are present, they must specify compatible Class;\ninstance of which can be assigned using the method. This means\nthat the Class has to be raw class of type, or its sub-class\n(or, implementing class if original Class instance is an interface).\n\n@param a Method or field that the type is associated with\n@param type Type derived from the setter argument\n@param prop Property that lead to this annotation, if any.\n@return Original type if no annotations are present; or a more\n  specific type derived from it if type annotation(s) was found\n@throws JsonMappingException if invalid annotation is found\n",
            "newValue": "Method called to see if given method has annotations that indicate\na more specific type than what the argument specifies.\nIf annotations are present, they must specify compatible Class;\ninstance of which can be assigned using the method. This means\nthat the Class has to be raw class of type, or its sub-class\n(or, implementing class if original Class instance is an interface).\n\n@param a Method or field that the type is associated with\n@param type Type derived from the setter argument\n@return Original type if no annotations are present; or a more\n  specific type derived from it if type annotation(s) was found\n@throws JsonMappingException if invalid annotation is found\n"
          }
        }
      ]
    },
    "2e5121ee9a521fe27e9caeaa91349183548a8820": {
      "type": "Ybodychange",
      "commitMessage": "Remove parametrization of ContextualDeserializer\n",
      "commitDate": "1/30/12, 8:24 AM",
      "commitName": "2e5121ee9a521fe27e9caeaa91349183548a8820",
      "commitAuthor": "Tatu Saloranta",
      "commitDateOld": "1/29/12, 9:36 PM",
      "commitNameOld": "06c20b1814a497cda59d46609ca03bfac20f64f1",
      "commitAuthorOld": "Tatu Saloranta",
      "daysBetweenCommits": 0.45,
      "commitsBetweenForRepo": 6,
      "commitsBetweenForFile": 1,
      "actualSource": "private JavaType modifyTypeByAnnotation(DeserializationContext ctxt, Annotated a, JavaType type, BeanProperty prop) throws JsonMappingException {\n    AnnotationIntrospector intr \u003d ctxt.getAnnotationIntrospector();\n    Class\u003c?\u003e subclass \u003d intr.findDeserializationType(a, type);\n    if (subclass !\u003d null) {\n        try {\n            type \u003d type.narrowBy(subclass);\n        } catch (IllegalArgumentException iae) {\n            throw new JsonMappingException(\"Failed to narrow type \" + type + \" with concrete-type annotation (value \" + subclass.getName() + \"), method \u0027\" + a.getName() + \"\u0027: \" + iae.getMessage(), null, iae);\n        }\n    }\n    if (type.isContainerType()) {\n        Class\u003c?\u003e keyClass \u003d intr.findDeserializationKeyType(a, type.getKeyType());\n        if (keyClass !\u003d null) {\n            if (!(type instanceof MapLikeType)) {\n                throw new JsonMappingException(\"Illegal key-type annotation: type \" + type + \" is not a Map(-like) type\");\n            }\n            try {\n                type \u003d ((MapLikeType) type).narrowKey(keyClass);\n            } catch (IllegalArgumentException iae) {\n                throw new JsonMappingException(\"Failed to narrow key type \" + type + \" with key-type annotation (\" + keyClass.getName() + \"): \" + iae.getMessage(), null, iae);\n            }\n        }\n        JavaType keyType \u003d type.getKeyType();\n        if (keyType !\u003d null \u0026\u0026 keyType.getValueHandler() \u003d\u003d null) {\n            Object kdDef \u003d intr.findKeyDeserializer(a);\n            if (kdDef !\u003d null) {\n                KeyDeserializer kd \u003d ctxt.keyDeserializerInstance(a, prop, kdDef);\n                if (kd !\u003d null) {\n                    type \u003d ((MapLikeType) type).withKeyValueHandler(kd);\n                    keyType \u003d type.getKeyType();\n                }\n            }\n        }\n        Class\u003c?\u003e cc \u003d intr.findDeserializationContentType(a, type.getContentType());\n        if (cc !\u003d null) {\n            try {\n                type \u003d type.narrowContentsBy(cc);\n            } catch (IllegalArgumentException iae) {\n                throw new JsonMappingException(\"Failed to narrow content type \" + type + \" with content-type annotation (\" + cc.getName() + \"): \" + iae.getMessage(), null, iae);\n            }\n        }\n        JavaType contentType \u003d type.getContentType();\n        if (contentType.getValueHandler() \u003d\u003d null) {\n            Object cdDef \u003d intr.findContentDeserializer(a);\n            if (cdDef !\u003d null) {\n                JsonDeserializer\u003c?\u003e cd \u003d null;\n                if (cdDef instanceof JsonDeserializer\u003c?\u003e) {\n                    cdDef \u003d (JsonDeserializer\u003c?\u003e) cdDef;\n                } else {\n                    Class\u003c?\u003e cdClass \u003d _verifyAsClass(cdDef, \"findContentDeserializer\", JsonDeserializer.None.class);\n                    if (cdClass !\u003d null) {\n                        cd \u003d ctxt.deserializerInstance(a, prop, cdClass);\n                    }\n                }\n                if (cd !\u003d null) {\n                    type \u003d type.withContentValueHandler(cd);\n                }\n            }\n        }\n    }\n    return type;\n}",
      "path": "src/main/java/com/fasterxml/jackson/databind/deser/DeserializerCache.java",
      "functionStartLine": 490,
      "functionName": "modifyTypeByAnnotation",
      "functionAnnotation": "",
      "functionDoc": "Method called to see if given method has annotations that indicate\na more specific type than what the argument specifies.\nIf annotations are present, they must specify compatible Class;\ninstance of which can be assigned using the method. This means\nthat the Class has to be raw class of type, or its sub-class\n(or, implementing class if original Class instance is an interface).\n\n@param a Method or field that the type is associated with\n@param type Type derived from the setter argument\n@param prop Property that lead to this annotation, if any.\n@return Original type if no annotations are present; or a more\n  specific type derived from it if type annotation(s) was found\n@throws JsonMappingException if invalid annotation is found\n",
      "diff": "@@ -1,62 +1,62 @@\n private JavaType modifyTypeByAnnotation(DeserializationContext ctxt, Annotated a, JavaType type, BeanProperty prop) throws JsonMappingException {\n     AnnotationIntrospector intr \u003d ctxt.getAnnotationIntrospector();\n-    Class\u003c?\u003e subclass \u003d intr.findDeserializationType(a, type, (prop \u003d\u003d null) ? null : prop.getName());\n+    Class\u003c?\u003e subclass \u003d intr.findDeserializationType(a, type);\n     if (subclass !\u003d null) {\n         try {\n             type \u003d type.narrowBy(subclass);\n         } catch (IllegalArgumentException iae) {\n             throw new JsonMappingException(\"Failed to narrow type \" + type + \" with concrete-type annotation (value \" + subclass.getName() + \"), method \u0027\" + a.getName() + \"\u0027: \" + iae.getMessage(), null, iae);\n         }\n     }\n     if (type.isContainerType()) {\n-        Class\u003c?\u003e keyClass \u003d intr.findDeserializationKeyType(a, type.getKeyType(), (prop \u003d\u003d null) ? null : prop.getName());\n+        Class\u003c?\u003e keyClass \u003d intr.findDeserializationKeyType(a, type.getKeyType());\n         if (keyClass !\u003d null) {\n             if (!(type instanceof MapLikeType)) {\n                 throw new JsonMappingException(\"Illegal key-type annotation: type \" + type + \" is not a Map(-like) type\");\n             }\n             try {\n                 type \u003d ((MapLikeType) type).narrowKey(keyClass);\n             } catch (IllegalArgumentException iae) {\n                 throw new JsonMappingException(\"Failed to narrow key type \" + type + \" with key-type annotation (\" + keyClass.getName() + \"): \" + iae.getMessage(), null, iae);\n             }\n         }\n         JavaType keyType \u003d type.getKeyType();\n         if (keyType !\u003d null \u0026\u0026 keyType.getValueHandler() \u003d\u003d null) {\n             Object kdDef \u003d intr.findKeyDeserializer(a);\n             if (kdDef !\u003d null) {\n                 KeyDeserializer kd \u003d ctxt.keyDeserializerInstance(a, prop, kdDef);\n                 if (kd !\u003d null) {\n                     type \u003d ((MapLikeType) type).withKeyValueHandler(kd);\n                     keyType \u003d type.getKeyType();\n                 }\n             }\n         }\n-        Class\u003c?\u003e cc \u003d intr.findDeserializationContentType(a, type.getContentType(), (prop \u003d\u003d null) ? null : prop.getName());\n+        Class\u003c?\u003e cc \u003d intr.findDeserializationContentType(a, type.getContentType());\n         if (cc !\u003d null) {\n             try {\n                 type \u003d type.narrowContentsBy(cc);\n             } catch (IllegalArgumentException iae) {\n                 throw new JsonMappingException(\"Failed to narrow content type \" + type + \" with content-type annotation (\" + cc.getName() + \"): \" + iae.getMessage(), null, iae);\n             }\n         }\n         JavaType contentType \u003d type.getContentType();\n         if (contentType.getValueHandler() \u003d\u003d null) {\n             Object cdDef \u003d intr.findContentDeserializer(a);\n             if (cdDef !\u003d null) {\n                 JsonDeserializer\u003c?\u003e cd \u003d null;\n                 if (cdDef instanceof JsonDeserializer\u003c?\u003e) {\n                     cdDef \u003d (JsonDeserializer\u003c?\u003e) cdDef;\n                 } else {\n                     Class\u003c?\u003e cdClass \u003d _verifyAsClass(cdDef, \"findContentDeserializer\", JsonDeserializer.None.class);\n                     if (cdClass !\u003d null) {\n                         cd \u003d ctxt.deserializerInstance(a, prop, cdClass);\n                     }\n                 }\n                 if (cd !\u003d null) {\n                     type \u003d type.withContentValueHandler(cd);\n                 }\n             }\n         }\n     }\n     return type;\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "b37ff33bbc7885f21a208bee4f42126468f55d41": {
      "type": "Ymultichange(Yparameterchange,Ybodychange,Ydocchange)",
      "commitMessage": "Yet more refactoring, trying to be able to pass DeserializationContext to ContextualDeserializer\n",
      "commitDate": "1/24/12, 4:19 PM",
      "commitName": "b37ff33bbc7885f21a208bee4f42126468f55d41",
      "commitAuthor": "Tatu",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "Yet more refactoring, trying to be able to pass DeserializationContext to ContextualDeserializer\n",
          "commitDate": "1/24/12, 4:19 PM",
          "commitName": "b37ff33bbc7885f21a208bee4f42126468f55d41",
          "commitAuthor": "Tatu",
          "commitDateOld": "1/24/12, 2:46 PM",
          "commitNameOld": "bf355caa0821e58968df3bf6c12f612639224e47",
          "commitAuthorOld": "Tatu",
          "daysBetweenCommits": 0.06,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "actualSource": "private JavaType modifyTypeByAnnotation(DeserializationContext ctxt, Annotated a, JavaType type, BeanProperty prop) throws JsonMappingException {\n    AnnotationIntrospector intr \u003d ctxt.getAnnotationIntrospector();\n    Class\u003c?\u003e subclass \u003d intr.findDeserializationType(a, type, (prop \u003d\u003d null) ? null : prop.getName());\n    if (subclass !\u003d null) {\n        try {\n            type \u003d type.narrowBy(subclass);\n        } catch (IllegalArgumentException iae) {\n            throw new JsonMappingException(\"Failed to narrow type \" + type + \" with concrete-type annotation (value \" + subclass.getName() + \"), method \u0027\" + a.getName() + \"\u0027: \" + iae.getMessage(), null, iae);\n        }\n    }\n    if (type.isContainerType()) {\n        Class\u003c?\u003e keyClass \u003d intr.findDeserializationKeyType(a, type.getKeyType(), (prop \u003d\u003d null) ? null : prop.getName());\n        if (keyClass !\u003d null) {\n            if (!(type instanceof MapLikeType)) {\n                throw new JsonMappingException(\"Illegal key-type annotation: type \" + type + \" is not a Map(-like) type\");\n            }\n            try {\n                type \u003d ((MapLikeType) type).narrowKey(keyClass);\n            } catch (IllegalArgumentException iae) {\n                throw new JsonMappingException(\"Failed to narrow key type \" + type + \" with key-type annotation (\" + keyClass.getName() + \"): \" + iae.getMessage(), null, iae);\n            }\n        }\n        JavaType keyType \u003d type.getKeyType();\n        if (keyType !\u003d null \u0026\u0026 keyType.getValueHandler() \u003d\u003d null) {\n            Object kdDef \u003d intr.findKeyDeserializer(a);\n            if (kdDef !\u003d null) {\n                KeyDeserializer kd \u003d ctxt.keyDeserializerInstance(a, prop, kdDef);\n                if (kd !\u003d null) {\n                    type \u003d ((MapLikeType) type).withKeyValueHandler(kd);\n                    keyType \u003d type.getKeyType();\n                }\n            }\n        }\n        Class\u003c?\u003e cc \u003d intr.findDeserializationContentType(a, type.getContentType(), (prop \u003d\u003d null) ? null : prop.getName());\n        if (cc !\u003d null) {\n            try {\n                type \u003d type.narrowContentsBy(cc);\n            } catch (IllegalArgumentException iae) {\n                throw new JsonMappingException(\"Failed to narrow content type \" + type + \" with content-type annotation (\" + cc.getName() + \"): \" + iae.getMessage(), null, iae);\n            }\n        }\n        JavaType contentType \u003d type.getContentType();\n        if (contentType.getValueHandler() \u003d\u003d null) {\n            Object cdDef \u003d intr.findContentDeserializer(a);\n            if (cdDef !\u003d null) {\n                JsonDeserializer\u003c?\u003e cd \u003d null;\n                if (cdDef instanceof JsonDeserializer\u003c?\u003e) {\n                    cdDef \u003d (JsonDeserializer\u003c?\u003e) cdDef;\n                } else {\n                    Class\u003c?\u003e cdClass \u003d _verifyAsClass(cdDef, \"findContentDeserializer\", JsonDeserializer.None.class);\n                    if (cdClass !\u003d null) {\n                        cd \u003d ctxt.deserializerInstance(a, prop, cdClass);\n                    }\n                }\n                if (cd !\u003d null) {\n                    type \u003d type.withContentValueHandler(cd);\n                }\n            }\n        }\n    }\n    return type;\n}",
          "path": "src/main/java/com/fasterxml/jackson/databind/deser/DeserializerCache.java",
          "functionStartLine": 492,
          "functionName": "modifyTypeByAnnotation",
          "functionAnnotation": "",
          "functionDoc": "Method called to see if given method has annotations that indicate\na more specific type than what the argument specifies.\nIf annotations are present, they must specify compatible Class;\ninstance of which can be assigned using the method. This means\nthat the Class has to be raw class of type, or its sub-class\n(or, implementing class if original Class instance is an interface).\n\n@param a Method or field that the type is associated with\n@param type Type derived from the setter argument\n@param prop Property that lead to this annotation, if any.\n@return Original type if no annotations are present; or a more\n  specific type derived from it if type annotation(s) was found\n@throws JsonMappingException if invalid annotation is found\n",
          "diff": "@@ -1,70 +1,62 @@\n-private JavaType modifyTypeByAnnotation(DeserializationConfig config, Annotated a, JavaType type, String propName) throws JsonMappingException {\n-    AnnotationIntrospector intr \u003d config.getAnnotationIntrospector();\n-    Class\u003c?\u003e subclass \u003d intr.findDeserializationType(a, type, propName);\n+private JavaType modifyTypeByAnnotation(DeserializationContext ctxt, Annotated a, JavaType type, BeanProperty prop) throws JsonMappingException {\n+    AnnotationIntrospector intr \u003d ctxt.getAnnotationIntrospector();\n+    Class\u003c?\u003e subclass \u003d intr.findDeserializationType(a, type, (prop \u003d\u003d null) ? null : prop.getName());\n     if (subclass !\u003d null) {\n         try {\n             type \u003d type.narrowBy(subclass);\n         } catch (IllegalArgumentException iae) {\n             throw new JsonMappingException(\"Failed to narrow type \" + type + \" with concrete-type annotation (value \" + subclass.getName() + \"), method \u0027\" + a.getName() + \"\u0027: \" + iae.getMessage(), null, iae);\n         }\n     }\n     if (type.isContainerType()) {\n-        Class\u003c?\u003e keyClass \u003d intr.findDeserializationKeyType(a, type.getKeyType(), propName);\n+        Class\u003c?\u003e keyClass \u003d intr.findDeserializationKeyType(a, type.getKeyType(), (prop \u003d\u003d null) ? null : prop.getName());\n         if (keyClass !\u003d null) {\n             if (!(type instanceof MapLikeType)) {\n                 throw new JsonMappingException(\"Illegal key-type annotation: type \" + type + \" is not a Map(-like) type\");\n             }\n             try {\n                 type \u003d ((MapLikeType) type).narrowKey(keyClass);\n             } catch (IllegalArgumentException iae) {\n                 throw new JsonMappingException(\"Failed to narrow key type \" + type + \" with key-type annotation (\" + keyClass.getName() + \"): \" + iae.getMessage(), null, iae);\n             }\n         }\n         JavaType keyType \u003d type.getKeyType();\n         if (keyType !\u003d null \u0026\u0026 keyType.getValueHandler() \u003d\u003d null) {\n             Object kdDef \u003d intr.findKeyDeserializer(a);\n             if (kdDef !\u003d null) {\n-                KeyDeserializer kd \u003d null;\n-                if (kdDef instanceof KeyDeserializer) {\n-                    kd \u003d (KeyDeserializer) kdDef;\n-                } else {\n-                    Class\u003c?\u003e kdClass \u003d _verifyAsClass(kdDef, \"findKeyDeserializer\", KeyDeserializer.None.class);\n-                    if (kdClass !\u003d null) {\n-                        kd \u003d config.keyDeserializerInstance(a, kdClass);\n-                    }\n-                }\n+                KeyDeserializer kd \u003d ctxt.keyDeserializerInstance(a, prop, kdDef);\n                 if (kd !\u003d null) {\n                     type \u003d ((MapLikeType) type).withKeyValueHandler(kd);\n                     keyType \u003d type.getKeyType();\n                 }\n             }\n         }\n-        Class\u003c?\u003e cc \u003d intr.findDeserializationContentType(a, type.getContentType(), propName);\n+        Class\u003c?\u003e cc \u003d intr.findDeserializationContentType(a, type.getContentType(), (prop \u003d\u003d null) ? null : prop.getName());\n         if (cc !\u003d null) {\n             try {\n                 type \u003d type.narrowContentsBy(cc);\n             } catch (IllegalArgumentException iae) {\n                 throw new JsonMappingException(\"Failed to narrow content type \" + type + \" with content-type annotation (\" + cc.getName() + \"): \" + iae.getMessage(), null, iae);\n             }\n         }\n         JavaType contentType \u003d type.getContentType();\n         if (contentType.getValueHandler() \u003d\u003d null) {\n             Object cdDef \u003d intr.findContentDeserializer(a);\n             if (cdDef !\u003d null) {\n                 JsonDeserializer\u003c?\u003e cd \u003d null;\n                 if (cdDef instanceof JsonDeserializer\u003c?\u003e) {\n                     cdDef \u003d (JsonDeserializer\u003c?\u003e) cdDef;\n                 } else {\n                     Class\u003c?\u003e cdClass \u003d _verifyAsClass(cdDef, \"findContentDeserializer\", JsonDeserializer.None.class);\n                     if (cdClass !\u003d null) {\n-                        cd \u003d config.deserializerInstance(a, cdClass);\n+                        cd \u003d ctxt.deserializerInstance(a, prop, cdClass);\n                     }\n                 }\n                 if (cd !\u003d null) {\n                     type \u003d type.withContentValueHandler(cd);\n                 }\n             }\n         }\n     }\n     return type;\n }\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldValue": "[config-DeserializationConfig, a-Annotated, type-JavaType, propName-String]",
            "newValue": "[ctxt-DeserializationContext, a-Annotated, type-JavaType, prop-BeanProperty]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "Yet more refactoring, trying to be able to pass DeserializationContext to ContextualDeserializer\n",
          "commitDate": "1/24/12, 4:19 PM",
          "commitName": "b37ff33bbc7885f21a208bee4f42126468f55d41",
          "commitAuthor": "Tatu",
          "commitDateOld": "1/24/12, 2:46 PM",
          "commitNameOld": "bf355caa0821e58968df3bf6c12f612639224e47",
          "commitAuthorOld": "Tatu",
          "daysBetweenCommits": 0.06,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "actualSource": "private JavaType modifyTypeByAnnotation(DeserializationContext ctxt, Annotated a, JavaType type, BeanProperty prop) throws JsonMappingException {\n    AnnotationIntrospector intr \u003d ctxt.getAnnotationIntrospector();\n    Class\u003c?\u003e subclass \u003d intr.findDeserializationType(a, type, (prop \u003d\u003d null) ? null : prop.getName());\n    if (subclass !\u003d null) {\n        try {\n            type \u003d type.narrowBy(subclass);\n        } catch (IllegalArgumentException iae) {\n            throw new JsonMappingException(\"Failed to narrow type \" + type + \" with concrete-type annotation (value \" + subclass.getName() + \"), method \u0027\" + a.getName() + \"\u0027: \" + iae.getMessage(), null, iae);\n        }\n    }\n    if (type.isContainerType()) {\n        Class\u003c?\u003e keyClass \u003d intr.findDeserializationKeyType(a, type.getKeyType(), (prop \u003d\u003d null) ? null : prop.getName());\n        if (keyClass !\u003d null) {\n            if (!(type instanceof MapLikeType)) {\n                throw new JsonMappingException(\"Illegal key-type annotation: type \" + type + \" is not a Map(-like) type\");\n            }\n            try {\n                type \u003d ((MapLikeType) type).narrowKey(keyClass);\n            } catch (IllegalArgumentException iae) {\n                throw new JsonMappingException(\"Failed to narrow key type \" + type + \" with key-type annotation (\" + keyClass.getName() + \"): \" + iae.getMessage(), null, iae);\n            }\n        }\n        JavaType keyType \u003d type.getKeyType();\n        if (keyType !\u003d null \u0026\u0026 keyType.getValueHandler() \u003d\u003d null) {\n            Object kdDef \u003d intr.findKeyDeserializer(a);\n            if (kdDef !\u003d null) {\n                KeyDeserializer kd \u003d ctxt.keyDeserializerInstance(a, prop, kdDef);\n                if (kd !\u003d null) {\n                    type \u003d ((MapLikeType) type).withKeyValueHandler(kd);\n                    keyType \u003d type.getKeyType();\n                }\n            }\n        }\n        Class\u003c?\u003e cc \u003d intr.findDeserializationContentType(a, type.getContentType(), (prop \u003d\u003d null) ? null : prop.getName());\n        if (cc !\u003d null) {\n            try {\n                type \u003d type.narrowContentsBy(cc);\n            } catch (IllegalArgumentException iae) {\n                throw new JsonMappingException(\"Failed to narrow content type \" + type + \" with content-type annotation (\" + cc.getName() + \"): \" + iae.getMessage(), null, iae);\n            }\n        }\n        JavaType contentType \u003d type.getContentType();\n        if (contentType.getValueHandler() \u003d\u003d null) {\n            Object cdDef \u003d intr.findContentDeserializer(a);\n            if (cdDef !\u003d null) {\n                JsonDeserializer\u003c?\u003e cd \u003d null;\n                if (cdDef instanceof JsonDeserializer\u003c?\u003e) {\n                    cdDef \u003d (JsonDeserializer\u003c?\u003e) cdDef;\n                } else {\n                    Class\u003c?\u003e cdClass \u003d _verifyAsClass(cdDef, \"findContentDeserializer\", JsonDeserializer.None.class);\n                    if (cdClass !\u003d null) {\n                        cd \u003d ctxt.deserializerInstance(a, prop, cdClass);\n                    }\n                }\n                if (cd !\u003d null) {\n                    type \u003d type.withContentValueHandler(cd);\n                }\n            }\n        }\n    }\n    return type;\n}",
          "path": "src/main/java/com/fasterxml/jackson/databind/deser/DeserializerCache.java",
          "functionStartLine": 492,
          "functionName": "modifyTypeByAnnotation",
          "functionAnnotation": "",
          "functionDoc": "Method called to see if given method has annotations that indicate\na more specific type than what the argument specifies.\nIf annotations are present, they must specify compatible Class;\ninstance of which can be assigned using the method. This means\nthat the Class has to be raw class of type, or its sub-class\n(or, implementing class if original Class instance is an interface).\n\n@param a Method or field that the type is associated with\n@param type Type derived from the setter argument\n@param prop Property that lead to this annotation, if any.\n@return Original type if no annotations are present; or a more\n  specific type derived from it if type annotation(s) was found\n@throws JsonMappingException if invalid annotation is found\n",
          "diff": "@@ -1,70 +1,62 @@\n-private JavaType modifyTypeByAnnotation(DeserializationConfig config, Annotated a, JavaType type, String propName) throws JsonMappingException {\n-    AnnotationIntrospector intr \u003d config.getAnnotationIntrospector();\n-    Class\u003c?\u003e subclass \u003d intr.findDeserializationType(a, type, propName);\n+private JavaType modifyTypeByAnnotation(DeserializationContext ctxt, Annotated a, JavaType type, BeanProperty prop) throws JsonMappingException {\n+    AnnotationIntrospector intr \u003d ctxt.getAnnotationIntrospector();\n+    Class\u003c?\u003e subclass \u003d intr.findDeserializationType(a, type, (prop \u003d\u003d null) ? null : prop.getName());\n     if (subclass !\u003d null) {\n         try {\n             type \u003d type.narrowBy(subclass);\n         } catch (IllegalArgumentException iae) {\n             throw new JsonMappingException(\"Failed to narrow type \" + type + \" with concrete-type annotation (value \" + subclass.getName() + \"), method \u0027\" + a.getName() + \"\u0027: \" + iae.getMessage(), null, iae);\n         }\n     }\n     if (type.isContainerType()) {\n-        Class\u003c?\u003e keyClass \u003d intr.findDeserializationKeyType(a, type.getKeyType(), propName);\n+        Class\u003c?\u003e keyClass \u003d intr.findDeserializationKeyType(a, type.getKeyType(), (prop \u003d\u003d null) ? null : prop.getName());\n         if (keyClass !\u003d null) {\n             if (!(type instanceof MapLikeType)) {\n                 throw new JsonMappingException(\"Illegal key-type annotation: type \" + type + \" is not a Map(-like) type\");\n             }\n             try {\n                 type \u003d ((MapLikeType) type).narrowKey(keyClass);\n             } catch (IllegalArgumentException iae) {\n                 throw new JsonMappingException(\"Failed to narrow key type \" + type + \" with key-type annotation (\" + keyClass.getName() + \"): \" + iae.getMessage(), null, iae);\n             }\n         }\n         JavaType keyType \u003d type.getKeyType();\n         if (keyType !\u003d null \u0026\u0026 keyType.getValueHandler() \u003d\u003d null) {\n             Object kdDef \u003d intr.findKeyDeserializer(a);\n             if (kdDef !\u003d null) {\n-                KeyDeserializer kd \u003d null;\n-                if (kdDef instanceof KeyDeserializer) {\n-                    kd \u003d (KeyDeserializer) kdDef;\n-                } else {\n-                    Class\u003c?\u003e kdClass \u003d _verifyAsClass(kdDef, \"findKeyDeserializer\", KeyDeserializer.None.class);\n-                    if (kdClass !\u003d null) {\n-                        kd \u003d config.keyDeserializerInstance(a, kdClass);\n-                    }\n-                }\n+                KeyDeserializer kd \u003d ctxt.keyDeserializerInstance(a, prop, kdDef);\n                 if (kd !\u003d null) {\n                     type \u003d ((MapLikeType) type).withKeyValueHandler(kd);\n                     keyType \u003d type.getKeyType();\n                 }\n             }\n         }\n-        Class\u003c?\u003e cc \u003d intr.findDeserializationContentType(a, type.getContentType(), propName);\n+        Class\u003c?\u003e cc \u003d intr.findDeserializationContentType(a, type.getContentType(), (prop \u003d\u003d null) ? null : prop.getName());\n         if (cc !\u003d null) {\n             try {\n                 type \u003d type.narrowContentsBy(cc);\n             } catch (IllegalArgumentException iae) {\n                 throw new JsonMappingException(\"Failed to narrow content type \" + type + \" with content-type annotation (\" + cc.getName() + \"): \" + iae.getMessage(), null, iae);\n             }\n         }\n         JavaType contentType \u003d type.getContentType();\n         if (contentType.getValueHandler() \u003d\u003d null) {\n             Object cdDef \u003d intr.findContentDeserializer(a);\n             if (cdDef !\u003d null) {\n                 JsonDeserializer\u003c?\u003e cd \u003d null;\n                 if (cdDef instanceof JsonDeserializer\u003c?\u003e) {\n                     cdDef \u003d (JsonDeserializer\u003c?\u003e) cdDef;\n                 } else {\n                     Class\u003c?\u003e cdClass \u003d _verifyAsClass(cdDef, \"findContentDeserializer\", JsonDeserializer.None.class);\n                     if (cdClass !\u003d null) {\n-                        cd \u003d config.deserializerInstance(a, cdClass);\n+                        cd \u003d ctxt.deserializerInstance(a, prop, cdClass);\n                     }\n                 }\n                 if (cd !\u003d null) {\n                     type \u003d type.withContentValueHandler(cd);\n                 }\n             }\n         }\n     }\n     return type;\n }\n\\ No newline at end of file\n",
          "extendedDetails": {}
        },
        {
          "type": "Ydocchange",
          "commitMessage": "Yet more refactoring, trying to be able to pass DeserializationContext to ContextualDeserializer\n",
          "commitDate": "1/24/12, 4:19 PM",
          "commitName": "b37ff33bbc7885f21a208bee4f42126468f55d41",
          "commitAuthor": "Tatu",
          "commitDateOld": "1/24/12, 2:46 PM",
          "commitNameOld": "bf355caa0821e58968df3bf6c12f612639224e47",
          "commitAuthorOld": "Tatu",
          "daysBetweenCommits": 0.06,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "actualSource": "private JavaType modifyTypeByAnnotation(DeserializationContext ctxt, Annotated a, JavaType type, BeanProperty prop) throws JsonMappingException {\n    AnnotationIntrospector intr \u003d ctxt.getAnnotationIntrospector();\n    Class\u003c?\u003e subclass \u003d intr.findDeserializationType(a, type, (prop \u003d\u003d null) ? null : prop.getName());\n    if (subclass !\u003d null) {\n        try {\n            type \u003d type.narrowBy(subclass);\n        } catch (IllegalArgumentException iae) {\n            throw new JsonMappingException(\"Failed to narrow type \" + type + \" with concrete-type annotation (value \" + subclass.getName() + \"), method \u0027\" + a.getName() + \"\u0027: \" + iae.getMessage(), null, iae);\n        }\n    }\n    if (type.isContainerType()) {\n        Class\u003c?\u003e keyClass \u003d intr.findDeserializationKeyType(a, type.getKeyType(), (prop \u003d\u003d null) ? null : prop.getName());\n        if (keyClass !\u003d null) {\n            if (!(type instanceof MapLikeType)) {\n                throw new JsonMappingException(\"Illegal key-type annotation: type \" + type + \" is not a Map(-like) type\");\n            }\n            try {\n                type \u003d ((MapLikeType) type).narrowKey(keyClass);\n            } catch (IllegalArgumentException iae) {\n                throw new JsonMappingException(\"Failed to narrow key type \" + type + \" with key-type annotation (\" + keyClass.getName() + \"): \" + iae.getMessage(), null, iae);\n            }\n        }\n        JavaType keyType \u003d type.getKeyType();\n        if (keyType !\u003d null \u0026\u0026 keyType.getValueHandler() \u003d\u003d null) {\n            Object kdDef \u003d intr.findKeyDeserializer(a);\n            if (kdDef !\u003d null) {\n                KeyDeserializer kd \u003d ctxt.keyDeserializerInstance(a, prop, kdDef);\n                if (kd !\u003d null) {\n                    type \u003d ((MapLikeType) type).withKeyValueHandler(kd);\n                    keyType \u003d type.getKeyType();\n                }\n            }\n        }\n        Class\u003c?\u003e cc \u003d intr.findDeserializationContentType(a, type.getContentType(), (prop \u003d\u003d null) ? null : prop.getName());\n        if (cc !\u003d null) {\n            try {\n                type \u003d type.narrowContentsBy(cc);\n            } catch (IllegalArgumentException iae) {\n                throw new JsonMappingException(\"Failed to narrow content type \" + type + \" with content-type annotation (\" + cc.getName() + \"): \" + iae.getMessage(), null, iae);\n            }\n        }\n        JavaType contentType \u003d type.getContentType();\n        if (contentType.getValueHandler() \u003d\u003d null) {\n            Object cdDef \u003d intr.findContentDeserializer(a);\n            if (cdDef !\u003d null) {\n                JsonDeserializer\u003c?\u003e cd \u003d null;\n                if (cdDef instanceof JsonDeserializer\u003c?\u003e) {\n                    cdDef \u003d (JsonDeserializer\u003c?\u003e) cdDef;\n                } else {\n                    Class\u003c?\u003e cdClass \u003d _verifyAsClass(cdDef, \"findContentDeserializer\", JsonDeserializer.None.class);\n                    if (cdClass !\u003d null) {\n                        cd \u003d ctxt.deserializerInstance(a, prop, cdClass);\n                    }\n                }\n                if (cd !\u003d null) {\n                    type \u003d type.withContentValueHandler(cd);\n                }\n            }\n        }\n    }\n    return type;\n}",
          "path": "src/main/java/com/fasterxml/jackson/databind/deser/DeserializerCache.java",
          "functionStartLine": 492,
          "functionName": "modifyTypeByAnnotation",
          "functionAnnotation": "",
          "functionDoc": "Method called to see if given method has annotations that indicate\na more specific type than what the argument specifies.\nIf annotations are present, they must specify compatible Class;\ninstance of which can be assigned using the method. This means\nthat the Class has to be raw class of type, or its sub-class\n(or, implementing class if original Class instance is an interface).\n\n@param a Method or field that the type is associated with\n@param type Type derived from the setter argument\n@param prop Property that lead to this annotation, if any.\n@return Original type if no annotations are present; or a more\n  specific type derived from it if type annotation(s) was found\n@throws JsonMappingException if invalid annotation is found\n",
          "diff": "@@ -1,70 +1,62 @@\n-private JavaType modifyTypeByAnnotation(DeserializationConfig config, Annotated a, JavaType type, String propName) throws JsonMappingException {\n-    AnnotationIntrospector intr \u003d config.getAnnotationIntrospector();\n-    Class\u003c?\u003e subclass \u003d intr.findDeserializationType(a, type, propName);\n+private JavaType modifyTypeByAnnotation(DeserializationContext ctxt, Annotated a, JavaType type, BeanProperty prop) throws JsonMappingException {\n+    AnnotationIntrospector intr \u003d ctxt.getAnnotationIntrospector();\n+    Class\u003c?\u003e subclass \u003d intr.findDeserializationType(a, type, (prop \u003d\u003d null) ? null : prop.getName());\n     if (subclass !\u003d null) {\n         try {\n             type \u003d type.narrowBy(subclass);\n         } catch (IllegalArgumentException iae) {\n             throw new JsonMappingException(\"Failed to narrow type \" + type + \" with concrete-type annotation (value \" + subclass.getName() + \"), method \u0027\" + a.getName() + \"\u0027: \" + iae.getMessage(), null, iae);\n         }\n     }\n     if (type.isContainerType()) {\n-        Class\u003c?\u003e keyClass \u003d intr.findDeserializationKeyType(a, type.getKeyType(), propName);\n+        Class\u003c?\u003e keyClass \u003d intr.findDeserializationKeyType(a, type.getKeyType(), (prop \u003d\u003d null) ? null : prop.getName());\n         if (keyClass !\u003d null) {\n             if (!(type instanceof MapLikeType)) {\n                 throw new JsonMappingException(\"Illegal key-type annotation: type \" + type + \" is not a Map(-like) type\");\n             }\n             try {\n                 type \u003d ((MapLikeType) type).narrowKey(keyClass);\n             } catch (IllegalArgumentException iae) {\n                 throw new JsonMappingException(\"Failed to narrow key type \" + type + \" with key-type annotation (\" + keyClass.getName() + \"): \" + iae.getMessage(), null, iae);\n             }\n         }\n         JavaType keyType \u003d type.getKeyType();\n         if (keyType !\u003d null \u0026\u0026 keyType.getValueHandler() \u003d\u003d null) {\n             Object kdDef \u003d intr.findKeyDeserializer(a);\n             if (kdDef !\u003d null) {\n-                KeyDeserializer kd \u003d null;\n-                if (kdDef instanceof KeyDeserializer) {\n-                    kd \u003d (KeyDeserializer) kdDef;\n-                } else {\n-                    Class\u003c?\u003e kdClass \u003d _verifyAsClass(kdDef, \"findKeyDeserializer\", KeyDeserializer.None.class);\n-                    if (kdClass !\u003d null) {\n-                        kd \u003d config.keyDeserializerInstance(a, kdClass);\n-                    }\n-                }\n+                KeyDeserializer kd \u003d ctxt.keyDeserializerInstance(a, prop, kdDef);\n                 if (kd !\u003d null) {\n                     type \u003d ((MapLikeType) type).withKeyValueHandler(kd);\n                     keyType \u003d type.getKeyType();\n                 }\n             }\n         }\n-        Class\u003c?\u003e cc \u003d intr.findDeserializationContentType(a, type.getContentType(), propName);\n+        Class\u003c?\u003e cc \u003d intr.findDeserializationContentType(a, type.getContentType(), (prop \u003d\u003d null) ? null : prop.getName());\n         if (cc !\u003d null) {\n             try {\n                 type \u003d type.narrowContentsBy(cc);\n             } catch (IllegalArgumentException iae) {\n                 throw new JsonMappingException(\"Failed to narrow content type \" + type + \" with content-type annotation (\" + cc.getName() + \"): \" + iae.getMessage(), null, iae);\n             }\n         }\n         JavaType contentType \u003d type.getContentType();\n         if (contentType.getValueHandler() \u003d\u003d null) {\n             Object cdDef \u003d intr.findContentDeserializer(a);\n             if (cdDef !\u003d null) {\n                 JsonDeserializer\u003c?\u003e cd \u003d null;\n                 if (cdDef instanceof JsonDeserializer\u003c?\u003e) {\n                     cdDef \u003d (JsonDeserializer\u003c?\u003e) cdDef;\n                 } else {\n                     Class\u003c?\u003e cdClass \u003d _verifyAsClass(cdDef, \"findContentDeserializer\", JsonDeserializer.None.class);\n                     if (cdClass !\u003d null) {\n-                        cd \u003d config.deserializerInstance(a, cdClass);\n+                        cd \u003d ctxt.deserializerInstance(a, prop, cdClass);\n                     }\n                 }\n                 if (cd !\u003d null) {\n                     type \u003d type.withContentValueHandler(cd);\n                 }\n             }\n         }\n     }\n     return type;\n }\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldValue": "Method called to see if given method has annotations that indicate\na more specific type than what the argument specifies.\nIf annotations are present, they must specify compatible Class;\ninstance of which can be assigned using the method. This means\nthat the Class has to be raw class of type, or its sub-class\n(or, implementing class if original Class instance is an interface).\n\n@param a Method or field that the type is associated with\n@param type Type derived from the setter argument\n@param propName Name of property that refers to type, if any; null\n  if no property information available (when modify type declaration\n  of a class, for example)\n@return Original type if no annotations are present; or a more\n  specific type derived from it if type annotation(s) was found\n@throws JsonMappingException if invalid annotation is found\n",
            "newValue": "Method called to see if given method has annotations that indicate\na more specific type than what the argument specifies.\nIf annotations are present, they must specify compatible Class;\ninstance of which can be assigned using the method. This means\nthat the Class has to be raw class of type, or its sub-class\n(or, implementing class if original Class instance is an interface).\n\n@param a Method or field that the type is associated with\n@param type Type derived from the setter argument\n@param prop Property that lead to this annotation, if any.\n@return Original type if no annotations are present; or a more\n  specific type derived from it if type annotation(s) was found\n@throws JsonMappingException if invalid annotation is found\n"
          }
        }
      ]
    },
    "bf355caa0821e58968df3bf6c12f612639224e47": {
      "type": "Ymultichange(Ymovefromfile,Yreturntypechange,Ymodifierchange,Ybodychange,Yannotationchange,Yparameterchange)",
      "commitMessage": "Yet more refactoring, trying to remove back-refs from DeserializerFactory to context/cache\n",
      "commitDate": "1/24/12, 2:46 PM",
      "commitName": "bf355caa0821e58968df3bf6c12f612639224e47",
      "commitAuthor": "Tatu",
      "subchanges": [
        {
          "type": "Ymovefromfile",
          "commitMessage": "Yet more refactoring, trying to remove back-refs from DeserializerFactory to context/cache\n",
          "commitDate": "1/24/12, 2:46 PM",
          "commitName": "bf355caa0821e58968df3bf6c12f612639224e47",
          "commitAuthor": "Tatu",
          "commitDateOld": "1/24/12, 1:27 PM",
          "commitNameOld": "f0b28a96644b3dc22c997a05975de335dfed0418",
          "commitAuthorOld": "Tatu",
          "daysBetweenCommits": 0.05,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "actualSource": "private JavaType modifyTypeByAnnotation(DeserializationConfig config, Annotated a, JavaType type, String propName) throws JsonMappingException {\n    AnnotationIntrospector intr \u003d config.getAnnotationIntrospector();\n    Class\u003c?\u003e subclass \u003d intr.findDeserializationType(a, type, propName);\n    if (subclass !\u003d null) {\n        try {\n            type \u003d type.narrowBy(subclass);\n        } catch (IllegalArgumentException iae) {\n            throw new JsonMappingException(\"Failed to narrow type \" + type + \" with concrete-type annotation (value \" + subclass.getName() + \"), method \u0027\" + a.getName() + \"\u0027: \" + iae.getMessage(), null, iae);\n        }\n    }\n    if (type.isContainerType()) {\n        Class\u003c?\u003e keyClass \u003d intr.findDeserializationKeyType(a, type.getKeyType(), propName);\n        if (keyClass !\u003d null) {\n            if (!(type instanceof MapLikeType)) {\n                throw new JsonMappingException(\"Illegal key-type annotation: type \" + type + \" is not a Map(-like) type\");\n            }\n            try {\n                type \u003d ((MapLikeType) type).narrowKey(keyClass);\n            } catch (IllegalArgumentException iae) {\n                throw new JsonMappingException(\"Failed to narrow key type \" + type + \" with key-type annotation (\" + keyClass.getName() + \"): \" + iae.getMessage(), null, iae);\n            }\n        }\n        JavaType keyType \u003d type.getKeyType();\n        if (keyType !\u003d null \u0026\u0026 keyType.getValueHandler() \u003d\u003d null) {\n            Object kdDef \u003d intr.findKeyDeserializer(a);\n            if (kdDef !\u003d null) {\n                KeyDeserializer kd \u003d null;\n                if (kdDef instanceof KeyDeserializer) {\n                    kd \u003d (KeyDeserializer) kdDef;\n                } else {\n                    Class\u003c?\u003e kdClass \u003d _verifyAsClass(kdDef, \"findKeyDeserializer\", KeyDeserializer.None.class);\n                    if (kdClass !\u003d null) {\n                        kd \u003d config.keyDeserializerInstance(a, kdClass);\n                    }\n                }\n                if (kd !\u003d null) {\n                    type \u003d ((MapLikeType) type).withKeyValueHandler(kd);\n                    keyType \u003d type.getKeyType();\n                }\n            }\n        }\n        Class\u003c?\u003e cc \u003d intr.findDeserializationContentType(a, type.getContentType(), propName);\n        if (cc !\u003d null) {\n            try {\n                type \u003d type.narrowContentsBy(cc);\n            } catch (IllegalArgumentException iae) {\n                throw new JsonMappingException(\"Failed to narrow content type \" + type + \" with content-type annotation (\" + cc.getName() + \"): \" + iae.getMessage(), null, iae);\n            }\n        }\n        JavaType contentType \u003d type.getContentType();\n        if (contentType.getValueHandler() \u003d\u003d null) {\n            Object cdDef \u003d intr.findContentDeserializer(a);\n            if (cdDef !\u003d null) {\n                JsonDeserializer\u003c?\u003e cd \u003d null;\n                if (cdDef instanceof JsonDeserializer\u003c?\u003e) {\n                    cdDef \u003d (JsonDeserializer\u003c?\u003e) cdDef;\n                } else {\n                    Class\u003c?\u003e cdClass \u003d _verifyAsClass(cdDef, \"findContentDeserializer\", JsonDeserializer.None.class);\n                    if (cdClass !\u003d null) {\n                        cd \u003d config.deserializerInstance(a, cdClass);\n                    }\n                }\n                if (cd !\u003d null) {\n                    type \u003d type.withContentValueHandler(cd);\n                }\n            }\n        }\n    }\n    return type;\n}",
          "path": "src/main/java/com/fasterxml/jackson/databind/deser/DeserializerCache.java",
          "functionStartLine": 522,
          "functionName": "modifyTypeByAnnotation",
          "functionAnnotation": "",
          "functionDoc": "Method called to see if given method has annotations that indicate\na more specific type than what the argument specifies.\nIf annotations are present, they must specify compatible Class;\ninstance of which can be assigned using the method. This means\nthat the Class has to be raw class of type, or its sub-class\n(or, implementing class if original Class instance is an interface).\n\n@param a Method or field that the type is associated with\n@param type Type derived from the setter argument\n@param propName Name of property that refers to type, if any; null\n  if no property information available (when modify type declaration\n  of a class, for example)\n@return Original type if no annotations are present; or a more\n  specific type derived from it if type annotation(s) was found\n@throws JsonMappingException if invalid annotation is found\n",
          "diff": "@@ -1,71 +1,70 @@\n-@SuppressWarnings({ \"unchecked\" })\n-protected \u003cT extends JavaType\u003e T modifyTypeByAnnotation(DeserializationConfig config, Annotated a, T type, String propName) throws JsonMappingException {\n+private JavaType modifyTypeByAnnotation(DeserializationConfig config, Annotated a, JavaType type, String propName) throws JsonMappingException {\n     AnnotationIntrospector intr \u003d config.getAnnotationIntrospector();\n     Class\u003c?\u003e subclass \u003d intr.findDeserializationType(a, type, propName);\n     if (subclass !\u003d null) {\n         try {\n-            type \u003d (T) type.narrowBy(subclass);\n+            type \u003d type.narrowBy(subclass);\n         } catch (IllegalArgumentException iae) {\n             throw new JsonMappingException(\"Failed to narrow type \" + type + \" with concrete-type annotation (value \" + subclass.getName() + \"), method \u0027\" + a.getName() + \"\u0027: \" + iae.getMessage(), null, iae);\n         }\n     }\n     if (type.isContainerType()) {\n         Class\u003c?\u003e keyClass \u003d intr.findDeserializationKeyType(a, type.getKeyType(), propName);\n         if (keyClass !\u003d null) {\n             if (!(type instanceof MapLikeType)) {\n                 throw new JsonMappingException(\"Illegal key-type annotation: type \" + type + \" is not a Map(-like) type\");\n             }\n             try {\n-                type \u003d (T) ((MapLikeType) type).narrowKey(keyClass);\n+                type \u003d ((MapLikeType) type).narrowKey(keyClass);\n             } catch (IllegalArgumentException iae) {\n                 throw new JsonMappingException(\"Failed to narrow key type \" + type + \" with key-type annotation (\" + keyClass.getName() + \"): \" + iae.getMessage(), null, iae);\n             }\n         }\n         JavaType keyType \u003d type.getKeyType();\n         if (keyType !\u003d null \u0026\u0026 keyType.getValueHandler() \u003d\u003d null) {\n             Object kdDef \u003d intr.findKeyDeserializer(a);\n             if (kdDef !\u003d null) {\n                 KeyDeserializer kd \u003d null;\n                 if (kdDef instanceof KeyDeserializer) {\n                     kd \u003d (KeyDeserializer) kdDef;\n                 } else {\n                     Class\u003c?\u003e kdClass \u003d _verifyAsClass(kdDef, \"findKeyDeserializer\", KeyDeserializer.None.class);\n                     if (kdClass !\u003d null) {\n                         kd \u003d config.keyDeserializerInstance(a, kdClass);\n                     }\n                 }\n                 if (kd !\u003d null) {\n-                    type \u003d (T) ((MapLikeType) type).withKeyValueHandler(kd);\n+                    type \u003d ((MapLikeType) type).withKeyValueHandler(kd);\n                     keyType \u003d type.getKeyType();\n                 }\n             }\n         }\n         Class\u003c?\u003e cc \u003d intr.findDeserializationContentType(a, type.getContentType(), propName);\n         if (cc !\u003d null) {\n             try {\n-                type \u003d (T) type.narrowContentsBy(cc);\n+                type \u003d type.narrowContentsBy(cc);\n             } catch (IllegalArgumentException iae) {\n                 throw new JsonMappingException(\"Failed to narrow content type \" + type + \" with content-type annotation (\" + cc.getName() + \"): \" + iae.getMessage(), null, iae);\n             }\n         }\n         JavaType contentType \u003d type.getContentType();\n         if (contentType.getValueHandler() \u003d\u003d null) {\n             Object cdDef \u003d intr.findContentDeserializer(a);\n             if (cdDef !\u003d null) {\n                 JsonDeserializer\u003c?\u003e cd \u003d null;\n                 if (cdDef instanceof JsonDeserializer\u003c?\u003e) {\n                     cdDef \u003d (JsonDeserializer\u003c?\u003e) cdDef;\n                 } else {\n                     Class\u003c?\u003e cdClass \u003d _verifyAsClass(cdDef, \"findContentDeserializer\", JsonDeserializer.None.class);\n                     if (cdClass !\u003d null) {\n                         cd \u003d config.deserializerInstance(a, cdClass);\n                     }\n                 }\n                 if (cd !\u003d null) {\n-                    type \u003d (T) type.withContentValueHandler(cd);\n+                    type \u003d type.withContentValueHandler(cd);\n                 }\n             }\n         }\n     }\n     return type;\n }\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldPath": "src/main/java/com/fasterxml/jackson/databind/deser/BasicDeserializerFactory.java",
            "newPath": "src/main/java/com/fasterxml/jackson/databind/deser/DeserializerCache.java",
            "oldMethodName": "modifyTypeByAnnotation",
            "newMethodName": "modifyTypeByAnnotation"
          }
        },
        {
          "type": "Yreturntypechange",
          "commitMessage": "Yet more refactoring, trying to remove back-refs from DeserializerFactory to context/cache\n",
          "commitDate": "1/24/12, 2:46 PM",
          "commitName": "bf355caa0821e58968df3bf6c12f612639224e47",
          "commitAuthor": "Tatu",
          "commitDateOld": "1/24/12, 1:27 PM",
          "commitNameOld": "f0b28a96644b3dc22c997a05975de335dfed0418",
          "commitAuthorOld": "Tatu",
          "daysBetweenCommits": 0.05,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "actualSource": "private JavaType modifyTypeByAnnotation(DeserializationConfig config, Annotated a, JavaType type, String propName) throws JsonMappingException {\n    AnnotationIntrospector intr \u003d config.getAnnotationIntrospector();\n    Class\u003c?\u003e subclass \u003d intr.findDeserializationType(a, type, propName);\n    if (subclass !\u003d null) {\n        try {\n            type \u003d type.narrowBy(subclass);\n        } catch (IllegalArgumentException iae) {\n            throw new JsonMappingException(\"Failed to narrow type \" + type + \" with concrete-type annotation (value \" + subclass.getName() + \"), method \u0027\" + a.getName() + \"\u0027: \" + iae.getMessage(), null, iae);\n        }\n    }\n    if (type.isContainerType()) {\n        Class\u003c?\u003e keyClass \u003d intr.findDeserializationKeyType(a, type.getKeyType(), propName);\n        if (keyClass !\u003d null) {\n            if (!(type instanceof MapLikeType)) {\n                throw new JsonMappingException(\"Illegal key-type annotation: type \" + type + \" is not a Map(-like) type\");\n            }\n            try {\n                type \u003d ((MapLikeType) type).narrowKey(keyClass);\n            } catch (IllegalArgumentException iae) {\n                throw new JsonMappingException(\"Failed to narrow key type \" + type + \" with key-type annotation (\" + keyClass.getName() + \"): \" + iae.getMessage(), null, iae);\n            }\n        }\n        JavaType keyType \u003d type.getKeyType();\n        if (keyType !\u003d null \u0026\u0026 keyType.getValueHandler() \u003d\u003d null) {\n            Object kdDef \u003d intr.findKeyDeserializer(a);\n            if (kdDef !\u003d null) {\n                KeyDeserializer kd \u003d null;\n                if (kdDef instanceof KeyDeserializer) {\n                    kd \u003d (KeyDeserializer) kdDef;\n                } else {\n                    Class\u003c?\u003e kdClass \u003d _verifyAsClass(kdDef, \"findKeyDeserializer\", KeyDeserializer.None.class);\n                    if (kdClass !\u003d null) {\n                        kd \u003d config.keyDeserializerInstance(a, kdClass);\n                    }\n                }\n                if (kd !\u003d null) {\n                    type \u003d ((MapLikeType) type).withKeyValueHandler(kd);\n                    keyType \u003d type.getKeyType();\n                }\n            }\n        }\n        Class\u003c?\u003e cc \u003d intr.findDeserializationContentType(a, type.getContentType(), propName);\n        if (cc !\u003d null) {\n            try {\n                type \u003d type.narrowContentsBy(cc);\n            } catch (IllegalArgumentException iae) {\n                throw new JsonMappingException(\"Failed to narrow content type \" + type + \" with content-type annotation (\" + cc.getName() + \"): \" + iae.getMessage(), null, iae);\n            }\n        }\n        JavaType contentType \u003d type.getContentType();\n        if (contentType.getValueHandler() \u003d\u003d null) {\n            Object cdDef \u003d intr.findContentDeserializer(a);\n            if (cdDef !\u003d null) {\n                JsonDeserializer\u003c?\u003e cd \u003d null;\n                if (cdDef instanceof JsonDeserializer\u003c?\u003e) {\n                    cdDef \u003d (JsonDeserializer\u003c?\u003e) cdDef;\n                } else {\n                    Class\u003c?\u003e cdClass \u003d _verifyAsClass(cdDef, \"findContentDeserializer\", JsonDeserializer.None.class);\n                    if (cdClass !\u003d null) {\n                        cd \u003d config.deserializerInstance(a, cdClass);\n                    }\n                }\n                if (cd !\u003d null) {\n                    type \u003d type.withContentValueHandler(cd);\n                }\n            }\n        }\n    }\n    return type;\n}",
          "path": "src/main/java/com/fasterxml/jackson/databind/deser/DeserializerCache.java",
          "functionStartLine": 522,
          "functionName": "modifyTypeByAnnotation",
          "functionAnnotation": "",
          "functionDoc": "Method called to see if given method has annotations that indicate\na more specific type than what the argument specifies.\nIf annotations are present, they must specify compatible Class;\ninstance of which can be assigned using the method. This means\nthat the Class has to be raw class of type, or its sub-class\n(or, implementing class if original Class instance is an interface).\n\n@param a Method or field that the type is associated with\n@param type Type derived from the setter argument\n@param propName Name of property that refers to type, if any; null\n  if no property information available (when modify type declaration\n  of a class, for example)\n@return Original type if no annotations are present; or a more\n  specific type derived from it if type annotation(s) was found\n@throws JsonMappingException if invalid annotation is found\n",
          "diff": "@@ -1,71 +1,70 @@\n-@SuppressWarnings({ \"unchecked\" })\n-protected \u003cT extends JavaType\u003e T modifyTypeByAnnotation(DeserializationConfig config, Annotated a, T type, String propName) throws JsonMappingException {\n+private JavaType modifyTypeByAnnotation(DeserializationConfig config, Annotated a, JavaType type, String propName) throws JsonMappingException {\n     AnnotationIntrospector intr \u003d config.getAnnotationIntrospector();\n     Class\u003c?\u003e subclass \u003d intr.findDeserializationType(a, type, propName);\n     if (subclass !\u003d null) {\n         try {\n-            type \u003d (T) type.narrowBy(subclass);\n+            type \u003d type.narrowBy(subclass);\n         } catch (IllegalArgumentException iae) {\n             throw new JsonMappingException(\"Failed to narrow type \" + type + \" with concrete-type annotation (value \" + subclass.getName() + \"), method \u0027\" + a.getName() + \"\u0027: \" + iae.getMessage(), null, iae);\n         }\n     }\n     if (type.isContainerType()) {\n         Class\u003c?\u003e keyClass \u003d intr.findDeserializationKeyType(a, type.getKeyType(), propName);\n         if (keyClass !\u003d null) {\n             if (!(type instanceof MapLikeType)) {\n                 throw new JsonMappingException(\"Illegal key-type annotation: type \" + type + \" is not a Map(-like) type\");\n             }\n             try {\n-                type \u003d (T) ((MapLikeType) type).narrowKey(keyClass);\n+                type \u003d ((MapLikeType) type).narrowKey(keyClass);\n             } catch (IllegalArgumentException iae) {\n                 throw new JsonMappingException(\"Failed to narrow key type \" + type + \" with key-type annotation (\" + keyClass.getName() + \"): \" + iae.getMessage(), null, iae);\n             }\n         }\n         JavaType keyType \u003d type.getKeyType();\n         if (keyType !\u003d null \u0026\u0026 keyType.getValueHandler() \u003d\u003d null) {\n             Object kdDef \u003d intr.findKeyDeserializer(a);\n             if (kdDef !\u003d null) {\n                 KeyDeserializer kd \u003d null;\n                 if (kdDef instanceof KeyDeserializer) {\n                     kd \u003d (KeyDeserializer) kdDef;\n                 } else {\n                     Class\u003c?\u003e kdClass \u003d _verifyAsClass(kdDef, \"findKeyDeserializer\", KeyDeserializer.None.class);\n                     if (kdClass !\u003d null) {\n                         kd \u003d config.keyDeserializerInstance(a, kdClass);\n                     }\n                 }\n                 if (kd !\u003d null) {\n-                    type \u003d (T) ((MapLikeType) type).withKeyValueHandler(kd);\n+                    type \u003d ((MapLikeType) type).withKeyValueHandler(kd);\n                     keyType \u003d type.getKeyType();\n                 }\n             }\n         }\n         Class\u003c?\u003e cc \u003d intr.findDeserializationContentType(a, type.getContentType(), propName);\n         if (cc !\u003d null) {\n             try {\n-                type \u003d (T) type.narrowContentsBy(cc);\n+                type \u003d type.narrowContentsBy(cc);\n             } catch (IllegalArgumentException iae) {\n                 throw new JsonMappingException(\"Failed to narrow content type \" + type + \" with content-type annotation (\" + cc.getName() + \"): \" + iae.getMessage(), null, iae);\n             }\n         }\n         JavaType contentType \u003d type.getContentType();\n         if (contentType.getValueHandler() \u003d\u003d null) {\n             Object cdDef \u003d intr.findContentDeserializer(a);\n             if (cdDef !\u003d null) {\n                 JsonDeserializer\u003c?\u003e cd \u003d null;\n                 if (cdDef instanceof JsonDeserializer\u003c?\u003e) {\n                     cdDef \u003d (JsonDeserializer\u003c?\u003e) cdDef;\n                 } else {\n                     Class\u003c?\u003e cdClass \u003d _verifyAsClass(cdDef, \"findContentDeserializer\", JsonDeserializer.None.class);\n                     if (cdClass !\u003d null) {\n                         cd \u003d config.deserializerInstance(a, cdClass);\n                     }\n                 }\n                 if (cd !\u003d null) {\n-                    type \u003d (T) type.withContentValueHandler(cd);\n+                    type \u003d type.withContentValueHandler(cd);\n                 }\n             }\n         }\n     }\n     return type;\n }\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldValue": "T",
            "newValue": "JavaType"
          }
        },
        {
          "type": "Ymodifierchange",
          "commitMessage": "Yet more refactoring, trying to remove back-refs from DeserializerFactory to context/cache\n",
          "commitDate": "1/24/12, 2:46 PM",
          "commitName": "bf355caa0821e58968df3bf6c12f612639224e47",
          "commitAuthor": "Tatu",
          "commitDateOld": "1/24/12, 1:27 PM",
          "commitNameOld": "f0b28a96644b3dc22c997a05975de335dfed0418",
          "commitAuthorOld": "Tatu",
          "daysBetweenCommits": 0.05,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "actualSource": "private JavaType modifyTypeByAnnotation(DeserializationConfig config, Annotated a, JavaType type, String propName) throws JsonMappingException {\n    AnnotationIntrospector intr \u003d config.getAnnotationIntrospector();\n    Class\u003c?\u003e subclass \u003d intr.findDeserializationType(a, type, propName);\n    if (subclass !\u003d null) {\n        try {\n            type \u003d type.narrowBy(subclass);\n        } catch (IllegalArgumentException iae) {\n            throw new JsonMappingException(\"Failed to narrow type \" + type + \" with concrete-type annotation (value \" + subclass.getName() + \"), method \u0027\" + a.getName() + \"\u0027: \" + iae.getMessage(), null, iae);\n        }\n    }\n    if (type.isContainerType()) {\n        Class\u003c?\u003e keyClass \u003d intr.findDeserializationKeyType(a, type.getKeyType(), propName);\n        if (keyClass !\u003d null) {\n            if (!(type instanceof MapLikeType)) {\n                throw new JsonMappingException(\"Illegal key-type annotation: type \" + type + \" is not a Map(-like) type\");\n            }\n            try {\n                type \u003d ((MapLikeType) type).narrowKey(keyClass);\n            } catch (IllegalArgumentException iae) {\n                throw new JsonMappingException(\"Failed to narrow key type \" + type + \" with key-type annotation (\" + keyClass.getName() + \"): \" + iae.getMessage(), null, iae);\n            }\n        }\n        JavaType keyType \u003d type.getKeyType();\n        if (keyType !\u003d null \u0026\u0026 keyType.getValueHandler() \u003d\u003d null) {\n            Object kdDef \u003d intr.findKeyDeserializer(a);\n            if (kdDef !\u003d null) {\n                KeyDeserializer kd \u003d null;\n                if (kdDef instanceof KeyDeserializer) {\n                    kd \u003d (KeyDeserializer) kdDef;\n                } else {\n                    Class\u003c?\u003e kdClass \u003d _verifyAsClass(kdDef, \"findKeyDeserializer\", KeyDeserializer.None.class);\n                    if (kdClass !\u003d null) {\n                        kd \u003d config.keyDeserializerInstance(a, kdClass);\n                    }\n                }\n                if (kd !\u003d null) {\n                    type \u003d ((MapLikeType) type).withKeyValueHandler(kd);\n                    keyType \u003d type.getKeyType();\n                }\n            }\n        }\n        Class\u003c?\u003e cc \u003d intr.findDeserializationContentType(a, type.getContentType(), propName);\n        if (cc !\u003d null) {\n            try {\n                type \u003d type.narrowContentsBy(cc);\n            } catch (IllegalArgumentException iae) {\n                throw new JsonMappingException(\"Failed to narrow content type \" + type + \" with content-type annotation (\" + cc.getName() + \"): \" + iae.getMessage(), null, iae);\n            }\n        }\n        JavaType contentType \u003d type.getContentType();\n        if (contentType.getValueHandler() \u003d\u003d null) {\n            Object cdDef \u003d intr.findContentDeserializer(a);\n            if (cdDef !\u003d null) {\n                JsonDeserializer\u003c?\u003e cd \u003d null;\n                if (cdDef instanceof JsonDeserializer\u003c?\u003e) {\n                    cdDef \u003d (JsonDeserializer\u003c?\u003e) cdDef;\n                } else {\n                    Class\u003c?\u003e cdClass \u003d _verifyAsClass(cdDef, \"findContentDeserializer\", JsonDeserializer.None.class);\n                    if (cdClass !\u003d null) {\n                        cd \u003d config.deserializerInstance(a, cdClass);\n                    }\n                }\n                if (cd !\u003d null) {\n                    type \u003d type.withContentValueHandler(cd);\n                }\n            }\n        }\n    }\n    return type;\n}",
          "path": "src/main/java/com/fasterxml/jackson/databind/deser/DeserializerCache.java",
          "functionStartLine": 522,
          "functionName": "modifyTypeByAnnotation",
          "functionAnnotation": "",
          "functionDoc": "Method called to see if given method has annotations that indicate\na more specific type than what the argument specifies.\nIf annotations are present, they must specify compatible Class;\ninstance of which can be assigned using the method. This means\nthat the Class has to be raw class of type, or its sub-class\n(or, implementing class if original Class instance is an interface).\n\n@param a Method or field that the type is associated with\n@param type Type derived from the setter argument\n@param propName Name of property that refers to type, if any; null\n  if no property information available (when modify type declaration\n  of a class, for example)\n@return Original type if no annotations are present; or a more\n  specific type derived from it if type annotation(s) was found\n@throws JsonMappingException if invalid annotation is found\n",
          "diff": "@@ -1,71 +1,70 @@\n-@SuppressWarnings({ \"unchecked\" })\n-protected \u003cT extends JavaType\u003e T modifyTypeByAnnotation(DeserializationConfig config, Annotated a, T type, String propName) throws JsonMappingException {\n+private JavaType modifyTypeByAnnotation(DeserializationConfig config, Annotated a, JavaType type, String propName) throws JsonMappingException {\n     AnnotationIntrospector intr \u003d config.getAnnotationIntrospector();\n     Class\u003c?\u003e subclass \u003d intr.findDeserializationType(a, type, propName);\n     if (subclass !\u003d null) {\n         try {\n-            type \u003d (T) type.narrowBy(subclass);\n+            type \u003d type.narrowBy(subclass);\n         } catch (IllegalArgumentException iae) {\n             throw new JsonMappingException(\"Failed to narrow type \" + type + \" with concrete-type annotation (value \" + subclass.getName() + \"), method \u0027\" + a.getName() + \"\u0027: \" + iae.getMessage(), null, iae);\n         }\n     }\n     if (type.isContainerType()) {\n         Class\u003c?\u003e keyClass \u003d intr.findDeserializationKeyType(a, type.getKeyType(), propName);\n         if (keyClass !\u003d null) {\n             if (!(type instanceof MapLikeType)) {\n                 throw new JsonMappingException(\"Illegal key-type annotation: type \" + type + \" is not a Map(-like) type\");\n             }\n             try {\n-                type \u003d (T) ((MapLikeType) type).narrowKey(keyClass);\n+                type \u003d ((MapLikeType) type).narrowKey(keyClass);\n             } catch (IllegalArgumentException iae) {\n                 throw new JsonMappingException(\"Failed to narrow key type \" + type + \" with key-type annotation (\" + keyClass.getName() + \"): \" + iae.getMessage(), null, iae);\n             }\n         }\n         JavaType keyType \u003d type.getKeyType();\n         if (keyType !\u003d null \u0026\u0026 keyType.getValueHandler() \u003d\u003d null) {\n             Object kdDef \u003d intr.findKeyDeserializer(a);\n             if (kdDef !\u003d null) {\n                 KeyDeserializer kd \u003d null;\n                 if (kdDef instanceof KeyDeserializer) {\n                     kd \u003d (KeyDeserializer) kdDef;\n                 } else {\n                     Class\u003c?\u003e kdClass \u003d _verifyAsClass(kdDef, \"findKeyDeserializer\", KeyDeserializer.None.class);\n                     if (kdClass !\u003d null) {\n                         kd \u003d config.keyDeserializerInstance(a, kdClass);\n                     }\n                 }\n                 if (kd !\u003d null) {\n-                    type \u003d (T) ((MapLikeType) type).withKeyValueHandler(kd);\n+                    type \u003d ((MapLikeType) type).withKeyValueHandler(kd);\n                     keyType \u003d type.getKeyType();\n                 }\n             }\n         }\n         Class\u003c?\u003e cc \u003d intr.findDeserializationContentType(a, type.getContentType(), propName);\n         if (cc !\u003d null) {\n             try {\n-                type \u003d (T) type.narrowContentsBy(cc);\n+                type \u003d type.narrowContentsBy(cc);\n             } catch (IllegalArgumentException iae) {\n                 throw new JsonMappingException(\"Failed to narrow content type \" + type + \" with content-type annotation (\" + cc.getName() + \"): \" + iae.getMessage(), null, iae);\n             }\n         }\n         JavaType contentType \u003d type.getContentType();\n         if (contentType.getValueHandler() \u003d\u003d null) {\n             Object cdDef \u003d intr.findContentDeserializer(a);\n             if (cdDef !\u003d null) {\n                 JsonDeserializer\u003c?\u003e cd \u003d null;\n                 if (cdDef instanceof JsonDeserializer\u003c?\u003e) {\n                     cdDef \u003d (JsonDeserializer\u003c?\u003e) cdDef;\n                 } else {\n                     Class\u003c?\u003e cdClass \u003d _verifyAsClass(cdDef, \"findContentDeserializer\", JsonDeserializer.None.class);\n                     if (cdClass !\u003d null) {\n                         cd \u003d config.deserializerInstance(a, cdClass);\n                     }\n                 }\n                 if (cd !\u003d null) {\n-                    type \u003d (T) type.withContentValueHandler(cd);\n+                    type \u003d type.withContentValueHandler(cd);\n                 }\n             }\n         }\n     }\n     return type;\n }\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldValue": "[protected]",
            "newValue": "[private]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "Yet more refactoring, trying to remove back-refs from DeserializerFactory to context/cache\n",
          "commitDate": "1/24/12, 2:46 PM",
          "commitName": "bf355caa0821e58968df3bf6c12f612639224e47",
          "commitAuthor": "Tatu",
          "commitDateOld": "1/24/12, 1:27 PM",
          "commitNameOld": "f0b28a96644b3dc22c997a05975de335dfed0418",
          "commitAuthorOld": "Tatu",
          "daysBetweenCommits": 0.05,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "actualSource": "private JavaType modifyTypeByAnnotation(DeserializationConfig config, Annotated a, JavaType type, String propName) throws JsonMappingException {\n    AnnotationIntrospector intr \u003d config.getAnnotationIntrospector();\n    Class\u003c?\u003e subclass \u003d intr.findDeserializationType(a, type, propName);\n    if (subclass !\u003d null) {\n        try {\n            type \u003d type.narrowBy(subclass);\n        } catch (IllegalArgumentException iae) {\n            throw new JsonMappingException(\"Failed to narrow type \" + type + \" with concrete-type annotation (value \" + subclass.getName() + \"), method \u0027\" + a.getName() + \"\u0027: \" + iae.getMessage(), null, iae);\n        }\n    }\n    if (type.isContainerType()) {\n        Class\u003c?\u003e keyClass \u003d intr.findDeserializationKeyType(a, type.getKeyType(), propName);\n        if (keyClass !\u003d null) {\n            if (!(type instanceof MapLikeType)) {\n                throw new JsonMappingException(\"Illegal key-type annotation: type \" + type + \" is not a Map(-like) type\");\n            }\n            try {\n                type \u003d ((MapLikeType) type).narrowKey(keyClass);\n            } catch (IllegalArgumentException iae) {\n                throw new JsonMappingException(\"Failed to narrow key type \" + type + \" with key-type annotation (\" + keyClass.getName() + \"): \" + iae.getMessage(), null, iae);\n            }\n        }\n        JavaType keyType \u003d type.getKeyType();\n        if (keyType !\u003d null \u0026\u0026 keyType.getValueHandler() \u003d\u003d null) {\n            Object kdDef \u003d intr.findKeyDeserializer(a);\n            if (kdDef !\u003d null) {\n                KeyDeserializer kd \u003d null;\n                if (kdDef instanceof KeyDeserializer) {\n                    kd \u003d (KeyDeserializer) kdDef;\n                } else {\n                    Class\u003c?\u003e kdClass \u003d _verifyAsClass(kdDef, \"findKeyDeserializer\", KeyDeserializer.None.class);\n                    if (kdClass !\u003d null) {\n                        kd \u003d config.keyDeserializerInstance(a, kdClass);\n                    }\n                }\n                if (kd !\u003d null) {\n                    type \u003d ((MapLikeType) type).withKeyValueHandler(kd);\n                    keyType \u003d type.getKeyType();\n                }\n            }\n        }\n        Class\u003c?\u003e cc \u003d intr.findDeserializationContentType(a, type.getContentType(), propName);\n        if (cc !\u003d null) {\n            try {\n                type \u003d type.narrowContentsBy(cc);\n            } catch (IllegalArgumentException iae) {\n                throw new JsonMappingException(\"Failed to narrow content type \" + type + \" with content-type annotation (\" + cc.getName() + \"): \" + iae.getMessage(), null, iae);\n            }\n        }\n        JavaType contentType \u003d type.getContentType();\n        if (contentType.getValueHandler() \u003d\u003d null) {\n            Object cdDef \u003d intr.findContentDeserializer(a);\n            if (cdDef !\u003d null) {\n                JsonDeserializer\u003c?\u003e cd \u003d null;\n                if (cdDef instanceof JsonDeserializer\u003c?\u003e) {\n                    cdDef \u003d (JsonDeserializer\u003c?\u003e) cdDef;\n                } else {\n                    Class\u003c?\u003e cdClass \u003d _verifyAsClass(cdDef, \"findContentDeserializer\", JsonDeserializer.None.class);\n                    if (cdClass !\u003d null) {\n                        cd \u003d config.deserializerInstance(a, cdClass);\n                    }\n                }\n                if (cd !\u003d null) {\n                    type \u003d type.withContentValueHandler(cd);\n                }\n            }\n        }\n    }\n    return type;\n}",
          "path": "src/main/java/com/fasterxml/jackson/databind/deser/DeserializerCache.java",
          "functionStartLine": 522,
          "functionName": "modifyTypeByAnnotation",
          "functionAnnotation": "",
          "functionDoc": "Method called to see if given method has annotations that indicate\na more specific type than what the argument specifies.\nIf annotations are present, they must specify compatible Class;\ninstance of which can be assigned using the method. This means\nthat the Class has to be raw class of type, or its sub-class\n(or, implementing class if original Class instance is an interface).\n\n@param a Method or field that the type is associated with\n@param type Type derived from the setter argument\n@param propName Name of property that refers to type, if any; null\n  if no property information available (when modify type declaration\n  of a class, for example)\n@return Original type if no annotations are present; or a more\n  specific type derived from it if type annotation(s) was found\n@throws JsonMappingException if invalid annotation is found\n",
          "diff": "@@ -1,71 +1,70 @@\n-@SuppressWarnings({ \"unchecked\" })\n-protected \u003cT extends JavaType\u003e T modifyTypeByAnnotation(DeserializationConfig config, Annotated a, T type, String propName) throws JsonMappingException {\n+private JavaType modifyTypeByAnnotation(DeserializationConfig config, Annotated a, JavaType type, String propName) throws JsonMappingException {\n     AnnotationIntrospector intr \u003d config.getAnnotationIntrospector();\n     Class\u003c?\u003e subclass \u003d intr.findDeserializationType(a, type, propName);\n     if (subclass !\u003d null) {\n         try {\n-            type \u003d (T) type.narrowBy(subclass);\n+            type \u003d type.narrowBy(subclass);\n         } catch (IllegalArgumentException iae) {\n             throw new JsonMappingException(\"Failed to narrow type \" + type + \" with concrete-type annotation (value \" + subclass.getName() + \"), method \u0027\" + a.getName() + \"\u0027: \" + iae.getMessage(), null, iae);\n         }\n     }\n     if (type.isContainerType()) {\n         Class\u003c?\u003e keyClass \u003d intr.findDeserializationKeyType(a, type.getKeyType(), propName);\n         if (keyClass !\u003d null) {\n             if (!(type instanceof MapLikeType)) {\n                 throw new JsonMappingException(\"Illegal key-type annotation: type \" + type + \" is not a Map(-like) type\");\n             }\n             try {\n-                type \u003d (T) ((MapLikeType) type).narrowKey(keyClass);\n+                type \u003d ((MapLikeType) type).narrowKey(keyClass);\n             } catch (IllegalArgumentException iae) {\n                 throw new JsonMappingException(\"Failed to narrow key type \" + type + \" with key-type annotation (\" + keyClass.getName() + \"): \" + iae.getMessage(), null, iae);\n             }\n         }\n         JavaType keyType \u003d type.getKeyType();\n         if (keyType !\u003d null \u0026\u0026 keyType.getValueHandler() \u003d\u003d null) {\n             Object kdDef \u003d intr.findKeyDeserializer(a);\n             if (kdDef !\u003d null) {\n                 KeyDeserializer kd \u003d null;\n                 if (kdDef instanceof KeyDeserializer) {\n                     kd \u003d (KeyDeserializer) kdDef;\n                 } else {\n                     Class\u003c?\u003e kdClass \u003d _verifyAsClass(kdDef, \"findKeyDeserializer\", KeyDeserializer.None.class);\n                     if (kdClass !\u003d null) {\n                         kd \u003d config.keyDeserializerInstance(a, kdClass);\n                     }\n                 }\n                 if (kd !\u003d null) {\n-                    type \u003d (T) ((MapLikeType) type).withKeyValueHandler(kd);\n+                    type \u003d ((MapLikeType) type).withKeyValueHandler(kd);\n                     keyType \u003d type.getKeyType();\n                 }\n             }\n         }\n         Class\u003c?\u003e cc \u003d intr.findDeserializationContentType(a, type.getContentType(), propName);\n         if (cc !\u003d null) {\n             try {\n-                type \u003d (T) type.narrowContentsBy(cc);\n+                type \u003d type.narrowContentsBy(cc);\n             } catch (IllegalArgumentException iae) {\n                 throw new JsonMappingException(\"Failed to narrow content type \" + type + \" with content-type annotation (\" + cc.getName() + \"): \" + iae.getMessage(), null, iae);\n             }\n         }\n         JavaType contentType \u003d type.getContentType();\n         if (contentType.getValueHandler() \u003d\u003d null) {\n             Object cdDef \u003d intr.findContentDeserializer(a);\n             if (cdDef !\u003d null) {\n                 JsonDeserializer\u003c?\u003e cd \u003d null;\n                 if (cdDef instanceof JsonDeserializer\u003c?\u003e) {\n                     cdDef \u003d (JsonDeserializer\u003c?\u003e) cdDef;\n                 } else {\n                     Class\u003c?\u003e cdClass \u003d _verifyAsClass(cdDef, \"findContentDeserializer\", JsonDeserializer.None.class);\n                     if (cdClass !\u003d null) {\n                         cd \u003d config.deserializerInstance(a, cdClass);\n                     }\n                 }\n                 if (cd !\u003d null) {\n-                    type \u003d (T) type.withContentValueHandler(cd);\n+                    type \u003d type.withContentValueHandler(cd);\n                 }\n             }\n         }\n     }\n     return type;\n }\n\\ No newline at end of file\n",
          "extendedDetails": {}
        },
        {
          "type": "Yannotationchange",
          "commitMessage": "Yet more refactoring, trying to remove back-refs from DeserializerFactory to context/cache\n",
          "commitDate": "1/24/12, 2:46 PM",
          "commitName": "bf355caa0821e58968df3bf6c12f612639224e47",
          "commitAuthor": "Tatu",
          "commitDateOld": "1/24/12, 1:27 PM",
          "commitNameOld": "f0b28a96644b3dc22c997a05975de335dfed0418",
          "commitAuthorOld": "Tatu",
          "daysBetweenCommits": 0.05,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "actualSource": "private JavaType modifyTypeByAnnotation(DeserializationConfig config, Annotated a, JavaType type, String propName) throws JsonMappingException {\n    AnnotationIntrospector intr \u003d config.getAnnotationIntrospector();\n    Class\u003c?\u003e subclass \u003d intr.findDeserializationType(a, type, propName);\n    if (subclass !\u003d null) {\n        try {\n            type \u003d type.narrowBy(subclass);\n        } catch (IllegalArgumentException iae) {\n            throw new JsonMappingException(\"Failed to narrow type \" + type + \" with concrete-type annotation (value \" + subclass.getName() + \"), method \u0027\" + a.getName() + \"\u0027: \" + iae.getMessage(), null, iae);\n        }\n    }\n    if (type.isContainerType()) {\n        Class\u003c?\u003e keyClass \u003d intr.findDeserializationKeyType(a, type.getKeyType(), propName);\n        if (keyClass !\u003d null) {\n            if (!(type instanceof MapLikeType)) {\n                throw new JsonMappingException(\"Illegal key-type annotation: type \" + type + \" is not a Map(-like) type\");\n            }\n            try {\n                type \u003d ((MapLikeType) type).narrowKey(keyClass);\n            } catch (IllegalArgumentException iae) {\n                throw new JsonMappingException(\"Failed to narrow key type \" + type + \" with key-type annotation (\" + keyClass.getName() + \"): \" + iae.getMessage(), null, iae);\n            }\n        }\n        JavaType keyType \u003d type.getKeyType();\n        if (keyType !\u003d null \u0026\u0026 keyType.getValueHandler() \u003d\u003d null) {\n            Object kdDef \u003d intr.findKeyDeserializer(a);\n            if (kdDef !\u003d null) {\n                KeyDeserializer kd \u003d null;\n                if (kdDef instanceof KeyDeserializer) {\n                    kd \u003d (KeyDeserializer) kdDef;\n                } else {\n                    Class\u003c?\u003e kdClass \u003d _verifyAsClass(kdDef, \"findKeyDeserializer\", KeyDeserializer.None.class);\n                    if (kdClass !\u003d null) {\n                        kd \u003d config.keyDeserializerInstance(a, kdClass);\n                    }\n                }\n                if (kd !\u003d null) {\n                    type \u003d ((MapLikeType) type).withKeyValueHandler(kd);\n                    keyType \u003d type.getKeyType();\n                }\n            }\n        }\n        Class\u003c?\u003e cc \u003d intr.findDeserializationContentType(a, type.getContentType(), propName);\n        if (cc !\u003d null) {\n            try {\n                type \u003d type.narrowContentsBy(cc);\n            } catch (IllegalArgumentException iae) {\n                throw new JsonMappingException(\"Failed to narrow content type \" + type + \" with content-type annotation (\" + cc.getName() + \"): \" + iae.getMessage(), null, iae);\n            }\n        }\n        JavaType contentType \u003d type.getContentType();\n        if (contentType.getValueHandler() \u003d\u003d null) {\n            Object cdDef \u003d intr.findContentDeserializer(a);\n            if (cdDef !\u003d null) {\n                JsonDeserializer\u003c?\u003e cd \u003d null;\n                if (cdDef instanceof JsonDeserializer\u003c?\u003e) {\n                    cdDef \u003d (JsonDeserializer\u003c?\u003e) cdDef;\n                } else {\n                    Class\u003c?\u003e cdClass \u003d _verifyAsClass(cdDef, \"findContentDeserializer\", JsonDeserializer.None.class);\n                    if (cdClass !\u003d null) {\n                        cd \u003d config.deserializerInstance(a, cdClass);\n                    }\n                }\n                if (cd !\u003d null) {\n                    type \u003d type.withContentValueHandler(cd);\n                }\n            }\n        }\n    }\n    return type;\n}",
          "path": "src/main/java/com/fasterxml/jackson/databind/deser/DeserializerCache.java",
          "functionStartLine": 522,
          "functionName": "modifyTypeByAnnotation",
          "functionAnnotation": "",
          "functionDoc": "Method called to see if given method has annotations that indicate\na more specific type than what the argument specifies.\nIf annotations are present, they must specify compatible Class;\ninstance of which can be assigned using the method. This means\nthat the Class has to be raw class of type, or its sub-class\n(or, implementing class if original Class instance is an interface).\n\n@param a Method or field that the type is associated with\n@param type Type derived from the setter argument\n@param propName Name of property that refers to type, if any; null\n  if no property information available (when modify type declaration\n  of a class, for example)\n@return Original type if no annotations are present; or a more\n  specific type derived from it if type annotation(s) was found\n@throws JsonMappingException if invalid annotation is found\n",
          "diff": "@@ -1,71 +1,70 @@\n-@SuppressWarnings({ \"unchecked\" })\n-protected \u003cT extends JavaType\u003e T modifyTypeByAnnotation(DeserializationConfig config, Annotated a, T type, String propName) throws JsonMappingException {\n+private JavaType modifyTypeByAnnotation(DeserializationConfig config, Annotated a, JavaType type, String propName) throws JsonMappingException {\n     AnnotationIntrospector intr \u003d config.getAnnotationIntrospector();\n     Class\u003c?\u003e subclass \u003d intr.findDeserializationType(a, type, propName);\n     if (subclass !\u003d null) {\n         try {\n-            type \u003d (T) type.narrowBy(subclass);\n+            type \u003d type.narrowBy(subclass);\n         } catch (IllegalArgumentException iae) {\n             throw new JsonMappingException(\"Failed to narrow type \" + type + \" with concrete-type annotation (value \" + subclass.getName() + \"), method \u0027\" + a.getName() + \"\u0027: \" + iae.getMessage(), null, iae);\n         }\n     }\n     if (type.isContainerType()) {\n         Class\u003c?\u003e keyClass \u003d intr.findDeserializationKeyType(a, type.getKeyType(), propName);\n         if (keyClass !\u003d null) {\n             if (!(type instanceof MapLikeType)) {\n                 throw new JsonMappingException(\"Illegal key-type annotation: type \" + type + \" is not a Map(-like) type\");\n             }\n             try {\n-                type \u003d (T) ((MapLikeType) type).narrowKey(keyClass);\n+                type \u003d ((MapLikeType) type).narrowKey(keyClass);\n             } catch (IllegalArgumentException iae) {\n                 throw new JsonMappingException(\"Failed to narrow key type \" + type + \" with key-type annotation (\" + keyClass.getName() + \"): \" + iae.getMessage(), null, iae);\n             }\n         }\n         JavaType keyType \u003d type.getKeyType();\n         if (keyType !\u003d null \u0026\u0026 keyType.getValueHandler() \u003d\u003d null) {\n             Object kdDef \u003d intr.findKeyDeserializer(a);\n             if (kdDef !\u003d null) {\n                 KeyDeserializer kd \u003d null;\n                 if (kdDef instanceof KeyDeserializer) {\n                     kd \u003d (KeyDeserializer) kdDef;\n                 } else {\n                     Class\u003c?\u003e kdClass \u003d _verifyAsClass(kdDef, \"findKeyDeserializer\", KeyDeserializer.None.class);\n                     if (kdClass !\u003d null) {\n                         kd \u003d config.keyDeserializerInstance(a, kdClass);\n                     }\n                 }\n                 if (kd !\u003d null) {\n-                    type \u003d (T) ((MapLikeType) type).withKeyValueHandler(kd);\n+                    type \u003d ((MapLikeType) type).withKeyValueHandler(kd);\n                     keyType \u003d type.getKeyType();\n                 }\n             }\n         }\n         Class\u003c?\u003e cc \u003d intr.findDeserializationContentType(a, type.getContentType(), propName);\n         if (cc !\u003d null) {\n             try {\n-                type \u003d (T) type.narrowContentsBy(cc);\n+                type \u003d type.narrowContentsBy(cc);\n             } catch (IllegalArgumentException iae) {\n                 throw new JsonMappingException(\"Failed to narrow content type \" + type + \" with content-type annotation (\" + cc.getName() + \"): \" + iae.getMessage(), null, iae);\n             }\n         }\n         JavaType contentType \u003d type.getContentType();\n         if (contentType.getValueHandler() \u003d\u003d null) {\n             Object cdDef \u003d intr.findContentDeserializer(a);\n             if (cdDef !\u003d null) {\n                 JsonDeserializer\u003c?\u003e cd \u003d null;\n                 if (cdDef instanceof JsonDeserializer\u003c?\u003e) {\n                     cdDef \u003d (JsonDeserializer\u003c?\u003e) cdDef;\n                 } else {\n                     Class\u003c?\u003e cdClass \u003d _verifyAsClass(cdDef, \"findContentDeserializer\", JsonDeserializer.None.class);\n                     if (cdClass !\u003d null) {\n                         cd \u003d config.deserializerInstance(a, cdClass);\n                     }\n                 }\n                 if (cd !\u003d null) {\n-                    type \u003d (T) type.withContentValueHandler(cd);\n+                    type \u003d type.withContentValueHandler(cd);\n                 }\n             }\n         }\n     }\n     return type;\n }\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldValue": "@SuppressWarnings({ \"unchecked\" })",
            "newValue": ""
          }
        },
        {
          "type": "Yparameterchange",
          "commitMessage": "Yet more refactoring, trying to remove back-refs from DeserializerFactory to context/cache\n",
          "commitDate": "1/24/12, 2:46 PM",
          "commitName": "bf355caa0821e58968df3bf6c12f612639224e47",
          "commitAuthor": "Tatu",
          "commitDateOld": "1/24/12, 1:27 PM",
          "commitNameOld": "f0b28a96644b3dc22c997a05975de335dfed0418",
          "commitAuthorOld": "Tatu",
          "daysBetweenCommits": 0.05,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "actualSource": "private JavaType modifyTypeByAnnotation(DeserializationConfig config, Annotated a, JavaType type, String propName) throws JsonMappingException {\n    AnnotationIntrospector intr \u003d config.getAnnotationIntrospector();\n    Class\u003c?\u003e subclass \u003d intr.findDeserializationType(a, type, propName);\n    if (subclass !\u003d null) {\n        try {\n            type \u003d type.narrowBy(subclass);\n        } catch (IllegalArgumentException iae) {\n            throw new JsonMappingException(\"Failed to narrow type \" + type + \" with concrete-type annotation (value \" + subclass.getName() + \"), method \u0027\" + a.getName() + \"\u0027: \" + iae.getMessage(), null, iae);\n        }\n    }\n    if (type.isContainerType()) {\n        Class\u003c?\u003e keyClass \u003d intr.findDeserializationKeyType(a, type.getKeyType(), propName);\n        if (keyClass !\u003d null) {\n            if (!(type instanceof MapLikeType)) {\n                throw new JsonMappingException(\"Illegal key-type annotation: type \" + type + \" is not a Map(-like) type\");\n            }\n            try {\n                type \u003d ((MapLikeType) type).narrowKey(keyClass);\n            } catch (IllegalArgumentException iae) {\n                throw new JsonMappingException(\"Failed to narrow key type \" + type + \" with key-type annotation (\" + keyClass.getName() + \"): \" + iae.getMessage(), null, iae);\n            }\n        }\n        JavaType keyType \u003d type.getKeyType();\n        if (keyType !\u003d null \u0026\u0026 keyType.getValueHandler() \u003d\u003d null) {\n            Object kdDef \u003d intr.findKeyDeserializer(a);\n            if (kdDef !\u003d null) {\n                KeyDeserializer kd \u003d null;\n                if (kdDef instanceof KeyDeserializer) {\n                    kd \u003d (KeyDeserializer) kdDef;\n                } else {\n                    Class\u003c?\u003e kdClass \u003d _verifyAsClass(kdDef, \"findKeyDeserializer\", KeyDeserializer.None.class);\n                    if (kdClass !\u003d null) {\n                        kd \u003d config.keyDeserializerInstance(a, kdClass);\n                    }\n                }\n                if (kd !\u003d null) {\n                    type \u003d ((MapLikeType) type).withKeyValueHandler(kd);\n                    keyType \u003d type.getKeyType();\n                }\n            }\n        }\n        Class\u003c?\u003e cc \u003d intr.findDeserializationContentType(a, type.getContentType(), propName);\n        if (cc !\u003d null) {\n            try {\n                type \u003d type.narrowContentsBy(cc);\n            } catch (IllegalArgumentException iae) {\n                throw new JsonMappingException(\"Failed to narrow content type \" + type + \" with content-type annotation (\" + cc.getName() + \"): \" + iae.getMessage(), null, iae);\n            }\n        }\n        JavaType contentType \u003d type.getContentType();\n        if (contentType.getValueHandler() \u003d\u003d null) {\n            Object cdDef \u003d intr.findContentDeserializer(a);\n            if (cdDef !\u003d null) {\n                JsonDeserializer\u003c?\u003e cd \u003d null;\n                if (cdDef instanceof JsonDeserializer\u003c?\u003e) {\n                    cdDef \u003d (JsonDeserializer\u003c?\u003e) cdDef;\n                } else {\n                    Class\u003c?\u003e cdClass \u003d _verifyAsClass(cdDef, \"findContentDeserializer\", JsonDeserializer.None.class);\n                    if (cdClass !\u003d null) {\n                        cd \u003d config.deserializerInstance(a, cdClass);\n                    }\n                }\n                if (cd !\u003d null) {\n                    type \u003d type.withContentValueHandler(cd);\n                }\n            }\n        }\n    }\n    return type;\n}",
          "path": "src/main/java/com/fasterxml/jackson/databind/deser/DeserializerCache.java",
          "functionStartLine": 522,
          "functionName": "modifyTypeByAnnotation",
          "functionAnnotation": "",
          "functionDoc": "Method called to see if given method has annotations that indicate\na more specific type than what the argument specifies.\nIf annotations are present, they must specify compatible Class;\ninstance of which can be assigned using the method. This means\nthat the Class has to be raw class of type, or its sub-class\n(or, implementing class if original Class instance is an interface).\n\n@param a Method or field that the type is associated with\n@param type Type derived from the setter argument\n@param propName Name of property that refers to type, if any; null\n  if no property information available (when modify type declaration\n  of a class, for example)\n@return Original type if no annotations are present; or a more\n  specific type derived from it if type annotation(s) was found\n@throws JsonMappingException if invalid annotation is found\n",
          "diff": "@@ -1,71 +1,70 @@\n-@SuppressWarnings({ \"unchecked\" })\n-protected \u003cT extends JavaType\u003e T modifyTypeByAnnotation(DeserializationConfig config, Annotated a, T type, String propName) throws JsonMappingException {\n+private JavaType modifyTypeByAnnotation(DeserializationConfig config, Annotated a, JavaType type, String propName) throws JsonMappingException {\n     AnnotationIntrospector intr \u003d config.getAnnotationIntrospector();\n     Class\u003c?\u003e subclass \u003d intr.findDeserializationType(a, type, propName);\n     if (subclass !\u003d null) {\n         try {\n-            type \u003d (T) type.narrowBy(subclass);\n+            type \u003d type.narrowBy(subclass);\n         } catch (IllegalArgumentException iae) {\n             throw new JsonMappingException(\"Failed to narrow type \" + type + \" with concrete-type annotation (value \" + subclass.getName() + \"), method \u0027\" + a.getName() + \"\u0027: \" + iae.getMessage(), null, iae);\n         }\n     }\n     if (type.isContainerType()) {\n         Class\u003c?\u003e keyClass \u003d intr.findDeserializationKeyType(a, type.getKeyType(), propName);\n         if (keyClass !\u003d null) {\n             if (!(type instanceof MapLikeType)) {\n                 throw new JsonMappingException(\"Illegal key-type annotation: type \" + type + \" is not a Map(-like) type\");\n             }\n             try {\n-                type \u003d (T) ((MapLikeType) type).narrowKey(keyClass);\n+                type \u003d ((MapLikeType) type).narrowKey(keyClass);\n             } catch (IllegalArgumentException iae) {\n                 throw new JsonMappingException(\"Failed to narrow key type \" + type + \" with key-type annotation (\" + keyClass.getName() + \"): \" + iae.getMessage(), null, iae);\n             }\n         }\n         JavaType keyType \u003d type.getKeyType();\n         if (keyType !\u003d null \u0026\u0026 keyType.getValueHandler() \u003d\u003d null) {\n             Object kdDef \u003d intr.findKeyDeserializer(a);\n             if (kdDef !\u003d null) {\n                 KeyDeserializer kd \u003d null;\n                 if (kdDef instanceof KeyDeserializer) {\n                     kd \u003d (KeyDeserializer) kdDef;\n                 } else {\n                     Class\u003c?\u003e kdClass \u003d _verifyAsClass(kdDef, \"findKeyDeserializer\", KeyDeserializer.None.class);\n                     if (kdClass !\u003d null) {\n                         kd \u003d config.keyDeserializerInstance(a, kdClass);\n                     }\n                 }\n                 if (kd !\u003d null) {\n-                    type \u003d (T) ((MapLikeType) type).withKeyValueHandler(kd);\n+                    type \u003d ((MapLikeType) type).withKeyValueHandler(kd);\n                     keyType \u003d type.getKeyType();\n                 }\n             }\n         }\n         Class\u003c?\u003e cc \u003d intr.findDeserializationContentType(a, type.getContentType(), propName);\n         if (cc !\u003d null) {\n             try {\n-                type \u003d (T) type.narrowContentsBy(cc);\n+                type \u003d type.narrowContentsBy(cc);\n             } catch (IllegalArgumentException iae) {\n                 throw new JsonMappingException(\"Failed to narrow content type \" + type + \" with content-type annotation (\" + cc.getName() + \"): \" + iae.getMessage(), null, iae);\n             }\n         }\n         JavaType contentType \u003d type.getContentType();\n         if (contentType.getValueHandler() \u003d\u003d null) {\n             Object cdDef \u003d intr.findContentDeserializer(a);\n             if (cdDef !\u003d null) {\n                 JsonDeserializer\u003c?\u003e cd \u003d null;\n                 if (cdDef instanceof JsonDeserializer\u003c?\u003e) {\n                     cdDef \u003d (JsonDeserializer\u003c?\u003e) cdDef;\n                 } else {\n                     Class\u003c?\u003e cdClass \u003d _verifyAsClass(cdDef, \"findContentDeserializer\", JsonDeserializer.None.class);\n                     if (cdClass !\u003d null) {\n                         cd \u003d config.deserializerInstance(a, cdClass);\n                     }\n                 }\n                 if (cd !\u003d null) {\n-                    type \u003d (T) type.withContentValueHandler(cd);\n+                    type \u003d type.withContentValueHandler(cd);\n                 }\n             }\n         }\n     }\n     return type;\n }\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldValue": "[config-DeserializationConfig, a-Annotated, type-T, propName-String]",
            "newValue": "[config-DeserializationConfig, a-Annotated, type-JavaType, propName-String]"
          }
        }
      ]
    },
    "a03e0ebf5825d587230093436b6db53f368185a0": {
      "type": "Ybodychange",
      "commitMessage": "Implemented [JACKSON-732] for 2.0\n",
      "commitDate": "1/14/12, 2:01 PM",
      "commitName": "a03e0ebf5825d587230093436b6db53f368185a0",
      "commitAuthor": "Tatu Saloranta",
      "commitDateOld": "1/11/12, 10:14 PM",
      "commitNameOld": "703bf4a104193e8098f904fe33531c58c6e7f359",
      "commitAuthorOld": "Tatu Saloranta",
      "daysBetweenCommits": 2.66,
      "commitsBetweenForRepo": 13,
      "commitsBetweenForFile": 1,
      "actualSource": "@SuppressWarnings({ \"unchecked\" })\nprotected \u003cT extends JavaType\u003e T modifyTypeByAnnotation(DeserializationConfig config, Annotated a, T type, String propName) throws JsonMappingException {\n    AnnotationIntrospector intr \u003d config.getAnnotationIntrospector();\n    Class\u003c?\u003e subclass \u003d intr.findDeserializationType(a, type, propName);\n    if (subclass !\u003d null) {\n        try {\n            type \u003d (T) type.narrowBy(subclass);\n        } catch (IllegalArgumentException iae) {\n            throw new JsonMappingException(\"Failed to narrow type \" + type + \" with concrete-type annotation (value \" + subclass.getName() + \"), method \u0027\" + a.getName() + \"\u0027: \" + iae.getMessage(), null, iae);\n        }\n    }\n    if (type.isContainerType()) {\n        Class\u003c?\u003e keyClass \u003d intr.findDeserializationKeyType(a, type.getKeyType(), propName);\n        if (keyClass !\u003d null) {\n            if (!(type instanceof MapLikeType)) {\n                throw new JsonMappingException(\"Illegal key-type annotation: type \" + type + \" is not a Map(-like) type\");\n            }\n            try {\n                type \u003d (T) ((MapLikeType) type).narrowKey(keyClass);\n            } catch (IllegalArgumentException iae) {\n                throw new JsonMappingException(\"Failed to narrow key type \" + type + \" with key-type annotation (\" + keyClass.getName() + \"): \" + iae.getMessage(), null, iae);\n            }\n        }\n        JavaType keyType \u003d type.getKeyType();\n        if (keyType !\u003d null \u0026\u0026 keyType.getValueHandler() \u003d\u003d null) {\n            Object kdDef \u003d intr.findKeyDeserializer(a);\n            if (kdDef !\u003d null) {\n                KeyDeserializer kd \u003d null;\n                if (kdDef instanceof KeyDeserializer) {\n                    kd \u003d (KeyDeserializer) kdDef;\n                } else {\n                    Class\u003c?\u003e kdClass \u003d _verifyAsClass(kdDef, \"findKeyDeserializer\", KeyDeserializer.None.class);\n                    if (kdClass !\u003d null) {\n                        kd \u003d config.keyDeserializerInstance(a, kdClass);\n                    }\n                }\n                if (kd !\u003d null) {\n                    type \u003d (T) ((MapLikeType) type).withKeyValueHandler(kd);\n                    keyType \u003d type.getKeyType();\n                }\n            }\n        }\n        Class\u003c?\u003e cc \u003d intr.findDeserializationContentType(a, type.getContentType(), propName);\n        if (cc !\u003d null) {\n            try {\n                type \u003d (T) type.narrowContentsBy(cc);\n            } catch (IllegalArgumentException iae) {\n                throw new JsonMappingException(\"Failed to narrow content type \" + type + \" with content-type annotation (\" + cc.getName() + \"): \" + iae.getMessage(), null, iae);\n            }\n        }\n        JavaType contentType \u003d type.getContentType();\n        if (contentType.getValueHandler() \u003d\u003d null) {\n            Object cdDef \u003d intr.findContentDeserializer(a);\n            if (cdDef !\u003d null) {\n                JsonDeserializer\u003c?\u003e cd \u003d null;\n                if (cdDef instanceof JsonDeserializer\u003c?\u003e) {\n                    cdDef \u003d (JsonDeserializer\u003c?\u003e) cdDef;\n                } else {\n                    Class\u003c?\u003e cdClass \u003d _verifyAsClass(cdDef, \"findContentDeserializer\", JsonDeserializer.None.class);\n                    if (cdClass !\u003d null) {\n                        cd \u003d config.deserializerInstance(a, cdClass);\n                    }\n                }\n                if (cd !\u003d null) {\n                    type \u003d (T) type.withContentValueHandler(cd);\n                }\n            }\n        }\n    }\n    return type;\n}",
      "path": "src/main/java/com/fasterxml/jackson/databind/deser/BasicDeserializerFactory.java",
      "functionStartLine": 720,
      "functionName": "modifyTypeByAnnotation",
      "functionAnnotation": "@SuppressWarnings({ \"unchecked\" })",
      "functionDoc": "Method called to see if given method has annotations that indicate\na more specific type than what the argument specifies.\nIf annotations are present, they must specify compatible Class;\ninstance of which can be assigned using the method. This means\nthat the Class has to be raw class of type, or its sub-class\n(or, implementing class if original Class instance is an interface).\n\n@param a Method or field that the type is associated with\n@param type Type derived from the setter argument\n@param propName Name of property that refers to type, if any; null\n  if no property information available (when modify type declaration\n  of a class, for example)\n@return Original type if no annotations are present; or a more\n  specific type derived from it if type annotation(s) was found\n@throws JsonMappingException if invalid annotation is found\n",
      "diff": "@@ -1,51 +1,71 @@\n @SuppressWarnings({ \"unchecked\" })\n protected \u003cT extends JavaType\u003e T modifyTypeByAnnotation(DeserializationConfig config, Annotated a, T type, String propName) throws JsonMappingException {\n     AnnotationIntrospector intr \u003d config.getAnnotationIntrospector();\n     Class\u003c?\u003e subclass \u003d intr.findDeserializationType(a, type, propName);\n     if (subclass !\u003d null) {\n         try {\n             type \u003d (T) type.narrowBy(subclass);\n         } catch (IllegalArgumentException iae) {\n             throw new JsonMappingException(\"Failed to narrow type \" + type + \" with concrete-type annotation (value \" + subclass.getName() + \"), method \u0027\" + a.getName() + \"\u0027: \" + iae.getMessage(), null, iae);\n         }\n     }\n     if (type.isContainerType()) {\n         Class\u003c?\u003e keyClass \u003d intr.findDeserializationKeyType(a, type.getKeyType(), propName);\n         if (keyClass !\u003d null) {\n             if (!(type instanceof MapLikeType)) {\n                 throw new JsonMappingException(\"Illegal key-type annotation: type \" + type + \" is not a Map(-like) type\");\n             }\n             try {\n                 type \u003d (T) ((MapLikeType) type).narrowKey(keyClass);\n             } catch (IllegalArgumentException iae) {\n                 throw new JsonMappingException(\"Failed to narrow key type \" + type + \" with key-type annotation (\" + keyClass.getName() + \"): \" + iae.getMessage(), null, iae);\n             }\n         }\n         JavaType keyType \u003d type.getKeyType();\n         if (keyType !\u003d null \u0026\u0026 keyType.getValueHandler() \u003d\u003d null) {\n-            Class\u003c? extends KeyDeserializer\u003e kdClass \u003d intr.findKeyDeserializer(a);\n-            if (kdClass !\u003d null \u0026\u0026 kdClass !\u003d KeyDeserializer.None.class) {\n-                KeyDeserializer kd \u003d config.keyDeserializerInstance(a, kdClass);\n-                type \u003d (T) ((MapLikeType) type).withKeyValueHandler(kd);\n-                keyType \u003d type.getKeyType();\n+            Object kdDef \u003d intr.findKeyDeserializer(a);\n+            if (kdDef !\u003d null) {\n+                KeyDeserializer kd \u003d null;\n+                if (kdDef instanceof KeyDeserializer) {\n+                    kd \u003d (KeyDeserializer) kdDef;\n+                } else {\n+                    Class\u003c?\u003e kdClass \u003d _verifyAsClass(kdDef, \"findKeyDeserializer\", KeyDeserializer.None.class);\n+                    if (kdClass !\u003d null) {\n+                        kd \u003d config.keyDeserializerInstance(a, kdClass);\n+                    }\n+                }\n+                if (kd !\u003d null) {\n+                    type \u003d (T) ((MapLikeType) type).withKeyValueHandler(kd);\n+                    keyType \u003d type.getKeyType();\n+                }\n             }\n         }\n         Class\u003c?\u003e cc \u003d intr.findDeserializationContentType(a, type.getContentType(), propName);\n         if (cc !\u003d null) {\n             try {\n                 type \u003d (T) type.narrowContentsBy(cc);\n             } catch (IllegalArgumentException iae) {\n                 throw new JsonMappingException(\"Failed to narrow content type \" + type + \" with content-type annotation (\" + cc.getName() + \"): \" + iae.getMessage(), null, iae);\n             }\n         }\n         JavaType contentType \u003d type.getContentType();\n         if (contentType.getValueHandler() \u003d\u003d null) {\n-            Class\u003c? extends JsonDeserializer\u003c?\u003e\u003e cdClass \u003d intr.findContentDeserializer(a);\n-            if (cdClass !\u003d null \u0026\u0026 cdClass !\u003d JsonDeserializer.None.class) {\n-                JsonDeserializer\u003cObject\u003e cd \u003d config.deserializerInstance(a, cdClass);\n-                type \u003d (T) type.withContentValueHandler(cd);\n+            Object cdDef \u003d intr.findContentDeserializer(a);\n+            if (cdDef !\u003d null) {\n+                JsonDeserializer\u003c?\u003e cd \u003d null;\n+                if (cdDef instanceof JsonDeserializer\u003c?\u003e) {\n+                    cdDef \u003d (JsonDeserializer\u003c?\u003e) cdDef;\n+                } else {\n+                    Class\u003c?\u003e cdClass \u003d _verifyAsClass(cdDef, \"findContentDeserializer\", JsonDeserializer.None.class);\n+                    if (cdClass !\u003d null) {\n+                        cd \u003d config.deserializerInstance(a, cdClass);\n+                    }\n+                }\n+                if (cd !\u003d null) {\n+                    type \u003d (T) type.withContentValueHandler(cd);\n+                }\n             }\n         }\n     }\n     return type;\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "d1e678e660f50c66113da7d03e4ffb52fef45fc0": {
      "type": "Ymultichange(Ybodychange,Yannotationchange)",
      "commitMessage": "Last pieces of the first round of refactoring: again compiles, may work\n",
      "commitDate": "12/23/11, 5:38 PM",
      "commitName": "d1e678e660f50c66113da7d03e4ffb52fef45fc0",
      "commitAuthor": "Tatu Saloranta",
      "subchanges": [
        {
          "type": "Ybodychange",
          "commitMessage": "Last pieces of the first round of refactoring: again compiles, may work\n",
          "commitDate": "12/23/11, 5:38 PM",
          "commitName": "d1e678e660f50c66113da7d03e4ffb52fef45fc0",
          "commitAuthor": "Tatu Saloranta",
          "commitDateOld": "12/23/11, 8:38 AM",
          "commitNameOld": "a342c0eef8c4abc3eba5568c52af73e59e1b6c17",
          "commitAuthorOld": "Tatu Saloranta",
          "daysBetweenCommits": 0.38,
          "commitsBetweenForRepo": 2,
          "commitsBetweenForFile": 1,
          "actualSource": "@SuppressWarnings({ \"unchecked\" })\nprotected \u003cT extends JavaType\u003e T modifyTypeByAnnotation(DeserializationConfig config, Annotated a, T type, String propName) throws JsonMappingException {\n    AnnotationIntrospector intr \u003d config.getAnnotationIntrospector();\n    Class\u003c?\u003e subclass \u003d intr.findDeserializationType(a, type, propName);\n    if (subclass !\u003d null) {\n        try {\n            type \u003d (T) type.narrowBy(subclass);\n        } catch (IllegalArgumentException iae) {\n            throw new JsonMappingException(\"Failed to narrow type \" + type + \" with concrete-type annotation (value \" + subclass.getName() + \"), method \u0027\" + a.getName() + \"\u0027: \" + iae.getMessage(), null, iae);\n        }\n    }\n    if (type.isContainerType()) {\n        Class\u003c?\u003e keyClass \u003d intr.findDeserializationKeyType(a, type.getKeyType(), propName);\n        if (keyClass !\u003d null) {\n            if (!(type instanceof MapLikeType)) {\n                throw new JsonMappingException(\"Illegal key-type annotation: type \" + type + \" is not a Map(-like) type\");\n            }\n            try {\n                type \u003d (T) ((MapLikeType) type).narrowKey(keyClass);\n            } catch (IllegalArgumentException iae) {\n                throw new JsonMappingException(\"Failed to narrow key type \" + type + \" with key-type annotation (\" + keyClass.getName() + \"): \" + iae.getMessage(), null, iae);\n            }\n        }\n        JavaType keyType \u003d type.getKeyType();\n        if (keyType !\u003d null \u0026\u0026 keyType.getValueHandler() \u003d\u003d null) {\n            Class\u003c? extends KeyDeserializer\u003e kdClass \u003d intr.findKeyDeserializer(a);\n            if (kdClass !\u003d null \u0026\u0026 kdClass !\u003d KeyDeserializer.None.class) {\n                KeyDeserializer kd \u003d config.keyDeserializerInstance(a, kdClass);\n                type \u003d (T) ((MapLikeType) type).withKeyValueHandler(kd);\n                keyType \u003d type.getKeyType();\n            }\n        }\n        Class\u003c?\u003e cc \u003d intr.findDeserializationContentType(a, type.getContentType(), propName);\n        if (cc !\u003d null) {\n            try {\n                type \u003d (T) type.narrowContentsBy(cc);\n            } catch (IllegalArgumentException iae) {\n                throw new JsonMappingException(\"Failed to narrow content type \" + type + \" with content-type annotation (\" + cc.getName() + \"): \" + iae.getMessage(), null, iae);\n            }\n        }\n        JavaType contentType \u003d type.getContentType();\n        if (contentType.getValueHandler() \u003d\u003d null) {\n            Class\u003c? extends JsonDeserializer\u003c?\u003e\u003e cdClass \u003d intr.findContentDeserializer(a);\n            if (cdClass !\u003d null \u0026\u0026 cdClass !\u003d JsonDeserializer.None.class) {\n                JsonDeserializer\u003cObject\u003e cd \u003d config.deserializerInstance(a, cdClass);\n                type \u003d (T) type.withContentValueHandler(cd);\n            }\n        }\n    }\n    return type;\n}",
          "path": "src/main/java/com/fasterxml/jackson/databind/deser/BasicDeserializerFactory.java",
          "functionStartLine": 733,
          "functionName": "modifyTypeByAnnotation",
          "functionAnnotation": "@SuppressWarnings({ \"unchecked\" })",
          "functionDoc": "Method called to see if given method has annotations that indicate\na more specific type than what the argument specifies.\nIf annotations are present, they must specify compatible Class;\ninstance of which can be assigned using the method. This means\nthat the Class has to be raw class of type, or its sub-class\n(or, implementing class if original Class instance is an interface).\n\n@param a Method or field that the type is associated with\n@param type Type derived from the setter argument\n@param propName Name of property that refers to type, if any; null\n  if no property information available (when modify type declaration\n  of a class, for example)\n@return Original type if no annotations are present; or a more\n  specific type derived from it if type annotation(s) was found\n@throws JsonMappingException if invalid annotation is found\n",
          "diff": "@@ -1,50 +1,51 @@\n-@SuppressWarnings({ \"unchecked\", \"deprecation\" })\n+@SuppressWarnings({ \"unchecked\" })\n protected \u003cT extends JavaType\u003e T modifyTypeByAnnotation(DeserializationConfig config, Annotated a, T type, String propName) throws JsonMappingException {\n     AnnotationIntrospector intr \u003d config.getAnnotationIntrospector();\n     Class\u003c?\u003e subclass \u003d intr.findDeserializationType(a, type, propName);\n     if (subclass !\u003d null) {\n         try {\n             type \u003d (T) type.narrowBy(subclass);\n         } catch (IllegalArgumentException iae) {\n             throw new JsonMappingException(\"Failed to narrow type \" + type + \" with concrete-type annotation (value \" + subclass.getName() + \"), method \u0027\" + a.getName() + \"\u0027: \" + iae.getMessage(), null, iae);\n         }\n     }\n     if (type.isContainerType()) {\n         Class\u003c?\u003e keyClass \u003d intr.findDeserializationKeyType(a, type.getKeyType(), propName);\n         if (keyClass !\u003d null) {\n             if (!(type instanceof MapLikeType)) {\n                 throw new JsonMappingException(\"Illegal key-type annotation: type \" + type + \" is not a Map(-like) type\");\n             }\n             try {\n                 type \u003d (T) ((MapLikeType) type).narrowKey(keyClass);\n             } catch (IllegalArgumentException iae) {\n                 throw new JsonMappingException(\"Failed to narrow key type \" + type + \" with key-type annotation (\" + keyClass.getName() + \"): \" + iae.getMessage(), null, iae);\n             }\n         }\n         JavaType keyType \u003d type.getKeyType();\n         if (keyType !\u003d null \u0026\u0026 keyType.getValueHandler() \u003d\u003d null) {\n             Class\u003c? extends KeyDeserializer\u003e kdClass \u003d intr.findKeyDeserializer(a);\n             if (kdClass !\u003d null \u0026\u0026 kdClass !\u003d KeyDeserializer.None.class) {\n                 KeyDeserializer kd \u003d config.keyDeserializerInstance(a, kdClass);\n-                keyType.setValueHandler(kd);\n+                type \u003d (T) ((MapLikeType) type).withKeyValueHandler(kd);\n+                keyType \u003d type.getKeyType();\n             }\n         }\n         Class\u003c?\u003e cc \u003d intr.findDeserializationContentType(a, type.getContentType(), propName);\n         if (cc !\u003d null) {\n             try {\n                 type \u003d (T) type.narrowContentsBy(cc);\n             } catch (IllegalArgumentException iae) {\n                 throw new JsonMappingException(\"Failed to narrow content type \" + type + \" with content-type annotation (\" + cc.getName() + \"): \" + iae.getMessage(), null, iae);\n             }\n         }\n         JavaType contentType \u003d type.getContentType();\n         if (contentType.getValueHandler() \u003d\u003d null) {\n             Class\u003c? extends JsonDeserializer\u003c?\u003e\u003e cdClass \u003d intr.findContentDeserializer(a);\n             if (cdClass !\u003d null \u0026\u0026 cdClass !\u003d JsonDeserializer.None.class) {\n                 JsonDeserializer\u003cObject\u003e cd \u003d config.deserializerInstance(a, cdClass);\n-                type.getContentType().setValueHandler(cd);\n+                type \u003d (T) type.withContentValueHandler(cd);\n             }\n         }\n     }\n     return type;\n }\n\\ No newline at end of file\n",
          "extendedDetails": {}
        },
        {
          "type": "Yannotationchange",
          "commitMessage": "Last pieces of the first round of refactoring: again compiles, may work\n",
          "commitDate": "12/23/11, 5:38 PM",
          "commitName": "d1e678e660f50c66113da7d03e4ffb52fef45fc0",
          "commitAuthor": "Tatu Saloranta",
          "commitDateOld": "12/23/11, 8:38 AM",
          "commitNameOld": "a342c0eef8c4abc3eba5568c52af73e59e1b6c17",
          "commitAuthorOld": "Tatu Saloranta",
          "daysBetweenCommits": 0.38,
          "commitsBetweenForRepo": 2,
          "commitsBetweenForFile": 1,
          "actualSource": "@SuppressWarnings({ \"unchecked\" })\nprotected \u003cT extends JavaType\u003e T modifyTypeByAnnotation(DeserializationConfig config, Annotated a, T type, String propName) throws JsonMappingException {\n    AnnotationIntrospector intr \u003d config.getAnnotationIntrospector();\n    Class\u003c?\u003e subclass \u003d intr.findDeserializationType(a, type, propName);\n    if (subclass !\u003d null) {\n        try {\n            type \u003d (T) type.narrowBy(subclass);\n        } catch (IllegalArgumentException iae) {\n            throw new JsonMappingException(\"Failed to narrow type \" + type + \" with concrete-type annotation (value \" + subclass.getName() + \"), method \u0027\" + a.getName() + \"\u0027: \" + iae.getMessage(), null, iae);\n        }\n    }\n    if (type.isContainerType()) {\n        Class\u003c?\u003e keyClass \u003d intr.findDeserializationKeyType(a, type.getKeyType(), propName);\n        if (keyClass !\u003d null) {\n            if (!(type instanceof MapLikeType)) {\n                throw new JsonMappingException(\"Illegal key-type annotation: type \" + type + \" is not a Map(-like) type\");\n            }\n            try {\n                type \u003d (T) ((MapLikeType) type).narrowKey(keyClass);\n            } catch (IllegalArgumentException iae) {\n                throw new JsonMappingException(\"Failed to narrow key type \" + type + \" with key-type annotation (\" + keyClass.getName() + \"): \" + iae.getMessage(), null, iae);\n            }\n        }\n        JavaType keyType \u003d type.getKeyType();\n        if (keyType !\u003d null \u0026\u0026 keyType.getValueHandler() \u003d\u003d null) {\n            Class\u003c? extends KeyDeserializer\u003e kdClass \u003d intr.findKeyDeserializer(a);\n            if (kdClass !\u003d null \u0026\u0026 kdClass !\u003d KeyDeserializer.None.class) {\n                KeyDeserializer kd \u003d config.keyDeserializerInstance(a, kdClass);\n                type \u003d (T) ((MapLikeType) type).withKeyValueHandler(kd);\n                keyType \u003d type.getKeyType();\n            }\n        }\n        Class\u003c?\u003e cc \u003d intr.findDeserializationContentType(a, type.getContentType(), propName);\n        if (cc !\u003d null) {\n            try {\n                type \u003d (T) type.narrowContentsBy(cc);\n            } catch (IllegalArgumentException iae) {\n                throw new JsonMappingException(\"Failed to narrow content type \" + type + \" with content-type annotation (\" + cc.getName() + \"): \" + iae.getMessage(), null, iae);\n            }\n        }\n        JavaType contentType \u003d type.getContentType();\n        if (contentType.getValueHandler() \u003d\u003d null) {\n            Class\u003c? extends JsonDeserializer\u003c?\u003e\u003e cdClass \u003d intr.findContentDeserializer(a);\n            if (cdClass !\u003d null \u0026\u0026 cdClass !\u003d JsonDeserializer.None.class) {\n                JsonDeserializer\u003cObject\u003e cd \u003d config.deserializerInstance(a, cdClass);\n                type \u003d (T) type.withContentValueHandler(cd);\n            }\n        }\n    }\n    return type;\n}",
          "path": "src/main/java/com/fasterxml/jackson/databind/deser/BasicDeserializerFactory.java",
          "functionStartLine": 733,
          "functionName": "modifyTypeByAnnotation",
          "functionAnnotation": "@SuppressWarnings({ \"unchecked\" })",
          "functionDoc": "Method called to see if given method has annotations that indicate\na more specific type than what the argument specifies.\nIf annotations are present, they must specify compatible Class;\ninstance of which can be assigned using the method. This means\nthat the Class has to be raw class of type, or its sub-class\n(or, implementing class if original Class instance is an interface).\n\n@param a Method or field that the type is associated with\n@param type Type derived from the setter argument\n@param propName Name of property that refers to type, if any; null\n  if no property information available (when modify type declaration\n  of a class, for example)\n@return Original type if no annotations are present; or a more\n  specific type derived from it if type annotation(s) was found\n@throws JsonMappingException if invalid annotation is found\n",
          "diff": "@@ -1,50 +1,51 @@\n-@SuppressWarnings({ \"unchecked\", \"deprecation\" })\n+@SuppressWarnings({ \"unchecked\" })\n protected \u003cT extends JavaType\u003e T modifyTypeByAnnotation(DeserializationConfig config, Annotated a, T type, String propName) throws JsonMappingException {\n     AnnotationIntrospector intr \u003d config.getAnnotationIntrospector();\n     Class\u003c?\u003e subclass \u003d intr.findDeserializationType(a, type, propName);\n     if (subclass !\u003d null) {\n         try {\n             type \u003d (T) type.narrowBy(subclass);\n         } catch (IllegalArgumentException iae) {\n             throw new JsonMappingException(\"Failed to narrow type \" + type + \" with concrete-type annotation (value \" + subclass.getName() + \"), method \u0027\" + a.getName() + \"\u0027: \" + iae.getMessage(), null, iae);\n         }\n     }\n     if (type.isContainerType()) {\n         Class\u003c?\u003e keyClass \u003d intr.findDeserializationKeyType(a, type.getKeyType(), propName);\n         if (keyClass !\u003d null) {\n             if (!(type instanceof MapLikeType)) {\n                 throw new JsonMappingException(\"Illegal key-type annotation: type \" + type + \" is not a Map(-like) type\");\n             }\n             try {\n                 type \u003d (T) ((MapLikeType) type).narrowKey(keyClass);\n             } catch (IllegalArgumentException iae) {\n                 throw new JsonMappingException(\"Failed to narrow key type \" + type + \" with key-type annotation (\" + keyClass.getName() + \"): \" + iae.getMessage(), null, iae);\n             }\n         }\n         JavaType keyType \u003d type.getKeyType();\n         if (keyType !\u003d null \u0026\u0026 keyType.getValueHandler() \u003d\u003d null) {\n             Class\u003c? extends KeyDeserializer\u003e kdClass \u003d intr.findKeyDeserializer(a);\n             if (kdClass !\u003d null \u0026\u0026 kdClass !\u003d KeyDeserializer.None.class) {\n                 KeyDeserializer kd \u003d config.keyDeserializerInstance(a, kdClass);\n-                keyType.setValueHandler(kd);\n+                type \u003d (T) ((MapLikeType) type).withKeyValueHandler(kd);\n+                keyType \u003d type.getKeyType();\n             }\n         }\n         Class\u003c?\u003e cc \u003d intr.findDeserializationContentType(a, type.getContentType(), propName);\n         if (cc !\u003d null) {\n             try {\n                 type \u003d (T) type.narrowContentsBy(cc);\n             } catch (IllegalArgumentException iae) {\n                 throw new JsonMappingException(\"Failed to narrow content type \" + type + \" with content-type annotation (\" + cc.getName() + \"): \" + iae.getMessage(), null, iae);\n             }\n         }\n         JavaType contentType \u003d type.getContentType();\n         if (contentType.getValueHandler() \u003d\u003d null) {\n             Class\u003c? extends JsonDeserializer\u003c?\u003e\u003e cdClass \u003d intr.findContentDeserializer(a);\n             if (cdClass !\u003d null \u0026\u0026 cdClass !\u003d JsonDeserializer.None.class) {\n                 JsonDeserializer\u003cObject\u003e cd \u003d config.deserializerInstance(a, cdClass);\n-                type.getContentType().setValueHandler(cd);\n+                type \u003d (T) type.withContentValueHandler(cd);\n             }\n         }\n     }\n     return type;\n }\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldValue": "@SuppressWarnings({ \"unchecked\", \"deprecation\" })",
            "newValue": "@SuppressWarnings({ \"unchecked\" })"
          }
        }
      ]
    },
    "e4f23bb6779d434d88a7c4335f92d13ea639b373": {
      "type": "Yintroduced",
      "commitMessage": "First check-in, tons of compilation errors to resolve\n",
      "commitDate": "12/23/11, 12:31 AM",
      "commitName": "e4f23bb6779d434d88a7c4335f92d13ea639b373",
      "commitAuthor": "Tatu Saloranta",
      "diff": "@@ -0,0 +1,50 @@\n+@SuppressWarnings({ \"unchecked\", \"deprecation\" })\n+protected \u003cT extends JavaType\u003e T modifyTypeByAnnotation(DeserializationConfig config, Annotated a, T type, String propName) throws JsonMappingException {\n+    AnnotationIntrospector intr \u003d config.getAnnotationIntrospector();\n+    Class\u003c?\u003e subclass \u003d intr.findDeserializationType(a, type, propName);\n+    if (subclass !\u003d null) {\n+        try {\n+            type \u003d (T) type.narrowBy(subclass);\n+        } catch (IllegalArgumentException iae) {\n+            throw new JsonMappingException(\"Failed to narrow type \" + type + \" with concrete-type annotation (value \" + subclass.getName() + \"), method \u0027\" + a.getName() + \"\u0027: \" + iae.getMessage(), null, iae);\n+        }\n+    }\n+    if (type.isContainerType()) {\n+        Class\u003c?\u003e keyClass \u003d intr.findDeserializationKeyType(a, type.getKeyType(), propName);\n+        if (keyClass !\u003d null) {\n+            if (!(type instanceof MapLikeType)) {\n+                throw new JsonMappingException(\"Illegal key-type annotation: type \" + type + \" is not a Map(-like) type\");\n+            }\n+            try {\n+                type \u003d (T) ((MapLikeType) type).narrowKey(keyClass);\n+            } catch (IllegalArgumentException iae) {\n+                throw new JsonMappingException(\"Failed to narrow key type \" + type + \" with key-type annotation (\" + keyClass.getName() + \"): \" + iae.getMessage(), null, iae);\n+            }\n+        }\n+        JavaType keyType \u003d type.getKeyType();\n+        if (keyType !\u003d null \u0026\u0026 keyType.getValueHandler() \u003d\u003d null) {\n+            Class\u003c? extends KeyDeserializer\u003e kdClass \u003d intr.findKeyDeserializer(a);\n+            if (kdClass !\u003d null \u0026\u0026 kdClass !\u003d KeyDeserializer.None.class) {\n+                KeyDeserializer kd \u003d config.keyDeserializerInstance(a, kdClass);\n+                keyType.setValueHandler(kd);\n+            }\n+        }\n+        Class\u003c?\u003e cc \u003d intr.findDeserializationContentType(a, type.getContentType(), propName);\n+        if (cc !\u003d null) {\n+            try {\n+                type \u003d (T) type.narrowContentsBy(cc);\n+            } catch (IllegalArgumentException iae) {\n+                throw new JsonMappingException(\"Failed to narrow content type \" + type + \" with content-type annotation (\" + cc.getName() + \"): \" + iae.getMessage(), null, iae);\n+            }\n+        }\n+        JavaType contentType \u003d type.getContentType();\n+        if (contentType.getValueHandler() \u003d\u003d null) {\n+            Class\u003c? extends JsonDeserializer\u003c?\u003e\u003e cdClass \u003d intr.findContentDeserializer(a);\n+            if (cdClass !\u003d null \u0026\u0026 cdClass !\u003d JsonDeserializer.None.class) {\n+                JsonDeserializer\u003cObject\u003e cd \u003d config.deserializerInstance(a, cdClass);\n+                type.getContentType().setValueHandler(cd);\n+            }\n+        }\n+    }\n+    return type;\n+}\n\\ No newline at end of file\n",
      "actualSource": "@SuppressWarnings({ \"unchecked\", \"deprecation\" })\nprotected \u003cT extends JavaType\u003e T modifyTypeByAnnotation(DeserializationConfig config, Annotated a, T type, String propName) throws JsonMappingException {\n    AnnotationIntrospector intr \u003d config.getAnnotationIntrospector();\n    Class\u003c?\u003e subclass \u003d intr.findDeserializationType(a, type, propName);\n    if (subclass !\u003d null) {\n        try {\n            type \u003d (T) type.narrowBy(subclass);\n        } catch (IllegalArgumentException iae) {\n            throw new JsonMappingException(\"Failed to narrow type \" + type + \" with concrete-type annotation (value \" + subclass.getName() + \"), method \u0027\" + a.getName() + \"\u0027: \" + iae.getMessage(), null, iae);\n        }\n    }\n    if (type.isContainerType()) {\n        Class\u003c?\u003e keyClass \u003d intr.findDeserializationKeyType(a, type.getKeyType(), propName);\n        if (keyClass !\u003d null) {\n            if (!(type instanceof MapLikeType)) {\n                throw new JsonMappingException(\"Illegal key-type annotation: type \" + type + \" is not a Map(-like) type\");\n            }\n            try {\n                type \u003d (T) ((MapLikeType) type).narrowKey(keyClass);\n            } catch (IllegalArgumentException iae) {\n                throw new JsonMappingException(\"Failed to narrow key type \" + type + \" with key-type annotation (\" + keyClass.getName() + \"): \" + iae.getMessage(), null, iae);\n            }\n        }\n        JavaType keyType \u003d type.getKeyType();\n        if (keyType !\u003d null \u0026\u0026 keyType.getValueHandler() \u003d\u003d null) {\n            Class\u003c? extends KeyDeserializer\u003e kdClass \u003d intr.findKeyDeserializer(a);\n            if (kdClass !\u003d null \u0026\u0026 kdClass !\u003d KeyDeserializer.None.class) {\n                KeyDeserializer kd \u003d config.keyDeserializerInstance(a, kdClass);\n                keyType.setValueHandler(kd);\n            }\n        }\n        Class\u003c?\u003e cc \u003d intr.findDeserializationContentType(a, type.getContentType(), propName);\n        if (cc !\u003d null) {\n            try {\n                type \u003d (T) type.narrowContentsBy(cc);\n            } catch (IllegalArgumentException iae) {\n                throw new JsonMappingException(\"Failed to narrow content type \" + type + \" with content-type annotation (\" + cc.getName() + \"): \" + iae.getMessage(), null, iae);\n            }\n        }\n        JavaType contentType \u003d type.getContentType();\n        if (contentType.getValueHandler() \u003d\u003d null) {\n            Class\u003c? extends JsonDeserializer\u003c?\u003e\u003e cdClass \u003d intr.findContentDeserializer(a);\n            if (cdClass !\u003d null \u0026\u0026 cdClass !\u003d JsonDeserializer.None.class) {\n                JsonDeserializer\u003cObject\u003e cd \u003d config.deserializerInstance(a, cdClass);\n                type.getContentType().setValueHandler(cd);\n            }\n        }\n    }\n    return type;\n}",
      "path": "src/main/java/com/fasterxml/jackson/databind/deser/BasicDeserializerFactory.java",
      "functionStartLine": 734,
      "functionName": "modifyTypeByAnnotation",
      "functionAnnotation": "@SuppressWarnings({ \"unchecked\", \"deprecation\" })",
      "functionDoc": "Method called to see if given method has annotations that indicate\na more specific type than what the argument specifies.\nIf annotations are present, they must specify compatible Class;\ninstance of which can be assigned using the method. This means\nthat the Class has to be raw class of type, or its sub-class\n(or, implementing class if original Class instance is an interface).\n\n@param a Method or field that the type is associated with\n@param type Type derived from the setter argument\n@param propName Name of property that refers to type, if any; null\n  if no property information available (when modify type declaration\n  of a class, for example)\n@return Original type if no annotations are present; or a more\n  specific type derived from it if type annotation(s) was found\n@throws JsonMappingException if invalid annotation is found\n"
    }
  }
}