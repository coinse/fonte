{
  "origin": "codeshovel",
  "repositoryName": "Csv-7b",
  "repositoryPath": "/tmp/Csv-7b//.git",
  "startCommitName": "HEAD",
  "sourceFileName": "CSVParser.java",
  "functionName": "nextRecord",
  "functionId": "nextRecord",
  "sourceFilePath": "src/main/java/org/apache/commons/csv/CSVParser.java",
  "functionAnnotation": "",
  "functionDoc": "Parses the next record from the current point in the stream.\n\n@return the record as an array of values, or \u003ctt\u003enull\u003c/tt\u003e if the end of the stream has been reached\n@throws IOException\n            on parse error or input read-failure\n",
  "functionStartLine": 445,
  "functionEndLine": 487,
  "numCommitsSeen": 218,
  "timeTaken": 3030,
  "changeHistory": [
    "a84668e0eafc96b88fe133cf4225a586986a5255",
    "966cd208ca18c299c6c765d4e1440f0877d96981",
    "9873b13df283ac65a37d56622bc1e01eca681611",
    "316a51f5208bc95f22124d1579882131a4f441b2",
    "69997467d419487cb4098ff116188091907b5ff1",
    "d5cc0d8a7c7141c792395f3a0b4a29819320e500",
    "5a0894f9e0ee9f4703b8db3f200ff4a507bf043b",
    "71c69df6dda034e9aa18ad07782ba88643423f58",
    "7d8c7f17ff5ee965b7e1d47e667fcd878d59c6aa",
    "9542a399b8fe5eafa87c22fb29590a923f0786d1",
    "0e8084ab27bdd1e183b243b6c4cef97d603d23ad",
    "daf984983bc695591965f2126e0ef641005fe347",
    "473727be265240adf6d15a1d7abad2f0f31967fd",
    "5e7945e1ceeb6cce60e3da5caf4d57f7bf531689",
    "6c1b0fa1c49a3b4c51a0765c6ab3806ae4aa3ce5",
    "bf06bed9b8905ccf5409179263707074167ccfc4",
    "787ab08db9230c67220ef453de211159e317d4e2",
    "fcfb6dc7c5262e54995dd70939f614f02a7f7cb6",
    "0a0f3bbd365c470c2ae86b1cf383838bfaab77e1",
    "aee6c50e2830c007a572cc96a57bc105308acc49",
    "9141cb39e6659340574a96b41d7f463ebdc2610e",
    "2ec4c994c0458ef893af9bd518849bec21b2dec4",
    "ca7bbae40ef89e561f74d1a00776e3a9f697bd37",
    "9dd3dda09f09c6baa7e053b39043bc9e2ef47ee0",
    "7bd9d1d970b04a8439fee0bd5224159f57cb2512",
    "045dbbbe4ab84618cee8ba27d00b9283ce0a2715",
    "16bfec07ffd785e5abbabdc4145eeac5cccc2c79",
    "c9aeca5c39033c95c26c1475dcf0fd2ea86672e8",
    "1166ca605bcc035654771f1ddc1092d86f2ec1e8",
    "1b0ccbe4c7d5a183913063429198e8c51bb768f9",
    "d7e94581d784067fccddd34e19ae46aea526f9fa",
    "f047581f9526aad1c9c9e624710a4e860f88ecaa",
    "4b5faabefd896ef24b21d7f9d3dc20741f6b89b8",
    "e23e79e0ceacf38d3298e7f5207c4518ad2b5955"
  ],
  "changeHistoryShort": {
    "a84668e0eafc96b88fe133cf4225a586986a5255": "Ymodifierchange",
    "966cd208ca18c299c6c765d4e1440f0877d96981": "Ymodifierchange",
    "9873b13df283ac65a37d56622bc1e01eca681611": "Ybodychange",
    "316a51f5208bc95f22124d1579882131a4f441b2": "Yformatchange",
    "69997467d419487cb4098ff116188091907b5ff1": "Ybodychange",
    "d5cc0d8a7c7141c792395f3a0b4a29819320e500": "Ybodychange",
    "5a0894f9e0ee9f4703b8db3f200ff4a507bf043b": "Ybodychange",
    "71c69df6dda034e9aa18ad07782ba88643423f58": "Ybodychange",
    "7d8c7f17ff5ee965b7e1d47e667fcd878d59c6aa": "Ybodychange",
    "9542a399b8fe5eafa87c22fb29590a923f0786d1": "Ybodychange",
    "0e8084ab27bdd1e183b243b6c4cef97d603d23ad": "Yrename",
    "daf984983bc695591965f2126e0ef641005fe347": "Ybodychange",
    "473727be265240adf6d15a1d7abad2f0f31967fd": "Ybodychange",
    "5e7945e1ceeb6cce60e3da5caf4d57f7bf531689": "Ybodychange",
    "6c1b0fa1c49a3b4c51a0765c6ab3806ae4aa3ce5": "Ymultichange(Ydocchange,Yformatchange)",
    "bf06bed9b8905ccf5409179263707074167ccfc4": "Yformatchange",
    "787ab08db9230c67220ef453de211159e317d4e2": "Ybodychange",
    "fcfb6dc7c5262e54995dd70939f614f02a7f7cb6": "Ybodychange",
    "0a0f3bbd365c470c2ae86b1cf383838bfaab77e1": "Ybodychange",
    "aee6c50e2830c007a572cc96a57bc105308acc49": "Ymultichange(Yreturntypechange,Ybodychange)",
    "9141cb39e6659340574a96b41d7f463ebdc2610e": "Ybodychange",
    "2ec4c994c0458ef893af9bd518849bec21b2dec4": "Ymultichange(Yrename,Ybodychange,Ydocchange)",
    "ca7bbae40ef89e561f74d1a00776e3a9f697bd37": "Ybodychange",
    "9dd3dda09f09c6baa7e053b39043bc9e2ef47ee0": "Ydocchange",
    "7bd9d1d970b04a8439fee0bd5224159f57cb2512": "Ymultichange(Ybodychange,Ydocchange)",
    "045dbbbe4ab84618cee8ba27d00b9283ce0a2715": "Ymodifierchange",
    "16bfec07ffd785e5abbabdc4145eeac5cccc2c79": "Ybodychange",
    "c9aeca5c39033c95c26c1475dcf0fd2ea86672e8": "Yfilerename",
    "1166ca605bcc035654771f1ddc1092d86f2ec1e8": "Ymultichange(Ydocchange,Yformatchange)",
    "1b0ccbe4c7d5a183913063429198e8c51bb768f9": "Ybodychange",
    "d7e94581d784067fccddd34e19ae46aea526f9fa": "Ybodychange",
    "f047581f9526aad1c9c9e624710a4e860f88ecaa": "Ybodychange",
    "4b5faabefd896ef24b21d7f9d3dc20741f6b89b8": "Yfilerename",
    "e23e79e0ceacf38d3298e7f5207c4518ad2b5955": "Yintroduced"
  },
  "changeHistoryDetails": {
    "a84668e0eafc96b88fe133cf4225a586986a5255": {
      "type": "Ymodifierchange",
      "commitMessage": "Revert.\n\ngit-svn-id: https://svn.apache.org/repos/asf/commons/proper/csv/trunk@1585716 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "4/8/14, 6:02 AM",
      "commitName": "a84668e0eafc96b88fe133cf4225a586986a5255",
      "commitAuthor": "Gary D. Gregory",
      "commitDateOld": "4/7/14, 7:50 AM",
      "commitNameOld": "966cd208ca18c299c6c765d4e1440f0877d96981",
      "commitAuthorOld": "Gary D. Gregory",
      "daysBetweenCommits": 0.92,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "CSVRecord nextRecord() throws IOException {\n    CSVRecord result \u003d null;\n    this.record.clear();\n    StringBuilder sb \u003d null;\n    do {\n        this.reusableToken.reset();\n        this.lexer.nextToken(this.reusableToken);\n        switch(this.reusableToken.type) {\n            case TOKEN:\n                this.addRecordValue();\n                break;\n            case EORECORD:\n                this.addRecordValue();\n                break;\n            case EOF:\n                if (this.reusableToken.isReady) {\n                    this.addRecordValue();\n                }\n                break;\n            case INVALID:\n                throw new IOException(\"(line \" + this.getCurrentLineNumber() + \") invalid parse sequence\");\n            case COMMENT:\n                if (sb \u003d\u003d null) {\n                    sb \u003d new StringBuilder();\n                } else {\n                    sb.append(Constants.LF);\n                }\n                sb.append(this.reusableToken.content);\n                this.reusableToken.type \u003d TOKEN;\n                break;\n            default:\n                throw new IllegalStateException(\"Unexpected Token type: \" + this.reusableToken.type);\n        }\n    } while (this.reusableToken.type \u003d\u003d TOKEN);\n    if (!this.record.isEmpty()) {\n        this.recordNumber++;\n        final String comment \u003d sb \u003d\u003d null ? null : sb.toString();\n        result \u003d new CSVRecord(this.record.toArray(new String[this.record.size()]), this.headerMap, comment, this.recordNumber);\n    }\n    return result;\n}",
      "path": "src/main/java/org/apache/commons/csv/CSVParser.java",
      "functionStartLine": 438,
      "functionName": "nextRecord",
      "functionAnnotation": "",
      "functionDoc": "Parses the next record from the current point in the stream.\n\n@return the record as an array of values, or \u003ctt\u003enull\u003c/tt\u003e if the end of the stream has been reached\n@throws IOException\n            on parse error or input read-failure\n",
      "diff": "@@ -1,41 +1,41 @@\n-public CSVRecord nextRecord() throws IOException {\n+CSVRecord nextRecord() throws IOException {\n     CSVRecord result \u003d null;\n     this.record.clear();\n     StringBuilder sb \u003d null;\n     do {\n         this.reusableToken.reset();\n         this.lexer.nextToken(this.reusableToken);\n         switch(this.reusableToken.type) {\n             case TOKEN:\n                 this.addRecordValue();\n                 break;\n             case EORECORD:\n                 this.addRecordValue();\n                 break;\n             case EOF:\n                 if (this.reusableToken.isReady) {\n                     this.addRecordValue();\n                 }\n                 break;\n             case INVALID:\n                 throw new IOException(\"(line \" + this.getCurrentLineNumber() + \") invalid parse sequence\");\n             case COMMENT:\n                 if (sb \u003d\u003d null) {\n                     sb \u003d new StringBuilder();\n                 } else {\n                     sb.append(Constants.LF);\n                 }\n                 sb.append(this.reusableToken.content);\n                 this.reusableToken.type \u003d TOKEN;\n                 break;\n             default:\n                 throw new IllegalStateException(\"Unexpected Token type: \" + this.reusableToken.type);\n         }\n     } while (this.reusableToken.type \u003d\u003d TOKEN);\n     if (!this.record.isEmpty()) {\n         this.recordNumber++;\n         final String comment \u003d sb \u003d\u003d null ? null : sb.toString();\n         result \u003d new CSVRecord(this.record.toArray(new String[this.record.size()]), this.headerMap, comment, this.recordNumber);\n     }\n     return result;\n }\n\\ No newline at end of file\n",
      "extendedDetails": {
        "oldValue": "[public]",
        "newValue": "[]"
      }
    },
    "966cd208ca18c299c6c765d4e1440f0877d96981": {
      "type": "Ymodifierchange",
      "commitMessage": "[CSV-110] Add ability to parse single lines.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/commons/proper/csv/trunk@1585496 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "4/7/14, 7:50 AM",
      "commitName": "966cd208ca18c299c6c765d4e1440f0877d96981",
      "commitAuthor": "Gary D. Gregory",
      "commitDateOld": "4/4/14, 4:28 PM",
      "commitNameOld": "5daf49a1801071d95c762db561cf6b9970b018a1",
      "commitAuthorOld": "Gary D. Gregory",
      "daysBetweenCommits": 2.64,
      "commitsBetweenForRepo": 4,
      "commitsBetweenForFile": 1,
      "actualSource": "public CSVRecord nextRecord() throws IOException {\n    CSVRecord result \u003d null;\n    this.record.clear();\n    StringBuilder sb \u003d null;\n    do {\n        this.reusableToken.reset();\n        this.lexer.nextToken(this.reusableToken);\n        switch(this.reusableToken.type) {\n            case TOKEN:\n                this.addRecordValue();\n                break;\n            case EORECORD:\n                this.addRecordValue();\n                break;\n            case EOF:\n                if (this.reusableToken.isReady) {\n                    this.addRecordValue();\n                }\n                break;\n            case INVALID:\n                throw new IOException(\"(line \" + this.getCurrentLineNumber() + \") invalid parse sequence\");\n            case COMMENT:\n                if (sb \u003d\u003d null) {\n                    sb \u003d new StringBuilder();\n                } else {\n                    sb.append(Constants.LF);\n                }\n                sb.append(this.reusableToken.content);\n                this.reusableToken.type \u003d TOKEN;\n                break;\n            default:\n                throw new IllegalStateException(\"Unexpected Token type: \" + this.reusableToken.type);\n        }\n    } while (this.reusableToken.type \u003d\u003d TOKEN);\n    if (!this.record.isEmpty()) {\n        this.recordNumber++;\n        final String comment \u003d sb \u003d\u003d null ? null : sb.toString();\n        result \u003d new CSVRecord(this.record.toArray(new String[this.record.size()]), this.headerMap, comment, this.recordNumber);\n    }\n    return result;\n}",
      "path": "src/main/java/org/apache/commons/csv/CSVParser.java",
      "functionStartLine": 438,
      "functionName": "nextRecord",
      "functionAnnotation": "",
      "functionDoc": "Parses the next record from the current point in the stream.\n\n@return the record as an array of values, or \u003ctt\u003enull\u003c/tt\u003e if the end of the stream has been reached\n@throws IOException\n            on parse error or input read-failure\n",
      "diff": "@@ -1,41 +1,41 @@\n-CSVRecord nextRecord() throws IOException {\n+public CSVRecord nextRecord() throws IOException {\n     CSVRecord result \u003d null;\n     this.record.clear();\n     StringBuilder sb \u003d null;\n     do {\n         this.reusableToken.reset();\n         this.lexer.nextToken(this.reusableToken);\n         switch(this.reusableToken.type) {\n             case TOKEN:\n                 this.addRecordValue();\n                 break;\n             case EORECORD:\n                 this.addRecordValue();\n                 break;\n             case EOF:\n                 if (this.reusableToken.isReady) {\n                     this.addRecordValue();\n                 }\n                 break;\n             case INVALID:\n                 throw new IOException(\"(line \" + this.getCurrentLineNumber() + \") invalid parse sequence\");\n             case COMMENT:\n                 if (sb \u003d\u003d null) {\n                     sb \u003d new StringBuilder();\n                 } else {\n                     sb.append(Constants.LF);\n                 }\n                 sb.append(this.reusableToken.content);\n                 this.reusableToken.type \u003d TOKEN;\n                 break;\n             default:\n                 throw new IllegalStateException(\"Unexpected Token type: \" + this.reusableToken.type);\n         }\n     } while (this.reusableToken.type \u003d\u003d TOKEN);\n     if (!this.record.isEmpty()) {\n         this.recordNumber++;\n         final String comment \u003d sb \u003d\u003d null ? null : sb.toString();\n         result \u003d new CSVRecord(this.record.toArray(new String[this.record.size()]), this.headerMap, comment, this.recordNumber);\n     }\n     return result;\n }\n\\ No newline at end of file\n",
      "extendedDetails": {
        "oldValue": "[]",
        "newValue": "[public]"
      }
    },
    "9873b13df283ac65a37d56622bc1e01eca681611": {
      "type": "Ybodychange",
      "commitMessage": "Don\u0027t omit default cases\n\ngit-svn-id: https://svn.apache.org/repos/asf/commons/proper/csv/trunk@1582814 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "3/28/14, 9:38 AM",
      "commitName": "9873b13df283ac65a37d56622bc1e01eca681611",
      "commitAuthor": "Sebastian Bazley",
      "commitDateOld": "3/17/14, 11:40 AM",
      "commitNameOld": "5d5458d7f60190df9c2c54e17e489218acd18783",
      "commitAuthorOld": "Gary D. Gregory",
      "daysBetweenCommits": 10.91,
      "commitsBetweenForRepo": 6,
      "commitsBetweenForFile": 1,
      "actualSource": "CSVRecord nextRecord() throws IOException {\n    CSVRecord result \u003d null;\n    this.record.clear();\n    StringBuilder sb \u003d null;\n    do {\n        this.reusableToken.reset();\n        this.lexer.nextToken(this.reusableToken);\n        switch(this.reusableToken.type) {\n            case TOKEN:\n                this.addRecordValue();\n                break;\n            case EORECORD:\n                this.addRecordValue();\n                break;\n            case EOF:\n                if (this.reusableToken.isReady) {\n                    this.addRecordValue();\n                }\n                break;\n            case INVALID:\n                throw new IOException(\"(line \" + this.getCurrentLineNumber() + \") invalid parse sequence\");\n            case COMMENT:\n                if (sb \u003d\u003d null) {\n                    sb \u003d new StringBuilder();\n                } else {\n                    sb.append(Constants.LF);\n                }\n                sb.append(this.reusableToken.content);\n                this.reusableToken.type \u003d TOKEN;\n                break;\n            default:\n                throw new IllegalStateException(\"Unexpected Token type: \" + this.reusableToken.type);\n        }\n    } while (this.reusableToken.type \u003d\u003d TOKEN);\n    if (!this.record.isEmpty()) {\n        this.recordNumber++;\n        final String comment \u003d sb \u003d\u003d null ? null : sb.toString();\n        result \u003d new CSVRecord(this.record.toArray(new String[this.record.size()]), this.headerMap, comment, this.recordNumber);\n    }\n    return result;\n}",
      "path": "src/main/java/org/apache/commons/csv/CSVParser.java",
      "functionStartLine": 422,
      "functionName": "nextRecord",
      "functionAnnotation": "",
      "functionDoc": "Parses the next record from the current point in the stream.\n\n@return the record as an array of values, or \u003ctt\u003enull\u003c/tt\u003e if the end of the stream has been reached\n@throws IOException\n            on parse error or input read-failure\n",
      "diff": "@@ -1,39 +1,41 @@\n CSVRecord nextRecord() throws IOException {\n     CSVRecord result \u003d null;\n     this.record.clear();\n     StringBuilder sb \u003d null;\n     do {\n         this.reusableToken.reset();\n         this.lexer.nextToken(this.reusableToken);\n         switch(this.reusableToken.type) {\n             case TOKEN:\n                 this.addRecordValue();\n                 break;\n             case EORECORD:\n                 this.addRecordValue();\n                 break;\n             case EOF:\n                 if (this.reusableToken.isReady) {\n                     this.addRecordValue();\n                 }\n                 break;\n             case INVALID:\n                 throw new IOException(\"(line \" + this.getCurrentLineNumber() + \") invalid parse sequence\");\n             case COMMENT:\n                 if (sb \u003d\u003d null) {\n                     sb \u003d new StringBuilder();\n                 } else {\n                     sb.append(Constants.LF);\n                 }\n                 sb.append(this.reusableToken.content);\n                 this.reusableToken.type \u003d TOKEN;\n                 break;\n+            default:\n+                throw new IllegalStateException(\"Unexpected Token type: \" + this.reusableToken.type);\n         }\n     } while (this.reusableToken.type \u003d\u003d TOKEN);\n     if (!this.record.isEmpty()) {\n         this.recordNumber++;\n         final String comment \u003d sb \u003d\u003d null ? null : sb.toString();\n         result \u003d new CSVRecord(this.record.toArray(new String[this.record.size()]), this.headerMap, comment, this.recordNumber);\n     }\n     return result;\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "316a51f5208bc95f22124d1579882131a4f441b2": {
      "type": "Yformatchange",
      "commitMessage": "- Add some real world CSV files. \n- Add a record API to get column values using an Enum.\n- Throw a better exception when a resource is not found in a class loader for the parser.\n- Replace some tabs with spaces.\n\ngit-svn-id: https://svn.apache.org/repos/asf/commons/proper/csv/trunk@1509068 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "7/31/13, 7:03 PM",
      "commitName": "316a51f5208bc95f22124d1579882131a4f441b2",
      "commitAuthor": "Gary D. Gregory",
      "commitDateOld": "7/31/13, 8:39 AM",
      "commitNameOld": "97d34575a1074197b8a1b5832d3b2cd3e7656d8f",
      "commitAuthorOld": "Gary D. Gregory",
      "daysBetweenCommits": 0.43,
      "commitsBetweenForRepo": 9,
      "commitsBetweenForFile": 1,
      "actualSource": "CSVRecord nextRecord() throws IOException {\n    CSVRecord result \u003d null;\n    this.record.clear();\n    StringBuilder sb \u003d null;\n    do {\n        this.reusableToken.reset();\n        this.lexer.nextToken(this.reusableToken);\n        switch(this.reusableToken.type) {\n            case TOKEN:\n                this.addRecordValue();\n                break;\n            case EORECORD:\n                this.addRecordValue();\n                break;\n            case EOF:\n                if (this.reusableToken.isReady) {\n                    this.addRecordValue();\n                }\n                break;\n            case INVALID:\n                throw new IOException(\"(line \" + this.getCurrentLineNumber() + \") invalid parse sequence\");\n            case COMMENT:\n                if (sb \u003d\u003d null) {\n                    sb \u003d new StringBuilder();\n                } else {\n                    sb.append(Constants.LF);\n                }\n                sb.append(this.reusableToken.content);\n                this.reusableToken.type \u003d TOKEN;\n                break;\n        }\n    } while (this.reusableToken.type \u003d\u003d TOKEN);\n    if (!this.record.isEmpty()) {\n        this.recordNumber++;\n        final String comment \u003d sb \u003d\u003d null ? null : sb.toString();\n        result \u003d new CSVRecord(this.record.toArray(new String[this.record.size()]), this.headerMap, comment, this.recordNumber);\n    }\n    return result;\n}",
      "path": "src/main/java/org/apache/commons/csv/CSVParser.java",
      "functionStartLine": 444,
      "functionName": "nextRecord",
      "functionAnnotation": "",
      "functionDoc": "Parses the next record from the current point in the stream.\n\n@return the record as an array of values, or \u003ctt\u003enull\u003c/tt\u003e if the end of the stream has been reached\n@throws IOException\n            on parse error or input read-failure\n",
      "diff": "",
      "extendedDetails": {}
    },
    "69997467d419487cb4098ff116188091907b5ff1": {
      "type": "Ybodychange",
      "commitMessage": "Refactor to only have minimal CSVParser constructors in favor of CSVParser factory methods for String, resource path, URL, and File. Update some tests to use the APIs.\n\ngit-svn-id: https://svn.apache.org/repos/asf/commons/proper/csv/trunk@1508544 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "7/30/13, 10:36 AM",
      "commitName": "69997467d419487cb4098ff116188091907b5ff1",
      "commitAuthor": "Gary D. Gregory",
      "commitDateOld": "7/30/13, 9:26 AM",
      "commitNameOld": "61fdb7a03a22065de4c63525a4b836ba616aa1f1",
      "commitAuthorOld": "Gary D. Gregory",
      "daysBetweenCommits": 0.05,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "CSVRecord nextRecord() throws IOException {\n    CSVRecord result \u003d null;\n    this.record.clear();\n    StringBuilder sb \u003d null;\n    do {\n        this.reusableToken.reset();\n        this.lexer.nextToken(this.reusableToken);\n        switch(this.reusableToken.type) {\n            case TOKEN:\n                this.addRecordValue();\n                break;\n            case EORECORD:\n                this.addRecordValue();\n                break;\n            case EOF:\n                if (this.reusableToken.isReady) {\n                    this.addRecordValue();\n                }\n                break;\n            case INVALID:\n                throw new IOException(\"(line \" + this.getCurrentLineNumber() + \") invalid parse sequence\");\n            case COMMENT:\n                if (sb \u003d\u003d null) {\n                    sb \u003d new StringBuilder();\n                } else {\n                    sb.append(Constants.LF);\n                }\n                sb.append(this.reusableToken.content);\n                this.reusableToken.type \u003d TOKEN;\n                break;\n        }\n    } while (this.reusableToken.type \u003d\u003d TOKEN);\n    if (!this.record.isEmpty()) {\n        this.recordNumber++;\n        final String comment \u003d sb \u003d\u003d null ? null : sb.toString();\n        result \u003d new CSVRecord(this.record.toArray(new String[this.record.size()]), this.headerMap, comment, this.recordNumber);\n    }\n    return result;\n}",
      "path": "src/main/java/org/apache/commons/csv/CSVParser.java",
      "functionStartLine": 411,
      "functionName": "nextRecord",
      "functionAnnotation": "",
      "functionDoc": "Parses the next record from the current point in the stream.\n\n@return the record as an array of values, or \u003ctt\u003enull\u003c/tt\u003e if the end of the stream has been reached\n@throws IOException\n            on parse error or input read-failure\n",
      "diff": "@@ -1,39 +1,39 @@\n CSVRecord nextRecord() throws IOException {\n     CSVRecord result \u003d null;\n-    record.clear();\n+    this.record.clear();\n     StringBuilder sb \u003d null;\n     do {\n-        reusableToken.reset();\n-        lexer.nextToken(reusableToken);\n-        switch(reusableToken.type) {\n+        this.reusableToken.reset();\n+        this.lexer.nextToken(this.reusableToken);\n+        switch(this.reusableToken.type) {\n             case TOKEN:\n                 this.addRecordValue();\n                 break;\n             case EORECORD:\n                 this.addRecordValue();\n                 break;\n             case EOF:\n-                if (reusableToken.isReady) {\n+                if (this.reusableToken.isReady) {\n                     this.addRecordValue();\n                 }\n                 break;\n             case INVALID:\n-                throw new IOException(\"(line \" + getCurrentLineNumber() + \") invalid parse sequence\");\n+                throw new IOException(\"(line \" + this.getCurrentLineNumber() + \") invalid parse sequence\");\n             case COMMENT:\n                 if (sb \u003d\u003d null) {\n                     sb \u003d new StringBuilder();\n                 } else {\n                     sb.append(Constants.LF);\n                 }\n-                sb.append(reusableToken.content);\n-                reusableToken.type \u003d TOKEN;\n+                sb.append(this.reusableToken.content);\n+                this.reusableToken.type \u003d TOKEN;\n                 break;\n         }\n-    } while (reusableToken.type \u003d\u003d TOKEN);\n-    if (!record.isEmpty()) {\n-        recordNumber++;\n+    } while (this.reusableToken.type \u003d\u003d TOKEN);\n+    if (!this.record.isEmpty()) {\n+        this.recordNumber++;\n         final String comment \u003d sb \u003d\u003d null ? null : sb.toString();\n-        result \u003d new CSVRecord(record.toArray(new String[record.size()]), headerMap, comment, this.recordNumber);\n+        result \u003d new CSVRecord(this.record.toArray(new String[this.record.size()]), this.headerMap, comment, this.recordNumber);\n     }\n     return result;\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "d5cc0d8a7c7141c792395f3a0b4a29819320e500": {
      "type": "Ybodychange",
      "commitMessage": "Replace magic String with constant from Constants.\n\ngit-svn-id: https://svn.apache.org/repos/asf/commons/proper/csv/trunk@1495912 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "6/23/13, 8:17 PM",
      "commitName": "d5cc0d8a7c7141c792395f3a0b4a29819320e500",
      "commitAuthor": "Gary D. Gregory",
      "commitDateOld": "6/23/13, 8:06 PM",
      "commitNameOld": "5a0894f9e0ee9f4703b8db3f200ff4a507bf043b",
      "commitAuthorOld": "Gary D. Gregory",
      "daysBetweenCommits": 0.01,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "CSVRecord nextRecord() throws IOException {\n    CSVRecord result \u003d null;\n    record.clear();\n    StringBuilder sb \u003d null;\n    do {\n        reusableToken.reset();\n        lexer.nextToken(reusableToken);\n        switch(reusableToken.type) {\n            case TOKEN:\n                this.addRecordValue();\n                break;\n            case EORECORD:\n                this.addRecordValue();\n                break;\n            case EOF:\n                if (reusableToken.isReady) {\n                    this.addRecordValue();\n                }\n                break;\n            case INVALID:\n                throw new IOException(\"(line \" + getCurrentLineNumber() + \") invalid parse sequence\");\n            case COMMENT:\n                if (sb \u003d\u003d null) {\n                    sb \u003d new StringBuilder();\n                } else {\n                    sb.append(Constants.LF);\n                }\n                sb.append(reusableToken.content);\n                reusableToken.type \u003d TOKEN;\n                break;\n        }\n    } while (reusableToken.type \u003d\u003d TOKEN);\n    if (!record.isEmpty()) {\n        recordNumber++;\n        final String comment \u003d sb \u003d\u003d null ? null : sb.toString();\n        result \u003d new CSVRecord(record.toArray(new String[record.size()]), headerMap, comment, this.recordNumber);\n    }\n    return result;\n}",
      "path": "src/main/java/org/apache/commons/csv/CSVParser.java",
      "functionStartLine": 185,
      "functionName": "nextRecord",
      "functionAnnotation": "",
      "functionDoc": "Parses the next record from the current point in the stream.\n\n@return the record as an array of values, or \u003ctt\u003enull\u003c/tt\u003e if the end of the stream has been reached\n@throws IOException\n            on parse error or input read-failure\n",
      "diff": "@@ -1,39 +1,39 @@\n CSVRecord nextRecord() throws IOException {\n     CSVRecord result \u003d null;\n     record.clear();\n     StringBuilder sb \u003d null;\n     do {\n         reusableToken.reset();\n         lexer.nextToken(reusableToken);\n         switch(reusableToken.type) {\n             case TOKEN:\n                 this.addRecordValue();\n                 break;\n             case EORECORD:\n                 this.addRecordValue();\n                 break;\n             case EOF:\n                 if (reusableToken.isReady) {\n                     this.addRecordValue();\n                 }\n                 break;\n             case INVALID:\n                 throw new IOException(\"(line \" + getCurrentLineNumber() + \") invalid parse sequence\");\n             case COMMENT:\n                 if (sb \u003d\u003d null) {\n                     sb \u003d new StringBuilder();\n                 } else {\n-                    sb.append(\"\\n\");\n+                    sb.append(Constants.LF);\n                 }\n                 sb.append(reusableToken.content);\n                 reusableToken.type \u003d TOKEN;\n                 break;\n         }\n     } while (reusableToken.type \u003d\u003d TOKEN);\n     if (!record.isEmpty()) {\n         recordNumber++;\n         final String comment \u003d sb \u003d\u003d null ? null : sb.toString();\n         result \u003d new CSVRecord(record.toArray(new String[record.size()]), headerMap, comment, this.recordNumber);\n     }\n     return result;\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "5a0894f9e0ee9f4703b8db3f200ff4a507bf043b": {
      "type": "Ybodychange",
      "commitMessage": "[CSV-93] Allow the handling of NULL values. Use a single property \u0027nullString\u0027 for both input and output processing. No substitutions occur if null. For reading, nullString is used to convert field values to null. For writing, nullString is used to output the given string instead of the empty string.\n\ngit-svn-id: https://svn.apache.org/repos/asf/commons/proper/csv/trunk@1495911 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "6/23/13, 8:06 PM",
      "commitName": "5a0894f9e0ee9f4703b8db3f200ff4a507bf043b",
      "commitAuthor": "Gary D. Gregory",
      "commitDateOld": "5/7/13, 8:12 AM",
      "commitNameOld": "71c69df6dda034e9aa18ad07782ba88643423f58",
      "commitAuthorOld": "Sebastian Bazley",
      "daysBetweenCommits": 47.5,
      "commitsBetweenForRepo": 14,
      "commitsBetweenForFile": 1,
      "actualSource": "CSVRecord nextRecord() throws IOException {\n    CSVRecord result \u003d null;\n    record.clear();\n    StringBuilder sb \u003d null;\n    do {\n        reusableToken.reset();\n        lexer.nextToken(reusableToken);\n        switch(reusableToken.type) {\n            case TOKEN:\n                this.addRecordValue();\n                break;\n            case EORECORD:\n                this.addRecordValue();\n                break;\n            case EOF:\n                if (reusableToken.isReady) {\n                    this.addRecordValue();\n                }\n                break;\n            case INVALID:\n                throw new IOException(\"(line \" + getCurrentLineNumber() + \") invalid parse sequence\");\n            case COMMENT:\n                if (sb \u003d\u003d null) {\n                    sb \u003d new StringBuilder();\n                } else {\n                    sb.append(\"\\n\");\n                }\n                sb.append(reusableToken.content);\n                reusableToken.type \u003d TOKEN;\n                break;\n        }\n    } while (reusableToken.type \u003d\u003d TOKEN);\n    if (!record.isEmpty()) {\n        recordNumber++;\n        final String comment \u003d sb \u003d\u003d null ? null : sb.toString();\n        result \u003d new CSVRecord(record.toArray(new String[record.size()]), headerMap, comment, this.recordNumber);\n    }\n    return result;\n}",
      "path": "src/main/java/org/apache/commons/csv/CSVParser.java",
      "functionStartLine": 185,
      "functionName": "nextRecord",
      "functionAnnotation": "",
      "functionDoc": "Parses the next record from the current point in the stream.\n\n@return the record as an array of values, or \u003ctt\u003enull\u003c/tt\u003e if the end of the stream has been reached\n@throws IOException\n            on parse error or input read-failure\n",
      "diff": "@@ -1,39 +1,39 @@\n CSVRecord nextRecord() throws IOException {\n     CSVRecord result \u003d null;\n     record.clear();\n     StringBuilder sb \u003d null;\n     do {\n         reusableToken.reset();\n         lexer.nextToken(reusableToken);\n         switch(reusableToken.type) {\n             case TOKEN:\n-                record.add(reusableToken.content.toString());\n+                this.addRecordValue();\n                 break;\n             case EORECORD:\n-                record.add(reusableToken.content.toString());\n+                this.addRecordValue();\n                 break;\n             case EOF:\n                 if (reusableToken.isReady) {\n-                    record.add(reusableToken.content.toString());\n+                    this.addRecordValue();\n                 }\n                 break;\n             case INVALID:\n                 throw new IOException(\"(line \" + getCurrentLineNumber() + \") invalid parse sequence\");\n             case COMMENT:\n                 if (sb \u003d\u003d null) {\n                     sb \u003d new StringBuilder();\n                 } else {\n                     sb.append(\"\\n\");\n                 }\n                 sb.append(reusableToken.content);\n                 reusableToken.type \u003d TOKEN;\n                 break;\n         }\n     } while (reusableToken.type \u003d\u003d TOKEN);\n     if (!record.isEmpty()) {\n         recordNumber++;\n         final String comment \u003d sb \u003d\u003d null ? null : sb.toString();\n         result \u003d new CSVRecord(record.toArray(new String[record.size()]), headerMap, comment, this.recordNumber);\n     }\n     return result;\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "71c69df6dda034e9aa18ad07782ba88643423f58": {
      "type": "Ybodychange",
      "commitMessage": "CSV-98  Line number counting is confusing\n\ngit-svn-id: https://svn.apache.org/repos/asf/commons/proper/csv/trunk@1479936 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "5/7/13, 8:12 AM",
      "commitName": "71c69df6dda034e9aa18ad07782ba88643423f58",
      "commitAuthor": "Sebastian Bazley",
      "commitDateOld": "4/8/13, 1:34 PM",
      "commitNameOld": "75b9a4ba4ed34eed0afe0a6c3b8a79979685a379",
      "commitAuthorOld": "Gary D. Gregory",
      "daysBetweenCommits": 28.78,
      "commitsBetweenForRepo": 26,
      "commitsBetweenForFile": 1,
      "actualSource": "CSVRecord nextRecord() throws IOException {\n    CSVRecord result \u003d null;\n    record.clear();\n    StringBuilder sb \u003d null;\n    do {\n        reusableToken.reset();\n        lexer.nextToken(reusableToken);\n        switch(reusableToken.type) {\n            case TOKEN:\n                record.add(reusableToken.content.toString());\n                break;\n            case EORECORD:\n                record.add(reusableToken.content.toString());\n                break;\n            case EOF:\n                if (reusableToken.isReady) {\n                    record.add(reusableToken.content.toString());\n                }\n                break;\n            case INVALID:\n                throw new IOException(\"(line \" + getCurrentLineNumber() + \") invalid parse sequence\");\n            case COMMENT:\n                if (sb \u003d\u003d null) {\n                    sb \u003d new StringBuilder();\n                } else {\n                    sb.append(\"\\n\");\n                }\n                sb.append(reusableToken.content);\n                reusableToken.type \u003d TOKEN;\n                break;\n        }\n    } while (reusableToken.type \u003d\u003d TOKEN);\n    if (!record.isEmpty()) {\n        recordNumber++;\n        final String comment \u003d sb \u003d\u003d null ? null : sb.toString();\n        result \u003d new CSVRecord(record.toArray(new String[record.size()]), headerMap, comment, this.recordNumber);\n    }\n    return result;\n}",
      "path": "src/main/java/org/apache/commons/csv/CSVParser.java",
      "functionStartLine": 183,
      "functionName": "nextRecord",
      "functionAnnotation": "",
      "functionDoc": "Parses the next record from the current point in the stream.\n\n@return the record as an array of values, or \u003ctt\u003enull\u003c/tt\u003e if the end of the stream has been reached\n@throws IOException\n            on parse error or input read-failure\n",
      "diff": "@@ -1,39 +1,39 @@\n CSVRecord nextRecord() throws IOException {\n     CSVRecord result \u003d null;\n     record.clear();\n     StringBuilder sb \u003d null;\n     do {\n         reusableToken.reset();\n         lexer.nextToken(reusableToken);\n         switch(reusableToken.type) {\n             case TOKEN:\n                 record.add(reusableToken.content.toString());\n                 break;\n             case EORECORD:\n                 record.add(reusableToken.content.toString());\n                 break;\n             case EOF:\n                 if (reusableToken.isReady) {\n                     record.add(reusableToken.content.toString());\n                 }\n                 break;\n             case INVALID:\n-                throw new IOException(\"(line \" + getLineNumber() + \") invalid parse sequence\");\n+                throw new IOException(\"(line \" + getCurrentLineNumber() + \") invalid parse sequence\");\n             case COMMENT:\n                 if (sb \u003d\u003d null) {\n                     sb \u003d new StringBuilder();\n                 } else {\n                     sb.append(\"\\n\");\n                 }\n                 sb.append(reusableToken.content);\n                 reusableToken.type \u003d TOKEN;\n                 break;\n         }\n     } while (reusableToken.type \u003d\u003d TOKEN);\n     if (!record.isEmpty()) {\n         recordNumber++;\n         final String comment \u003d sb \u003d\u003d null ? null : sb.toString();\n         result \u003d new CSVRecord(record.toArray(new String[record.size()]), headerMap, comment, this.recordNumber);\n     }\n     return result;\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "7d8c7f17ff5ee965b7e1d47e667fcd878d59c6aa": {
      "type": "Ybodychange",
      "commitMessage": "Remove redundant code\n\ngit-svn-id: https://svn.apache.org/repos/asf/commons/proper/csv/trunk@1398367 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "10/15/12, 9:27 AM",
      "commitName": "7d8c7f17ff5ee965b7e1d47e667fcd878d59c6aa",
      "commitAuthor": "Sebastian Bazley",
      "commitDateOld": "10/14/12, 8:25 PM",
      "commitNameOld": "6eddd544e56b4c376619cad6b279885962293b6d",
      "commitAuthorOld": "Gary D. Gregory",
      "daysBetweenCommits": 0.54,
      "commitsBetweenForRepo": 13,
      "commitsBetweenForFile": 1,
      "actualSource": "CSVRecord nextRecord() throws IOException {\n    CSVRecord result \u003d null;\n    record.clear();\n    StringBuilder sb \u003d null;\n    do {\n        reusableToken.reset();\n        lexer.nextToken(reusableToken);\n        switch(reusableToken.type) {\n            case TOKEN:\n                record.add(reusableToken.content.toString());\n                break;\n            case EORECORD:\n                record.add(reusableToken.content.toString());\n                break;\n            case EOF:\n                if (reusableToken.isReady) {\n                    record.add(reusableToken.content.toString());\n                }\n                break;\n            case INVALID:\n                throw new IOException(\"(line \" + getLineNumber() + \") invalid parse sequence\");\n            case COMMENT:\n                if (sb \u003d\u003d null) {\n                    sb \u003d new StringBuilder();\n                } else {\n                    sb.append(\"\\n\");\n                }\n                sb.append(reusableToken.content);\n                reusableToken.type \u003d TOKEN;\n                break;\n        }\n    } while (reusableToken.type \u003d\u003d TOKEN);\n    if (!record.isEmpty()) {\n        recordNumber++;\n        final String comment \u003d sb \u003d\u003d null ? null : sb.toString();\n        result \u003d new CSVRecord(record.toArray(new String[record.size()]), headerMap, comment, this.recordNumber);\n    }\n    return result;\n}",
      "path": "src/main/java/org/apache/commons/csv/CSVParser.java",
      "functionStartLine": 166,
      "functionName": "nextRecord",
      "functionAnnotation": "",
      "functionDoc": "Parses the next record from the current point in the stream.\n\n@return the record as an array of values, or \u003ctt\u003enull\u003c/tt\u003e if the end of the stream has been reached\n@throws IOException\n            on parse error or input read-failure\n",
      "diff": "@@ -1,41 +1,39 @@\n CSVRecord nextRecord() throws IOException {\n     CSVRecord result \u003d null;\n     record.clear();\n     StringBuilder sb \u003d null;\n     do {\n         reusableToken.reset();\n         lexer.nextToken(reusableToken);\n         switch(reusableToken.type) {\n             case TOKEN:\n                 record.add(reusableToken.content.toString());\n                 break;\n             case EORECORD:\n                 record.add(reusableToken.content.toString());\n                 break;\n             case EOF:\n                 if (reusableToken.isReady) {\n                     record.add(reusableToken.content.toString());\n-                } else {\n-                    result \u003d null;\n                 }\n                 break;\n             case INVALID:\n                 throw new IOException(\"(line \" + getLineNumber() + \") invalid parse sequence\");\n             case COMMENT:\n                 if (sb \u003d\u003d null) {\n                     sb \u003d new StringBuilder();\n                 } else {\n                     sb.append(\"\\n\");\n                 }\n                 sb.append(reusableToken.content);\n                 reusableToken.type \u003d TOKEN;\n                 break;\n         }\n     } while (reusableToken.type \u003d\u003d TOKEN);\n     if (!record.isEmpty()) {\n         recordNumber++;\n         final String comment \u003d sb \u003d\u003d null ? null : sb.toString();\n         result \u003d new CSVRecord(record.toArray(new String[record.size()]), headerMap, comment, this.recordNumber);\n     }\n     return result;\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "9542a399b8fe5eafa87c22fb29590a923f0786d1": {
      "type": "Ybodychange",
      "commitMessage": "It looks like TWO record objects were created for each record read!\n\ngit-svn-id: https://svn.apache.org/repos/asf/commons/proper/csv/trunk@1397902 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "10/13/12, 10:16 AM",
      "commitName": "9542a399b8fe5eafa87c22fb29590a923f0786d1",
      "commitAuthor": "Gary D. Gregory",
      "commitDateOld": "10/13/12, 10:13 AM",
      "commitNameOld": "0e8084ab27bdd1e183b243b6c4cef97d603d23ad",
      "commitAuthorOld": "Gary D. Gregory",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "CSVRecord nextRecord() throws IOException {\n    CSVRecord result \u003d null;\n    record.clear();\n    StringBuilder sb \u003d null;\n    do {\n        reusableToken.reset();\n        lexer.nextToken(reusableToken);\n        switch(reusableToken.type) {\n            case TOKEN:\n                record.add(reusableToken.content.toString());\n                break;\n            case EORECORD:\n                record.add(reusableToken.content.toString());\n                break;\n            case EOF:\n                if (reusableToken.isReady) {\n                    record.add(reusableToken.content.toString());\n                } else {\n                    result \u003d null;\n                }\n                break;\n            case INVALID:\n                throw new IOException(\"(line \" + getLineNumber() + \") invalid parse sequence\");\n            case COMMENT:\n                if (sb \u003d\u003d null) {\n                    sb \u003d new StringBuilder();\n                } else {\n                    sb.append(\"\\n\");\n                }\n                sb.append(reusableToken.content);\n                reusableToken.type \u003d TOKEN;\n                break;\n        }\n    } while (reusableToken.type \u003d\u003d TOKEN);\n    if (!record.isEmpty()) {\n        recordNumber++;\n        final String comment \u003d sb \u003d\u003d null ? null : sb.toString();\n        result \u003d new CSVRecord(record.toArray(new String[record.size()]), headerMap, comment, this.recordNumber);\n    }\n    return result;\n}",
      "path": "src/main/java/org/apache/commons/csv/CSVParser.java",
      "functionStartLine": 164,
      "functionName": "nextRecord",
      "functionAnnotation": "",
      "functionDoc": "Parses the next record from the current point in the stream.\n\n@return the record as an array of values, or \u003ctt\u003enull\u003c/tt\u003e if the end of the stream has been reached\n@throws IOException\n            on parse error or input read-failure\n",
      "diff": "@@ -1,41 +1,41 @@\n CSVRecord nextRecord() throws IOException {\n-    CSVRecord result \u003d new CSVRecord(null, headerMap, null, recordNumber + 1);\n+    CSVRecord result \u003d null;\n     record.clear();\n     StringBuilder sb \u003d null;\n     do {\n         reusableToken.reset();\n         lexer.nextToken(reusableToken);\n         switch(reusableToken.type) {\n             case TOKEN:\n                 record.add(reusableToken.content.toString());\n                 break;\n             case EORECORD:\n                 record.add(reusableToken.content.toString());\n                 break;\n             case EOF:\n                 if (reusableToken.isReady) {\n                     record.add(reusableToken.content.toString());\n                 } else {\n                     result \u003d null;\n                 }\n                 break;\n             case INVALID:\n                 throw new IOException(\"(line \" + getLineNumber() + \") invalid parse sequence\");\n             case COMMENT:\n                 if (sb \u003d\u003d null) {\n                     sb \u003d new StringBuilder();\n                 } else {\n                     sb.append(\"\\n\");\n                 }\n                 sb.append(reusableToken.content);\n                 reusableToken.type \u003d TOKEN;\n                 break;\n         }\n     } while (reusableToken.type \u003d\u003d TOKEN);\n     if (!record.isEmpty()) {\n         recordNumber++;\n         final String comment \u003d sb \u003d\u003d null ? null : sb.toString();\n         result \u003d new CSVRecord(record.toArray(new String[record.size()]), headerMap, comment, this.recordNumber);\n     }\n     return result;\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "0e8084ab27bdd1e183b243b6c4cef97d603d23ad": {
      "type": "Yrename",
      "commitMessage": "Rename getRecord() to nextRecord()\n\ngit-svn-id: https://svn.apache.org/repos/asf/commons/proper/csv/trunk@1397900 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "10/13/12, 10:13 AM",
      "commitName": "0e8084ab27bdd1e183b243b6c4cef97d603d23ad",
      "commitAuthor": "Gary D. Gregory",
      "commitDateOld": "10/13/12, 10:11 AM",
      "commitNameOld": "3b938ba40d050c319be41a415daf5832e6097d72",
      "commitAuthorOld": "Gary D. Gregory",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "CSVRecord nextRecord() throws IOException {\n    CSVRecord result \u003d new CSVRecord(null, headerMap, null, recordNumber + 1);\n    record.clear();\n    StringBuilder sb \u003d null;\n    do {\n        reusableToken.reset();\n        lexer.nextToken(reusableToken);\n        switch(reusableToken.type) {\n            case TOKEN:\n                record.add(reusableToken.content.toString());\n                break;\n            case EORECORD:\n                record.add(reusableToken.content.toString());\n                break;\n            case EOF:\n                if (reusableToken.isReady) {\n                    record.add(reusableToken.content.toString());\n                } else {\n                    result \u003d null;\n                }\n                break;\n            case INVALID:\n                throw new IOException(\"(line \" + getLineNumber() + \") invalid parse sequence\");\n            case COMMENT:\n                if (sb \u003d\u003d null) {\n                    sb \u003d new StringBuilder();\n                } else {\n                    sb.append(\"\\n\");\n                }\n                sb.append(reusableToken.content);\n                reusableToken.type \u003d TOKEN;\n                break;\n        }\n    } while (reusableToken.type \u003d\u003d TOKEN);\n    if (!record.isEmpty()) {\n        recordNumber++;\n        final String comment \u003d sb \u003d\u003d null ? null : sb.toString();\n        result \u003d new CSVRecord(record.toArray(new String[record.size()]), headerMap, comment, this.recordNumber);\n    }\n    return result;\n}",
      "path": "src/main/java/org/apache/commons/csv/CSVParser.java",
      "functionStartLine": 164,
      "functionName": "nextRecord",
      "functionAnnotation": "",
      "functionDoc": "Parses the next record from the current point in the stream.\n\n@return the record as an array of values, or \u003ctt\u003enull\u003c/tt\u003e if the end of the stream has been reached\n@throws IOException\n            on parse error or input read-failure\n",
      "diff": "@@ -1,41 +1,41 @@\n-CSVRecord getRecord() throws IOException {\n+CSVRecord nextRecord() throws IOException {\n     CSVRecord result \u003d new CSVRecord(null, headerMap, null, recordNumber + 1);\n     record.clear();\n     StringBuilder sb \u003d null;\n     do {\n         reusableToken.reset();\n         lexer.nextToken(reusableToken);\n         switch(reusableToken.type) {\n             case TOKEN:\n                 record.add(reusableToken.content.toString());\n                 break;\n             case EORECORD:\n                 record.add(reusableToken.content.toString());\n                 break;\n             case EOF:\n                 if (reusableToken.isReady) {\n                     record.add(reusableToken.content.toString());\n                 } else {\n                     result \u003d null;\n                 }\n                 break;\n             case INVALID:\n                 throw new IOException(\"(line \" + getLineNumber() + \") invalid parse sequence\");\n             case COMMENT:\n                 if (sb \u003d\u003d null) {\n                     sb \u003d new StringBuilder();\n                 } else {\n                     sb.append(\"\\n\");\n                 }\n                 sb.append(reusableToken.content);\n                 reusableToken.type \u003d TOKEN;\n                 break;\n         }\n     } while (reusableToken.type \u003d\u003d TOKEN);\n     if (!record.isEmpty()) {\n         recordNumber++;\n         final String comment \u003d sb \u003d\u003d null ? null : sb.toString();\n         result \u003d new CSVRecord(record.toArray(new String[record.size()]), headerMap, comment, this.recordNumber);\n     }\n     return result;\n }\n\\ No newline at end of file\n",
      "extendedDetails": {
        "oldValue": "getRecord",
        "newValue": "nextRecord"
      }
    },
    "daf984983bc695591965f2126e0ef641005fe347": {
      "type": "Ybodychange",
      "commitMessage": "[CSV-52] Keep track of record numbers.\n\ngit-svn-id: https://svn.apache.org/repos/asf/commons/proper/csv/trunk@1397895 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "10/13/12, 10:09 AM",
      "commitName": "daf984983bc695591965f2126e0ef641005fe347",
      "commitAuthor": "Gary D. Gregory",
      "commitDateOld": "10/13/12, 9:23 AM",
      "commitNameOld": "3d72cb087af521b9c9cf5035af4e56889769537b",
      "commitAuthorOld": "Gary D. Gregory",
      "daysBetweenCommits": 0.03,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "CSVRecord getRecord() throws IOException {\n    CSVRecord result \u003d new CSVRecord(null, headerMap, null, recordNumber + 1);\n    record.clear();\n    StringBuilder sb \u003d null;\n    do {\n        reusableToken.reset();\n        lexer.nextToken(reusableToken);\n        switch(reusableToken.type) {\n            case TOKEN:\n                record.add(reusableToken.content.toString());\n                break;\n            case EORECORD:\n                record.add(reusableToken.content.toString());\n                break;\n            case EOF:\n                if (reusableToken.isReady) {\n                    record.add(reusableToken.content.toString());\n                } else {\n                    result \u003d null;\n                }\n                break;\n            case INVALID:\n                throw new IOException(\"(line \" + getLineNumber() + \") invalid parse sequence\");\n            case COMMENT:\n                if (sb \u003d\u003d null) {\n                    sb \u003d new StringBuilder();\n                } else {\n                    sb.append(\"\\n\");\n                }\n                sb.append(reusableToken.content);\n                reusableToken.type \u003d TOKEN;\n                break;\n        }\n    } while (reusableToken.type \u003d\u003d TOKEN);\n    if (!record.isEmpty()) {\n        recordNumber++;\n        final String comment \u003d sb \u003d\u003d null ? null : sb.toString();\n        result \u003d new CSVRecord(record.toArray(new String[record.size()]), headerMap, comment, this.recordNumber);\n    }\n    return result;\n}",
      "path": "src/main/java/org/apache/commons/csv/CSVParser.java",
      "functionStartLine": 164,
      "functionName": "getRecord",
      "functionAnnotation": "",
      "functionDoc": "Parses the next record from the current point in the stream.\n\n@return the record as an array of values, or \u003ctt\u003enull\u003c/tt\u003e if the end of the stream has been reached\n@throws IOException\n            on parse error or input read-failure\n",
      "diff": "@@ -1,40 +1,41 @@\n CSVRecord getRecord() throws IOException {\n-    CSVRecord result \u003d new CSVRecord(null, headerMap, null);\n+    CSVRecord result \u003d new CSVRecord(null, headerMap, null, recordNumber + 1);\n     record.clear();\n     StringBuilder sb \u003d null;\n     do {\n         reusableToken.reset();\n         lexer.nextToken(reusableToken);\n         switch(reusableToken.type) {\n             case TOKEN:\n                 record.add(reusableToken.content.toString());\n                 break;\n             case EORECORD:\n                 record.add(reusableToken.content.toString());\n                 break;\n             case EOF:\n                 if (reusableToken.isReady) {\n                     record.add(reusableToken.content.toString());\n                 } else {\n                     result \u003d null;\n                 }\n                 break;\n             case INVALID:\n                 throw new IOException(\"(line \" + getLineNumber() + \") invalid parse sequence\");\n             case COMMENT:\n                 if (sb \u003d\u003d null) {\n                     sb \u003d new StringBuilder();\n                 } else {\n                     sb.append(\"\\n\");\n                 }\n                 sb.append(reusableToken.content);\n                 reusableToken.type \u003d TOKEN;\n                 break;\n         }\n     } while (reusableToken.type \u003d\u003d TOKEN);\n     if (!record.isEmpty()) {\n+        recordNumber++;\n         final String comment \u003d sb \u003d\u003d null ? null : sb.toString();\n-        result \u003d new CSVRecord(record.toArray(new String[record.size()]), headerMap, comment);\n+        result \u003d new CSVRecord(record.toArray(new String[record.size()]), headerMap, comment, this.recordNumber);\n     }\n     return result;\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "473727be265240adf6d15a1d7abad2f0f31967fd": {
      "type": "Ybodychange",
      "commitMessage": "Rename ivar headerMapping -\u003e headerMap.\n\ngit-svn-id: https://svn.apache.org/repos/asf/commons/proper/csv/trunk@1383920 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "9/12/12, 5:59 AM",
      "commitName": "473727be265240adf6d15a1d7abad2f0f31967fd",
      "commitAuthor": "Gary D. Gregory",
      "commitDateOld": "9/11/12, 9:14 PM",
      "commitNameOld": "5e7945e1ceeb6cce60e3da5caf4d57f7bf531689",
      "commitAuthorOld": "Gary D. Gregory",
      "daysBetweenCommits": 0.36,
      "commitsBetweenForRepo": 2,
      "commitsBetweenForFile": 1,
      "actualSource": "CSVRecord getRecord() throws IOException {\n    CSVRecord result \u003d new CSVRecord(null, headerMap, null);\n    record.clear();\n    StringBuilder sb \u003d null;\n    do {\n        reusableToken.reset();\n        lexer.nextToken(reusableToken);\n        switch(reusableToken.type) {\n            case TOKEN:\n                record.add(reusableToken.content.toString());\n                break;\n            case EORECORD:\n                record.add(reusableToken.content.toString());\n                break;\n            case EOF:\n                if (reusableToken.isReady) {\n                    record.add(reusableToken.content.toString());\n                } else {\n                    result \u003d null;\n                }\n                break;\n            case INVALID:\n                throw new IOException(\"(line \" + getLineNumber() + \") invalid parse sequence\");\n            case COMMENT:\n                if (sb \u003d\u003d null) {\n                    sb \u003d new StringBuilder();\n                } else {\n                    sb.append(\"\\n\");\n                }\n                sb.append(reusableToken.content);\n                reusableToken.type \u003d TOKEN;\n                break;\n        }\n    } while (reusableToken.type \u003d\u003d TOKEN);\n    if (!record.isEmpty()) {\n        final String comment \u003d sb \u003d\u003d null ? null : sb.toString();\n        result \u003d new CSVRecord(record.toArray(new String[record.size()]), headerMap, comment);\n    }\n    return result;\n}",
      "path": "src/main/java/org/apache/commons/csv/CSVParser.java",
      "functionStartLine": 150,
      "functionName": "getRecord",
      "functionAnnotation": "",
      "functionDoc": "Parses the next record from the current point in the stream.\n\n@return the record as an array of values, or \u003ctt\u003enull\u003c/tt\u003e if the end of the stream has been reached\n@throws IOException\n            on parse error or input read-failure\n",
      "diff": "@@ -1,40 +1,40 @@\n CSVRecord getRecord() throws IOException {\n-    CSVRecord result \u003d new CSVRecord(null, headerMapping, null);\n+    CSVRecord result \u003d new CSVRecord(null, headerMap, null);\n     record.clear();\n     StringBuilder sb \u003d null;\n     do {\n         reusableToken.reset();\n         lexer.nextToken(reusableToken);\n         switch(reusableToken.type) {\n             case TOKEN:\n                 record.add(reusableToken.content.toString());\n                 break;\n             case EORECORD:\n                 record.add(reusableToken.content.toString());\n                 break;\n             case EOF:\n                 if (reusableToken.isReady) {\n                     record.add(reusableToken.content.toString());\n                 } else {\n                     result \u003d null;\n                 }\n                 break;\n             case INVALID:\n                 throw new IOException(\"(line \" + getLineNumber() + \") invalid parse sequence\");\n             case COMMENT:\n                 if (sb \u003d\u003d null) {\n                     sb \u003d new StringBuilder();\n                 } else {\n                     sb.append(\"\\n\");\n                 }\n                 sb.append(reusableToken.content);\n                 reusableToken.type \u003d TOKEN;\n                 break;\n         }\n     } while (reusableToken.type \u003d\u003d TOKEN);\n     if (!record.isEmpty()) {\n         final String comment \u003d sb \u003d\u003d null ? null : sb.toString();\n-        result \u003d new CSVRecord(record.toArray(new String[record.size()]), headerMapping, comment);\n+        result \u003d new CSVRecord(record.toArray(new String[record.size()]), headerMap, comment);\n     }\n     return result;\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "5e7945e1ceeb6cce60e3da5caf4d57f7bf531689": {
      "type": "Ybodychange",
      "commitMessage": "Last of the Checkstyle fixes.\n\ngit-svn-id: https://svn.apache.org/repos/asf/commons/proper/csv/trunk@1383758 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "9/11/12, 9:14 PM",
      "commitName": "5e7945e1ceeb6cce60e3da5caf4d57f7bf531689",
      "commitAuthor": "Gary D. Gregory",
      "commitDateOld": "9/11/12, 1:12 PM",
      "commitNameOld": "6c1b0fa1c49a3b4c51a0765c6ab3806ae4aa3ce5",
      "commitAuthorOld": "Gary D. Gregory",
      "daysBetweenCommits": 0.33,
      "commitsBetweenForRepo": 2,
      "commitsBetweenForFile": 1,
      "actualSource": "CSVRecord getRecord() throws IOException {\n    CSVRecord result \u003d new CSVRecord(null, headerMapping, null);\n    record.clear();\n    StringBuilder sb \u003d null;\n    do {\n        reusableToken.reset();\n        lexer.nextToken(reusableToken);\n        switch(reusableToken.type) {\n            case TOKEN:\n                record.add(reusableToken.content.toString());\n                break;\n            case EORECORD:\n                record.add(reusableToken.content.toString());\n                break;\n            case EOF:\n                if (reusableToken.isReady) {\n                    record.add(reusableToken.content.toString());\n                } else {\n                    result \u003d null;\n                }\n                break;\n            case INVALID:\n                throw new IOException(\"(line \" + getLineNumber() + \") invalid parse sequence\");\n            case COMMENT:\n                if (sb \u003d\u003d null) {\n                    sb \u003d new StringBuilder();\n                } else {\n                    sb.append(\"\\n\");\n                }\n                sb.append(reusableToken.content);\n                reusableToken.type \u003d TOKEN;\n                break;\n        }\n    } while (reusableToken.type \u003d\u003d TOKEN);\n    if (!record.isEmpty()) {\n        final String comment \u003d sb \u003d\u003d null ? null : sb.toString();\n        result \u003d new CSVRecord(record.toArray(new String[record.size()]), headerMapping, comment);\n    }\n    return result;\n}",
      "path": "src/main/java/org/apache/commons/csv/CSVParser.java",
      "functionStartLine": 150,
      "functionName": "getRecord",
      "functionAnnotation": "",
      "functionDoc": "Parses the next record from the current point in the stream.\n\n@return the record as an array of values, or \u003ctt\u003enull\u003c/tt\u003e if the end of the stream has been reached\n@throws IOException\n            on parse error or input read-failure\n",
      "diff": "@@ -1,39 +1,40 @@\n CSVRecord getRecord() throws IOException {\n     CSVRecord result \u003d new CSVRecord(null, headerMapping, null);\n     record.clear();\n     StringBuilder sb \u003d null;\n     do {\n         reusableToken.reset();\n         lexer.nextToken(reusableToken);\n         switch(reusableToken.type) {\n             case TOKEN:\n                 record.add(reusableToken.content.toString());\n                 break;\n             case EORECORD:\n                 record.add(reusableToken.content.toString());\n                 break;\n             case EOF:\n                 if (reusableToken.isReady) {\n                     record.add(reusableToken.content.toString());\n                 } else {\n                     result \u003d null;\n                 }\n                 break;\n             case INVALID:\n                 throw new IOException(\"(line \" + getLineNumber() + \") invalid parse sequence\");\n             case COMMENT:\n                 if (sb \u003d\u003d null) {\n                     sb \u003d new StringBuilder();\n                 } else {\n                     sb.append(\"\\n\");\n                 }\n                 sb.append(reusableToken.content);\n                 reusableToken.type \u003d TOKEN;\n                 break;\n         }\n     } while (reusableToken.type \u003d\u003d TOKEN);\n     if (!record.isEmpty()) {\n-        result \u003d new CSVRecord(record.toArray(new String[record.size()]), headerMapping, sb \u003d\u003d null ? null : sb.toString());\n+        final String comment \u003d sb \u003d\u003d null ? null : sb.toString();\n+        result \u003d new CSVRecord(record.toArray(new String[record.size()]), headerMapping, comment);\n     }\n     return result;\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "6c1b0fa1c49a3b4c51a0765c6ab3806ae4aa3ce5": {
      "type": "Ymultichange(Ydocchange,Yformatchange)",
      "commitMessage": "Fix Checkstyle: Format for 120 line length.\n\ngit-svn-id: https://svn.apache.org/repos/asf/commons/proper/csv/trunk@1383598 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "9/11/12, 1:12 PM",
      "commitName": "6c1b0fa1c49a3b4c51a0765c6ab3806ae4aa3ce5",
      "commitAuthor": "Gary D. Gregory",
      "subchanges": [
        {
          "type": "Ydocchange",
          "commitMessage": "Fix Checkstyle: Format for 120 line length.\n\ngit-svn-id: https://svn.apache.org/repos/asf/commons/proper/csv/trunk@1383598 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "9/11/12, 1:12 PM",
          "commitName": "6c1b0fa1c49a3b4c51a0765c6ab3806ae4aa3ce5",
          "commitAuthor": "Gary D. Gregory",
          "commitDateOld": "9/11/12, 12:40 PM",
          "commitNameOld": "bf06bed9b8905ccf5409179263707074167ccfc4",
          "commitAuthorOld": "Gary D. Gregory",
          "daysBetweenCommits": 0.02,
          "commitsBetweenForRepo": 5,
          "commitsBetweenForFile": 1,
          "actualSource": "CSVRecord getRecord() throws IOException {\n    CSVRecord result \u003d new CSVRecord(null, headerMapping, null);\n    record.clear();\n    StringBuilder sb \u003d null;\n    do {\n        reusableToken.reset();\n        lexer.nextToken(reusableToken);\n        switch(reusableToken.type) {\n            case TOKEN:\n                record.add(reusableToken.content.toString());\n                break;\n            case EORECORD:\n                record.add(reusableToken.content.toString());\n                break;\n            case EOF:\n                if (reusableToken.isReady) {\n                    record.add(reusableToken.content.toString());\n                } else {\n                    result \u003d null;\n                }\n                break;\n            case INVALID:\n                throw new IOException(\"(line \" + getLineNumber() + \") invalid parse sequence\");\n            case COMMENT:\n                if (sb \u003d\u003d null) {\n                    sb \u003d new StringBuilder();\n                } else {\n                    sb.append(\"\\n\");\n                }\n                sb.append(reusableToken.content);\n                reusableToken.type \u003d TOKEN;\n                break;\n        }\n    } while (reusableToken.type \u003d\u003d TOKEN);\n    if (!record.isEmpty()) {\n        result \u003d new CSVRecord(record.toArray(new String[record.size()]), headerMapping, sb \u003d\u003d null ? null : sb.toString());\n    }\n    return result;\n}",
          "path": "src/main/java/org/apache/commons/csv/CSVParser.java",
          "functionStartLine": 150,
          "functionName": "getRecord",
          "functionAnnotation": "",
          "functionDoc": "Parses the next record from the current point in the stream.\n\n@return the record as an array of values, or \u003ctt\u003enull\u003c/tt\u003e if the end of the stream has been reached\n@throws IOException\n            on parse error or input read-failure\n",
          "diff": "",
          "extendedDetails": {
            "oldValue": "Parses the next record from the current point in the stream.\n\n@return the record as an array of values, or \u003ctt\u003enull\u003c/tt\u003e if the end of the stream has been reached\n@throws IOException on parse error or input read-failure\n",
            "newValue": "Parses the next record from the current point in the stream.\n\n@return the record as an array of values, or \u003ctt\u003enull\u003c/tt\u003e if the end of the stream has been reached\n@throws IOException\n            on parse error or input read-failure\n"
          }
        },
        {
          "type": "Yformatchange",
          "commitMessage": "Fix Checkstyle: Format for 120 line length.\n\ngit-svn-id: https://svn.apache.org/repos/asf/commons/proper/csv/trunk@1383598 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "9/11/12, 1:12 PM",
          "commitName": "6c1b0fa1c49a3b4c51a0765c6ab3806ae4aa3ce5",
          "commitAuthor": "Gary D. Gregory",
          "commitDateOld": "9/11/12, 12:40 PM",
          "commitNameOld": "bf06bed9b8905ccf5409179263707074167ccfc4",
          "commitAuthorOld": "Gary D. Gregory",
          "daysBetweenCommits": 0.02,
          "commitsBetweenForRepo": 5,
          "commitsBetweenForFile": 1,
          "actualSource": "CSVRecord getRecord() throws IOException {\n    CSVRecord result \u003d new CSVRecord(null, headerMapping, null);\n    record.clear();\n    StringBuilder sb \u003d null;\n    do {\n        reusableToken.reset();\n        lexer.nextToken(reusableToken);\n        switch(reusableToken.type) {\n            case TOKEN:\n                record.add(reusableToken.content.toString());\n                break;\n            case EORECORD:\n                record.add(reusableToken.content.toString());\n                break;\n            case EOF:\n                if (reusableToken.isReady) {\n                    record.add(reusableToken.content.toString());\n                } else {\n                    result \u003d null;\n                }\n                break;\n            case INVALID:\n                throw new IOException(\"(line \" + getLineNumber() + \") invalid parse sequence\");\n            case COMMENT:\n                if (sb \u003d\u003d null) {\n                    sb \u003d new StringBuilder();\n                } else {\n                    sb.append(\"\\n\");\n                }\n                sb.append(reusableToken.content);\n                reusableToken.type \u003d TOKEN;\n                break;\n        }\n    } while (reusableToken.type \u003d\u003d TOKEN);\n    if (!record.isEmpty()) {\n        result \u003d new CSVRecord(record.toArray(new String[record.size()]), headerMapping, sb \u003d\u003d null ? null : sb.toString());\n    }\n    return result;\n}",
          "path": "src/main/java/org/apache/commons/csv/CSVParser.java",
          "functionStartLine": 150,
          "functionName": "getRecord",
          "functionAnnotation": "",
          "functionDoc": "Parses the next record from the current point in the stream.\n\n@return the record as an array of values, or \u003ctt\u003enull\u003c/tt\u003e if the end of the stream has been reached\n@throws IOException\n            on parse error or input read-failure\n",
          "diff": "",
          "extendedDetails": {}
        }
      ]
    },
    "bf06bed9b8905ccf5409179263707074167ccfc4": {
      "type": "Yformatchange",
      "commitMessage": "Remove trailing spaces.\n\ngit-svn-id: https://svn.apache.org/repos/asf/commons/proper/csv/trunk@1383577 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "9/11/12, 12:40 PM",
      "commitName": "bf06bed9b8905ccf5409179263707074167ccfc4",
      "commitAuthor": "Gary D. Gregory",
      "commitDateOld": "9/11/12, 12:35 PM",
      "commitNameOld": "6a132b40abbefb97ff58528eab8a8835fb353df1",
      "commitAuthorOld": "Gary D. Gregory",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 2,
      "commitsBetweenForFile": 1,
      "actualSource": "CSVRecord getRecord() throws IOException {\n    CSVRecord result \u003d new CSVRecord(null, headerMapping, null);\n    record.clear();\n    StringBuilder sb \u003d null;\n    do {\n        reusableToken.reset();\n        lexer.nextToken(reusableToken);\n        switch(reusableToken.type) {\n            case TOKEN:\n                record.add(reusableToken.content.toString());\n                break;\n            case EORECORD:\n                record.add(reusableToken.content.toString());\n                break;\n            case EOF:\n                if (reusableToken.isReady) {\n                    record.add(reusableToken.content.toString());\n                } else {\n                    result \u003d null;\n                }\n                break;\n            case INVALID:\n                throw new IOException(\"(line \" + getLineNumber() + \") invalid parse sequence\");\n            case COMMENT:\n                if (sb \u003d\u003d null) {\n                    sb \u003d new StringBuilder();\n                } else {\n                    sb.append(\"\\n\");\n                }\n                sb.append(reusableToken.content);\n                reusableToken.type \u003d TOKEN;\n                break;\n        }\n    } while (reusableToken.type \u003d\u003d TOKEN);\n    if (!record.isEmpty()) {\n        result \u003d new CSVRecord(record.toArray(new String[record.size()]), headerMapping, sb \u003d\u003d null ? null : sb.toString());\n    }\n    return result;\n}",
      "path": "src/main/java/org/apache/commons/csv/CSVParser.java",
      "functionStartLine": 135,
      "functionName": "getRecord",
      "functionAnnotation": "",
      "functionDoc": "Parses the next record from the current point in the stream.\n\n@return the record as an array of values, or \u003ctt\u003enull\u003c/tt\u003e if the end of the stream has been reached\n@throws IOException on parse error or input read-failure\n",
      "diff": "",
      "extendedDetails": {}
    },
    "787ab08db9230c67220ef453de211159e317d4e2": {
      "type": "Ybodychange",
      "commitMessage": "CSV-85 Allow comments to be returned in CSVRecord\n\ngit-svn-id: https://svn.apache.org/repos/asf/commons/proper/csv/trunk@1306947 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "3/29/12, 9:03 AM",
      "commitName": "787ab08db9230c67220ef453de211159e317d4e2",
      "commitAuthor": "Sebastian Bazley",
      "commitDateOld": "3/28/12, 7:05 AM",
      "commitNameOld": "fcfb6dc7c5262e54995dd70939f614f02a7f7cb6",
      "commitAuthorOld": "Sebastian Bazley",
      "daysBetweenCommits": 1.08,
      "commitsBetweenForRepo": 27,
      "commitsBetweenForFile": 1,
      "actualSource": "CSVRecord getRecord() throws IOException {\n    CSVRecord result \u003d new CSVRecord(null, headerMapping, null);\n    record.clear();\n    StringBuilder sb \u003d null;\n    do {\n        reusableToken.reset();\n        lexer.nextToken(reusableToken);\n        switch(reusableToken.type) {\n            case TOKEN:\n                record.add(reusableToken.content.toString());\n                break;\n            case EORECORD:\n                record.add(reusableToken.content.toString());\n                break;\n            case EOF:\n                if (reusableToken.isReady) {\n                    record.add(reusableToken.content.toString());\n                } else {\n                    result \u003d null;\n                }\n                break;\n            case INVALID:\n                throw new IOException(\"(line \" + getLineNumber() + \") invalid parse sequence\");\n            case COMMENT:\n                if (sb \u003d\u003d null) {\n                    sb \u003d new StringBuilder();\n                } else {\n                    sb.append(\"\\n\");\n                }\n                sb.append(reusableToken.content);\n                reusableToken.type \u003d TOKEN;\n                break;\n        }\n    } while (reusableToken.type \u003d\u003d TOKEN);\n    if (!record.isEmpty()) {\n        result \u003d new CSVRecord(record.toArray(new String[record.size()]), headerMapping, sb \u003d\u003d null ? null : sb.toString());\n    }\n    return result;\n}",
      "path": "src/main/java/org/apache/commons/csv/CSVParser.java",
      "functionStartLine": 135,
      "functionName": "getRecord",
      "functionAnnotation": "",
      "functionDoc": "Parses the next record from the current point in the stream.\n\n@return the record as an array of values, or \u003ctt\u003enull\u003c/tt\u003e if the end of the stream has been reached\n@throws IOException on parse error or input read-failure\n",
      "diff": "@@ -1,32 +1,39 @@\n CSVRecord getRecord() throws IOException {\n-    CSVRecord result \u003d new CSVRecord(null, headerMapping);\n+    CSVRecord result \u003d new CSVRecord(null, headerMapping, null);\n     record.clear();\n+    StringBuilder sb \u003d null;\n     do {\n         reusableToken.reset();\n         lexer.nextToken(reusableToken);\n         switch(reusableToken.type) {\n             case TOKEN:\n                 record.add(reusableToken.content.toString());\n                 break;\n             case EORECORD:\n                 record.add(reusableToken.content.toString());\n                 break;\n             case EOF:\n                 if (reusableToken.isReady) {\n                     record.add(reusableToken.content.toString());\n                 } else {\n                     result \u003d null;\n                 }\n                 break;\n             case INVALID:\n                 throw new IOException(\"(line \" + getLineNumber() + \") invalid parse sequence\");\n             case COMMENT:\n+                if (sb \u003d\u003d null) {\n+                    sb \u003d new StringBuilder();\n+                } else {\n+                    sb.append(\"\\n\");\n+                }\n+                sb.append(reusableToken.content);\n                 reusableToken.type \u003d TOKEN;\n                 break;\n         }\n     } while (reusableToken.type \u003d\u003d TOKEN);\n     if (!record.isEmpty()) {\n-        result \u003d new CSVRecord(record.toArray(new String[record.size()]), headerMapping);\n+        result \u003d new CSVRecord(record.toArray(new String[record.size()]), headerMapping, sb \u003d\u003d null ? null : sb.toString());\n     }\n     return result;\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "fcfb6dc7c5262e54995dd70939f614f02a7f7cb6": {
      "type": "Ybodychange",
      "commitMessage": "CSV-84 Clarify comment handling\nTest was wrong; line comment should have been dropped entirely.\nFix record handling accordingly\n\ngit-svn-id: https://svn.apache.org/repos/asf/commons/proper/csv/trunk@1306342 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "3/28/12, 7:05 AM",
      "commitName": "fcfb6dc7c5262e54995dd70939f614f02a7f7cb6",
      "commitAuthor": "Sebastian Bazley",
      "commitDateOld": "3/27/12, 5:01 PM",
      "commitNameOld": "0a0f3bbd365c470c2ae86b1cf383838bfaab77e1",
      "commitAuthorOld": "Sebastian Bazley",
      "daysBetweenCommits": 0.59,
      "commitsBetweenForRepo": 11,
      "commitsBetweenForFile": 1,
      "actualSource": "CSVRecord getRecord() throws IOException {\n    CSVRecord result \u003d new CSVRecord(null, headerMapping);\n    record.clear();\n    do {\n        reusableToken.reset();\n        lexer.nextToken(reusableToken);\n        switch(reusableToken.type) {\n            case TOKEN:\n                record.add(reusableToken.content.toString());\n                break;\n            case EORECORD:\n                record.add(reusableToken.content.toString());\n                break;\n            case EOF:\n                if (reusableToken.isReady) {\n                    record.add(reusableToken.content.toString());\n                } else {\n                    result \u003d null;\n                }\n                break;\n            case INVALID:\n                throw new IOException(\"(line \" + getLineNumber() + \") invalid parse sequence\");\n            case COMMENT:\n                reusableToken.type \u003d TOKEN;\n                break;\n        }\n    } while (reusableToken.type \u003d\u003d TOKEN);\n    if (!record.isEmpty()) {\n        result \u003d new CSVRecord(record.toArray(new String[record.size()]), headerMapping);\n    }\n    return result;\n}",
      "path": "src/main/java/org/apache/commons/csv/CSVParser.java",
      "functionStartLine": 135,
      "functionName": "getRecord",
      "functionAnnotation": "",
      "functionDoc": "Parses the next record from the current point in the stream.\n\n@return the record as an array of values, or \u003ctt\u003enull\u003c/tt\u003e if the end of the stream has been reached\n@throws IOException on parse error or input read-failure\n",
      "diff": "@@ -1,31 +1,32 @@\n CSVRecord getRecord() throws IOException {\n     CSVRecord result \u003d new CSVRecord(null, headerMapping);\n     record.clear();\n     do {\n         reusableToken.reset();\n         lexer.nextToken(reusableToken);\n         switch(reusableToken.type) {\n             case TOKEN:\n                 record.add(reusableToken.content.toString());\n                 break;\n             case EORECORD:\n                 record.add(reusableToken.content.toString());\n                 break;\n             case EOF:\n                 if (reusableToken.isReady) {\n                     record.add(reusableToken.content.toString());\n                 } else {\n                     result \u003d null;\n                 }\n                 break;\n             case INVALID:\n                 throw new IOException(\"(line \" + getLineNumber() + \") invalid parse sequence\");\n             case COMMENT:\n+                reusableToken.type \u003d TOKEN;\n                 break;\n         }\n     } while (reusableToken.type \u003d\u003d TOKEN);\n     if (!record.isEmpty()) {\n         result \u003d new CSVRecord(record.toArray(new String[record.size()]), headerMapping);\n     }\n     return result;\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "0a0f3bbd365c470c2ae86b1cf383838bfaab77e1": {
      "type": "Ybodychange",
      "commitMessage": "CSV-70 Improve readability of CSVLexer\nIntroduce COMMENT type\n\ngit-svn-id: https://svn.apache.org/repos/asf/commons/proper/csv/trunk@1306064 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "3/27/12, 5:01 PM",
      "commitName": "0a0f3bbd365c470c2ae86b1cf383838bfaab77e1",
      "commitAuthor": "Sebastian Bazley",
      "commitDateOld": "3/26/12, 5:42 PM",
      "commitNameOld": "0833f45bffd40f44ba6f294d84e9bac8a9ba0a37",
      "commitAuthorOld": "Sebastian Bazley",
      "daysBetweenCommits": 0.97,
      "commitsBetweenForRepo": 10,
      "commitsBetweenForFile": 1,
      "actualSource": "CSVRecord getRecord() throws IOException {\n    CSVRecord result \u003d new CSVRecord(null, headerMapping);\n    record.clear();\n    do {\n        reusableToken.reset();\n        lexer.nextToken(reusableToken);\n        switch(reusableToken.type) {\n            case TOKEN:\n                record.add(reusableToken.content.toString());\n                break;\n            case EORECORD:\n                record.add(reusableToken.content.toString());\n                break;\n            case EOF:\n                if (reusableToken.isReady) {\n                    record.add(reusableToken.content.toString());\n                } else {\n                    result \u003d null;\n                }\n                break;\n            case INVALID:\n                throw new IOException(\"(line \" + getLineNumber() + \") invalid parse sequence\");\n            case COMMENT:\n                break;\n        }\n    } while (reusableToken.type \u003d\u003d TOKEN);\n    if (!record.isEmpty()) {\n        result \u003d new CSVRecord(record.toArray(new String[record.size()]), headerMapping);\n    }\n    return result;\n}",
      "path": "src/main/java/org/apache/commons/csv/CSVParser.java",
      "functionStartLine": 135,
      "functionName": "getRecord",
      "functionAnnotation": "",
      "functionDoc": "Parses the next record from the current point in the stream.\n\n@return the record as an array of values, or \u003ctt\u003enull\u003c/tt\u003e if the end of the stream has been reached\n@throws IOException on parse error or input read-failure\n",
      "diff": "@@ -1,29 +1,31 @@\n CSVRecord getRecord() throws IOException {\n     CSVRecord result \u003d new CSVRecord(null, headerMapping);\n     record.clear();\n     do {\n         reusableToken.reset();\n         lexer.nextToken(reusableToken);\n         switch(reusableToken.type) {\n             case TOKEN:\n                 record.add(reusableToken.content.toString());\n                 break;\n             case EORECORD:\n                 record.add(reusableToken.content.toString());\n                 break;\n             case EOF:\n                 if (reusableToken.isReady) {\n                     record.add(reusableToken.content.toString());\n                 } else {\n                     result \u003d null;\n                 }\n                 break;\n             case INVALID:\n                 throw new IOException(\"(line \" + getLineNumber() + \") invalid parse sequence\");\n+            case COMMENT:\n+                break;\n         }\n     } while (reusableToken.type \u003d\u003d TOKEN);\n     if (!record.isEmpty()) {\n         result \u003d new CSVRecord(record.toArray(new String[record.size()]), headerMapping);\n     }\n     return result;\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "aee6c50e2830c007a572cc96a57bc105308acc49": {
      "type": "Ymultichange(Yreturntypechange,Ybodychange)",
      "commitMessage": "Header support (CSV-65)\n\ngit-svn-id: https://svn.apache.org/repos/asf/commons/proper/csv/trunk@1301852 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "3/16/12, 6:39 PM",
      "commitName": "aee6c50e2830c007a572cc96a57bc105308acc49",
      "commitAuthor": "Emmanuel Bourg",
      "subchanges": [
        {
          "type": "Yreturntypechange",
          "commitMessage": "Header support (CSV-65)\n\ngit-svn-id: https://svn.apache.org/repos/asf/commons/proper/csv/trunk@1301852 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "3/16/12, 6:39 PM",
          "commitName": "aee6c50e2830c007a572cc96a57bc105308acc49",
          "commitAuthor": "Emmanuel Bourg",
          "commitDateOld": "3/15/12, 1:52 AM",
          "commitNameOld": "38670dbe9232dc9b56d6464c42293e745974cf60",
          "commitAuthorOld": "Emmanuel Bourg",
          "daysBetweenCommits": 1.7,
          "commitsBetweenForRepo": 4,
          "commitsBetweenForFile": 1,
          "actualSource": "CSVRecord getRecord() throws IOException {\n    CSVRecord result \u003d new CSVRecord(null, headerMapping);\n    record.clear();\n    do {\n        reusableToken.reset();\n        lexer.nextToken(reusableToken);\n        switch(reusableToken.type) {\n            case TOKEN:\n                record.add(reusableToken.content.toString());\n                break;\n            case EORECORD:\n                record.add(reusableToken.content.toString());\n                break;\n            case EOF:\n                if (reusableToken.isReady) {\n                    record.add(reusableToken.content.toString());\n                } else {\n                    result \u003d null;\n                }\n                break;\n            case INVALID:\n                throw new IOException(\"(line \" + getLineNumber() + \") invalid parse sequence\");\n        }\n    } while (reusableToken.type \u003d\u003d TOKEN);\n    if (!record.isEmpty()) {\n        result \u003d new CSVRecord(record.toArray(new String[record.size()]), headerMapping);\n    }\n    return result;\n}",
          "path": "src/main/java/org/apache/commons/csv/CSVParser.java",
          "functionStartLine": 145,
          "functionName": "getRecord",
          "functionAnnotation": "",
          "functionDoc": "Parses the next record from the current point in the stream.\n\n@return the record as an array of values, or \u003ctt\u003enull\u003c/tt\u003e if the end of the stream has been reached\n@throws IOException on parse error or input read-failure\n",
          "diff": "@@ -1,29 +1,29 @@\n-String[] getRecord() throws IOException {\n-    String[] result \u003d EMPTY_STRING_ARRAY;\n+CSVRecord getRecord() throws IOException {\n+    CSVRecord result \u003d new CSVRecord(null, headerMapping);\n     record.clear();\n     do {\n         reusableToken.reset();\n         lexer.nextToken(reusableToken);\n         switch(reusableToken.type) {\n             case TOKEN:\n                 record.add(reusableToken.content.toString());\n                 break;\n             case EORECORD:\n                 record.add(reusableToken.content.toString());\n                 break;\n             case EOF:\n                 if (reusableToken.isReady) {\n                     record.add(reusableToken.content.toString());\n                 } else {\n                     result \u003d null;\n                 }\n                 break;\n             case INVALID:\n                 throw new IOException(\"(line \" + getLineNumber() + \") invalid parse sequence\");\n         }\n     } while (reusableToken.type \u003d\u003d TOKEN);\n     if (!record.isEmpty()) {\n-        result \u003d record.toArray(new String[record.size()]);\n+        result \u003d new CSVRecord(record.toArray(new String[record.size()]), headerMapping);\n     }\n     return result;\n }\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldValue": "String[]",
            "newValue": "CSVRecord"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "Header support (CSV-65)\n\ngit-svn-id: https://svn.apache.org/repos/asf/commons/proper/csv/trunk@1301852 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "3/16/12, 6:39 PM",
          "commitName": "aee6c50e2830c007a572cc96a57bc105308acc49",
          "commitAuthor": "Emmanuel Bourg",
          "commitDateOld": "3/15/12, 1:52 AM",
          "commitNameOld": "38670dbe9232dc9b56d6464c42293e745974cf60",
          "commitAuthorOld": "Emmanuel Bourg",
          "daysBetweenCommits": 1.7,
          "commitsBetweenForRepo": 4,
          "commitsBetweenForFile": 1,
          "actualSource": "CSVRecord getRecord() throws IOException {\n    CSVRecord result \u003d new CSVRecord(null, headerMapping);\n    record.clear();\n    do {\n        reusableToken.reset();\n        lexer.nextToken(reusableToken);\n        switch(reusableToken.type) {\n            case TOKEN:\n                record.add(reusableToken.content.toString());\n                break;\n            case EORECORD:\n                record.add(reusableToken.content.toString());\n                break;\n            case EOF:\n                if (reusableToken.isReady) {\n                    record.add(reusableToken.content.toString());\n                } else {\n                    result \u003d null;\n                }\n                break;\n            case INVALID:\n                throw new IOException(\"(line \" + getLineNumber() + \") invalid parse sequence\");\n        }\n    } while (reusableToken.type \u003d\u003d TOKEN);\n    if (!record.isEmpty()) {\n        result \u003d new CSVRecord(record.toArray(new String[record.size()]), headerMapping);\n    }\n    return result;\n}",
          "path": "src/main/java/org/apache/commons/csv/CSVParser.java",
          "functionStartLine": 145,
          "functionName": "getRecord",
          "functionAnnotation": "",
          "functionDoc": "Parses the next record from the current point in the stream.\n\n@return the record as an array of values, or \u003ctt\u003enull\u003c/tt\u003e if the end of the stream has been reached\n@throws IOException on parse error or input read-failure\n",
          "diff": "@@ -1,29 +1,29 @@\n-String[] getRecord() throws IOException {\n-    String[] result \u003d EMPTY_STRING_ARRAY;\n+CSVRecord getRecord() throws IOException {\n+    CSVRecord result \u003d new CSVRecord(null, headerMapping);\n     record.clear();\n     do {\n         reusableToken.reset();\n         lexer.nextToken(reusableToken);\n         switch(reusableToken.type) {\n             case TOKEN:\n                 record.add(reusableToken.content.toString());\n                 break;\n             case EORECORD:\n                 record.add(reusableToken.content.toString());\n                 break;\n             case EOF:\n                 if (reusableToken.isReady) {\n                     record.add(reusableToken.content.toString());\n                 } else {\n                     result \u003d null;\n                 }\n                 break;\n             case INVALID:\n                 throw new IOException(\"(line \" + getLineNumber() + \") invalid parse sequence\");\n         }\n     } while (reusableToken.type \u003d\u003d TOKEN);\n     if (!record.isEmpty()) {\n-        result \u003d record.toArray(new String[record.size()]);\n+        result \u003d new CSVRecord(record.toArray(new String[record.size()]), headerMapping);\n     }\n     return result;\n }\n\\ No newline at end of file\n",
          "extendedDetails": {}
        }
      ]
    },
    "9141cb39e6659340574a96b41d7f463ebdc2610e": {
      "type": "Ybodychange",
      "commitMessage": "Changed while loops (CSV-55)\n\ngit-svn-id: https://svn.apache.org/repos/asf/commons/proper/csv/trunk@1299706 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "3/12/12, 8:12 AM",
      "commitName": "9141cb39e6659340574a96b41d7f463ebdc2610e",
      "commitAuthor": "Emmanuel Bourg",
      "commitDateOld": "3/11/12, 4:23 PM",
      "commitNameOld": "94b9f8dc957d3a2276232c8e6f3acc6fe633b00a",
      "commitAuthorOld": "Emmanuel Bourg",
      "daysBetweenCommits": 0.66,
      "commitsBetweenForRepo": 3,
      "commitsBetweenForFile": 1,
      "actualSource": "String[] getRecord() throws IOException {\n    String[] result \u003d EMPTY_STRING_ARRAY;\n    record.clear();\n    do {\n        reusableToken.reset();\n        lexer.nextToken(reusableToken);\n        switch(reusableToken.type) {\n            case TOKEN:\n                record.add(reusableToken.content.toString());\n                break;\n            case EORECORD:\n                record.add(reusableToken.content.toString());\n                break;\n            case EOF:\n                if (reusableToken.isReady) {\n                    record.add(reusableToken.content.toString());\n                } else {\n                    result \u003d null;\n                }\n                break;\n            case INVALID:\n                throw new IOException(\"(line \" + getLineNumber() + \") invalid parse sequence\");\n        }\n    } while (reusableToken.type \u003d\u003d TOKEN);\n    if (!record.isEmpty()) {\n        result \u003d record.toArray(new String[record.size()]);\n    }\n    return result;\n}",
      "path": "src/main/java/org/apache/commons/csv/CSVParser.java",
      "functionStartLine": 143,
      "functionName": "getRecord",
      "functionAnnotation": "",
      "functionDoc": "Parses the next record from the current point in the stream.\n\n@return the record as an array of values, or \u003ctt\u003enull\u003c/tt\u003e if the end of the stream has been reached\n@throws IOException on parse error or input read-failure\n",
      "diff": "@@ -1,32 +1,29 @@\n String[] getRecord() throws IOException {\n     String[] result \u003d EMPTY_STRING_ARRAY;\n     record.clear();\n-    while (true) {\n+    do {\n         reusableToken.reset();\n         lexer.nextToken(reusableToken);\n         switch(reusableToken.type) {\n             case TOKEN:\n                 record.add(reusableToken.content.toString());\n                 break;\n             case EORECORD:\n                 record.add(reusableToken.content.toString());\n                 break;\n             case EOF:\n                 if (reusableToken.isReady) {\n                     record.add(reusableToken.content.toString());\n                 } else {\n                     result \u003d null;\n                 }\n                 break;\n             case INVALID:\n                 throw new IOException(\"(line \" + getLineNumber() + \") invalid parse sequence\");\n         }\n-        if (reusableToken.type !\u003d TOKEN) {\n-            break;\n-        }\n-    }\n+    } while (reusableToken.type \u003d\u003d TOKEN);\n     if (!record.isEmpty()) {\n         result \u003d record.toArray(new String[record.size()]);\n     }\n     return result;\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "2ec4c994c0458ef893af9bd518849bec21b2dec4": {
      "type": "Ymultichange(Yrename,Ybodychange,Ydocchange)",
      "commitMessage": "Renamed CSVParser.getLine() into getRecord() to avoid confusions since a record can span several lines\n\ngit-svn-id: https://svn.apache.org/repos/asf/commons/sandbox/csv/trunk@1298333 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "3/8/12, 1:59 AM",
      "commitName": "2ec4c994c0458ef893af9bd518849bec21b2dec4",
      "commitAuthor": "Emmanuel Bourg",
      "subchanges": [
        {
          "type": "Yrename",
          "commitMessage": "Renamed CSVParser.getLine() into getRecord() to avoid confusions since a record can span several lines\n\ngit-svn-id: https://svn.apache.org/repos/asf/commons/sandbox/csv/trunk@1298333 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "3/8/12, 1:59 AM",
          "commitName": "2ec4c994c0458ef893af9bd518849bec21b2dec4",
          "commitAuthor": "Emmanuel Bourg",
          "commitDateOld": "3/7/12, 4:00 PM",
          "commitNameOld": "a65806a126d71477b3538b571c45f27de054ff84",
          "commitAuthorOld": "Emmanuel Bourg",
          "daysBetweenCommits": 0.42,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "actualSource": "String[] getRecord() throws IOException {\n    String[] result \u003d EMPTY_STRING_ARRAY;\n    record.clear();\n    while (true) {\n        reusableToken.reset();\n        lexer.nextToken(reusableToken);\n        switch(reusableToken.type) {\n            case TOKEN:\n                record.add(reusableToken.content.toString());\n                break;\n            case EORECORD:\n                record.add(reusableToken.content.toString());\n                break;\n            case EOF:\n                if (reusableToken.isReady) {\n                    record.add(reusableToken.content.toString());\n                } else {\n                    result \u003d null;\n                }\n                break;\n            case INVALID:\n                throw new IOException(\"(line \" + getLineNumber() + \") invalid parse sequence\");\n        }\n        if (reusableToken.type !\u003d TOKEN) {\n            break;\n        }\n    }\n    if (!record.isEmpty()) {\n        result \u003d record.toArray(new String[record.size()]);\n    }\n    return result;\n}",
          "path": "src/main/java/org/apache/commons/csv/CSVParser.java",
          "functionStartLine": 143,
          "functionName": "getRecord",
          "functionAnnotation": "",
          "functionDoc": "Parses the next record from the current point in the stream.\n\n@return the record as an array of values, or \u003ctt\u003enull\u003c/tt\u003e if the end of the stream has been reached\n@throws IOException on parse error or input read-failure\n",
          "diff": "@@ -1,33 +1,32 @@\n-String[] getLine() throws IOException {\n-    String[] ret \u003d EMPTY_STRING_ARRAY;\n+String[] getRecord() throws IOException {\n+    String[] result \u003d EMPTY_STRING_ARRAY;\n     record.clear();\n     while (true) {\n         reusableToken.reset();\n         lexer.nextToken(reusableToken);\n         switch(reusableToken.type) {\n             case TOKEN:\n                 record.add(reusableToken.content.toString());\n                 break;\n             case EORECORD:\n                 record.add(reusableToken.content.toString());\n                 break;\n             case EOF:\n                 if (reusableToken.isReady) {\n                     record.add(reusableToken.content.toString());\n                 } else {\n-                    ret \u003d null;\n+                    result \u003d null;\n                 }\n                 break;\n             case INVALID:\n-            default:\n                 throw new IOException(\"(line \" + getLineNumber() + \") invalid parse sequence\");\n         }\n         if (reusableToken.type !\u003d TOKEN) {\n             break;\n         }\n     }\n     if (!record.isEmpty()) {\n-        ret \u003d record.toArray(new String[record.size()]);\n+        result \u003d record.toArray(new String[record.size()]);\n     }\n-    return ret;\n+    return result;\n }\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldValue": "getLine",
            "newValue": "getRecord"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "Renamed CSVParser.getLine() into getRecord() to avoid confusions since a record can span several lines\n\ngit-svn-id: https://svn.apache.org/repos/asf/commons/sandbox/csv/trunk@1298333 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "3/8/12, 1:59 AM",
          "commitName": "2ec4c994c0458ef893af9bd518849bec21b2dec4",
          "commitAuthor": "Emmanuel Bourg",
          "commitDateOld": "3/7/12, 4:00 PM",
          "commitNameOld": "a65806a126d71477b3538b571c45f27de054ff84",
          "commitAuthorOld": "Emmanuel Bourg",
          "daysBetweenCommits": 0.42,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "actualSource": "String[] getRecord() throws IOException {\n    String[] result \u003d EMPTY_STRING_ARRAY;\n    record.clear();\n    while (true) {\n        reusableToken.reset();\n        lexer.nextToken(reusableToken);\n        switch(reusableToken.type) {\n            case TOKEN:\n                record.add(reusableToken.content.toString());\n                break;\n            case EORECORD:\n                record.add(reusableToken.content.toString());\n                break;\n            case EOF:\n                if (reusableToken.isReady) {\n                    record.add(reusableToken.content.toString());\n                } else {\n                    result \u003d null;\n                }\n                break;\n            case INVALID:\n                throw new IOException(\"(line \" + getLineNumber() + \") invalid parse sequence\");\n        }\n        if (reusableToken.type !\u003d TOKEN) {\n            break;\n        }\n    }\n    if (!record.isEmpty()) {\n        result \u003d record.toArray(new String[record.size()]);\n    }\n    return result;\n}",
          "path": "src/main/java/org/apache/commons/csv/CSVParser.java",
          "functionStartLine": 143,
          "functionName": "getRecord",
          "functionAnnotation": "",
          "functionDoc": "Parses the next record from the current point in the stream.\n\n@return the record as an array of values, or \u003ctt\u003enull\u003c/tt\u003e if the end of the stream has been reached\n@throws IOException on parse error or input read-failure\n",
          "diff": "@@ -1,33 +1,32 @@\n-String[] getLine() throws IOException {\n-    String[] ret \u003d EMPTY_STRING_ARRAY;\n+String[] getRecord() throws IOException {\n+    String[] result \u003d EMPTY_STRING_ARRAY;\n     record.clear();\n     while (true) {\n         reusableToken.reset();\n         lexer.nextToken(reusableToken);\n         switch(reusableToken.type) {\n             case TOKEN:\n                 record.add(reusableToken.content.toString());\n                 break;\n             case EORECORD:\n                 record.add(reusableToken.content.toString());\n                 break;\n             case EOF:\n                 if (reusableToken.isReady) {\n                     record.add(reusableToken.content.toString());\n                 } else {\n-                    ret \u003d null;\n+                    result \u003d null;\n                 }\n                 break;\n             case INVALID:\n-            default:\n                 throw new IOException(\"(line \" + getLineNumber() + \") invalid parse sequence\");\n         }\n         if (reusableToken.type !\u003d TOKEN) {\n             break;\n         }\n     }\n     if (!record.isEmpty()) {\n-        ret \u003d record.toArray(new String[record.size()]);\n+        result \u003d record.toArray(new String[record.size()]);\n     }\n-    return ret;\n+    return result;\n }\n\\ No newline at end of file\n",
          "extendedDetails": {}
        },
        {
          "type": "Ydocchange",
          "commitMessage": "Renamed CSVParser.getLine() into getRecord() to avoid confusions since a record can span several lines\n\ngit-svn-id: https://svn.apache.org/repos/asf/commons/sandbox/csv/trunk@1298333 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "3/8/12, 1:59 AM",
          "commitName": "2ec4c994c0458ef893af9bd518849bec21b2dec4",
          "commitAuthor": "Emmanuel Bourg",
          "commitDateOld": "3/7/12, 4:00 PM",
          "commitNameOld": "a65806a126d71477b3538b571c45f27de054ff84",
          "commitAuthorOld": "Emmanuel Bourg",
          "daysBetweenCommits": 0.42,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "actualSource": "String[] getRecord() throws IOException {\n    String[] result \u003d EMPTY_STRING_ARRAY;\n    record.clear();\n    while (true) {\n        reusableToken.reset();\n        lexer.nextToken(reusableToken);\n        switch(reusableToken.type) {\n            case TOKEN:\n                record.add(reusableToken.content.toString());\n                break;\n            case EORECORD:\n                record.add(reusableToken.content.toString());\n                break;\n            case EOF:\n                if (reusableToken.isReady) {\n                    record.add(reusableToken.content.toString());\n                } else {\n                    result \u003d null;\n                }\n                break;\n            case INVALID:\n                throw new IOException(\"(line \" + getLineNumber() + \") invalid parse sequence\");\n        }\n        if (reusableToken.type !\u003d TOKEN) {\n            break;\n        }\n    }\n    if (!record.isEmpty()) {\n        result \u003d record.toArray(new String[record.size()]);\n    }\n    return result;\n}",
          "path": "src/main/java/org/apache/commons/csv/CSVParser.java",
          "functionStartLine": 143,
          "functionName": "getRecord",
          "functionAnnotation": "",
          "functionDoc": "Parses the next record from the current point in the stream.\n\n@return the record as an array of values, or \u003ctt\u003enull\u003c/tt\u003e if the end of the stream has been reached\n@throws IOException on parse error or input read-failure\n",
          "diff": "@@ -1,33 +1,32 @@\n-String[] getLine() throws IOException {\n-    String[] ret \u003d EMPTY_STRING_ARRAY;\n+String[] getRecord() throws IOException {\n+    String[] result \u003d EMPTY_STRING_ARRAY;\n     record.clear();\n     while (true) {\n         reusableToken.reset();\n         lexer.nextToken(reusableToken);\n         switch(reusableToken.type) {\n             case TOKEN:\n                 record.add(reusableToken.content.toString());\n                 break;\n             case EORECORD:\n                 record.add(reusableToken.content.toString());\n                 break;\n             case EOF:\n                 if (reusableToken.isReady) {\n                     record.add(reusableToken.content.toString());\n                 } else {\n-                    ret \u003d null;\n+                    result \u003d null;\n                 }\n                 break;\n             case INVALID:\n-            default:\n                 throw new IOException(\"(line \" + getLineNumber() + \") invalid parse sequence\");\n         }\n         if (reusableToken.type !\u003d TOKEN) {\n             break;\n         }\n     }\n     if (!record.isEmpty()) {\n-        ret \u003d record.toArray(new String[record.size()]);\n+        result \u003d record.toArray(new String[record.size()]);\n     }\n-    return ret;\n+    return result;\n }\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldValue": "Parses from the current point in the stream til the end of the current line.\n\n@return array of values til end of line (\u0027null\u0027 when end of file has been reached)\n@throws IOException on parse error or input read-failure\n",
            "newValue": "Parses the next record from the current point in the stream.\n\n@return the record as an array of values, or \u003ctt\u003enull\u003c/tt\u003e if the end of the stream has been reached\n@throws IOException on parse error or input read-failure\n"
          }
        }
      ]
    },
    "ca7bbae40ef89e561f74d1a00776e3a9f697bd37": {
      "type": "Ybodychange",
      "commitMessage": "Extracted the lexer from CSVParser in a distinct class (suggested by Bob Smith)\n\ngit-svn-id: https://svn.apache.org/repos/asf/commons/sandbox/csv/trunk@1298033 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "3/7/12, 10:21 AM",
      "commitName": "ca7bbae40ef89e561f74d1a00776e3a9f697bd37",
      "commitAuthor": "Emmanuel Bourg",
      "commitDateOld": "3/7/12, 7:58 AM",
      "commitNameOld": "00d0def6953d414af6ecf36a9584c5453ee39c29",
      "commitAuthorOld": "Emmanuel Bourg",
      "daysBetweenCommits": 0.1,
      "commitsBetweenForRepo": 2,
      "commitsBetweenForFile": 1,
      "actualSource": "String[] getLine() throws IOException {\n    String[] ret \u003d EMPTY_STRING_ARRAY;\n    record.clear();\n    while (true) {\n        reusableToken.reset();\n        lexer.nextToken(reusableToken);\n        switch(reusableToken.type) {\n            case TOKEN:\n                record.add(reusableToken.content.toString());\n                break;\n            case EORECORD:\n                record.add(reusableToken.content.toString());\n                break;\n            case EOF:\n                if (reusableToken.isReady) {\n                    record.add(reusableToken.content.toString());\n                } else {\n                    ret \u003d null;\n                }\n                break;\n            case INVALID:\n            default:\n                throw new IOException(\"(line \" + getLineNumber() + \") invalid parse sequence\");\n        }\n        if (reusableToken.type !\u003d TOKEN) {\n            break;\n        }\n    }\n    if (!record.isEmpty()) {\n        ret \u003d record.toArray(new String[record.size()]);\n    }\n    return ret;\n}",
      "path": "src/main/java/org/apache/commons/csv/CSVParser.java",
      "functionStartLine": 138,
      "functionName": "getLine",
      "functionAnnotation": "",
      "functionDoc": "Parses from the current point in the stream til the end of the current line.\n\n@return array of values til end of line (\u0027null\u0027 when end of file has been reached)\n@throws IOException on parse error or input read-failure\n",
      "diff": "@@ -1,33 +1,33 @@\n String[] getLine() throws IOException {\n     String[] ret \u003d EMPTY_STRING_ARRAY;\n     record.clear();\n     while (true) {\n         reusableToken.reset();\n-        nextToken(reusableToken);\n+        lexer.nextToken(reusableToken);\n         switch(reusableToken.type) {\n             case TOKEN:\n                 record.add(reusableToken.content.toString());\n                 break;\n             case EORECORD:\n                 record.add(reusableToken.content.toString());\n                 break;\n             case EOF:\n                 if (reusableToken.isReady) {\n                     record.add(reusableToken.content.toString());\n                 } else {\n                     ret \u003d null;\n                 }\n                 break;\n             case INVALID:\n             default:\n                 throw new IOException(\"(line \" + getLineNumber() + \") invalid parse sequence\");\n         }\n         if (reusableToken.type !\u003d TOKEN) {\n             break;\n         }\n     }\n     if (!record.isEmpty()) {\n         ret \u003d record.toArray(new String[record.size()]);\n     }\n     return ret;\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "9dd3dda09f09c6baa7e053b39043bc9e2ef47ee0": {
      "type": "Ydocchange",
      "commitMessage": "Removed the package private method CSVParser.nextToken()\n\ngit-svn-id: https://svn.apache.org/repos/asf/commons/sandbox/csv/trunk@1297431 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "3/6/12, 3:23 AM",
      "commitName": "9dd3dda09f09c6baa7e053b39043bc9e2ef47ee0",
      "commitAuthor": "Emmanuel Bourg",
      "commitDateOld": "3/5/12, 9:27 AM",
      "commitNameOld": "f6c0433b65a97745b9a3044cebe3ddc6e28c1836",
      "commitAuthorOld": "Emmanuel Bourg",
      "daysBetweenCommits": 0.75,
      "commitsBetweenForRepo": 7,
      "commitsBetweenForFile": 1,
      "actualSource": "String[] getLine() throws IOException {\n    String[] ret \u003d EMPTY_STRING_ARRAY;\n    record.clear();\n    while (true) {\n        reusableToken.reset();\n        nextToken(reusableToken);\n        switch(reusableToken.type) {\n            case TOKEN:\n                record.add(reusableToken.content.toString());\n                break;\n            case EORECORD:\n                record.add(reusableToken.content.toString());\n                break;\n            case EOF:\n                if (reusableToken.isReady) {\n                    record.add(reusableToken.content.toString());\n                } else {\n                    ret \u003d null;\n                }\n                break;\n            case INVALID:\n            default:\n                throw new IOException(\"(line \" + getLineNumber() + \") invalid parse sequence\");\n        }\n        if (reusableToken.type !\u003d TOKEN) {\n            break;\n        }\n    }\n    if (!record.isEmpty()) {\n        ret \u003d record.toArray(new String[record.size()]);\n    }\n    return ret;\n}",
      "path": "src/main/java/org/apache/commons/csv/CSVParser.java",
      "functionStartLine": 187,
      "functionName": "getLine",
      "functionAnnotation": "",
      "functionDoc": "Parses from the current point in the stream til the end of the current line.\n\n@return array of values til end of line (\u0027null\u0027 when end of file has been reached)\n@throws IOException on parse error or input read-failure\n",
      "diff": "",
      "extendedDetails": {
        "oldValue": "Parses from the current point in the stream til * the end of the current line.\n\n@return array of values til end of line (\u0027null\u0027 when end of file has been reached)\n@throws IOException on parse error or input read-failure\n",
        "newValue": "Parses from the current point in the stream til the end of the current line.\n\n@return array of values til end of line (\u0027null\u0027 when end of file has been reached)\n@throws IOException on parse error or input read-failure\n"
      }
    },
    "7bd9d1d970b04a8439fee0bd5224159f57cb2512": {
      "type": "Ymultichange(Ybodychange,Ydocchange)",
      "commitMessage": "Updated the Javadoc\n\ngit-svn-id: https://svn.apache.org/repos/asf/commons/sandbox/csv/trunk@1297043 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "3/5/12, 5:08 AM",
      "commitName": "7bd9d1d970b04a8439fee0bd5224159f57cb2512",
      "commitAuthor": "Emmanuel Bourg",
      "subchanges": [
        {
          "type": "Ybodychange",
          "commitMessage": "Updated the Javadoc\n\ngit-svn-id: https://svn.apache.org/repos/asf/commons/sandbox/csv/trunk@1297043 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "3/5/12, 5:08 AM",
          "commitName": "7bd9d1d970b04a8439fee0bd5224159f57cb2512",
          "commitAuthor": "Emmanuel Bourg",
          "commitDateOld": "11/9/11, 3:04 PM",
          "commitNameOld": "045dbbbe4ab84618cee8ba27d00b9283ce0a2715",
          "commitAuthorOld": "Emmanuel Bourg",
          "daysBetweenCommits": 116.59,
          "commitsBetweenForRepo": 9,
          "commitsBetweenForFile": 1,
          "actualSource": "String[] getLine() throws IOException {\n    String[] ret \u003d EMPTY_STRING_ARRAY;\n    record.clear();\n    while (true) {\n        reusableToken.reset();\n        nextToken(reusableToken);\n        switch(reusableToken.type) {\n            case TOKEN:\n                record.add(reusableToken.content.toString());\n                break;\n            case EORECORD:\n                record.add(reusableToken.content.toString());\n                break;\n            case EOF:\n                if (reusableToken.isReady) {\n                    record.add(reusableToken.content.toString());\n                } else {\n                    ret \u003d null;\n                }\n                break;\n            case INVALID:\n            default:\n                throw new IOException(\"(line \" + getLineNumber() + \") invalid parse sequence\");\n        }\n        if (reusableToken.type !\u003d TOKEN) {\n            break;\n        }\n    }\n    if (!record.isEmpty()) {\n        ret \u003d record.toArray(new String[record.size()]);\n    }\n    return ret;\n}",
          "path": "src/main/java/org/apache/commons/csv/CSVParser.java",
          "functionStartLine": 176,
          "functionName": "getLine",
          "functionAnnotation": "",
          "functionDoc": "Parses from the current point in the stream til * the end of the current line.\n\n@return array of values til end of line (\u0027null\u0027 when end of file has been reached)\n@throws IOException on parse error or input read-failure\n",
          "diff": "@@ -1,33 +1,33 @@\n String[] getLine() throws IOException {\n     String[] ret \u003d EMPTY_STRING_ARRAY;\n     record.clear();\n     while (true) {\n         reusableToken.reset();\n         nextToken(reusableToken);\n         switch(reusableToken.type) {\n             case TOKEN:\n                 record.add(reusableToken.content.toString());\n                 break;\n             case EORECORD:\n                 record.add(reusableToken.content.toString());\n                 break;\n             case EOF:\n                 if (reusableToken.isReady) {\n                     record.add(reusableToken.content.toString());\n                 } else {\n                     ret \u003d null;\n                 }\n                 break;\n             case INVALID:\n             default:\n                 throw new IOException(\"(line \" + getLineNumber() + \") invalid parse sequence\");\n         }\n         if (reusableToken.type !\u003d TOKEN) {\n             break;\n         }\n     }\n     if (!record.isEmpty()) {\n-        ret \u003d (String[]) record.toArray(new String[record.size()]);\n+        ret \u003d record.toArray(new String[record.size()]);\n     }\n     return ret;\n }\n\\ No newline at end of file\n",
          "extendedDetails": {}
        },
        {
          "type": "Ydocchange",
          "commitMessage": "Updated the Javadoc\n\ngit-svn-id: https://svn.apache.org/repos/asf/commons/sandbox/csv/trunk@1297043 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "3/5/12, 5:08 AM",
          "commitName": "7bd9d1d970b04a8439fee0bd5224159f57cb2512",
          "commitAuthor": "Emmanuel Bourg",
          "commitDateOld": "11/9/11, 3:04 PM",
          "commitNameOld": "045dbbbe4ab84618cee8ba27d00b9283ce0a2715",
          "commitAuthorOld": "Emmanuel Bourg",
          "daysBetweenCommits": 116.59,
          "commitsBetweenForRepo": 9,
          "commitsBetweenForFile": 1,
          "actualSource": "String[] getLine() throws IOException {\n    String[] ret \u003d EMPTY_STRING_ARRAY;\n    record.clear();\n    while (true) {\n        reusableToken.reset();\n        nextToken(reusableToken);\n        switch(reusableToken.type) {\n            case TOKEN:\n                record.add(reusableToken.content.toString());\n                break;\n            case EORECORD:\n                record.add(reusableToken.content.toString());\n                break;\n            case EOF:\n                if (reusableToken.isReady) {\n                    record.add(reusableToken.content.toString());\n                } else {\n                    ret \u003d null;\n                }\n                break;\n            case INVALID:\n            default:\n                throw new IOException(\"(line \" + getLineNumber() + \") invalid parse sequence\");\n        }\n        if (reusableToken.type !\u003d TOKEN) {\n            break;\n        }\n    }\n    if (!record.isEmpty()) {\n        ret \u003d record.toArray(new String[record.size()]);\n    }\n    return ret;\n}",
          "path": "src/main/java/org/apache/commons/csv/CSVParser.java",
          "functionStartLine": 176,
          "functionName": "getLine",
          "functionAnnotation": "",
          "functionDoc": "Parses from the current point in the stream til * the end of the current line.\n\n@return array of values til end of line (\u0027null\u0027 when end of file has been reached)\n@throws IOException on parse error or input read-failure\n",
          "diff": "@@ -1,33 +1,33 @@\n String[] getLine() throws IOException {\n     String[] ret \u003d EMPTY_STRING_ARRAY;\n     record.clear();\n     while (true) {\n         reusableToken.reset();\n         nextToken(reusableToken);\n         switch(reusableToken.type) {\n             case TOKEN:\n                 record.add(reusableToken.content.toString());\n                 break;\n             case EORECORD:\n                 record.add(reusableToken.content.toString());\n                 break;\n             case EOF:\n                 if (reusableToken.isReady) {\n                     record.add(reusableToken.content.toString());\n                 } else {\n                     ret \u003d null;\n                 }\n                 break;\n             case INVALID:\n             default:\n                 throw new IOException(\"(line \" + getLineNumber() + \") invalid parse sequence\");\n         }\n         if (reusableToken.type !\u003d TOKEN) {\n             break;\n         }\n     }\n     if (!record.isEmpty()) {\n-        ret \u003d (String[]) record.toArray(new String[record.size()]);\n+        ret \u003d record.toArray(new String[record.size()]);\n     }\n     return ret;\n }\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldValue": "Parses from the current point in the stream til\nthe end of the current line.\n\n@return array of values til end of line\n        (\u0027null\u0027 when end of file has been reached)\n@throws IOException on parse error or input read-failure\n",
            "newValue": "Parses from the current point in the stream til * the end of the current line.\n\n@return array of values til end of line (\u0027null\u0027 when end of file has been reached)\n@throws IOException on parse error or input read-failure\n"
          }
        }
      ]
    },
    "045dbbbe4ab84618cee8ba27d00b9283ce0a2715": {
      "type": "Ymodifierchange",
      "commitMessage": "Made CSVParser iterable to simplify the iteration over the records\n\ngit-svn-id: https://svn.apache.org/repos/asf/commons/sandbox/csv/trunk@1200024 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "11/9/11, 3:04 PM",
      "commitName": "045dbbbe4ab84618cee8ba27d00b9283ce0a2715",
      "commitAuthor": "Emmanuel Bourg",
      "commitDateOld": "11/9/11, 2:04 PM",
      "commitNameOld": "a7bd28c496457aa7c32db4ea529c4f3df7e78fe9",
      "commitAuthorOld": "Emmanuel Bourg",
      "daysBetweenCommits": 0.04,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "String[] getLine() throws IOException {\n    String[] ret \u003d EMPTY_STRING_ARRAY;\n    record.clear();\n    while (true) {\n        reusableToken.reset();\n        nextToken(reusableToken);\n        switch(reusableToken.type) {\n            case TOKEN:\n                record.add(reusableToken.content.toString());\n                break;\n            case EORECORD:\n                record.add(reusableToken.content.toString());\n                break;\n            case EOF:\n                if (reusableToken.isReady) {\n                    record.add(reusableToken.content.toString());\n                } else {\n                    ret \u003d null;\n                }\n                break;\n            case INVALID:\n            default:\n                throw new IOException(\"(line \" + getLineNumber() + \") invalid parse sequence\");\n        }\n        if (reusableToken.type !\u003d TOKEN) {\n            break;\n        }\n    }\n    if (!record.isEmpty()) {\n        ret \u003d (String[]) record.toArray(new String[record.size()]);\n    }\n    return ret;\n}",
      "path": "src/main/java/org/apache/commons/csv/CSVParser.java",
      "functionStartLine": 181,
      "functionName": "getLine",
      "functionAnnotation": "",
      "functionDoc": "Parses from the current point in the stream til\nthe end of the current line.\n\n@return array of values til end of line\n        (\u0027null\u0027 when end of file has been reached)\n@throws IOException on parse error or input read-failure\n",
      "diff": "@@ -1,33 +1,33 @@\n-public String[] getLine() throws IOException {\n+String[] getLine() throws IOException {\n     String[] ret \u003d EMPTY_STRING_ARRAY;\n     record.clear();\n     while (true) {\n         reusableToken.reset();\n         nextToken(reusableToken);\n         switch(reusableToken.type) {\n             case TOKEN:\n                 record.add(reusableToken.content.toString());\n                 break;\n             case EORECORD:\n                 record.add(reusableToken.content.toString());\n                 break;\n             case EOF:\n                 if (reusableToken.isReady) {\n                     record.add(reusableToken.content.toString());\n                 } else {\n                     ret \u003d null;\n                 }\n                 break;\n             case INVALID:\n             default:\n                 throw new IOException(\"(line \" + getLineNumber() + \") invalid parse sequence\");\n         }\n         if (reusableToken.type !\u003d TOKEN) {\n             break;\n         }\n     }\n     if (!record.isEmpty()) {\n         ret \u003d (String[]) record.toArray(new String[record.size()]);\n     }\n     return ret;\n }\n\\ No newline at end of file\n",
      "extendedDetails": {
        "oldValue": "[public]",
        "newValue": "[]"
      }
    },
    "16bfec07ffd785e5abbabdc4145eeac5cccc2c79": {
      "type": "Ybodychange",
      "commitMessage": "Turned the token types into an Enum\n\ngit-svn-id: https://svn.apache.org/repos/asf/commons/sandbox/csv/trunk@1199872 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "11/9/11, 9:11 AM",
      "commitName": "16bfec07ffd785e5abbabdc4145eeac5cccc2c79",
      "commitAuthor": "Emmanuel Bourg",
      "commitDateOld": "11/9/11, 8:58 AM",
      "commitNameOld": "cbcfb72912f41d1fac3f6d26ca27406cca94da9e",
      "commitAuthorOld": "Emmanuel Bourg",
      "daysBetweenCommits": 0.01,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "public String[] getLine() throws IOException {\n    String[] ret \u003d EMPTY_STRING_ARRAY;\n    record.clear();\n    while (true) {\n        reusableToken.reset();\n        nextToken(reusableToken);\n        switch(reusableToken.type) {\n            case TOKEN:\n                record.add(reusableToken.content.toString());\n                break;\n            case EORECORD:\n                record.add(reusableToken.content.toString());\n                break;\n            case EOF:\n                if (reusableToken.isReady) {\n                    record.add(reusableToken.content.toString());\n                } else {\n                    ret \u003d null;\n                }\n                break;\n            case INVALID:\n            default:\n                throw new IOException(\"(line \" + getLineNumber() + \") invalid parse sequence\");\n        }\n        if (reusableToken.type !\u003d TOKEN) {\n            break;\n        }\n    }\n    if (!record.isEmpty()) {\n        ret \u003d (String[]) record.toArray(new String[record.size()]);\n    }\n    return ret;\n}",
      "path": "src/main/java/org/apache/commons/csv/CSVParser.java",
      "functionStartLine": 175,
      "functionName": "getLine",
      "functionAnnotation": "",
      "functionDoc": "Parses from the current point in the stream til\nthe end of the current line.\n\n@return array of values til end of line\n        (\u0027null\u0027 when end of file has been reached)\n@throws IOException on parse error or input read-failure\n",
      "diff": "@@ -1,33 +1,33 @@\n public String[] getLine() throws IOException {\n     String[] ret \u003d EMPTY_STRING_ARRAY;\n     record.clear();\n     while (true) {\n         reusableToken.reset();\n         nextToken(reusableToken);\n         switch(reusableToken.type) {\n-            case TT_TOKEN:\n+            case TOKEN:\n                 record.add(reusableToken.content.toString());\n                 break;\n-            case TT_EORECORD:\n+            case EORECORD:\n                 record.add(reusableToken.content.toString());\n                 break;\n-            case TT_EOF:\n+            case EOF:\n                 if (reusableToken.isReady) {\n                     record.add(reusableToken.content.toString());\n                 } else {\n                     ret \u003d null;\n                 }\n                 break;\n-            case TT_INVALID:\n+            case INVALID:\n             default:\n                 throw new IOException(\"(line \" + getLineNumber() + \") invalid parse sequence\");\n         }\n-        if (reusableToken.type !\u003d TT_TOKEN) {\n+        if (reusableToken.type !\u003d TOKEN) {\n             break;\n         }\n     }\n     if (!record.isEmpty()) {\n         ret \u003d (String[]) record.toArray(new String[record.size()]);\n     }\n     return ret;\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "c9aeca5c39033c95c26c1475dcf0fd2ea86672e8": {
      "type": "Yfilerename",
      "commitMessage": "Moved the directories to match the Maven layout\n\ngit-svn-id: https://svn.apache.org/repos/asf/commons/sandbox/csv/trunk@1199691 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "11/9/11, 2:38 AM",
      "commitName": "c9aeca5c39033c95c26c1475dcf0fd2ea86672e8",
      "commitAuthor": "Emmanuel Bourg",
      "commitDateOld": "7/20/11, 9:14 AM",
      "commitNameOld": "76cab04936e8b539d983510079419fabeeaecea0",
      "commitAuthorOld": "Stephen Colebourne",
      "daysBetweenCommits": 111.77,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "public String[] getLine() throws IOException {\n    String[] ret \u003d EMPTY_STRING_ARRAY;\n    record.clear();\n    while (true) {\n        reusableToken.reset();\n        nextToken(reusableToken);\n        switch(reusableToken.type) {\n            case TT_TOKEN:\n                record.add(reusableToken.content.toString());\n                break;\n            case TT_EORECORD:\n                record.add(reusableToken.content.toString());\n                break;\n            case TT_EOF:\n                if (reusableToken.isReady) {\n                    record.add(reusableToken.content.toString());\n                } else {\n                    ret \u003d null;\n                }\n                break;\n            case TT_INVALID:\n            default:\n                throw new IOException(\"(line \" + getLineNumber() + \") invalid parse sequence\");\n        }\n        if (reusableToken.type !\u003d TT_TOKEN) {\n            break;\n        }\n    }\n    if (!record.isEmpty()) {\n        ret \u003d (String[]) record.toArray(new String[record.size()]);\n    }\n    return ret;\n}",
      "path": "src/main/java/org/apache/commons/csv/CSVParser.java",
      "functionStartLine": 255,
      "functionName": "getLine",
      "functionAnnotation": "",
      "functionDoc": "Parses from the current point in the stream til\nthe end of the current line.\n\n@return array of values til end of line\n        (\u0027null\u0027 when end of file has been reached)\n@throws IOException on parse error or input read-failure\n",
      "diff": "",
      "extendedDetails": {
        "oldPath": "src/java/org/apache/commons/csv/CSVParser.java",
        "newPath": "src/main/java/org/apache/commons/csv/CSVParser.java"
      }
    },
    "1166ca605bcc035654771f1ddc1092d86f2ec1e8": {
      "type": "Ymultichange(Ydocchange,Yformatchange)",
      "commitMessage": "No functional changes are contained in this commit: reformatted Java code to fix several formatting inconsistencies (between classes and within the same class); sorry for the big commit, but I have preferred to isolate into one commit all the formatting changes.\n\ngit-svn-id: https://svn.apache.org/repos/asf/commons/sandbox/csv/trunk@1065950 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "2/1/11, 12:46 AM",
      "commitName": "1166ca605bcc035654771f1ddc1092d86f2ec1e8",
      "commitAuthor": "Jacopo Cappellato",
      "subchanges": [
        {
          "type": "Ydocchange",
          "commitMessage": "No functional changes are contained in this commit: reformatted Java code to fix several formatting inconsistencies (between classes and within the same class); sorry for the big commit, but I have preferred to isolate into one commit all the formatting changes.\n\ngit-svn-id: https://svn.apache.org/repos/asf/commons/sandbox/csv/trunk@1065950 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "2/1/11, 12:46 AM",
          "commitName": "1166ca605bcc035654771f1ddc1092d86f2ec1e8",
          "commitAuthor": "Jacopo Cappellato",
          "commitDateOld": "1/31/11, 2:47 AM",
          "commitNameOld": "c6bdecabd82eebc9efce450aa4057b668984479e",
          "commitAuthorOld": "Jacopo Cappellato",
          "daysBetweenCommits": 0.92,
          "commitsBetweenForRepo": 2,
          "commitsBetweenForFile": 1,
          "actualSource": "public String[] getLine() throws IOException {\n    String[] ret \u003d EMPTY_STRING_ARRAY;\n    record.clear();\n    while (true) {\n        reusableToken.reset();\n        nextToken(reusableToken);\n        switch(reusableToken.type) {\n            case TT_TOKEN:\n                record.add(reusableToken.content.toString());\n                break;\n            case TT_EORECORD:\n                record.add(reusableToken.content.toString());\n                break;\n            case TT_EOF:\n                if (reusableToken.isReady) {\n                    record.add(reusableToken.content.toString());\n                } else {\n                    ret \u003d null;\n                }\n                break;\n            case TT_INVALID:\n            default:\n                throw new IOException(\"(line \" + getLineNumber() + \") invalid parse sequence\");\n        }\n        if (reusableToken.type !\u003d TT_TOKEN) {\n            break;\n        }\n    }\n    if (!record.isEmpty()) {\n        ret \u003d (String[]) record.toArray(new String[record.size()]);\n    }\n    return ret;\n}",
          "path": "src/java/org/apache/commons/csv/CSVParser.java",
          "functionStartLine": 255,
          "functionName": "getLine",
          "functionAnnotation": "",
          "functionDoc": "Parses from the current point in the stream til\nthe end of the current line.\n\n@return array of values til end of line\n        (\u0027null\u0027 when end of file has been reached)\n@throws IOException on parse error or input read-failure\n",
          "diff": "",
          "extendedDetails": {
            "oldValue": "Parses from the current point in the stream til\nthe end of the current line.\n\n@return array of values til end of line \n       (\u0027null\u0027 when end of file has been reached)\n@throws IOException on parse error or input read-failure\n",
            "newValue": "Parses from the current point in the stream til\nthe end of the current line.\n\n@return array of values til end of line\n        (\u0027null\u0027 when end of file has been reached)\n@throws IOException on parse error or input read-failure\n"
          }
        },
        {
          "type": "Yformatchange",
          "commitMessage": "No functional changes are contained in this commit: reformatted Java code to fix several formatting inconsistencies (between classes and within the same class); sorry for the big commit, but I have preferred to isolate into one commit all the formatting changes.\n\ngit-svn-id: https://svn.apache.org/repos/asf/commons/sandbox/csv/trunk@1065950 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "2/1/11, 12:46 AM",
          "commitName": "1166ca605bcc035654771f1ddc1092d86f2ec1e8",
          "commitAuthor": "Jacopo Cappellato",
          "commitDateOld": "1/31/11, 2:47 AM",
          "commitNameOld": "c6bdecabd82eebc9efce450aa4057b668984479e",
          "commitAuthorOld": "Jacopo Cappellato",
          "daysBetweenCommits": 0.92,
          "commitsBetweenForRepo": 2,
          "commitsBetweenForFile": 1,
          "actualSource": "public String[] getLine() throws IOException {\n    String[] ret \u003d EMPTY_STRING_ARRAY;\n    record.clear();\n    while (true) {\n        reusableToken.reset();\n        nextToken(reusableToken);\n        switch(reusableToken.type) {\n            case TT_TOKEN:\n                record.add(reusableToken.content.toString());\n                break;\n            case TT_EORECORD:\n                record.add(reusableToken.content.toString());\n                break;\n            case TT_EOF:\n                if (reusableToken.isReady) {\n                    record.add(reusableToken.content.toString());\n                } else {\n                    ret \u003d null;\n                }\n                break;\n            case TT_INVALID:\n            default:\n                throw new IOException(\"(line \" + getLineNumber() + \") invalid parse sequence\");\n        }\n        if (reusableToken.type !\u003d TT_TOKEN) {\n            break;\n        }\n    }\n    if (!record.isEmpty()) {\n        ret \u003d (String[]) record.toArray(new String[record.size()]);\n    }\n    return ret;\n}",
          "path": "src/java/org/apache/commons/csv/CSVParser.java",
          "functionStartLine": 255,
          "functionName": "getLine",
          "functionAnnotation": "",
          "functionDoc": "Parses from the current point in the stream til\nthe end of the current line.\n\n@return array of values til end of line\n        (\u0027null\u0027 when end of file has been reached)\n@throws IOException on parse error or input read-failure\n",
          "diff": "",
          "extendedDetails": {}
        }
      ]
    },
    "1b0ccbe4c7d5a183913063429198e8c51bb768f9": {
      "type": "Ybodychange",
      "commitMessage": "Applying checkstyle changes\n\ngit-svn-id: https://svn.apache.org/repos/asf/commons/sandbox/csv/trunk@631133 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "2/26/08, 12:47 AM",
      "commitName": "1b0ccbe4c7d5a183913063429198e8c51bb768f9",
      "commitAuthor": "Henri Yandell",
      "commitDateOld": "1/6/08, 7:13 AM",
      "commitNameOld": "086f434320e68a82ce1adcac69668ffcd7f48e52",
      "commitAuthorOld": "Yonik Seeley",
      "daysBetweenCommits": 50.73,
      "commitsBetweenForRepo": 5,
      "commitsBetweenForFile": 1,
      "actualSource": "public String[] getLine() throws IOException {\n    String[] ret \u003d EMPTY_STRING_ARRAY;\n    record.clear();\n    while (true) {\n        reusableToken.reset();\n        nextToken(reusableToken);\n        switch(reusableToken.type) {\n            case TT_TOKEN:\n                record.add(reusableToken.content.toString());\n                break;\n            case TT_EORECORD:\n                record.add(reusableToken.content.toString());\n                break;\n            case TT_EOF:\n                if (reusableToken.isReady) {\n                    record.add(reusableToken.content.toString());\n                } else {\n                    ret \u003d null;\n                }\n                break;\n            case TT_INVALID:\n            default:\n                throw new IOException(\"(line \" + getLineNumber() + \") invalid parse sequence\");\n        }\n        if (reusableToken.type !\u003d TT_TOKEN) {\n            break;\n        }\n    }\n    if (!record.isEmpty()) {\n        ret \u003d (String[]) record.toArray(new String[record.size()]);\n    }\n    return ret;\n}",
      "path": "src/java/org/apache/commons/csv/CSVParser.java",
      "functionStartLine": 237,
      "functionName": "getLine",
      "functionAnnotation": "",
      "functionDoc": "Parses from the current point in the stream til\nthe end of the current line.\n\n@return array of values til end of line \n       (\u0027null\u0027 when end of file has been reached)\n@throws IOException on parse error or input read-failure\n",
      "diff": "@@ -1,32 +1,33 @@\n public String[] getLine() throws IOException {\n     String[] ret \u003d EMPTY_STRING_ARRAY;\n     record.clear();\n     while (true) {\n         reusableToken.reset();\n         nextToken(reusableToken);\n         switch(reusableToken.type) {\n             case TT_TOKEN:\n                 record.add(reusableToken.content.toString());\n                 break;\n             case TT_EORECORD:\n                 record.add(reusableToken.content.toString());\n                 break;\n             case TT_EOF:\n                 if (reusableToken.isReady) {\n                     record.add(reusableToken.content.toString());\n                 } else {\n                     ret \u003d null;\n                 }\n                 break;\n             case TT_INVALID:\n             default:\n                 throw new IOException(\"(line \" + getLineNumber() + \") invalid parse sequence\");\n         }\n-        if (reusableToken.type !\u003d TT_TOKEN)\n+        if (reusableToken.type !\u003d TT_TOKEN) {\n             break;\n+        }\n     }\n     if (!record.isEmpty()) {\n         ret \u003d (String[]) record.toArray(new String[record.size()]);\n     }\n     return ret;\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "d7e94581d784067fccddd34e19ae46aea526f9fa": {
      "type": "Ybodychange",
      "commitMessage": "This patch reduces the amount of intermediate garbage significantly.\nPR: SANDBOX-166\nContributed by: Ortwin Glck\nReviewed by: Henri Yandell\n\ngit-svn-id: https://svn.apache.org/repos/asf/jakarta/commons/sandbox/csv/trunk@430322 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "8/10/06, 2:01 AM",
      "commitName": "d7e94581d784067fccddd34e19ae46aea526f9fa",
      "commitAuthor": "Ortwin Glueck",
      "commitDateOld": "7/31/06, 11:50 PM",
      "commitNameOld": "ce34196827e6ac834b4c566e1e6fbe863c8e8d1c",
      "commitAuthorOld": "Henri Yandell",
      "daysBetweenCommits": 9.09,
      "commitsBetweenForRepo": 6,
      "commitsBetweenForFile": 1,
      "actualSource": "public String[] getLine() throws IOException {\n    String[] ret \u003d EMPTY_STRING_ARRAY;\n    record.clear();\n    while (true) {\n        reusableToken.reset();\n        nextToken(reusableToken);\n        switch(reusableToken.type) {\n            case TT_TOKEN:\n                record.add(reusableToken.content.toString());\n                break;\n            case TT_EORECORD:\n                record.add(reusableToken.content.toString());\n                break;\n            case TT_EOF:\n                if (reusableToken.isReady) {\n                    record.add(reusableToken.content.toString());\n                } else {\n                    ret \u003d null;\n                }\n                break;\n            case TT_INVALID:\n            default:\n                throw new IOException(\"(line \" + getLineNumber() + \") invalid parse sequence\");\n        }\n        if (reusableToken.type !\u003d TT_TOKEN)\n            break;\n    }\n    if (!record.isEmpty()) {\n        ret \u003d (String[]) record.toArray(new String[record.size()]);\n    }\n    return ret;\n}",
      "path": "src/java/org/apache/commons/csv/CSVParser.java",
      "functionStartLine": 225,
      "functionName": "getLine",
      "functionAnnotation": "",
      "functionDoc": "Parses from the current point in the stream til\nthe end of the current line.\n\n@return array of values til end of line \n       (\u0027null\u0027 when end of file has been reached)\n@throws IOException on parse error or input read-failure\n",
      "diff": "@@ -1,28 +1,32 @@\n public String[] getLine() throws IOException {\n-    Vector record \u003d new Vector();\n-    String[] ret \u003d new String[0];\n-    Token tkn;\n-    while ((tkn \u003d nextToken()).type \u003d\u003d TT_TOKEN) {\n-        record.add(tkn.content.toString());\n-    }\n-    switch(tkn.type) {\n-        case TT_EORECORD:\n-            record.add(tkn.content.toString());\n+    String[] ret \u003d EMPTY_STRING_ARRAY;\n+    record.clear();\n+    while (true) {\n+        reusableToken.reset();\n+        nextToken(reusableToken);\n+        switch(reusableToken.type) {\n+            case TT_TOKEN:\n+                record.add(reusableToken.content.toString());\n+                break;\n+            case TT_EORECORD:\n+                record.add(reusableToken.content.toString());\n+                break;\n+            case TT_EOF:\n+                if (reusableToken.isReady) {\n+                    record.add(reusableToken.content.toString());\n+                } else {\n+                    ret \u003d null;\n+                }\n+                break;\n+            case TT_INVALID:\n+            default:\n+                throw new IOException(\"(line \" + getLineNumber() + \") invalid parse sequence\");\n+        }\n+        if (reusableToken.type !\u003d TT_TOKEN)\n             break;\n-        case TT_EOF:\n-            if (tkn.isReady) {\n-                record.add(tkn.content.toString());\n-            } else {\n-                ret \u003d null;\n-            }\n-            break;\n-        case TT_INVALID:\n-        default:\n-            throw new IOException(\"(line \" + getLineNumber() + \") invalid parse sequence\");\n     }\n-    if (record.size() \u003e 0) {\n-        ret \u003d new String[record.size()];\n-        record.toArray(ret);\n+    if (!record.isEmpty()) {\n+        ret \u003d (String[]) record.toArray(new String[record.size()]);\n     }\n     return ret;\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "f047581f9526aad1c9c9e624710a4e860f88ecaa": {
      "type": "Ybodychange",
      "commitMessage": "Javadoc improvements, more unit tests, change of API to a chain style, some bugfixes\n\ngit-svn-id: https://svn.apache.org/repos/asf/jakarta/commons/sandbox/csv/trunk@383468 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "3/5/06, 9:11 PM",
      "commitName": "f047581f9526aad1c9c9e624710a4e860f88ecaa",
      "commitAuthor": "Henri Yandell",
      "commitDateOld": "12/16/05, 9:46 PM",
      "commitNameOld": "0e1f0adb716515aba5e98e5690779f2fb73ad716",
      "commitAuthorOld": "Henri Yandell",
      "daysBetweenCommits": 78.98,
      "commitsBetweenForRepo": 18,
      "commitsBetweenForFile": 1,
      "actualSource": "public String[] getLine() throws IOException {\n    Vector record \u003d new Vector();\n    String[] ret \u003d new String[0];\n    Token tkn;\n    while ((tkn \u003d nextToken()).type \u003d\u003d TT_TOKEN) {\n        record.add(tkn.content.toString());\n    }\n    switch(tkn.type) {\n        case TT_EORECORD:\n            record.add(tkn.content.toString());\n            break;\n        case TT_EOF:\n            if (tkn.isReady) {\n                record.add(tkn.content.toString());\n            } else {\n                ret \u003d null;\n            }\n            break;\n        case TT_INVALID:\n        default:\n            throw new IOException(\"(line \" + getLineNumber() + \") invalid parse sequence\");\n    }\n    if (record.size() \u003e 0) {\n        ret \u003d new String[record.size()];\n        record.toArray(ret);\n    }\n    return ret;\n}",
      "path": "src/java/org/apache/commons/csv/CSVParser.java",
      "functionStartLine": 276,
      "functionName": "getLine",
      "functionAnnotation": "",
      "functionDoc": "Parses from the current point in the stream til\nthe end of the current line.\n\n@return array of values til end of line \n       (\u0027null\u0027 when end of file has been reached)\n@throws IOException on parse error or input read-failure\n",
      "diff": "@@ -1,24 +1,28 @@\n public String[] getLine() throws IOException {\n     Vector record \u003d new Vector();\n     String[] ret \u003d new String[0];\n     Token tkn;\n     while ((tkn \u003d nextToken()).type \u003d\u003d TT_TOKEN) {\n         record.add(tkn.content.toString());\n     }\n     switch(tkn.type) {\n         case TT_EORECORD:\n             record.add(tkn.content.toString());\n             break;\n         case TT_EOF:\n-            ret \u003d null;\n+            if (tkn.isReady) {\n+                record.add(tkn.content.toString());\n+            } else {\n+                ret \u003d null;\n+            }\n             break;\n         case TT_INVALID:\n         default:\n             throw new IOException(\"(line \" + getLineNumber() + \") invalid parse sequence\");\n     }\n     if (record.size() \u003e 0) {\n         ret \u003d new String[record.size()];\n         record.toArray(ret);\n     }\n     return ret;\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "4b5faabefd896ef24b21d7f9d3dc20741f6b89b8": {
      "type": "Yfilerename",
      "commitMessage": "repackaging - directory change\n\ngit-svn-id: https://svn.apache.org/repos/asf/jakarta/commons/trunks-sandbox/csv@357301 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "12/16/05, 9:42 PM",
      "commitName": "4b5faabefd896ef24b21d7f9d3dc20741f6b89b8",
      "commitAuthor": "Henri Yandell",
      "commitDateOld": "12/16/05, 9:41 PM",
      "commitNameOld": "e23e79e0ceacf38d3298e7f5207c4518ad2b5955",
      "commitAuthorOld": "Henri Yandell",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "public String[] getLine() throws IOException {\n    Vector record \u003d new Vector();\n    String[] ret \u003d new String[0];\n    Token tkn;\n    while ((tkn \u003d nextToken()).type \u003d\u003d TT_TOKEN) {\n        record.add(tkn.content.toString());\n    }\n    switch(tkn.type) {\n        case TT_EORECORD:\n            record.add(tkn.content.toString());\n            break;\n        case TT_EOF:\n            ret \u003d null;\n            break;\n        case TT_INVALID:\n        default:\n            throw new IOException(\"(line \" + getLineNumber() + \") invalid parse sequence\");\n    }\n    if (record.size() \u003e 0) {\n        ret \u003d new String[record.size()];\n        record.toArray(ret);\n    }\n    return ret;\n}",
      "path": "src/java/org/apache/commons/csv/CSVParser.java",
      "functionStartLine": 250,
      "functionName": "getLine",
      "functionAnnotation": "",
      "functionDoc": "Parses from the current point in the stream til\nthe end of the current line.\n\n@return array of values til end of line \n       (\u0027null\u0027 when end of file has been reached)\n@throws IOException on parse error or input read-failure\n",
      "diff": "",
      "extendedDetails": {
        "oldPath": "src/java/ch/netcetera/wake/core/format/csv/CSVParser.java",
        "newPath": "src/java/org/apache/commons/csv/CSVParser.java"
      }
    },
    "e23e79e0ceacf38d3298e7f5207c4518ad2b5955": {
      "type": "Yintroduced",
      "commitMessage": "import of csv parser code, as donated by netcetera [code grant recorded]\n\ngit-svn-id: https://svn.apache.org/repos/asf/jakarta/commons/trunks-sandbox/csv@357300 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "12/16/05, 9:41 PM",
      "commitName": "e23e79e0ceacf38d3298e7f5207c4518ad2b5955",
      "commitAuthor": "Henri Yandell",
      "diff": "@@ -0,0 +1,24 @@\n+public String[] getLine() throws IOException {\n+    Vector record \u003d new Vector();\n+    String[] ret \u003d new String[0];\n+    Token tkn;\n+    while ((tkn \u003d nextToken()).type \u003d\u003d TT_TOKEN) {\n+        record.add(tkn.content.toString());\n+    }\n+    switch(tkn.type) {\n+        case TT_EORECORD:\n+            record.add(tkn.content.toString());\n+            break;\n+        case TT_EOF:\n+            ret \u003d null;\n+            break;\n+        case TT_INVALID:\n+        default:\n+            throw new IOException(\"(line \" + getLineNumber() + \") invalid parse sequence\");\n+    }\n+    if (record.size() \u003e 0) {\n+        ret \u003d new String[record.size()];\n+        record.toArray(ret);\n+    }\n+    return ret;\n+}\n\\ No newline at end of file\n",
      "actualSource": "public String[] getLine() throws IOException {\n    Vector record \u003d new Vector();\n    String[] ret \u003d new String[0];\n    Token tkn;\n    while ((tkn \u003d nextToken()).type \u003d\u003d TT_TOKEN) {\n        record.add(tkn.content.toString());\n    }\n    switch(tkn.type) {\n        case TT_EORECORD:\n            record.add(tkn.content.toString());\n            break;\n        case TT_EOF:\n            ret \u003d null;\n            break;\n        case TT_INVALID:\n        default:\n            throw new IOException(\"(line \" + getLineNumber() + \") invalid parse sequence\");\n    }\n    if (record.size() \u003e 0) {\n        ret \u003d new String[record.size()];\n        record.toArray(ret);\n    }\n    return ret;\n}",
      "path": "src/java/ch/netcetera/wake/core/format/csv/CSVParser.java",
      "functionStartLine": 250,
      "functionName": "getLine",
      "functionAnnotation": "",
      "functionDoc": "Parses from the current point in the stream til\nthe end of the current line.\n\n@return array of values til end of line \n       (\u0027null\u0027 when end of file has been reached)\n@throws IOException on parse error or input read-failure\n"
    }
  }
}