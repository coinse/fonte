{
  "origin": "codeshovel",
  "repositoryName": "JacksonDatabind-16b",
  "repositoryPath": "/tmp/JacksonDatabind-16b//.git",
  "startCommitName": "HEAD",
  "sourceFileName": "BeanSerializerFactory.java",
  "functionName": "createSerializer",
  "functionId": "createSerializer___prov-SerializerProvider__origType-JavaType",
  "sourceFilePath": "src/main/java/com/fasterxml/jackson/databind/ser/BeanSerializerFactory.java",
  "functionAnnotation": "@Override,@SuppressWarnings(\"unchecked\")",
  "functionDoc": "Main serializer constructor method. We will have to be careful\nwith respect to ordering of various method calls: essentially\nwe want to reliably figure out which classes are standard types,\nand which are beans. The problem is that some bean Classes may\nimplement standard interfaces (say, {@link java.lang.Iterable}.\n\u003cp\u003e\nNote: sub-classes may choose to complete replace implementation,\nif they want to alter priority of serializer lookups.\n",
  "functionStartLine": 127,
  "functionEndLine": 167,
  "numCommitsSeen": 141,
  "timeTaken": 3540,
  "changeHistory": [
    "119ddc9701c94ac184362166742ceaa7437eec8f",
    "8d6fa487db65fc9b3610784da9627356ef1eb16c",
    "3745034e0883a9d0d22fd4eaf70aa4958fce525e",
    "cc737528660b99e71865096e3cd0c4c4a2b3871e",
    "be97826b2c8702639503cc6c7f8398d84073aaf0",
    "d5daa45d6fd13867bca1e7dfe8c027436ae0d92f",
    "315ab606b14b830668b2d69f99d8b90132d89919",
    "ab511e5576579139951022c2085662904ad85b07",
    "bd3ded190c05c5f2f34a5677bbb4469d02599444",
    "65b73d92974414c018dec24a67c285ae484654c8",
    "15d6ea2adef8ade224b6479581eaee7d9acd592a",
    "a063b79f364923a4b98ce66254bf478284c63340",
    "752b57e524d5f85f2c2a6b7e97eddf9b5498794a",
    "ca93163ef2a71f2e1497ef5d4e5a841d6fb3ac82",
    "21b3805ce084371f278d6eb6bf2ebc0882e268cf",
    "288087216060a7f910a9bcf20bfd4504bd31c89d",
    "82b474d51545919cb38a49485f56fd29d6ed199b",
    "334892f4c5c0f346248eb6ebae306330e6512d93",
    "3f2db3343f2b159f7c5de6b7310c70ea15b3384d",
    "aaba9c105d557bdbb4e94a1e3927cbdd61bd2807",
    "28bde0726d83be7f70ca4586abee6f536bfc8885",
    "e4f23bb6779d434d88a7c4335f92d13ea639b373"
  ],
  "changeHistoryShort": {
    "119ddc9701c94ac184362166742ceaa7437eec8f": "Ybodychange",
    "8d6fa487db65fc9b3610784da9627356ef1eb16c": "Ybodychange",
    "3745034e0883a9d0d22fd4eaf70aa4958fce525e": "Ybodychange",
    "cc737528660b99e71865096e3cd0c4c4a2b3871e": "Ybodychange",
    "be97826b2c8702639503cc6c7f8398d84073aaf0": "Ybodychange",
    "d5daa45d6fd13867bca1e7dfe8c027436ae0d92f": "Ybodychange",
    "315ab606b14b830668b2d69f99d8b90132d89919": "Ybodychange",
    "ab511e5576579139951022c2085662904ad85b07": "Yparameterchange",
    "bd3ded190c05c5f2f34a5677bbb4469d02599444": "Ybodychange",
    "65b73d92974414c018dec24a67c285ae484654c8": "Ybodychange",
    "15d6ea2adef8ade224b6479581eaee7d9acd592a": "Ybodychange",
    "a063b79f364923a4b98ce66254bf478284c63340": "Ybodychange",
    "752b57e524d5f85f2c2a6b7e97eddf9b5498794a": "Ybodychange",
    "ca93163ef2a71f2e1497ef5d4e5a841d6fb3ac82": "Ybodychange",
    "21b3805ce084371f278d6eb6bf2ebc0882e268cf": "Ybodychange",
    "288087216060a7f910a9bcf20bfd4504bd31c89d": "Ybodychange",
    "82b474d51545919cb38a49485f56fd29d6ed199b": "Yformatchange",
    "334892f4c5c0f346248eb6ebae306330e6512d93": "Ybodychange",
    "3f2db3343f2b159f7c5de6b7310c70ea15b3384d": "Ybodychange",
    "aaba9c105d557bdbb4e94a1e3927cbdd61bd2807": "Ymultichange(Yparameterchange,Ybodychange)",
    "28bde0726d83be7f70ca4586abee6f536bfc8885": "Ybodychange",
    "e4f23bb6779d434d88a7c4335f92d13ea639b373": "Yintroduced"
  },
  "changeHistoryDetails": {
    "119ddc9701c94ac184362166742ceaa7437eec8f": {
      "type": "Ybodychange",
      "commitMessage": "Fix #731\n",
      "commitDate": "4/2/15, 2:32 PM",
      "commitName": "119ddc9701c94ac184362166742ceaa7437eec8f",
      "commitAuthor": "Cowtowncoder",
      "commitDateOld": "2/23/15, 4:53 PM",
      "commitNameOld": "466f706901d39ae95393c6c7b1d0b544247922f1",
      "commitAuthorOld": "Cowtowncoder",
      "daysBetweenCommits": 37.86,
      "commitsBetweenForRepo": 26,
      "commitsBetweenForFile": 1,
      "actualSource": "@Override\n@SuppressWarnings(\"unchecked\")\npublic JsonSerializer\u003cObject\u003e createSerializer(SerializerProvider prov, JavaType origType) throws JsonMappingException {\n    final SerializationConfig config \u003d prov.getConfig();\n    BeanDescription beanDesc \u003d config.introspect(origType);\n    JsonSerializer\u003c?\u003e ser \u003d findSerializerFromAnnotation(prov, beanDesc.getClassInfo());\n    if (ser !\u003d null) {\n        return (JsonSerializer\u003cObject\u003e) ser;\n    }\n    boolean staticTyping;\n    JavaType type \u003d modifyTypeByAnnotation(config, beanDesc.getClassInfo(), origType);\n    if (type \u003d\u003d origType) {\n        staticTyping \u003d false;\n    } else {\n        staticTyping \u003d true;\n        if (!type.hasRawClass(origType.getRawClass())) {\n            beanDesc \u003d config.introspect(type);\n        }\n    }\n    Converter\u003cObject, Object\u003e conv \u003d beanDesc.findSerializationConverter();\n    if (conv \u003d\u003d null) {\n        return (JsonSerializer\u003cObject\u003e) _createSerializer2(prov, type, beanDesc, staticTyping);\n    }\n    JavaType delegateType \u003d conv.getOutputType(prov.getTypeFactory());\n    if (!delegateType.hasRawClass(type.getRawClass())) {\n        beanDesc \u003d config.introspect(delegateType);\n        ser \u003d findSerializerFromAnnotation(prov, beanDesc.getClassInfo());\n    }\n    if (ser \u003d\u003d null \u0026\u0026 !delegateType.isJavaLangObject()) {\n        ser \u003d _createSerializer2(prov, delegateType, beanDesc, true);\n    }\n    return new StdDelegatingSerializer(conv, delegateType, ser);\n}",
      "path": "src/main/java/com/fasterxml/jackson/databind/ser/BeanSerializerFactory.java",
      "functionStartLine": 127,
      "functionName": "createSerializer",
      "functionAnnotation": "@Override,@SuppressWarnings(\"unchecked\")",
      "functionDoc": "Main serializer constructor method. We will have to be careful\nwith respect to ordering of various method calls: essentially\nwe want to reliably figure out which classes are standard types,\nand which are beans. The problem is that some bean Classes may\nimplement standard interfaces (say, {@link java.lang.Iterable}.\n\u003cp\u003e\nNote: sub-classes may choose to complete replace implementation,\nif they want to alter priority of serializer lookups.\n",
      "diff": "@@ -1,33 +1,33 @@\n @Override\n @SuppressWarnings(\"unchecked\")\n public JsonSerializer\u003cObject\u003e createSerializer(SerializerProvider prov, JavaType origType) throws JsonMappingException {\n     final SerializationConfig config \u003d prov.getConfig();\n     BeanDescription beanDesc \u003d config.introspect(origType);\n     JsonSerializer\u003c?\u003e ser \u003d findSerializerFromAnnotation(prov, beanDesc.getClassInfo());\n     if (ser !\u003d null) {\n         return (JsonSerializer\u003cObject\u003e) ser;\n     }\n     boolean staticTyping;\n     JavaType type \u003d modifyTypeByAnnotation(config, beanDesc.getClassInfo(), origType);\n     if (type \u003d\u003d origType) {\n         staticTyping \u003d false;\n     } else {\n         staticTyping \u003d true;\n         if (!type.hasRawClass(origType.getRawClass())) {\n             beanDesc \u003d config.introspect(type);\n         }\n     }\n     Converter\u003cObject, Object\u003e conv \u003d beanDesc.findSerializationConverter();\n     if (conv \u003d\u003d null) {\n         return (JsonSerializer\u003cObject\u003e) _createSerializer2(prov, type, beanDesc, staticTyping);\n     }\n     JavaType delegateType \u003d conv.getOutputType(prov.getTypeFactory());\n     if (!delegateType.hasRawClass(type.getRawClass())) {\n         beanDesc \u003d config.introspect(delegateType);\n         ser \u003d findSerializerFromAnnotation(prov, beanDesc.getClassInfo());\n     }\n-    if (ser \u003d\u003d null) {\n+    if (ser \u003d\u003d null \u0026\u0026 !delegateType.isJavaLangObject()) {\n         ser \u003d _createSerializer2(prov, delegateType, beanDesc, true);\n     }\n     return new StdDelegatingSerializer(conv, delegateType, ser);\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "8d6fa487db65fc9b3610784da9627356ef1eb16c": {
      "type": "Ybodychange",
      "commitMessage": "Fixed #359 for 2.4\n",
      "commitDate": "3/17/14, 9:06 PM",
      "commitName": "8d6fa487db65fc9b3610784da9627356ef1eb16c",
      "commitAuthor": "Tatu Saloranta",
      "commitDateOld": "2/17/14, 10:00 AM",
      "commitNameOld": "43603cc1d5617553697539a8219ed674dee1b9bc",
      "commitAuthorOld": "Tatu",
      "daysBetweenCommits": 28.42,
      "commitsBetweenForRepo": 38,
      "commitsBetweenForFile": 1,
      "actualSource": "@Override\n@SuppressWarnings(\"unchecked\")\npublic JsonSerializer\u003cObject\u003e createSerializer(SerializerProvider prov, JavaType origType) throws JsonMappingException {\n    final SerializationConfig config \u003d prov.getConfig();\n    BeanDescription beanDesc \u003d config.introspect(origType);\n    JsonSerializer\u003c?\u003e ser \u003d findSerializerFromAnnotation(prov, beanDesc.getClassInfo());\n    if (ser !\u003d null) {\n        return (JsonSerializer\u003cObject\u003e) ser;\n    }\n    boolean staticTyping;\n    JavaType type \u003d modifyTypeByAnnotation(config, beanDesc.getClassInfo(), origType);\n    if (type \u003d\u003d origType) {\n        staticTyping \u003d false;\n    } else {\n        staticTyping \u003d true;\n        if (!type.hasRawClass(origType.getRawClass())) {\n            beanDesc \u003d config.introspect(type);\n        }\n    }\n    Converter\u003cObject, Object\u003e conv \u003d beanDesc.findSerializationConverter();\n    if (conv \u003d\u003d null) {\n        return (JsonSerializer\u003cObject\u003e) _createSerializer2(prov, type, beanDesc, staticTyping);\n    }\n    JavaType delegateType \u003d conv.getOutputType(prov.getTypeFactory());\n    if (!delegateType.hasRawClass(type.getRawClass())) {\n        beanDesc \u003d config.introspect(delegateType);\n        ser \u003d findSerializerFromAnnotation(prov, beanDesc.getClassInfo());\n    }\n    if (ser \u003d\u003d null) {\n        ser \u003d _createSerializer2(prov, delegateType, beanDesc, true);\n    }\n    return new StdDelegatingSerializer(conv, delegateType, ser);\n}",
      "path": "src/main/java/com/fasterxml/jackson/databind/ser/BeanSerializerFactory.java",
      "functionStartLine": 127,
      "functionName": "createSerializer",
      "functionAnnotation": "@Override,@SuppressWarnings(\"unchecked\")",
      "functionDoc": "Main serializer constructor method. We will have to be careful\nwith respect to ordering of various method calls: essentially\nwe want to reliably figure out which classes are standard types,\nand which are beans. The problem is that some bean Classes may\nimplement standard interfaces (say, {@link java.lang.Iterable}.\n\u003cp\u003e\nNote: sub-classes may choose to complete replace implementation,\nif they want to alter priority of serializer lookups.\n",
      "diff": "@@ -1,29 +1,33 @@\n @Override\n @SuppressWarnings(\"unchecked\")\n public JsonSerializer\u003cObject\u003e createSerializer(SerializerProvider prov, JavaType origType) throws JsonMappingException {\n     final SerializationConfig config \u003d prov.getConfig();\n     BeanDescription beanDesc \u003d config.introspect(origType);\n     JsonSerializer\u003c?\u003e ser \u003d findSerializerFromAnnotation(prov, beanDesc.getClassInfo());\n     if (ser !\u003d null) {\n         return (JsonSerializer\u003cObject\u003e) ser;\n     }\n     boolean staticTyping;\n     JavaType type \u003d modifyTypeByAnnotation(config, beanDesc.getClassInfo(), origType);\n     if (type \u003d\u003d origType) {\n         staticTyping \u003d false;\n     } else {\n         staticTyping \u003d true;\n         if (!type.hasRawClass(origType.getRawClass())) {\n             beanDesc \u003d config.introspect(type);\n         }\n     }\n     Converter\u003cObject, Object\u003e conv \u003d beanDesc.findSerializationConverter();\n     if (conv \u003d\u003d null) {\n         return (JsonSerializer\u003cObject\u003e) _createSerializer2(prov, type, beanDesc, staticTyping);\n     }\n     JavaType delegateType \u003d conv.getOutputType(prov.getTypeFactory());\n     if (!delegateType.hasRawClass(type.getRawClass())) {\n         beanDesc \u003d config.introspect(delegateType);\n+        ser \u003d findSerializerFromAnnotation(prov, beanDesc.getClassInfo());\n     }\n-    return new StdDelegatingSerializer(conv, delegateType, _createSerializer2(prov, delegateType, beanDesc, true));\n+    if (ser \u003d\u003d null) {\n+        ser \u003d _createSerializer2(prov, delegateType, beanDesc, true);\n+    }\n+    return new StdDelegatingSerializer(conv, delegateType, ser);\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "3745034e0883a9d0d22fd4eaf70aa4958fce525e": {
      "type": "Ybodychange",
      "commitMessage": "Fix #288\n",
      "commitDate": "8/21/13, 9:20 PM",
      "commitName": "3745034e0883a9d0d22fd4eaf70aa4958fce525e",
      "commitAuthor": "Tatu Saloranta",
      "commitDateOld": "7/26/13, 4:18 PM",
      "commitNameOld": "8bdd49b36c8c05483669f6bd50b3839016f78983",
      "commitAuthorOld": "Tatu Saloranta",
      "daysBetweenCommits": 26.21,
      "commitsBetweenForRepo": 51,
      "commitsBetweenForFile": 1,
      "actualSource": "@Override\n@SuppressWarnings(\"unchecked\")\npublic JsonSerializer\u003cObject\u003e createSerializer(SerializerProvider prov, JavaType origType) throws JsonMappingException {\n    final SerializationConfig config \u003d prov.getConfig();\n    BeanDescription beanDesc \u003d config.introspect(origType);\n    JsonSerializer\u003c?\u003e ser \u003d findSerializerFromAnnotation(prov, beanDesc.getClassInfo());\n    if (ser !\u003d null) {\n        return (JsonSerializer\u003cObject\u003e) ser;\n    }\n    boolean staticTyping;\n    JavaType type \u003d modifyTypeByAnnotation(config, beanDesc.getClassInfo(), origType);\n    if (type \u003d\u003d origType) {\n        staticTyping \u003d false;\n    } else {\n        staticTyping \u003d true;\n        if (!type.hasRawClass(origType.getRawClass())) {\n            beanDesc \u003d config.introspect(type);\n        }\n    }\n    Converter\u003cObject, Object\u003e conv \u003d beanDesc.findSerializationConverter();\n    if (conv \u003d\u003d null) {\n        return (JsonSerializer\u003cObject\u003e) _createSerializer2(prov, type, beanDesc, staticTyping);\n    }\n    JavaType delegateType \u003d conv.getOutputType(prov.getTypeFactory());\n    if (!delegateType.hasRawClass(type.getRawClass())) {\n        beanDesc \u003d config.introspect(delegateType);\n    }\n    return new StdDelegatingSerializer(conv, delegateType, _createSerializer2(prov, delegateType, beanDesc, true));\n}",
      "path": "src/main/java/com/fasterxml/jackson/databind/ser/BeanSerializerFactory.java",
      "functionStartLine": 127,
      "functionName": "createSerializer",
      "functionAnnotation": "@Override,@SuppressWarnings(\"unchecked\")",
      "functionDoc": "Main serializer constructor method. We will have to be careful\nwith respect to ordering of various method calls: essentially\nwe want to reliably figure out which classes are standard types,\nand which are beans. The problem is that some bean Classes may\nimplement standard interfaces (say, {@link java.lang.Iterable}.\n\u003cp\u003e\nNote: sub-classes may choose to complete replace implementation,\nif they want to alter priority of serializer lookups.\n",
      "diff": "@@ -1,26 +1,29 @@\n @Override\n @SuppressWarnings(\"unchecked\")\n public JsonSerializer\u003cObject\u003e createSerializer(SerializerProvider prov, JavaType origType) throws JsonMappingException {\n     final SerializationConfig config \u003d prov.getConfig();\n     BeanDescription beanDesc \u003d config.introspect(origType);\n     JsonSerializer\u003c?\u003e ser \u003d findSerializerFromAnnotation(prov, beanDesc.getClassInfo());\n     if (ser !\u003d null) {\n         return (JsonSerializer\u003cObject\u003e) ser;\n     }\n     boolean staticTyping;\n     JavaType type \u003d modifyTypeByAnnotation(config, beanDesc.getClassInfo(), origType);\n     if (type \u003d\u003d origType) {\n         staticTyping \u003d false;\n     } else {\n         staticTyping \u003d true;\n-        if (type.getRawClass() !\u003d origType.getRawClass()) {\n+        if (!type.hasRawClass(origType.getRawClass())) {\n             beanDesc \u003d config.introspect(type);\n         }\n     }\n     Converter\u003cObject, Object\u003e conv \u003d beanDesc.findSerializationConverter();\n     if (conv \u003d\u003d null) {\n         return (JsonSerializer\u003cObject\u003e) _createSerializer2(prov, type, beanDesc, staticTyping);\n     }\n     JavaType delegateType \u003d conv.getOutputType(prov.getTypeFactory());\n+    if (!delegateType.hasRawClass(type.getRawClass())) {\n+        beanDesc \u003d config.introspect(delegateType);\n+    }\n     return new StdDelegatingSerializer(conv, delegateType, _createSerializer2(prov, delegateType, beanDesc, true));\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "cc737528660b99e71865096e3cd0c4c4a2b3871e": {
      "type": "Ybodychange",
      "commitMessage": "Improvements to Converter, added StdConverter base class\n",
      "commitDate": "3/3/13, 1:11 PM",
      "commitName": "cc737528660b99e71865096e3cd0c4c4a2b3871e",
      "commitAuthor": "Tatu Saloranta",
      "commitDateOld": "2/18/13, 10:28 PM",
      "commitNameOld": "be97826b2c8702639503cc6c7f8398d84073aaf0",
      "commitAuthorOld": "Tatu Saloranta",
      "daysBetweenCommits": 12.61,
      "commitsBetweenForRepo": 26,
      "commitsBetweenForFile": 1,
      "actualSource": "@Override\n@SuppressWarnings(\"unchecked\")\npublic JsonSerializer\u003cObject\u003e createSerializer(SerializerProvider prov, JavaType origType) throws JsonMappingException {\n    final SerializationConfig config \u003d prov.getConfig();\n    BeanDescription beanDesc \u003d config.introspect(origType);\n    JsonSerializer\u003c?\u003e ser \u003d findSerializerFromAnnotation(prov, beanDesc.getClassInfo());\n    if (ser !\u003d null) {\n        return (JsonSerializer\u003cObject\u003e) ser;\n    }\n    boolean staticTyping;\n    JavaType type \u003d modifyTypeByAnnotation(config, beanDesc.getClassInfo(), origType);\n    if (type \u003d\u003d origType) {\n        staticTyping \u003d false;\n    } else {\n        staticTyping \u003d true;\n        if (type.getRawClass() !\u003d origType.getRawClass()) {\n            beanDesc \u003d config.introspect(type);\n        }\n    }\n    Converter\u003cObject, Object\u003e conv \u003d beanDesc.findSerializationConverter();\n    if (conv \u003d\u003d null) {\n        return (JsonSerializer\u003cObject\u003e) _createSerializer2(prov, type, beanDesc, staticTyping);\n    }\n    JavaType delegateType \u003d conv.getOutputType(prov.getTypeFactory());\n    return new StdDelegatingSerializer(conv, delegateType, _createSerializer2(prov, delegateType, beanDesc, true));\n}",
      "path": "src/main/java/com/fasterxml/jackson/databind/ser/BeanSerializerFactory.java",
      "functionStartLine": 127,
      "functionName": "createSerializer",
      "functionAnnotation": "@Override,@SuppressWarnings(\"unchecked\")",
      "functionDoc": "Main serializer constructor method. We will have to be careful\nwith respect to ordering of various method calls: essentially\nwe want to reliably figure out which classes are standard types,\nand which are beans. The problem is that some bean Classes may\nimplement standard interfaces (say, {@link java.lang.Iterable}.\n\u003cp\u003e\nNote: sub-classes may choose to complete replace implementation,\nif they want to alter priority of serializer lookups.\n",
      "diff": "@@ -1,32 +1,26 @@\n @Override\n @SuppressWarnings(\"unchecked\")\n public JsonSerializer\u003cObject\u003e createSerializer(SerializerProvider prov, JavaType origType) throws JsonMappingException {\n     final SerializationConfig config \u003d prov.getConfig();\n     BeanDescription beanDesc \u003d config.introspect(origType);\n     JsonSerializer\u003c?\u003e ser \u003d findSerializerFromAnnotation(prov, beanDesc.getClassInfo());\n     if (ser !\u003d null) {\n         return (JsonSerializer\u003cObject\u003e) ser;\n     }\n     boolean staticTyping;\n     JavaType type \u003d modifyTypeByAnnotation(config, beanDesc.getClassInfo(), origType);\n     if (type \u003d\u003d origType) {\n         staticTyping \u003d false;\n     } else {\n         staticTyping \u003d true;\n         if (type.getRawClass() !\u003d origType.getRawClass()) {\n             beanDesc \u003d config.introspect(type);\n         }\n     }\n     Converter\u003cObject, Object\u003e conv \u003d beanDesc.findSerializationConverter();\n     if (conv \u003d\u003d null) {\n         return (JsonSerializer\u003cObject\u003e) _createSerializer2(prov, type, beanDesc, staticTyping);\n     }\n-    TypeFactory tf \u003d prov.getTypeFactory();\n-    JavaType converterType \u003d tf.constructType(conv.getClass());\n-    JavaType[] params \u003d tf.findTypeParameters(converterType, Converter.class);\n-    if (params \u003d\u003d null || params.length !\u003d 2) {\n-        throw new JsonMappingException(\"Could not determine Converter parameterization for \" + converterType);\n-    }\n-    JavaType delegateType \u003d params[1];\n+    JavaType delegateType \u003d conv.getOutputType(prov.getTypeFactory());\n     return new StdDelegatingSerializer(conv, delegateType, _createSerializer2(prov, delegateType, beanDesc, true));\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "be97826b2c8702639503cc6c7f8398d84073aaf0": {
      "type": "Ybodychange",
      "commitMessage": "Completed (?) #124 implementation: now Converters seem to work ok\n",
      "commitDate": "2/18/13, 10:28 PM",
      "commitName": "be97826b2c8702639503cc6c7f8398d84073aaf0",
      "commitAuthor": "Tatu Saloranta",
      "commitDateOld": "2/18/13, 9:25 PM",
      "commitNameOld": "d5daa45d6fd13867bca1e7dfe8c027436ae0d92f",
      "commitAuthorOld": "Tatu Saloranta",
      "daysBetweenCommits": 0.04,
      "commitsBetweenForRepo": 3,
      "commitsBetweenForFile": 1,
      "actualSource": "@Override\n@SuppressWarnings(\"unchecked\")\npublic JsonSerializer\u003cObject\u003e createSerializer(SerializerProvider prov, JavaType origType) throws JsonMappingException {\n    final SerializationConfig config \u003d prov.getConfig();\n    BeanDescription beanDesc \u003d config.introspect(origType);\n    JsonSerializer\u003c?\u003e ser \u003d findSerializerFromAnnotation(prov, beanDesc.getClassInfo());\n    if (ser !\u003d null) {\n        return (JsonSerializer\u003cObject\u003e) ser;\n    }\n    boolean staticTyping;\n    JavaType type \u003d modifyTypeByAnnotation(config, beanDesc.getClassInfo(), origType);\n    if (type \u003d\u003d origType) {\n        staticTyping \u003d false;\n    } else {\n        staticTyping \u003d true;\n        if (type.getRawClass() !\u003d origType.getRawClass()) {\n            beanDesc \u003d config.introspect(type);\n        }\n    }\n    Converter\u003cObject, Object\u003e conv \u003d beanDesc.findSerializationConverter();\n    if (conv \u003d\u003d null) {\n        return (JsonSerializer\u003cObject\u003e) _createSerializer2(prov, type, beanDesc, staticTyping);\n    }\n    TypeFactory tf \u003d prov.getTypeFactory();\n    JavaType converterType \u003d tf.constructType(conv.getClass());\n    JavaType[] params \u003d tf.findTypeParameters(converterType, Converter.class);\n    if (params \u003d\u003d null || params.length !\u003d 2) {\n        throw new JsonMappingException(\"Could not determine Converter parameterization for \" + converterType);\n    }\n    JavaType delegateType \u003d params[1];\n    return new StdDelegatingSerializer(conv, delegateType, _createSerializer2(prov, delegateType, beanDesc, true));\n}",
      "path": "src/main/java/com/fasterxml/jackson/databind/ser/BeanSerializerFactory.java",
      "functionStartLine": 127,
      "functionName": "createSerializer",
      "functionAnnotation": "@Override,@SuppressWarnings(\"unchecked\")",
      "functionDoc": "Main serializer constructor method. We will have to be careful\nwith respect to ordering of various method calls: essentially\nwe want to reliably figure out which classes are standard types,\nand which are beans. The problem is that some bean Classes may\nimplement standard interfaces (say, {@link java.lang.Iterable}.\n\u003cp\u003e\nNote: sub-classes may choose to complete replace implementation,\nif they want to alter priority of serializer lookups.\n",
      "diff": "@@ -1,60 +1,32 @@\n @Override\n @SuppressWarnings(\"unchecked\")\n public JsonSerializer\u003cObject\u003e createSerializer(SerializerProvider prov, JavaType origType) throws JsonMappingException {\n     final SerializationConfig config \u003d prov.getConfig();\n     BeanDescription beanDesc \u003d config.introspect(origType);\n     JsonSerializer\u003c?\u003e ser \u003d findSerializerFromAnnotation(prov, beanDesc.getClassInfo());\n     if (ser !\u003d null) {\n         return (JsonSerializer\u003cObject\u003e) ser;\n     }\n     boolean staticTyping;\n     JavaType type \u003d modifyTypeByAnnotation(config, beanDesc.getClassInfo(), origType);\n     if (type \u003d\u003d origType) {\n         staticTyping \u003d false;\n     } else {\n         staticTyping \u003d true;\n         if (type.getRawClass() !\u003d origType.getRawClass()) {\n             beanDesc \u003d config.introspect(type);\n         }\n     }\n-    ser \u003d findSerializerByAnnotations(prov, type, beanDesc);\n-    if (ser !\u003d null) {\n-        return (JsonSerializer\u003cObject\u003e) ser;\n+    Converter\u003cObject, Object\u003e conv \u003d beanDesc.findSerializationConverter();\n+    if (conv \u003d\u003d null) {\n+        return (JsonSerializer\u003cObject\u003e) _createSerializer2(prov, type, beanDesc, staticTyping);\n     }\n-    if (origType.isContainerType()) {\n-        if (!staticTyping) {\n-            staticTyping \u003d usesStaticTyping(config, beanDesc, null);\n-        }\n-        ser \u003d buildContainerSerializer(prov, type, beanDesc, staticTyping);\n-        if (ser !\u003d null) {\n-            return (JsonSerializer\u003cObject\u003e) ser;\n-        }\n-    } else {\n-        for (Serializers serializers : customSerializers()) {\n-            ser \u003d serializers.findSerializer(config, type, beanDesc);\n-            if (ser !\u003d null) {\n-                break;\n-            }\n-        }\n+    TypeFactory tf \u003d prov.getTypeFactory();\n+    JavaType converterType \u003d tf.constructType(conv.getClass());\n+    JavaType[] params \u003d tf.findTypeParameters(converterType, Converter.class);\n+    if (params \u003d\u003d null || params.length !\u003d 2) {\n+        throw new JsonMappingException(\"Could not determine Converter parameterization for \" + converterType);\n     }\n-    if (ser \u003d\u003d null) {\n-        ser \u003d findSerializerByLookup(type, config, beanDesc, staticTyping);\n-        if (ser \u003d\u003d null) {\n-            ser \u003d findSerializerByPrimaryType(prov, type, beanDesc, staticTyping);\n-            if (ser \u003d\u003d null) {\n-                ser \u003d findBeanSerializer(prov, type, beanDesc);\n-                if (ser \u003d\u003d null) {\n-                    ser \u003d findSerializerByAddonType(config, type, beanDesc, staticTyping);\n-                }\n-            }\n-        }\n-    }\n-    if (ser !\u003d null) {\n-        if (_factoryConfig.hasSerializerModifiers()) {\n-            for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) {\n-                ser \u003d mod.modifySerializer(config, beanDesc, ser);\n-            }\n-        }\n-    }\n-    return (JsonSerializer\u003cObject\u003e) ser;\n+    JavaType delegateType \u003d params[1];\n+    return new StdDelegatingSerializer(conv, delegateType, _createSerializer2(prov, delegateType, beanDesc, true));\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "d5daa45d6fd13867bca1e7dfe8c027436ae0d92f": {
      "type": "Ybodychange",
      "commitMessage": "Working on #124, serializer converters\n",
      "commitDate": "2/18/13, 9:25 PM",
      "commitName": "d5daa45d6fd13867bca1e7dfe8c027436ae0d92f",
      "commitAuthor": "Tatu Saloranta",
      "commitDateOld": "12/1/12, 11:40 PM",
      "commitNameOld": "8416dde89136e2fa8a6f996ce3196560eba1dd26",
      "commitAuthorOld": "Tatu Saloranta",
      "daysBetweenCommits": 78.91,
      "commitsBetweenForRepo": 73,
      "commitsBetweenForFile": 1,
      "actualSource": "@Override\n@SuppressWarnings(\"unchecked\")\npublic JsonSerializer\u003cObject\u003e createSerializer(SerializerProvider prov, JavaType origType) throws JsonMappingException {\n    final SerializationConfig config \u003d prov.getConfig();\n    BeanDescription beanDesc \u003d config.introspect(origType);\n    JsonSerializer\u003c?\u003e ser \u003d findSerializerFromAnnotation(prov, beanDesc.getClassInfo());\n    if (ser !\u003d null) {\n        return (JsonSerializer\u003cObject\u003e) ser;\n    }\n    boolean staticTyping;\n    JavaType type \u003d modifyTypeByAnnotation(config, beanDesc.getClassInfo(), origType);\n    if (type \u003d\u003d origType) {\n        staticTyping \u003d false;\n    } else {\n        staticTyping \u003d true;\n        if (type.getRawClass() !\u003d origType.getRawClass()) {\n            beanDesc \u003d config.introspect(type);\n        }\n    }\n    ser \u003d findSerializerByAnnotations(prov, type, beanDesc);\n    if (ser !\u003d null) {\n        return (JsonSerializer\u003cObject\u003e) ser;\n    }\n    if (origType.isContainerType()) {\n        if (!staticTyping) {\n            staticTyping \u003d usesStaticTyping(config, beanDesc, null);\n        }\n        ser \u003d buildContainerSerializer(prov, type, beanDesc, staticTyping);\n        if (ser !\u003d null) {\n            return (JsonSerializer\u003cObject\u003e) ser;\n        }\n    } else {\n        for (Serializers serializers : customSerializers()) {\n            ser \u003d serializers.findSerializer(config, type, beanDesc);\n            if (ser !\u003d null) {\n                break;\n            }\n        }\n    }\n    if (ser \u003d\u003d null) {\n        ser \u003d findSerializerByLookup(type, config, beanDesc, staticTyping);\n        if (ser \u003d\u003d null) {\n            ser \u003d findSerializerByPrimaryType(prov, type, beanDesc, staticTyping);\n            if (ser \u003d\u003d null) {\n                ser \u003d findBeanSerializer(prov, type, beanDesc);\n                if (ser \u003d\u003d null) {\n                    ser \u003d findSerializerByAddonType(config, type, beanDesc, staticTyping);\n                }\n            }\n        }\n    }\n    if (ser !\u003d null) {\n        if (_factoryConfig.hasSerializerModifiers()) {\n            for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) {\n                ser \u003d mod.modifySerializer(config, beanDesc, ser);\n            }\n        }\n    }\n    return (JsonSerializer\u003cObject\u003e) ser;\n}",
      "path": "src/main/java/com/fasterxml/jackson/databind/ser/BeanSerializerFactory.java",
      "functionStartLine": 125,
      "functionName": "createSerializer",
      "functionAnnotation": "@Override,@SuppressWarnings(\"unchecked\")",
      "functionDoc": "Main serializer constructor method. We will have to be careful\nwith respect to ordering of various method calls: essentially\nwe want to reliably figure out which classes are standard types,\nand which are beans. The problem is that some bean Classes may\nimplement standard interfaces (say, {@link java.lang.Iterable}.\n\u003cp\u003e\nNote: sub-classes may choose to complete replace implementation,\nif they want to alter priority of serializer lookups.\n",
      "diff": "",
      "extendedDetails": {}
    },
    "315ab606b14b830668b2d69f99d8b90132d89919": {
      "type": "Ybodychange",
      "commitMessage": "almost completed #120, only missing key serializer post-processing\n",
      "commitDate": "11/30/12, 9:54 PM",
      "commitName": "315ab606b14b830668b2d69f99d8b90132d89919",
      "commitAuthor": "Tatu Saloranta",
      "commitDateOld": "10/6/12, 10:45 AM",
      "commitNameOld": "0e114114d330caaf6a56e63ab4d8a3ee1ba3e350",
      "commitAuthorOld": "Tatu Saloranta",
      "daysBetweenCommits": 55.51,
      "commitsBetweenForRepo": 89,
      "commitsBetweenForFile": 1,
      "actualSource": "@Override\n@SuppressWarnings(\"unchecked\")\npublic JsonSerializer\u003cObject\u003e createSerializer(SerializerProvider prov, JavaType origType) throws JsonMappingException {\n    final SerializationConfig config \u003d prov.getConfig();\n    BeanDescription beanDesc \u003d config.introspect(origType);\n    JsonSerializer\u003c?\u003e ser \u003d findSerializerFromAnnotation(prov, beanDesc.getClassInfo());\n    if (ser !\u003d null) {\n        return (JsonSerializer\u003cObject\u003e) ser;\n    }\n    boolean staticTyping;\n    JavaType type \u003d modifyTypeByAnnotation(config, beanDesc.getClassInfo(), origType);\n    if (type \u003d\u003d origType) {\n        staticTyping \u003d false;\n    } else {\n        staticTyping \u003d true;\n        if (type.getRawClass() !\u003d origType.getRawClass()) {\n            beanDesc \u003d config.introspect(type);\n        }\n    }\n    ser \u003d findSerializerByAnnotations(prov, type, beanDesc);\n    if (ser !\u003d null) {\n        return (JsonSerializer\u003cObject\u003e) ser;\n    }\n    if (origType.isContainerType()) {\n        if (!staticTyping) {\n            staticTyping \u003d usesStaticTyping(config, beanDesc, null);\n        }\n        ser \u003d buildContainerSerializer(prov, type, beanDesc, staticTyping);\n        if (ser !\u003d null) {\n            return (JsonSerializer\u003cObject\u003e) ser;\n        }\n    } else {\n        for (Serializers serializers : customSerializers()) {\n            ser \u003d serializers.findSerializer(config, type, beanDesc);\n            if (ser !\u003d null) {\n                break;\n            }\n        }\n    }\n    if (ser \u003d\u003d null) {\n        ser \u003d findSerializerByLookup(type, config, beanDesc, staticTyping);\n        if (ser \u003d\u003d null) {\n            ser \u003d findSerializerByPrimaryType(prov, type, beanDesc, staticTyping);\n            if (ser \u003d\u003d null) {\n                ser \u003d findBeanSerializer(prov, type, beanDesc);\n                if (ser \u003d\u003d null) {\n                    ser \u003d findSerializerByAddonType(config, type, beanDesc, staticTyping);\n                }\n            }\n        }\n    }\n    if (ser !\u003d null) {\n        if (_factoryConfig.hasSerializerModifiers()) {\n            for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) {\n                ser \u003d mod.modifySerializer(config, beanDesc, ser);\n            }\n        }\n    }\n    return (JsonSerializer\u003cObject\u003e) ser;\n}",
      "path": "src/main/java/com/fasterxml/jackson/databind/ser/BeanSerializerFactory.java",
      "functionStartLine": 125,
      "functionName": "createSerializer",
      "functionAnnotation": "@Override,@SuppressWarnings(\"unchecked\")",
      "functionDoc": "Main serializer constructor method. We will have to be careful\nwith respect to ordering of various method calls: essentially\nwe want to reliably figure out which classes are standard types,\nand which are beans. The problem is that some bean Classes may\nimplement standard interfaces (say, {@link java.lang.Iterable}.\n\u003cp\u003e\nNote: sub-classes may choose to complete replace implementation,\nif they want to alter priority of serializer lookups.\n",
      "diff": "@@ -1,51 +1,60 @@\n @Override\n @SuppressWarnings(\"unchecked\")\n public JsonSerializer\u003cObject\u003e createSerializer(SerializerProvider prov, JavaType origType) throws JsonMappingException {\n     final SerializationConfig config \u003d prov.getConfig();\n     BeanDescription beanDesc \u003d config.introspect(origType);\n     JsonSerializer\u003c?\u003e ser \u003d findSerializerFromAnnotation(prov, beanDesc.getClassInfo());\n     if (ser !\u003d null) {\n         return (JsonSerializer\u003cObject\u003e) ser;\n     }\n     boolean staticTyping;\n     JavaType type \u003d modifyTypeByAnnotation(config, beanDesc.getClassInfo(), origType);\n     if (type \u003d\u003d origType) {\n         staticTyping \u003d false;\n     } else {\n         staticTyping \u003d true;\n         if (type.getRawClass() !\u003d origType.getRawClass()) {\n             beanDesc \u003d config.introspect(type);\n         }\n     }\n     ser \u003d findSerializerByAnnotations(prov, type, beanDesc);\n     if (ser !\u003d null) {\n         return (JsonSerializer\u003cObject\u003e) ser;\n     }\n     if (origType.isContainerType()) {\n         if (!staticTyping) {\n             staticTyping \u003d usesStaticTyping(config, beanDesc, null);\n         }\n         ser \u003d buildContainerSerializer(prov, type, beanDesc, staticTyping);\n         if (ser !\u003d null) {\n             return (JsonSerializer\u003cObject\u003e) ser;\n         }\n     } else {\n         for (Serializers serializers : customSerializers()) {\n             ser \u003d serializers.findSerializer(config, type, beanDesc);\n             if (ser !\u003d null) {\n-                return (JsonSerializer\u003cObject\u003e) ser;\n+                break;\n             }\n         }\n     }\n-    ser \u003d findSerializerByLookup(type, config, beanDesc, staticTyping);\n     if (ser \u003d\u003d null) {\n-        ser \u003d findSerializerByPrimaryType(prov, type, beanDesc, staticTyping);\n+        ser \u003d findSerializerByLookup(type, config, beanDesc, staticTyping);\n         if (ser \u003d\u003d null) {\n-            ser \u003d findBeanSerializer(prov, type, beanDesc);\n+            ser \u003d findSerializerByPrimaryType(prov, type, beanDesc, staticTyping);\n             if (ser \u003d\u003d null) {\n-                ser \u003d findSerializerByAddonType(config, type, beanDesc, staticTyping);\n+                ser \u003d findBeanSerializer(prov, type, beanDesc);\n+                if (ser \u003d\u003d null) {\n+                    ser \u003d findSerializerByAddonType(config, type, beanDesc, staticTyping);\n+                }\n+            }\n+        }\n+    }\n+    if (ser !\u003d null) {\n+        if (_factoryConfig.hasSerializerModifiers()) {\n+            for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) {\n+                ser \u003d mod.modifySerializer(config, beanDesc, ser);\n             }\n         }\n     }\n     return (JsonSerializer\u003cObject\u003e) ser;\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "ab511e5576579139951022c2085662904ad85b07": {
      "type": "Yparameterchange",
      "commitMessage": "Completed SerializerFactory clean up; factories now should not get or expect BeanProperty, as that is only applicable for contextualSerializers\n",
      "commitDate": "9/30/12, 12:56 PM",
      "commitName": "ab511e5576579139951022c2085662904ad85b07",
      "commitAuthor": "Tatu Saloranta",
      "commitDateOld": "9/30/12, 12:43 PM",
      "commitNameOld": "bd3ded190c05c5f2f34a5677bbb4469d02599444",
      "commitAuthorOld": "Tatu Saloranta",
      "daysBetweenCommits": 0.01,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "@Override\n@SuppressWarnings(\"unchecked\")\npublic JsonSerializer\u003cObject\u003e createSerializer(SerializerProvider prov, JavaType origType) throws JsonMappingException {\n    final SerializationConfig config \u003d prov.getConfig();\n    BeanDescription beanDesc \u003d config.introspect(origType);\n    JsonSerializer\u003c?\u003e ser \u003d findSerializerFromAnnotation(prov, beanDesc.getClassInfo());\n    if (ser !\u003d null) {\n        return (JsonSerializer\u003cObject\u003e) ser;\n    }\n    boolean staticTyping;\n    JavaType type \u003d modifyTypeByAnnotation(config, beanDesc.getClassInfo(), origType);\n    if (type \u003d\u003d origType) {\n        staticTyping \u003d false;\n    } else {\n        staticTyping \u003d true;\n        if (type.getRawClass() !\u003d origType.getRawClass()) {\n            beanDesc \u003d config.introspect(type);\n        }\n    }\n    ser \u003d findSerializerByAnnotations(prov, type, beanDesc);\n    if (ser !\u003d null) {\n        return (JsonSerializer\u003cObject\u003e) ser;\n    }\n    if (origType.isContainerType()) {\n        if (!staticTyping) {\n            staticTyping \u003d usesStaticTyping(config, beanDesc, null);\n        }\n        ser \u003d buildContainerSerializer(prov, type, beanDesc, staticTyping);\n        if (ser !\u003d null) {\n            return (JsonSerializer\u003cObject\u003e) ser;\n        }\n    } else {\n        for (Serializers serializers : customSerializers()) {\n            ser \u003d serializers.findSerializer(config, type, beanDesc);\n            if (ser !\u003d null) {\n                return (JsonSerializer\u003cObject\u003e) ser;\n            }\n        }\n    }\n    ser \u003d findSerializerByLookup(type, config, beanDesc, staticTyping);\n    if (ser \u003d\u003d null) {\n        ser \u003d findSerializerByPrimaryType(prov, type, beanDesc, staticTyping);\n        if (ser \u003d\u003d null) {\n            ser \u003d findBeanSerializer(prov, type, beanDesc);\n            if (ser \u003d\u003d null) {\n                ser \u003d findSerializerByAddonType(config, type, beanDesc, staticTyping);\n            }\n        }\n    }\n    return (JsonSerializer\u003cObject\u003e) ser;\n}",
      "path": "src/main/java/com/fasterxml/jackson/databind/ser/BeanSerializerFactory.java",
      "functionStartLine": 123,
      "functionName": "createSerializer",
      "functionAnnotation": "@Override,@SuppressWarnings(\"unchecked\")",
      "functionDoc": "Main serializer constructor method. We will have to be careful\nwith respect to ordering of various method calls: essentially\nwe want to reliably figure out which classes are standard types,\nand which are beans. The problem is that some bean Classes may\nimplement standard interfaces (say, {@link java.lang.Iterable}.\n\u003cp\u003e\nNote: sub-classes may choose to complete replace implementation,\nif they want to alter priority of serializer lookups.\n",
      "diff": "@@ -1,51 +1,51 @@\n @Override\n @SuppressWarnings(\"unchecked\")\n-public JsonSerializer\u003cObject\u003e createSerializer(SerializerProvider prov, JavaType origType, BeanProperty property) throws JsonMappingException {\n+public JsonSerializer\u003cObject\u003e createSerializer(SerializerProvider prov, JavaType origType) throws JsonMappingException {\n     final SerializationConfig config \u003d prov.getConfig();\n     BeanDescription beanDesc \u003d config.introspect(origType);\n     JsonSerializer\u003c?\u003e ser \u003d findSerializerFromAnnotation(prov, beanDesc.getClassInfo());\n     if (ser !\u003d null) {\n         return (JsonSerializer\u003cObject\u003e) ser;\n     }\n     boolean staticTyping;\n     JavaType type \u003d modifyTypeByAnnotation(config, beanDesc.getClassInfo(), origType);\n     if (type \u003d\u003d origType) {\n         staticTyping \u003d false;\n     } else {\n         staticTyping \u003d true;\n         if (type.getRawClass() !\u003d origType.getRawClass()) {\n             beanDesc \u003d config.introspect(type);\n         }\n     }\n     ser \u003d findSerializerByAnnotations(prov, type, beanDesc);\n     if (ser !\u003d null) {\n         return (JsonSerializer\u003cObject\u003e) ser;\n     }\n     if (origType.isContainerType()) {\n         if (!staticTyping) {\n             staticTyping \u003d usesStaticTyping(config, beanDesc, null);\n         }\n         ser \u003d buildContainerSerializer(prov, type, beanDesc, staticTyping);\n         if (ser !\u003d null) {\n             return (JsonSerializer\u003cObject\u003e) ser;\n         }\n     } else {\n         for (Serializers serializers : customSerializers()) {\n             ser \u003d serializers.findSerializer(config, type, beanDesc);\n             if (ser !\u003d null) {\n                 return (JsonSerializer\u003cObject\u003e) ser;\n             }\n         }\n     }\n     ser \u003d findSerializerByLookup(type, config, beanDesc, staticTyping);\n     if (ser \u003d\u003d null) {\n         ser \u003d findSerializerByPrimaryType(prov, type, beanDesc, staticTyping);\n         if (ser \u003d\u003d null) {\n             ser \u003d findBeanSerializer(prov, type, beanDesc);\n             if (ser \u003d\u003d null) {\n                 ser \u003d findSerializerByAddonType(config, type, beanDesc, staticTyping);\n             }\n         }\n     }\n     return (JsonSerializer\u003cObject\u003e) ser;\n }\n\\ No newline at end of file\n",
      "extendedDetails": {
        "oldValue": "[prov-SerializerProvider, origType-JavaType, property-BeanProperty]",
        "newValue": "[prov-SerializerProvider, origType-JavaType]"
      }
    },
    "bd3ded190c05c5f2f34a5677bbb4469d02599444": {
      "type": "Ybodychange",
      "commitMessage": "More SerializerFactory clean up, getting read of BeanProperty arg\n",
      "commitDate": "9/30/12, 12:43 PM",
      "commitName": "bd3ded190c05c5f2f34a5677bbb4469d02599444",
      "commitAuthor": "Tatu Saloranta",
      "commitDateOld": "9/30/12, 12:04 PM",
      "commitNameOld": "65b73d92974414c018dec24a67c285ae484654c8",
      "commitAuthorOld": "Tatu Saloranta",
      "daysBetweenCommits": 0.03,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "@Override\n@SuppressWarnings(\"unchecked\")\npublic JsonSerializer\u003cObject\u003e createSerializer(SerializerProvider prov, JavaType origType, BeanProperty property) throws JsonMappingException {\n    final SerializationConfig config \u003d prov.getConfig();\n    BeanDescription beanDesc \u003d config.introspect(origType);\n    JsonSerializer\u003c?\u003e ser \u003d findSerializerFromAnnotation(prov, beanDesc.getClassInfo());\n    if (ser !\u003d null) {\n        return (JsonSerializer\u003cObject\u003e) ser;\n    }\n    boolean staticTyping;\n    JavaType type \u003d modifyTypeByAnnotation(config, beanDesc.getClassInfo(), origType);\n    if (type \u003d\u003d origType) {\n        staticTyping \u003d false;\n    } else {\n        staticTyping \u003d true;\n        if (type.getRawClass() !\u003d origType.getRawClass()) {\n            beanDesc \u003d config.introspect(type);\n        }\n    }\n    ser \u003d findSerializerByAnnotations(prov, type, beanDesc);\n    if (ser !\u003d null) {\n        return (JsonSerializer\u003cObject\u003e) ser;\n    }\n    if (origType.isContainerType()) {\n        if (!staticTyping) {\n            staticTyping \u003d usesStaticTyping(config, beanDesc, null);\n        }\n        ser \u003d buildContainerSerializer(prov, type, beanDesc, staticTyping);\n        if (ser !\u003d null) {\n            return (JsonSerializer\u003cObject\u003e) ser;\n        }\n    } else {\n        for (Serializers serializers : customSerializers()) {\n            ser \u003d serializers.findSerializer(config, type, beanDesc);\n            if (ser !\u003d null) {\n                return (JsonSerializer\u003cObject\u003e) ser;\n            }\n        }\n    }\n    ser \u003d findSerializerByLookup(type, config, beanDesc, staticTyping);\n    if (ser \u003d\u003d null) {\n        ser \u003d findSerializerByPrimaryType(prov, type, beanDesc, staticTyping);\n        if (ser \u003d\u003d null) {\n            ser \u003d findBeanSerializer(prov, type, beanDesc);\n            if (ser \u003d\u003d null) {\n                ser \u003d findSerializerByAddonType(config, type, beanDesc, staticTyping);\n            }\n        }\n    }\n    return (JsonSerializer\u003cObject\u003e) ser;\n}",
      "path": "src/main/java/com/fasterxml/jackson/databind/ser/BeanSerializerFactory.java",
      "functionStartLine": 123,
      "functionName": "createSerializer",
      "functionAnnotation": "@Override,@SuppressWarnings(\"unchecked\")",
      "functionDoc": "Main serializer constructor method. We will have to be careful\nwith respect to ordering of various method calls: essentially\nwe want to reliably figure out which classes are standard types,\nand which are beans. The problem is that some bean Classes may\nimplement standard interfaces (say, {@link java.lang.Iterable}.\n\u003cp\u003e\nNote: sub-classes may choose to complete replace implementation,\nif they want to alter priority of serializer lookups.\n",
      "diff": "@@ -1,51 +1,51 @@\n @Override\n @SuppressWarnings(\"unchecked\")\n public JsonSerializer\u003cObject\u003e createSerializer(SerializerProvider prov, JavaType origType, BeanProperty property) throws JsonMappingException {\n     final SerializationConfig config \u003d prov.getConfig();\n     BeanDescription beanDesc \u003d config.introspect(origType);\n     JsonSerializer\u003c?\u003e ser \u003d findSerializerFromAnnotation(prov, beanDesc.getClassInfo());\n     if (ser !\u003d null) {\n         return (JsonSerializer\u003cObject\u003e) ser;\n     }\n     boolean staticTyping;\n     JavaType type \u003d modifyTypeByAnnotation(config, beanDesc.getClassInfo(), origType);\n     if (type \u003d\u003d origType) {\n         staticTyping \u003d false;\n     } else {\n         staticTyping \u003d true;\n         if (type.getRawClass() !\u003d origType.getRawClass()) {\n             beanDesc \u003d config.introspect(type);\n         }\n     }\n     ser \u003d findSerializerByAnnotations(prov, type, beanDesc);\n     if (ser !\u003d null) {\n         return (JsonSerializer\u003cObject\u003e) ser;\n     }\n     if (origType.isContainerType()) {\n         if (!staticTyping) {\n-            staticTyping \u003d usesStaticTyping(config, beanDesc, null, property);\n+            staticTyping \u003d usesStaticTyping(config, beanDesc, null);\n         }\n         ser \u003d buildContainerSerializer(prov, type, beanDesc, staticTyping);\n         if (ser !\u003d null) {\n             return (JsonSerializer\u003cObject\u003e) ser;\n         }\n     } else {\n         for (Serializers serializers : customSerializers()) {\n             ser \u003d serializers.findSerializer(config, type, beanDesc);\n             if (ser !\u003d null) {\n                 return (JsonSerializer\u003cObject\u003e) ser;\n             }\n         }\n     }\n     ser \u003d findSerializerByLookup(type, config, beanDesc, staticTyping);\n     if (ser \u003d\u003d null) {\n         ser \u003d findSerializerByPrimaryType(prov, type, beanDesc, staticTyping);\n         if (ser \u003d\u003d null) {\n             ser \u003d findBeanSerializer(prov, type, beanDesc);\n             if (ser \u003d\u003d null) {\n                 ser \u003d findSerializerByAddonType(config, type, beanDesc, staticTyping);\n             }\n         }\n     }\n     return (JsonSerializer\u003cObject\u003e) ser;\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "65b73d92974414c018dec24a67c285ae484654c8": {
      "type": "Ybodychange",
      "commitMessage": "Starting to clean up SerializerFactory, to remove/reduce passing of BeanProperty, which in general is not available at time of call.\n",
      "commitDate": "9/30/12, 12:04 PM",
      "commitName": "65b73d92974414c018dec24a67c285ae484654c8",
      "commitAuthor": "Tatu Saloranta",
      "commitDateOld": "8/24/12, 1:33 PM",
      "commitNameOld": "88040e2fa32c3bff2ce18e40a55807a3fca3d2d2",
      "commitAuthorOld": "Tatu Saloranta",
      "daysBetweenCommits": 36.94,
      "commitsBetweenForRepo": 66,
      "commitsBetweenForFile": 1,
      "actualSource": "@Override\n@SuppressWarnings(\"unchecked\")\npublic JsonSerializer\u003cObject\u003e createSerializer(SerializerProvider prov, JavaType origType, BeanProperty property) throws JsonMappingException {\n    final SerializationConfig config \u003d prov.getConfig();\n    BeanDescription beanDesc \u003d config.introspect(origType);\n    JsonSerializer\u003c?\u003e ser \u003d findSerializerFromAnnotation(prov, beanDesc.getClassInfo());\n    if (ser !\u003d null) {\n        return (JsonSerializer\u003cObject\u003e) ser;\n    }\n    boolean staticTyping;\n    JavaType type \u003d modifyTypeByAnnotation(config, beanDesc.getClassInfo(), origType);\n    if (type \u003d\u003d origType) {\n        staticTyping \u003d false;\n    } else {\n        staticTyping \u003d true;\n        if (type.getRawClass() !\u003d origType.getRawClass()) {\n            beanDesc \u003d config.introspect(type);\n        }\n    }\n    ser \u003d findSerializerByAnnotations(prov, type, beanDesc);\n    if (ser !\u003d null) {\n        return (JsonSerializer\u003cObject\u003e) ser;\n    }\n    if (origType.isContainerType()) {\n        if (!staticTyping) {\n            staticTyping \u003d usesStaticTyping(config, beanDesc, null, property);\n        }\n        ser \u003d buildContainerSerializer(prov, type, beanDesc, staticTyping);\n        if (ser !\u003d null) {\n            return (JsonSerializer\u003cObject\u003e) ser;\n        }\n    } else {\n        for (Serializers serializers : customSerializers()) {\n            ser \u003d serializers.findSerializer(config, type, beanDesc);\n            if (ser !\u003d null) {\n                return (JsonSerializer\u003cObject\u003e) ser;\n            }\n        }\n    }\n    ser \u003d findSerializerByLookup(type, config, beanDesc, staticTyping);\n    if (ser \u003d\u003d null) {\n        ser \u003d findSerializerByPrimaryType(prov, type, beanDesc, staticTyping);\n        if (ser \u003d\u003d null) {\n            ser \u003d findBeanSerializer(prov, type, beanDesc);\n            if (ser \u003d\u003d null) {\n                ser \u003d findSerializerByAddonType(config, type, beanDesc, staticTyping);\n            }\n        }\n    }\n    return (JsonSerializer\u003cObject\u003e) ser;\n}",
      "path": "src/main/java/com/fasterxml/jackson/databind/ser/BeanSerializerFactory.java",
      "functionStartLine": 123,
      "functionName": "createSerializer",
      "functionAnnotation": "@Override,@SuppressWarnings(\"unchecked\")",
      "functionDoc": "Main serializer constructor method. We will have to be careful\nwith respect to ordering of various method calls: essentially\nwe want to reliably figure out which classes are standard types,\nand which are beans. The problem is that some bean Classes may\nimplement standard interfaces (say, {@link java.lang.Iterable}.\n\u003cp\u003e\nNote: sub-classes may choose to complete replace implementation,\nif they want to alter priority of serializer lookups.\n",
      "diff": "@@ -1,51 +1,51 @@\n @Override\n @SuppressWarnings(\"unchecked\")\n public JsonSerializer\u003cObject\u003e createSerializer(SerializerProvider prov, JavaType origType, BeanProperty property) throws JsonMappingException {\n     final SerializationConfig config \u003d prov.getConfig();\n     BeanDescription beanDesc \u003d config.introspect(origType);\n     JsonSerializer\u003c?\u003e ser \u003d findSerializerFromAnnotation(prov, beanDesc.getClassInfo());\n     if (ser !\u003d null) {\n         return (JsonSerializer\u003cObject\u003e) ser;\n     }\n     boolean staticTyping;\n     JavaType type \u003d modifyTypeByAnnotation(config, beanDesc.getClassInfo(), origType);\n     if (type \u003d\u003d origType) {\n         staticTyping \u003d false;\n     } else {\n         staticTyping \u003d true;\n         if (type.getRawClass() !\u003d origType.getRawClass()) {\n             beanDesc \u003d config.introspect(type);\n         }\n     }\n     ser \u003d findSerializerByAnnotations(prov, type, beanDesc);\n     if (ser !\u003d null) {\n         return (JsonSerializer\u003cObject\u003e) ser;\n     }\n     if (origType.isContainerType()) {\n         if (!staticTyping) {\n             staticTyping \u003d usesStaticTyping(config, beanDesc, null, property);\n         }\n-        ser \u003d buildContainerSerializer(prov, type, beanDesc, property, staticTyping);\n+        ser \u003d buildContainerSerializer(prov, type, beanDesc, staticTyping);\n         if (ser !\u003d null) {\n             return (JsonSerializer\u003cObject\u003e) ser;\n         }\n     } else {\n         for (Serializers serializers : customSerializers()) {\n             ser \u003d serializers.findSerializer(config, type, beanDesc);\n             if (ser !\u003d null) {\n                 return (JsonSerializer\u003cObject\u003e) ser;\n             }\n         }\n     }\n     ser \u003d findSerializerByLookup(type, config, beanDesc, staticTyping);\n     if (ser \u003d\u003d null) {\n         ser \u003d findSerializerByPrimaryType(prov, type, beanDesc, staticTyping);\n         if (ser \u003d\u003d null) {\n-            ser \u003d findBeanSerializer(prov, type, beanDesc, property);\n+            ser \u003d findBeanSerializer(prov, type, beanDesc);\n             if (ser \u003d\u003d null) {\n                 ser \u003d findSerializerByAddonType(config, type, beanDesc, staticTyping);\n             }\n         }\n     }\n     return (JsonSerializer\u003cObject\u003e) ser;\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "15d6ea2adef8ade224b6479581eaee7d9acd592a": {
      "type": "Ybodychange",
      "commitMessage": "Implemented [Issue#25] (enums as JSON Object); started implementation of [Issue#40] (Collections as JSON Objects)\n",
      "commitDate": "8/3/12, 6:29 PM",
      "commitName": "15d6ea2adef8ade224b6479581eaee7d9acd592a",
      "commitAuthor": "Tatu Saloranta",
      "commitDateOld": "7/31/12, 10:24 PM",
      "commitNameOld": "6cada0a47ed675fffe15697968dfef68864b57e7",
      "commitAuthorOld": "Tatu Saloranta",
      "daysBetweenCommits": 2.84,
      "commitsBetweenForRepo": 5,
      "commitsBetweenForFile": 1,
      "actualSource": "@Override\n@SuppressWarnings(\"unchecked\")\npublic JsonSerializer\u003cObject\u003e createSerializer(SerializerProvider prov, JavaType origType, BeanProperty property) throws JsonMappingException {\n    final SerializationConfig config \u003d prov.getConfig();\n    BeanDescription beanDesc \u003d config.introspect(origType);\n    JsonSerializer\u003c?\u003e ser \u003d findSerializerFromAnnotation(prov, beanDesc.getClassInfo());\n    if (ser !\u003d null) {\n        return (JsonSerializer\u003cObject\u003e) ser;\n    }\n    boolean staticTyping;\n    JavaType type \u003d modifyTypeByAnnotation(config, beanDesc.getClassInfo(), origType);\n    if (type \u003d\u003d origType) {\n        staticTyping \u003d false;\n    } else {\n        staticTyping \u003d true;\n        if (type.getRawClass() !\u003d origType.getRawClass()) {\n            beanDesc \u003d config.introspect(type);\n        }\n    }\n    ser \u003d findSerializerByAnnotations(prov, type, beanDesc);\n    if (ser !\u003d null) {\n        return (JsonSerializer\u003cObject\u003e) ser;\n    }\n    if (origType.isContainerType()) {\n        if (!staticTyping) {\n            staticTyping \u003d usesStaticTyping(config, beanDesc, null, property);\n        }\n        ser \u003d buildContainerSerializer(prov, type, beanDesc, property, staticTyping);\n        if (ser !\u003d null) {\n            return (JsonSerializer\u003cObject\u003e) ser;\n        }\n    } else {\n        for (Serializers serializers : customSerializers()) {\n            ser \u003d serializers.findSerializer(config, type, beanDesc);\n            if (ser !\u003d null) {\n                return (JsonSerializer\u003cObject\u003e) ser;\n            }\n        }\n    }\n    ser \u003d findSerializerByLookup(type, config, beanDesc, staticTyping);\n    if (ser \u003d\u003d null) {\n        ser \u003d findSerializerByPrimaryType(prov, type, beanDesc, staticTyping);\n        if (ser \u003d\u003d null) {\n            ser \u003d findBeanSerializer(prov, type, beanDesc, property);\n            if (ser \u003d\u003d null) {\n                ser \u003d findSerializerByAddonType(config, type, beanDesc, staticTyping);\n            }\n        }\n    }\n    return (JsonSerializer\u003cObject\u003e) ser;\n}",
      "path": "src/main/java/com/fasterxml/jackson/databind/ser/BeanSerializerFactory.java",
      "functionStartLine": 123,
      "functionName": "createSerializer",
      "functionAnnotation": "@Override,@SuppressWarnings(\"unchecked\")",
      "functionDoc": "Main serializer constructor method. We will have to be careful\nwith respect to ordering of various method calls: essentially\nwe want to reliably figure out which classes are standard types,\nand which are beans. The problem is that some bean Classes may\nimplement standard interfaces (say, {@link java.lang.Iterable}.\n\u003cp\u003e\nNote: sub-classes may choose to complete replace implementation,\nif they want to alter priority of serializer lookups.\n",
      "diff": "@@ -1,47 +1,51 @@\n @Override\n @SuppressWarnings(\"unchecked\")\n public JsonSerializer\u003cObject\u003e createSerializer(SerializerProvider prov, JavaType origType, BeanProperty property) throws JsonMappingException {\n     final SerializationConfig config \u003d prov.getConfig();\n     BeanDescription beanDesc \u003d config.introspect(origType);\n     JsonSerializer\u003c?\u003e ser \u003d findSerializerFromAnnotation(prov, beanDesc.getClassInfo());\n     if (ser !\u003d null) {\n         return (JsonSerializer\u003cObject\u003e) ser;\n     }\n     boolean staticTyping;\n     JavaType type \u003d modifyTypeByAnnotation(config, beanDesc.getClassInfo(), origType);\n     if (type \u003d\u003d origType) {\n         staticTyping \u003d false;\n     } else {\n         staticTyping \u003d true;\n         if (type.getRawClass() !\u003d origType.getRawClass()) {\n             beanDesc \u003d config.introspect(type);\n         }\n     }\n     ser \u003d findSerializerByAnnotations(prov, type, beanDesc);\n     if (ser !\u003d null) {\n         return (JsonSerializer\u003cObject\u003e) ser;\n     }\n     if (origType.isContainerType()) {\n         if (!staticTyping) {\n             staticTyping \u003d usesStaticTyping(config, beanDesc, null, property);\n         }\n-        return (JsonSerializer\u003cObject\u003e) buildContainerSerializer(prov, type, beanDesc, property, staticTyping);\n-    }\n-    for (Serializers serializers : customSerializers()) {\n-        ser \u003d serializers.findSerializer(config, type, beanDesc);\n+        ser \u003d buildContainerSerializer(prov, type, beanDesc, property, staticTyping);\n         if (ser !\u003d null) {\n             return (JsonSerializer\u003cObject\u003e) ser;\n         }\n+    } else {\n+        for (Serializers serializers : customSerializers()) {\n+            ser \u003d serializers.findSerializer(config, type, beanDesc);\n+            if (ser !\u003d null) {\n+                return (JsonSerializer\u003cObject\u003e) ser;\n+            }\n+        }\n     }\n     ser \u003d findSerializerByLookup(type, config, beanDesc, staticTyping);\n     if (ser \u003d\u003d null) {\n         ser \u003d findSerializerByPrimaryType(prov, type, beanDesc, staticTyping);\n         if (ser \u003d\u003d null) {\n             ser \u003d findBeanSerializer(prov, type, beanDesc, property);\n             if (ser \u003d\u003d null) {\n                 ser \u003d findSerializerByAddonType(config, type, beanDesc, staticTyping);\n             }\n         }\n     }\n     return (JsonSerializer\u003cObject\u003e) ser;\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "a063b79f364923a4b98ce66254bf478284c63340": {
      "type": "Ybodychange",
      "commitMessage": "Fixes to make TokenBuffer (etc) support \u0027readBinaryValue()\u0027; also improve handling of\ncustom serializers (wasn\u0027t being resolved for array types)\n",
      "commitDate": "6/13/12, 6:47 PM",
      "commitName": "a063b79f364923a4b98ce66254bf478284c63340",
      "commitAuthor": "Tatu Saloranta",
      "commitDateOld": "6/8/12, 11:20 PM",
      "commitNameOld": "752b57e524d5f85f2c2a6b7e97eddf9b5498794a",
      "commitAuthorOld": "Tatu Saloranta",
      "daysBetweenCommits": 4.81,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "@Override\n@SuppressWarnings(\"unchecked\")\npublic JsonSerializer\u003cObject\u003e createSerializer(SerializerProvider prov, JavaType origType, BeanProperty property) throws JsonMappingException {\n    final SerializationConfig config \u003d prov.getConfig();\n    BeanDescription beanDesc \u003d config.introspect(origType);\n    JsonSerializer\u003c?\u003e ser \u003d findSerializerFromAnnotation(prov, beanDesc.getClassInfo());\n    if (ser !\u003d null) {\n        return (JsonSerializer\u003cObject\u003e) ser;\n    }\n    boolean staticTyping;\n    JavaType type \u003d modifyTypeByAnnotation(config, beanDesc.getClassInfo(), origType);\n    if (type \u003d\u003d origType) {\n        staticTyping \u003d false;\n    } else {\n        staticTyping \u003d true;\n        if (type.getRawClass() !\u003d origType.getRawClass()) {\n            beanDesc \u003d config.introspect(type);\n        }\n    }\n    ser \u003d findSerializerByAnnotations(prov, type, beanDesc);\n    if (ser !\u003d null) {\n        return (JsonSerializer\u003cObject\u003e) ser;\n    }\n    if (origType.isContainerType()) {\n        if (!staticTyping) {\n            staticTyping \u003d usesStaticTyping(config, beanDesc, null, property);\n        }\n        return (JsonSerializer\u003cObject\u003e) buildContainerSerializer(prov, type, beanDesc, property, staticTyping);\n    }\n    for (Serializers serializers : customSerializers()) {\n        ser \u003d serializers.findSerializer(config, type, beanDesc);\n        if (ser !\u003d null) {\n            return (JsonSerializer\u003cObject\u003e) ser;\n        }\n    }\n    ser \u003d findSerializerByLookup(type, config, beanDesc, staticTyping);\n    if (ser \u003d\u003d null) {\n        ser \u003d findSerializerByPrimaryType(prov, type, beanDesc, staticTyping);\n        if (ser \u003d\u003d null) {\n            ser \u003d findBeanSerializer(prov, type, beanDesc, property);\n            if (ser \u003d\u003d null) {\n                ser \u003d findSerializerByAddonType(config, type, beanDesc, staticTyping);\n            }\n        }\n    }\n    return (JsonSerializer\u003cObject\u003e) ser;\n}",
      "path": "src/main/java/com/fasterxml/jackson/databind/ser/BeanSerializerFactory.java",
      "functionStartLine": 123,
      "functionName": "createSerializer",
      "functionAnnotation": "@Override,@SuppressWarnings(\"unchecked\")",
      "functionDoc": "Main serializer constructor method. We will have to be careful\nwith respect to ordering of various method calls: essentially\nwe want to reliably figure out which classes are standard types,\nand which are beans. The problem is that some bean Classes may\nimplement standard interfaces (say, {@link java.lang.Iterable}.\n\u003cp\u003e\nNote: sub-classes may choose to complete replace implementation,\nif they want to alter priority of serializer lookups.\n",
      "diff": "@@ -1,47 +1,47 @@\n @Override\n @SuppressWarnings(\"unchecked\")\n public JsonSerializer\u003cObject\u003e createSerializer(SerializerProvider prov, JavaType origType, BeanProperty property) throws JsonMappingException {\n     final SerializationConfig config \u003d prov.getConfig();\n     BeanDescription beanDesc \u003d config.introspect(origType);\n     JsonSerializer\u003c?\u003e ser \u003d findSerializerFromAnnotation(prov, beanDesc.getClassInfo());\n     if (ser !\u003d null) {\n         return (JsonSerializer\u003cObject\u003e) ser;\n     }\n     boolean staticTyping;\n     JavaType type \u003d modifyTypeByAnnotation(config, beanDesc.getClassInfo(), origType);\n     if (type \u003d\u003d origType) {\n         staticTyping \u003d false;\n     } else {\n         staticTyping \u003d true;\n         if (type.getRawClass() !\u003d origType.getRawClass()) {\n             beanDesc \u003d config.introspect(type);\n         }\n     }\n-    for (Serializers serializers : _factoryConfig.serializers()) {\n-        ser \u003d serializers.findSerializer(config, type, beanDesc);\n-        if (ser !\u003d null) {\n-            return (JsonSerializer\u003cObject\u003e) ser;\n-        }\n-    }\n     ser \u003d findSerializerByAnnotations(prov, type, beanDesc);\n     if (ser !\u003d null) {\n         return (JsonSerializer\u003cObject\u003e) ser;\n     }\n     if (origType.isContainerType()) {\n         if (!staticTyping) {\n             staticTyping \u003d usesStaticTyping(config, beanDesc, null, property);\n         }\n         return (JsonSerializer\u003cObject\u003e) buildContainerSerializer(prov, type, beanDesc, property, staticTyping);\n     }\n+    for (Serializers serializers : customSerializers()) {\n+        ser \u003d serializers.findSerializer(config, type, beanDesc);\n+        if (ser !\u003d null) {\n+            return (JsonSerializer\u003cObject\u003e) ser;\n+        }\n+    }\n     ser \u003d findSerializerByLookup(type, config, beanDesc, staticTyping);\n     if (ser \u003d\u003d null) {\n         ser \u003d findSerializerByPrimaryType(prov, type, beanDesc, staticTyping);\n         if (ser \u003d\u003d null) {\n             ser \u003d findBeanSerializer(prov, type, beanDesc, property);\n             if (ser \u003d\u003d null) {\n                 ser \u003d findSerializerByAddonType(config, type, beanDesc, staticTyping);\n             }\n         }\n     }\n     return (JsonSerializer\u003cObject\u003e) ser;\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "752b57e524d5f85f2c2a6b7e97eddf9b5498794a": {
      "type": "Ybodychange",
      "commitMessage": "Implemented [Issue-22], add ObjectMapper.setAnnotationIntrospectors(...)\n",
      "commitDate": "6/8/12, 11:20 PM",
      "commitName": "752b57e524d5f85f2c2a6b7e97eddf9b5498794a",
      "commitAuthor": "Tatu Saloranta",
      "commitDateOld": "4/30/12, 9:51 PM",
      "commitNameOld": "ca93163ef2a71f2e1497ef5d4e5a841d6fb3ac82",
      "commitAuthorOld": "Tatu Saloranta",
      "daysBetweenCommits": 39.06,
      "commitsBetweenForRepo": 24,
      "commitsBetweenForFile": 1,
      "actualSource": "@Override\n@SuppressWarnings(\"unchecked\")\npublic JsonSerializer\u003cObject\u003e createSerializer(SerializerProvider prov, JavaType origType, BeanProperty property) throws JsonMappingException {\n    final SerializationConfig config \u003d prov.getConfig();\n    BeanDescription beanDesc \u003d config.introspect(origType);\n    JsonSerializer\u003c?\u003e ser \u003d findSerializerFromAnnotation(prov, beanDesc.getClassInfo());\n    if (ser !\u003d null) {\n        return (JsonSerializer\u003cObject\u003e) ser;\n    }\n    boolean staticTyping;\n    JavaType type \u003d modifyTypeByAnnotation(config, beanDesc.getClassInfo(), origType);\n    if (type \u003d\u003d origType) {\n        staticTyping \u003d false;\n    } else {\n        staticTyping \u003d true;\n        if (type.getRawClass() !\u003d origType.getRawClass()) {\n            beanDesc \u003d config.introspect(type);\n        }\n    }\n    for (Serializers serializers : _factoryConfig.serializers()) {\n        ser \u003d serializers.findSerializer(config, type, beanDesc);\n        if (ser !\u003d null) {\n            return (JsonSerializer\u003cObject\u003e) ser;\n        }\n    }\n    ser \u003d findSerializerByAnnotations(prov, type, beanDesc);\n    if (ser !\u003d null) {\n        return (JsonSerializer\u003cObject\u003e) ser;\n    }\n    if (origType.isContainerType()) {\n        if (!staticTyping) {\n            staticTyping \u003d usesStaticTyping(config, beanDesc, null, property);\n        }\n        return (JsonSerializer\u003cObject\u003e) buildContainerSerializer(prov, type, beanDesc, property, staticTyping);\n    }\n    ser \u003d findSerializerByLookup(type, config, beanDesc, staticTyping);\n    if (ser \u003d\u003d null) {\n        ser \u003d findSerializerByPrimaryType(prov, type, beanDesc, staticTyping);\n        if (ser \u003d\u003d null) {\n            ser \u003d findBeanSerializer(prov, type, beanDesc, property);\n            if (ser \u003d\u003d null) {\n                ser \u003d findSerializerByAddonType(config, type, beanDesc, staticTyping);\n            }\n        }\n    }\n    return (JsonSerializer\u003cObject\u003e) ser;\n}",
      "path": "src/main/java/com/fasterxml/jackson/databind/ser/BeanSerializerFactory.java",
      "functionStartLine": 123,
      "functionName": "createSerializer",
      "functionAnnotation": "@Override,@SuppressWarnings(\"unchecked\")",
      "functionDoc": "Main serializer constructor method. We will have to be careful\nwith respect to ordering of various method calls: essentially\nwe want to reliably figure out which classes are standard types,\nand which are beans. The problem is that some bean Classes may\nimplement standard interfaces (say, {@link java.lang.Iterable}.\n\u003cp\u003e\nNote: sub-classes may choose to complete replace implementation,\nif they want to alter priority of serializer lookups.\n",
      "diff": "",
      "extendedDetails": {}
    },
    "ca93163ef2a71f2e1497ef5d4e5a841d6fb3ac82": {
      "type": "Ybodychange",
      "commitMessage": "Add unit tests to reproduce [JACKSON-822]\n",
      "commitDate": "4/30/12, 9:51 PM",
      "commitName": "ca93163ef2a71f2e1497ef5d4e5a841d6fb3ac82",
      "commitAuthor": "Tatu Saloranta",
      "commitDateOld": "3/12/12, 11:17 PM",
      "commitNameOld": "d8e52fa5172158312b11780eb99292f46815876b",
      "commitAuthorOld": "Tatu Saloranta",
      "daysBetweenCommits": 48.94,
      "commitsBetweenForRepo": 63,
      "commitsBetweenForFile": 1,
      "actualSource": "@Override\n@SuppressWarnings(\"unchecked\")\npublic JsonSerializer\u003cObject\u003e createSerializer(SerializerProvider prov, JavaType origType, BeanProperty property) throws JsonMappingException {\n    final SerializationConfig config \u003d prov.getConfig();\n    BeanDescription beanDesc \u003d config.introspect(origType);\n    JsonSerializer\u003c?\u003e ser \u003d findSerializerFromAnnotation(prov, beanDesc.getClassInfo());\n    if (ser !\u003d null) {\n        return (JsonSerializer\u003cObject\u003e) ser;\n    }\n    boolean staticTyping;\n    JavaType type \u003d modifyTypeByAnnotation(config, beanDesc.getClassInfo(), origType);\n    if (type \u003d\u003d origType) {\n        staticTyping \u003d false;\n    } else {\n        staticTyping \u003d true;\n        if (type.getRawClass() !\u003d origType.getRawClass()) {\n            beanDesc \u003d config.introspect(type);\n        }\n    }\n    for (Serializers serializers : _factoryConfig.serializers()) {\n        ser \u003d serializers.findSerializer(config, type, beanDesc);\n        if (ser !\u003d null) {\n            return (JsonSerializer\u003cObject\u003e) ser;\n        }\n    }\n    ser \u003d findSerializerByAnnotations(prov, type, beanDesc);\n    if (ser !\u003d null) {\n        return (JsonSerializer\u003cObject\u003e) ser;\n    }\n    if (origType.isContainerType()) {\n        if (!staticTyping) {\n            staticTyping \u003d usesStaticTyping(config, beanDesc, null, property);\n        }\n        return (JsonSerializer\u003cObject\u003e) buildContainerSerializer(prov, type, beanDesc, property, staticTyping);\n    }\n    ser \u003d findSerializerByLookup(type, config, beanDesc, staticTyping);\n    if (ser \u003d\u003d null) {\n        ser \u003d findSerializerByPrimaryType(prov, type, beanDesc, staticTyping);\n        if (ser \u003d\u003d null) {\n            ser \u003d findBeanSerializer(prov, type, beanDesc, property);\n            if (ser \u003d\u003d null) {\n                ser \u003d findSerializerByAddonType(config, type, beanDesc, staticTyping);\n            }\n        }\n    }\n    return (JsonSerializer\u003cObject\u003e) ser;\n}",
      "path": "src/main/java/com/fasterxml/jackson/databind/ser/BeanSerializerFactory.java",
      "functionStartLine": 123,
      "functionName": "createSerializer",
      "functionAnnotation": "@Override,@SuppressWarnings(\"unchecked\")",
      "functionDoc": "Main serializer constructor method. We will have to be careful\nwith respect to ordering of various method calls: essentially\nwe want to reliably figure out which classes are standard types,\nand which are beans. The problem is that some bean Classes may\nimplement standard interfaces (say, {@link java.lang.Iterable}.\n\u003cp\u003e\nNote: sub-classes may choose to complete replace implementation,\nif they want to alter priority of serializer lookups.\n",
      "diff": "",
      "extendedDetails": {}
    },
    "21b3805ce084371f278d6eb6bf2ebc0882e268cf": {
      "type": "Ybodychange",
      "commitMessage": "Fixed [JACKSON-799]; @JsonSerialize.as() not working for root values\n",
      "commitDate": "3/9/12, 5:57 PM",
      "commitName": "21b3805ce084371f278d6eb6bf2ebc0882e268cf",
      "commitAuthor": "Tatu Saloranta",
      "commitDateOld": "2/24/12, 6:35 PM",
      "commitNameOld": "288087216060a7f910a9bcf20bfd4504bd31c89d",
      "commitAuthorOld": "Tatu Saloranta",
      "daysBetweenCommits": 13.97,
      "commitsBetweenForRepo": 27,
      "commitsBetweenForFile": 1,
      "actualSource": "@Override\n@SuppressWarnings(\"unchecked\")\npublic JsonSerializer\u003cObject\u003e createSerializer(SerializerProvider prov, JavaType origType, BeanProperty property) throws JsonMappingException {\n    final SerializationConfig config \u003d prov.getConfig();\n    BeanDescription beanDesc \u003d config.introspect(origType);\n    JsonSerializer\u003c?\u003e ser \u003d findSerializerFromAnnotation(prov, beanDesc.getClassInfo());\n    if (ser !\u003d null) {\n        return (JsonSerializer\u003cObject\u003e) ser;\n    }\n    boolean staticTyping;\n    JavaType type \u003d modifyTypeByAnnotation(config, beanDesc.getClassInfo(), origType);\n    if (type \u003d\u003d origType) {\n        staticTyping \u003d false;\n    } else {\n        staticTyping \u003d true;\n        if (type.getRawClass() !\u003d origType.getRawClass()) {\n            beanDesc \u003d config.introspect(type);\n        }\n    }\n    for (Serializers serializers : _factoryConfig.serializers()) {\n        ser \u003d serializers.findSerializer(config, type, beanDesc);\n        if (ser !\u003d null) {\n            return (JsonSerializer\u003cObject\u003e) ser;\n        }\n    }\n    ser \u003d findSerializerByAnnotations(prov, type, beanDesc);\n    if (ser !\u003d null) {\n        return (JsonSerializer\u003cObject\u003e) ser;\n    }\n    if (origType.isContainerType()) {\n        if (!staticTyping) {\n            staticTyping \u003d usesStaticTyping(config, beanDesc, null, property);\n        }\n        return (JsonSerializer\u003cObject\u003e) buildContainerSerializer(prov, type, beanDesc, property, staticTyping);\n    }\n    ser \u003d findSerializerByLookup(type, config, beanDesc, staticTyping);\n    if (ser \u003d\u003d null) {\n        ser \u003d findSerializerByPrimaryType(prov, type, beanDesc, staticTyping);\n        if (ser \u003d\u003d null) {\n            ser \u003d findBeanSerializer(prov, type, beanDesc, property);\n            if (ser \u003d\u003d null) {\n                ser \u003d findSerializerByAddonType(config, type, beanDesc, staticTyping);\n            }\n        }\n    }\n    return (JsonSerializer\u003cObject\u003e) ser;\n}",
      "path": "src/main/java/com/fasterxml/jackson/databind/ser/BeanSerializerFactory.java",
      "functionStartLine": 123,
      "functionName": "createSerializer",
      "functionAnnotation": "@Override,@SuppressWarnings(\"unchecked\")",
      "functionDoc": "Main serializer constructor method. We will have to be careful\nwith respect to ordering of various method calls: essentially\nwe want to reliably figure out which classes are standard types,\nand which are beans. The problem is that some bean Classes may\nimplement standard interfaces (say, {@link java.lang.Iterable}.\n\u003cp\u003e\nNote: sub-classes may choose to complete replace implementation,\nif they want to alter priority of serializer lookups.\n",
      "diff": "@@ -1,39 +1,47 @@\n @Override\n @SuppressWarnings(\"unchecked\")\n public JsonSerializer\u003cObject\u003e createSerializer(SerializerProvider prov, JavaType origType, BeanProperty property) throws JsonMappingException {\n     final SerializationConfig config \u003d prov.getConfig();\n     BeanDescription beanDesc \u003d config.introspect(origType);\n     JsonSerializer\u003c?\u003e ser \u003d findSerializerFromAnnotation(prov, beanDesc.getClassInfo());\n     if (ser !\u003d null) {\n         return (JsonSerializer\u003cObject\u003e) ser;\n     }\n+    boolean staticTyping;\n     JavaType type \u003d modifyTypeByAnnotation(config, beanDesc.getClassInfo(), origType);\n-    boolean staticTyping \u003d (type !\u003d origType);\n+    if (type \u003d\u003d origType) {\n+        staticTyping \u003d false;\n+    } else {\n+        staticTyping \u003d true;\n+        if (type.getRawClass() !\u003d origType.getRawClass()) {\n+            beanDesc \u003d config.introspect(type);\n+        }\n+    }\n     for (Serializers serializers : _factoryConfig.serializers()) {\n         ser \u003d serializers.findSerializer(config, type, beanDesc);\n         if (ser !\u003d null) {\n             return (JsonSerializer\u003cObject\u003e) ser;\n         }\n     }\n     ser \u003d findSerializerByAnnotations(prov, type, beanDesc);\n     if (ser !\u003d null) {\n         return (JsonSerializer\u003cObject\u003e) ser;\n     }\n     if (origType.isContainerType()) {\n         if (!staticTyping) {\n             staticTyping \u003d usesStaticTyping(config, beanDesc, null, property);\n         }\n         return (JsonSerializer\u003cObject\u003e) buildContainerSerializer(prov, type, beanDesc, property, staticTyping);\n     }\n     ser \u003d findSerializerByLookup(type, config, beanDesc, staticTyping);\n     if (ser \u003d\u003d null) {\n         ser \u003d findSerializerByPrimaryType(prov, type, beanDesc, staticTyping);\n         if (ser \u003d\u003d null) {\n             ser \u003d findBeanSerializer(prov, type, beanDesc, property);\n             if (ser \u003d\u003d null) {\n                 ser \u003d findSerializerByAddonType(config, type, beanDesc, staticTyping);\n             }\n         }\n     }\n     return (JsonSerializer\u003cObject\u003e) ser;\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "288087216060a7f910a9bcf20bfd4504bd31c89d": {
      "type": "Ybodychange",
      "commitMessage": "Implement [JACKSON-795]: @JsonValue will now work with Maps, Collections too\n",
      "commitDate": "2/24/12, 6:35 PM",
      "commitName": "288087216060a7f910a9bcf20bfd4504bd31c89d",
      "commitAuthor": "Tatu Saloranta",
      "commitDateOld": "2/17/12, 10:40 PM",
      "commitNameOld": "2fd4ffd9963545ce735a58957a84afb90809561e",
      "commitAuthorOld": "Tatu Saloranta",
      "daysBetweenCommits": 6.83,
      "commitsBetweenForRepo": 30,
      "commitsBetweenForFile": 1,
      "actualSource": "@Override\n@SuppressWarnings(\"unchecked\")\npublic JsonSerializer\u003cObject\u003e createSerializer(SerializerProvider prov, JavaType origType, BeanProperty property) throws JsonMappingException {\n    final SerializationConfig config \u003d prov.getConfig();\n    BeanDescription beanDesc \u003d config.introspect(origType);\n    JsonSerializer\u003c?\u003e ser \u003d findSerializerFromAnnotation(prov, beanDesc.getClassInfo());\n    if (ser !\u003d null) {\n        return (JsonSerializer\u003cObject\u003e) ser;\n    }\n    JavaType type \u003d modifyTypeByAnnotation(config, beanDesc.getClassInfo(), origType);\n    boolean staticTyping \u003d (type !\u003d origType);\n    for (Serializers serializers : _factoryConfig.serializers()) {\n        ser \u003d serializers.findSerializer(config, type, beanDesc);\n        if (ser !\u003d null) {\n            return (JsonSerializer\u003cObject\u003e) ser;\n        }\n    }\n    ser \u003d findSerializerByAnnotations(prov, type, beanDesc);\n    if (ser !\u003d null) {\n        return (JsonSerializer\u003cObject\u003e) ser;\n    }\n    if (origType.isContainerType()) {\n        if (!staticTyping) {\n            staticTyping \u003d usesStaticTyping(config, beanDesc, null, property);\n        }\n        return (JsonSerializer\u003cObject\u003e) buildContainerSerializer(prov, type, beanDesc, property, staticTyping);\n    }\n    ser \u003d findSerializerByLookup(type, config, beanDesc, staticTyping);\n    if (ser \u003d\u003d null) {\n        ser \u003d findSerializerByPrimaryType(prov, type, beanDesc, staticTyping);\n        if (ser \u003d\u003d null) {\n            ser \u003d findBeanSerializer(prov, type, beanDesc, property);\n            if (ser \u003d\u003d null) {\n                ser \u003d findSerializerByAddonType(config, type, beanDesc, staticTyping);\n            }\n        }\n    }\n    return (JsonSerializer\u003cObject\u003e) ser;\n}",
      "path": "src/main/java/com/fasterxml/jackson/databind/ser/BeanSerializerFactory.java",
      "functionStartLine": 123,
      "functionName": "createSerializer",
      "functionAnnotation": "@Override,@SuppressWarnings(\"unchecked\")",
      "functionDoc": "Main serializer constructor method. We will have to be careful\nwith respect to ordering of various method calls: essentially\nwe want to reliably figure out which classes are standard types,\nand which are beans. The problem is that some bean Classes may\nimplement standard interfaces (say, {@link java.lang.Iterable}.\n\u003cp\u003e\nNote: sub-classes may choose to complete replace implementation,\nif they want to alter priority of serializer lookups.\n",
      "diff": "@@ -1,35 +1,39 @@\n @Override\n @SuppressWarnings(\"unchecked\")\n public JsonSerializer\u003cObject\u003e createSerializer(SerializerProvider prov, JavaType origType, BeanProperty property) throws JsonMappingException {\n     final SerializationConfig config \u003d prov.getConfig();\n     BeanDescription beanDesc \u003d config.introspect(origType);\n     JsonSerializer\u003c?\u003e ser \u003d findSerializerFromAnnotation(prov, beanDesc.getClassInfo());\n     if (ser !\u003d null) {\n         return (JsonSerializer\u003cObject\u003e) ser;\n     }\n     JavaType type \u003d modifyTypeByAnnotation(config, beanDesc.getClassInfo(), origType);\n     boolean staticTyping \u003d (type !\u003d origType);\n     for (Serializers serializers : _factoryConfig.serializers()) {\n         ser \u003d serializers.findSerializer(config, type, beanDesc);\n         if (ser !\u003d null) {\n             return (JsonSerializer\u003cObject\u003e) ser;\n         }\n     }\n+    ser \u003d findSerializerByAnnotations(prov, type, beanDesc);\n+    if (ser !\u003d null) {\n+        return (JsonSerializer\u003cObject\u003e) ser;\n+    }\n     if (origType.isContainerType()) {\n         if (!staticTyping) {\n             staticTyping \u003d usesStaticTyping(config, beanDesc, null, property);\n         }\n         return (JsonSerializer\u003cObject\u003e) buildContainerSerializer(prov, type, beanDesc, property, staticTyping);\n     }\n     ser \u003d findSerializerByLookup(type, config, beanDesc, staticTyping);\n     if (ser \u003d\u003d null) {\n         ser \u003d findSerializerByPrimaryType(prov, type, beanDesc, staticTyping);\n         if (ser \u003d\u003d null) {\n             ser \u003d findBeanSerializer(prov, type, beanDesc, property);\n             if (ser \u003d\u003d null) {\n                 ser \u003d findSerializerByAddonType(config, type, beanDesc, staticTyping);\n             }\n         }\n     }\n     return (JsonSerializer\u003cObject\u003e) ser;\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "82b474d51545919cb38a49485f56fd29d6ed199b": {
      "type": "Yformatchange",
      "commitMessage": "Fix 3 unit test failures\n",
      "commitDate": "2/2/12, 5:33 PM",
      "commitName": "82b474d51545919cb38a49485f56fd29d6ed199b",
      "commitAuthor": "Tatu",
      "commitDateOld": "2/2/12, 11:30 AM",
      "commitNameOld": "9610aff9eb922486478ab92ad5c4d02a11b2ad1f",
      "commitAuthorOld": "Tatu",
      "daysBetweenCommits": 0.25,
      "commitsBetweenForRepo": 3,
      "commitsBetweenForFile": 1,
      "actualSource": "@Override\n@SuppressWarnings(\"unchecked\")\npublic JsonSerializer\u003cObject\u003e createSerializer(SerializerProvider prov, JavaType origType, BeanProperty property) throws JsonMappingException {\n    final SerializationConfig config \u003d prov.getConfig();\n    BeanDescription beanDesc \u003d config.introspect(origType);\n    JsonSerializer\u003c?\u003e ser \u003d findSerializerFromAnnotation(prov, beanDesc.getClassInfo());\n    if (ser !\u003d null) {\n        return (JsonSerializer\u003cObject\u003e) ser;\n    }\n    JavaType type \u003d modifyTypeByAnnotation(config, beanDesc.getClassInfo(), origType);\n    boolean staticTyping \u003d (type !\u003d origType);\n    for (Serializers serializers : _factoryConfig.serializers()) {\n        ser \u003d serializers.findSerializer(config, type, beanDesc);\n        if (ser !\u003d null) {\n            return (JsonSerializer\u003cObject\u003e) ser;\n        }\n    }\n    if (origType.isContainerType()) {\n        if (!staticTyping) {\n            staticTyping \u003d usesStaticTyping(config, beanDesc, null, property);\n        }\n        return (JsonSerializer\u003cObject\u003e) buildContainerSerializer(prov, type, beanDesc, property, staticTyping);\n    }\n    ser \u003d findSerializerByLookup(type, config, beanDesc, staticTyping);\n    if (ser \u003d\u003d null) {\n        ser \u003d findSerializerByPrimaryType(prov, type, beanDesc, staticTyping);\n        if (ser \u003d\u003d null) {\n            ser \u003d findBeanSerializer(prov, type, beanDesc, property);\n            if (ser \u003d\u003d null) {\n                ser \u003d findSerializerByAddonType(config, type, beanDesc, staticTyping);\n            }\n        }\n    }\n    return (JsonSerializer\u003cObject\u003e) ser;\n}",
      "path": "src/main/java/com/fasterxml/jackson/databind/ser/BeanSerializerFactory.java",
      "functionStartLine": 120,
      "functionName": "createSerializer",
      "functionAnnotation": "@Override,@SuppressWarnings(\"unchecked\")",
      "functionDoc": "Main serializer constructor method. We will have to be careful\nwith respect to ordering of various method calls: essentially\nwe want to reliably figure out which classes are standard types,\nand which are beans. The problem is that some bean Classes may\nimplement standard interfaces (say, {@link java.lang.Iterable}.\n\u003cp\u003e\nNote: sub-classes may choose to complete replace implementation,\nif they want to alter priority of serializer lookups.\n",
      "diff": "",
      "extendedDetails": {}
    },
    "334892f4c5c0f346248eb6ebae306330e6512d93": {
      "type": "Ybodychange",
      "commitMessage": "...\n",
      "commitDate": "2/1/12, 8:01 PM",
      "commitName": "334892f4c5c0f346248eb6ebae306330e6512d93",
      "commitAuthor": "Tatu Saloranta",
      "commitDateOld": "2/1/12, 6:17 PM",
      "commitNameOld": "67bf19c225daeef0ac0e6a0ea3f371b4d57946c4",
      "commitAuthorOld": "Tatu Saloranta",
      "daysBetweenCommits": 0.07,
      "commitsBetweenForRepo": 3,
      "commitsBetweenForFile": 1,
      "actualSource": "@Override\n@SuppressWarnings(\"unchecked\")\npublic JsonSerializer\u003cObject\u003e createSerializer(SerializerProvider prov, JavaType origType, BeanProperty property) throws JsonMappingException {\n    final SerializationConfig config \u003d prov.getConfig();\n    BeanDescription beanDesc \u003d config.introspect(origType);\n    JsonSerializer\u003c?\u003e ser \u003d findSerializerFromAnnotation(prov, beanDesc.getClassInfo());\n    if (ser !\u003d null) {\n        return (JsonSerializer\u003cObject\u003e) ser;\n    }\n    JavaType type \u003d modifyTypeByAnnotation(config, beanDesc.getClassInfo(), origType);\n    boolean staticTyping \u003d (type !\u003d origType);\n    for (Serializers serializers : _factoryConfig.serializers()) {\n        ser \u003d serializers.findSerializer(config, type, beanDesc);\n        if (ser !\u003d null) {\n            return (JsonSerializer\u003cObject\u003e) ser;\n        }\n    }\n    if (origType.isContainerType()) {\n        if (!staticTyping) {\n            staticTyping \u003d usesStaticTyping(config, beanDesc, null, property);\n        }\n        return (JsonSerializer\u003cObject\u003e) buildContainerSerializer(prov, type, beanDesc, property, staticTyping);\n    }\n    ser \u003d findSerializerByLookup(type, config, beanDesc, staticTyping);\n    if (ser \u003d\u003d null) {\n        ser \u003d findSerializerByPrimaryType(prov, type, beanDesc, staticTyping);\n        if (ser \u003d\u003d null) {\n            ser \u003d findBeanSerializer(prov, type, beanDesc, property);\n            if (ser \u003d\u003d null) {\n                ser \u003d findSerializerByAddonType(config, type, beanDesc, staticTyping);\n            }\n        }\n    }\n    return (JsonSerializer\u003cObject\u003e) ser;\n}",
      "path": "src/main/java/com/fasterxml/jackson/databind/ser/BeanSerializerFactory.java",
      "functionStartLine": 120,
      "functionName": "createSerializer",
      "functionAnnotation": "@Override,@SuppressWarnings(\"unchecked\")",
      "functionDoc": "Main serializer constructor method. We will have to be careful\nwith respect to ordering of various method calls: essentially\nwe want to reliably figure out which classes are standard types,\nand which are beans. The problem is that some bean Classes may\nimplement standard interfaces (say, {@link java.lang.Iterable}.\n\u003cp\u003e\nNote: sub-classes may choose to complete replace implementation,\nif they want to alter priority of serializer lookups.\n",
      "diff": "@@ -1,32 +1,35 @@\n @Override\n @SuppressWarnings(\"unchecked\")\n public JsonSerializer\u003cObject\u003e createSerializer(SerializerProvider prov, JavaType origType, BeanProperty property) throws JsonMappingException {\n     final SerializationConfig config \u003d prov.getConfig();\n     BeanDescription beanDesc \u003d config.introspect(origType);\n-    JsonSerializer\u003c?\u003e ser \u003d findSerializerFromAnnotation(prov, beanDesc.getClassInfo(), property);\n+    JsonSerializer\u003c?\u003e ser \u003d findSerializerFromAnnotation(prov, beanDesc.getClassInfo());\n     if (ser !\u003d null) {\n         return (JsonSerializer\u003cObject\u003e) ser;\n     }\n     JavaType type \u003d modifyTypeByAnnotation(config, beanDesc.getClassInfo(), origType);\n     boolean staticTyping \u003d (type !\u003d origType);\n-    if (origType.isContainerType()) {\n-        return (JsonSerializer\u003cObject\u003e) buildContainerSerializer(prov, type, beanDesc, property, staticTyping);\n-    }\n     for (Serializers serializers : _factoryConfig.serializers()) {\n         ser \u003d serializers.findSerializer(config, type, beanDesc);\n         if (ser !\u003d null) {\n             return (JsonSerializer\u003cObject\u003e) ser;\n         }\n     }\n-    ser \u003d findSerializerByLookup(type, config, beanDesc, property, staticTyping);\n+    if (origType.isContainerType()) {\n+        if (!staticTyping) {\n+            staticTyping \u003d usesStaticTyping(config, beanDesc, null, property);\n+        }\n+        return (JsonSerializer\u003cObject\u003e) buildContainerSerializer(prov, type, beanDesc, property, staticTyping);\n+    }\n+    ser \u003d findSerializerByLookup(type, config, beanDesc, staticTyping);\n     if (ser \u003d\u003d null) {\n-        ser \u003d findSerializerByPrimaryType(prov, type, beanDesc, property, staticTyping);\n+        ser \u003d findSerializerByPrimaryType(prov, type, beanDesc, staticTyping);\n         if (ser \u003d\u003d null) {\n             ser \u003d findBeanSerializer(prov, type, beanDesc, property);\n             if (ser \u003d\u003d null) {\n-                ser \u003d findSerializerByAddonType(config, type, beanDesc, property, staticTyping);\n+                ser \u003d findSerializerByAddonType(config, type, beanDesc, staticTyping);\n             }\n         }\n     }\n     return (JsonSerializer\u003cObject\u003e) ser;\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "3f2db3343f2b159f7c5de6b7310c70ea15b3384d": {
      "type": "Ybodychange",
      "commitMessage": "...\n",
      "commitDate": "1/31/12, 8:56 PM",
      "commitName": "3f2db3343f2b159f7c5de6b7310c70ea15b3384d",
      "commitAuthor": "Tatu Saloranta",
      "commitDateOld": "1/31/12, 8:42 PM",
      "commitNameOld": "886ca96f608a1a3e9a72b1cb2d86a2b45c5eae40",
      "commitAuthorOld": "Tatu Saloranta",
      "daysBetweenCommits": 0.01,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "@Override\n@SuppressWarnings(\"unchecked\")\npublic JsonSerializer\u003cObject\u003e createSerializer(SerializerProvider prov, JavaType origType, BeanProperty property) throws JsonMappingException {\n    final SerializationConfig config \u003d prov.getConfig();\n    BeanDescription beanDesc \u003d config.introspect(origType);\n    JsonSerializer\u003c?\u003e ser \u003d findSerializerFromAnnotation(prov, beanDesc.getClassInfo(), property);\n    if (ser !\u003d null) {\n        return (JsonSerializer\u003cObject\u003e) ser;\n    }\n    JavaType type \u003d modifyTypeByAnnotation(config, beanDesc.getClassInfo(), origType);\n    boolean staticTyping \u003d (type !\u003d origType);\n    if (origType.isContainerType()) {\n        return (JsonSerializer\u003cObject\u003e) buildContainerSerializer(prov, type, beanDesc, property, staticTyping);\n    }\n    for (Serializers serializers : _factoryConfig.serializers()) {\n        ser \u003d serializers.findSerializer(config, type, beanDesc);\n        if (ser !\u003d null) {\n            return (JsonSerializer\u003cObject\u003e) ser;\n        }\n    }\n    ser \u003d findSerializerByLookup(type, config, beanDesc, property, staticTyping);\n    if (ser \u003d\u003d null) {\n        ser \u003d findSerializerByPrimaryType(prov, type, beanDesc, property, staticTyping);\n        if (ser \u003d\u003d null) {\n            ser \u003d findBeanSerializer(prov, type, beanDesc, property);\n            if (ser \u003d\u003d null) {\n                ser \u003d findSerializerByAddonType(config, type, beanDesc, property, staticTyping);\n            }\n        }\n    }\n    return (JsonSerializer\u003cObject\u003e) ser;\n}",
      "path": "src/main/java/com/fasterxml/jackson/databind/ser/BeanSerializerFactory.java",
      "functionStartLine": 227,
      "functionName": "createSerializer",
      "functionAnnotation": "@Override,@SuppressWarnings(\"unchecked\")",
      "functionDoc": "Main serializer constructor method. We will have to be careful\nwith respect to ordering of various method calls: essentially\nwe want to reliably figure out which classes are standard types,\nand which are beans. The problem is that some bean Classes may\nimplement standard interfaces (say, {@link java.lang.Iterable}.\n\u003cp\u003e\nNote: sub-classes may choose to complete replace implementation,\nif they want to alter priority of serializer lookups.\n",
      "diff": "@@ -1,32 +1,32 @@\n @Override\n @SuppressWarnings(\"unchecked\")\n public JsonSerializer\u003cObject\u003e createSerializer(SerializerProvider prov, JavaType origType, BeanProperty property) throws JsonMappingException {\n     final SerializationConfig config \u003d prov.getConfig();\n     BeanDescription beanDesc \u003d config.introspect(origType);\n     JsonSerializer\u003c?\u003e ser \u003d findSerializerFromAnnotation(prov, beanDesc.getClassInfo(), property);\n     if (ser !\u003d null) {\n         return (JsonSerializer\u003cObject\u003e) ser;\n     }\n     JavaType type \u003d modifyTypeByAnnotation(config, beanDesc.getClassInfo(), origType);\n     boolean staticTyping \u003d (type !\u003d origType);\n     if (origType.isContainerType()) {\n         return (JsonSerializer\u003cObject\u003e) buildContainerSerializer(prov, type, beanDesc, property, staticTyping);\n     }\n     for (Serializers serializers : _factoryConfig.serializers()) {\n-        ser \u003d serializers.findSerializer(config, type, beanDesc, property);\n+        ser \u003d serializers.findSerializer(config, type, beanDesc);\n         if (ser !\u003d null) {\n             return (JsonSerializer\u003cObject\u003e) ser;\n         }\n     }\n     ser \u003d findSerializerByLookup(type, config, beanDesc, property, staticTyping);\n     if (ser \u003d\u003d null) {\n         ser \u003d findSerializerByPrimaryType(prov, type, beanDesc, property, staticTyping);\n         if (ser \u003d\u003d null) {\n             ser \u003d findBeanSerializer(prov, type, beanDesc, property);\n             if (ser \u003d\u003d null) {\n                 ser \u003d findSerializerByAddonType(config, type, beanDesc, property, staticTyping);\n             }\n         }\n     }\n     return (JsonSerializer\u003cObject\u003e) ser;\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "aaba9c105d557bdbb4e94a1e3927cbdd61bd2807": {
      "type": "Ymultichange(Yparameterchange,Ybodychange)",
      "commitMessage": "Completed (?) major refactoring to give necessary context for Resolvable Serializers, Deserializers.\n",
      "commitDate": "1/24/12, 6:51 PM",
      "commitName": "aaba9c105d557bdbb4e94a1e3927cbdd61bd2807",
      "commitAuthor": "Tatu Saloranta",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "Completed (?) major refactoring to give necessary context for Resolvable Serializers, Deserializers.\n",
          "commitDate": "1/24/12, 6:51 PM",
          "commitName": "aaba9c105d557bdbb4e94a1e3927cbdd61bd2807",
          "commitAuthor": "Tatu Saloranta",
          "commitDateOld": "1/22/12, 10:57 PM",
          "commitNameOld": "28bde0726d83be7f70ca4586abee6f536bfc8885",
          "commitAuthorOld": "Tatu Saloranta",
          "daysBetweenCommits": 1.83,
          "commitsBetweenForRepo": 21,
          "commitsBetweenForFile": 1,
          "actualSource": "@Override\n@SuppressWarnings(\"unchecked\")\npublic JsonSerializer\u003cObject\u003e createSerializer(SerializerProvider prov, JavaType origType, BeanProperty property) throws JsonMappingException {\n    final SerializationConfig config \u003d prov.getConfig();\n    BeanDescription beanDesc \u003d config.introspect(origType);\n    JsonSerializer\u003c?\u003e ser \u003d findSerializerFromAnnotation(prov, beanDesc.getClassInfo(), property);\n    if (ser !\u003d null) {\n        return (JsonSerializer\u003cObject\u003e) ser;\n    }\n    JavaType type \u003d modifyTypeByAnnotation(config, beanDesc.getClassInfo(), origType);\n    boolean staticTyping \u003d (type !\u003d origType);\n    if (origType.isContainerType()) {\n        return (JsonSerializer\u003cObject\u003e) buildContainerSerializer(prov, type, beanDesc, property, staticTyping);\n    }\n    for (Serializers serializers : _factoryConfig.serializers()) {\n        ser \u003d serializers.findSerializer(config, type, beanDesc, property);\n        if (ser !\u003d null) {\n            return (JsonSerializer\u003cObject\u003e) ser;\n        }\n    }\n    ser \u003d findSerializerByLookup(type, config, beanDesc, property, staticTyping);\n    if (ser \u003d\u003d null) {\n        ser \u003d findSerializerByPrimaryType(prov, type, beanDesc, property, staticTyping);\n        if (ser \u003d\u003d null) {\n            ser \u003d findBeanSerializer(prov, type, beanDesc, property);\n            if (ser \u003d\u003d null) {\n                ser \u003d findSerializerByAddonType(config, type, beanDesc, property, staticTyping);\n            }\n        }\n    }\n    return (JsonSerializer\u003cObject\u003e) ser;\n}",
          "path": "src/main/java/com/fasterxml/jackson/databind/ser/BeanSerializerFactory.java",
          "functionStartLine": 226,
          "functionName": "createSerializer",
          "functionAnnotation": "@Override,@SuppressWarnings(\"unchecked\")",
          "functionDoc": "Main serializer constructor method. We will have to be careful\nwith respect to ordering of various method calls: essentially\nwe want to reliably figure out which classes are standard types,\nand which are beans. The problem is that some bean Classes may\nimplement standard interfaces (say, {@link java.lang.Iterable}.\n\u003cp\u003e\nNote: sub-classes may choose to complete replace implementation,\nif they want to alter priority of serializer lookups.\n",
          "diff": "@@ -1,31 +1,32 @@\n @Override\n @SuppressWarnings(\"unchecked\")\n-public JsonSerializer\u003cObject\u003e createSerializer(SerializationConfig config, JavaType origType, BeanProperty property) throws JsonMappingException {\n+public JsonSerializer\u003cObject\u003e createSerializer(SerializerProvider prov, JavaType origType, BeanProperty property) throws JsonMappingException {\n+    final SerializationConfig config \u003d prov.getConfig();\n     BeanDescription beanDesc \u003d config.introspect(origType);\n-    JsonSerializer\u003c?\u003e ser \u003d findSerializerFromAnnotation(config, beanDesc.getClassInfo(), property);\n+    JsonSerializer\u003c?\u003e ser \u003d findSerializerFromAnnotation(prov, beanDesc.getClassInfo(), property);\n     if (ser !\u003d null) {\n         return (JsonSerializer\u003cObject\u003e) ser;\n     }\n     JavaType type \u003d modifyTypeByAnnotation(config, beanDesc.getClassInfo(), origType);\n     boolean staticTyping \u003d (type !\u003d origType);\n     if (origType.isContainerType()) {\n-        return (JsonSerializer\u003cObject\u003e) buildContainerSerializer(config, type, beanDesc, property, staticTyping);\n+        return (JsonSerializer\u003cObject\u003e) buildContainerSerializer(prov, type, beanDesc, property, staticTyping);\n     }\n     for (Serializers serializers : _factoryConfig.serializers()) {\n         ser \u003d serializers.findSerializer(config, type, beanDesc, property);\n         if (ser !\u003d null) {\n             return (JsonSerializer\u003cObject\u003e) ser;\n         }\n     }\n     ser \u003d findSerializerByLookup(type, config, beanDesc, property, staticTyping);\n     if (ser \u003d\u003d null) {\n-        ser \u003d findSerializerByPrimaryType(type, config, beanDesc, property, staticTyping);\n+        ser \u003d findSerializerByPrimaryType(prov, type, beanDesc, property, staticTyping);\n         if (ser \u003d\u003d null) {\n-            ser \u003d findBeanSerializer(config, type, beanDesc, property);\n+            ser \u003d findBeanSerializer(prov, type, beanDesc, property);\n             if (ser \u003d\u003d null) {\n                 ser \u003d findSerializerByAddonType(config, type, beanDesc, property, staticTyping);\n             }\n         }\n     }\n     return (JsonSerializer\u003cObject\u003e) ser;\n }\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldValue": "[config-SerializationConfig, origType-JavaType, property-BeanProperty]",
            "newValue": "[prov-SerializerProvider, origType-JavaType, property-BeanProperty]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "Completed (?) major refactoring to give necessary context for Resolvable Serializers, Deserializers.\n",
          "commitDate": "1/24/12, 6:51 PM",
          "commitName": "aaba9c105d557bdbb4e94a1e3927cbdd61bd2807",
          "commitAuthor": "Tatu Saloranta",
          "commitDateOld": "1/22/12, 10:57 PM",
          "commitNameOld": "28bde0726d83be7f70ca4586abee6f536bfc8885",
          "commitAuthorOld": "Tatu Saloranta",
          "daysBetweenCommits": 1.83,
          "commitsBetweenForRepo": 21,
          "commitsBetweenForFile": 1,
          "actualSource": "@Override\n@SuppressWarnings(\"unchecked\")\npublic JsonSerializer\u003cObject\u003e createSerializer(SerializerProvider prov, JavaType origType, BeanProperty property) throws JsonMappingException {\n    final SerializationConfig config \u003d prov.getConfig();\n    BeanDescription beanDesc \u003d config.introspect(origType);\n    JsonSerializer\u003c?\u003e ser \u003d findSerializerFromAnnotation(prov, beanDesc.getClassInfo(), property);\n    if (ser !\u003d null) {\n        return (JsonSerializer\u003cObject\u003e) ser;\n    }\n    JavaType type \u003d modifyTypeByAnnotation(config, beanDesc.getClassInfo(), origType);\n    boolean staticTyping \u003d (type !\u003d origType);\n    if (origType.isContainerType()) {\n        return (JsonSerializer\u003cObject\u003e) buildContainerSerializer(prov, type, beanDesc, property, staticTyping);\n    }\n    for (Serializers serializers : _factoryConfig.serializers()) {\n        ser \u003d serializers.findSerializer(config, type, beanDesc, property);\n        if (ser !\u003d null) {\n            return (JsonSerializer\u003cObject\u003e) ser;\n        }\n    }\n    ser \u003d findSerializerByLookup(type, config, beanDesc, property, staticTyping);\n    if (ser \u003d\u003d null) {\n        ser \u003d findSerializerByPrimaryType(prov, type, beanDesc, property, staticTyping);\n        if (ser \u003d\u003d null) {\n            ser \u003d findBeanSerializer(prov, type, beanDesc, property);\n            if (ser \u003d\u003d null) {\n                ser \u003d findSerializerByAddonType(config, type, beanDesc, property, staticTyping);\n            }\n        }\n    }\n    return (JsonSerializer\u003cObject\u003e) ser;\n}",
          "path": "src/main/java/com/fasterxml/jackson/databind/ser/BeanSerializerFactory.java",
          "functionStartLine": 226,
          "functionName": "createSerializer",
          "functionAnnotation": "@Override,@SuppressWarnings(\"unchecked\")",
          "functionDoc": "Main serializer constructor method. We will have to be careful\nwith respect to ordering of various method calls: essentially\nwe want to reliably figure out which classes are standard types,\nand which are beans. The problem is that some bean Classes may\nimplement standard interfaces (say, {@link java.lang.Iterable}.\n\u003cp\u003e\nNote: sub-classes may choose to complete replace implementation,\nif they want to alter priority of serializer lookups.\n",
          "diff": "@@ -1,31 +1,32 @@\n @Override\n @SuppressWarnings(\"unchecked\")\n-public JsonSerializer\u003cObject\u003e createSerializer(SerializationConfig config, JavaType origType, BeanProperty property) throws JsonMappingException {\n+public JsonSerializer\u003cObject\u003e createSerializer(SerializerProvider prov, JavaType origType, BeanProperty property) throws JsonMappingException {\n+    final SerializationConfig config \u003d prov.getConfig();\n     BeanDescription beanDesc \u003d config.introspect(origType);\n-    JsonSerializer\u003c?\u003e ser \u003d findSerializerFromAnnotation(config, beanDesc.getClassInfo(), property);\n+    JsonSerializer\u003c?\u003e ser \u003d findSerializerFromAnnotation(prov, beanDesc.getClassInfo(), property);\n     if (ser !\u003d null) {\n         return (JsonSerializer\u003cObject\u003e) ser;\n     }\n     JavaType type \u003d modifyTypeByAnnotation(config, beanDesc.getClassInfo(), origType);\n     boolean staticTyping \u003d (type !\u003d origType);\n     if (origType.isContainerType()) {\n-        return (JsonSerializer\u003cObject\u003e) buildContainerSerializer(config, type, beanDesc, property, staticTyping);\n+        return (JsonSerializer\u003cObject\u003e) buildContainerSerializer(prov, type, beanDesc, property, staticTyping);\n     }\n     for (Serializers serializers : _factoryConfig.serializers()) {\n         ser \u003d serializers.findSerializer(config, type, beanDesc, property);\n         if (ser !\u003d null) {\n             return (JsonSerializer\u003cObject\u003e) ser;\n         }\n     }\n     ser \u003d findSerializerByLookup(type, config, beanDesc, property, staticTyping);\n     if (ser \u003d\u003d null) {\n-        ser \u003d findSerializerByPrimaryType(type, config, beanDesc, property, staticTyping);\n+        ser \u003d findSerializerByPrimaryType(prov, type, beanDesc, property, staticTyping);\n         if (ser \u003d\u003d null) {\n-            ser \u003d findBeanSerializer(config, type, beanDesc, property);\n+            ser \u003d findBeanSerializer(prov, type, beanDesc, property);\n             if (ser \u003d\u003d null) {\n                 ser \u003d findSerializerByAddonType(config, type, beanDesc, property, staticTyping);\n             }\n         }\n     }\n     return (JsonSerializer\u003cObject\u003e) ser;\n }\n\\ No newline at end of file\n",
          "extendedDetails": {}
        }
      ]
    },
    "28bde0726d83be7f70ca4586abee6f536bfc8885": {
      "type": "Ybodychange",
      "commitMessage": "Refactoring: eliminate exposure of BasicBeanDescription (now just base class. BeanDescription)\n",
      "commitDate": "1/22/12, 10:57 PM",
      "commitName": "28bde0726d83be7f70ca4586abee6f536bfc8885",
      "commitAuthor": "Tatu Saloranta",
      "commitDateOld": "1/20/12, 8:16 PM",
      "commitNameOld": "b2a9ca7bb27c21b12ccd8d17314e83275381027c",
      "commitAuthorOld": "Tatu Saloranta",
      "daysBetweenCommits": 2.11,
      "commitsBetweenForRepo": 12,
      "commitsBetweenForFile": 1,
      "actualSource": "@Override\n@SuppressWarnings(\"unchecked\")\npublic JsonSerializer\u003cObject\u003e createSerializer(SerializationConfig config, JavaType origType, BeanProperty property) throws JsonMappingException {\n    BeanDescription beanDesc \u003d config.introspect(origType);\n    JsonSerializer\u003c?\u003e ser \u003d findSerializerFromAnnotation(config, beanDesc.getClassInfo(), property);\n    if (ser !\u003d null) {\n        return (JsonSerializer\u003cObject\u003e) ser;\n    }\n    JavaType type \u003d modifyTypeByAnnotation(config, beanDesc.getClassInfo(), origType);\n    boolean staticTyping \u003d (type !\u003d origType);\n    if (origType.isContainerType()) {\n        return (JsonSerializer\u003cObject\u003e) buildContainerSerializer(config, type, beanDesc, property, staticTyping);\n    }\n    for (Serializers serializers : _factoryConfig.serializers()) {\n        ser \u003d serializers.findSerializer(config, type, beanDesc, property);\n        if (ser !\u003d null) {\n            return (JsonSerializer\u003cObject\u003e) ser;\n        }\n    }\n    ser \u003d findSerializerByLookup(type, config, beanDesc, property, staticTyping);\n    if (ser \u003d\u003d null) {\n        ser \u003d findSerializerByPrimaryType(type, config, beanDesc, property, staticTyping);\n        if (ser \u003d\u003d null) {\n            ser \u003d findBeanSerializer(config, type, beanDesc, property);\n            if (ser \u003d\u003d null) {\n                ser \u003d findSerializerByAddonType(config, type, beanDesc, property, staticTyping);\n            }\n        }\n    }\n    return (JsonSerializer\u003cObject\u003e) ser;\n}",
      "path": "src/main/java/com/fasterxml/jackson/databind/ser/BeanSerializerFactory.java",
      "functionStartLine": 226,
      "functionName": "createSerializer",
      "functionAnnotation": "@Override,@SuppressWarnings(\"unchecked\")",
      "functionDoc": "Main serializer constructor method. We will have to be careful\nwith respect to ordering of various method calls: essentially\nwe want to reliably figure out which classes are standard types,\nand which are beans. The problem is that some bean Classes may\nimplement standard interfaces (say, {@link java.lang.Iterable}.\n\u003cp\u003e\nNote: sub-classes may choose to complete replace implementation,\nif they want to alter priority of serializer lookups.\n",
      "diff": "@@ -1,31 +1,31 @@\n @Override\n @SuppressWarnings(\"unchecked\")\n public JsonSerializer\u003cObject\u003e createSerializer(SerializationConfig config, JavaType origType, BeanProperty property) throws JsonMappingException {\n-    BasicBeanDescription beanDesc \u003d config.introspect(origType);\n+    BeanDescription beanDesc \u003d config.introspect(origType);\n     JsonSerializer\u003c?\u003e ser \u003d findSerializerFromAnnotation(config, beanDesc.getClassInfo(), property);\n     if (ser !\u003d null) {\n         return (JsonSerializer\u003cObject\u003e) ser;\n     }\n     JavaType type \u003d modifyTypeByAnnotation(config, beanDesc.getClassInfo(), origType);\n     boolean staticTyping \u003d (type !\u003d origType);\n     if (origType.isContainerType()) {\n         return (JsonSerializer\u003cObject\u003e) buildContainerSerializer(config, type, beanDesc, property, staticTyping);\n     }\n     for (Serializers serializers : _factoryConfig.serializers()) {\n         ser \u003d serializers.findSerializer(config, type, beanDesc, property);\n         if (ser !\u003d null) {\n             return (JsonSerializer\u003cObject\u003e) ser;\n         }\n     }\n     ser \u003d findSerializerByLookup(type, config, beanDesc, property, staticTyping);\n     if (ser \u003d\u003d null) {\n         ser \u003d findSerializerByPrimaryType(type, config, beanDesc, property, staticTyping);\n         if (ser \u003d\u003d null) {\n             ser \u003d findBeanSerializer(config, type, beanDesc, property);\n             if (ser \u003d\u003d null) {\n                 ser \u003d findSerializerByAddonType(config, type, beanDesc, property, staticTyping);\n             }\n         }\n     }\n     return (JsonSerializer\u003cObject\u003e) ser;\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "e4f23bb6779d434d88a7c4335f92d13ea639b373": {
      "type": "Yintroduced",
      "commitMessage": "First check-in, tons of compilation errors to resolve\n",
      "commitDate": "12/23/11, 12:31 AM",
      "commitName": "e4f23bb6779d434d88a7c4335f92d13ea639b373",
      "commitAuthor": "Tatu Saloranta",
      "diff": "@@ -0,0 +1,31 @@\n+@Override\n+@SuppressWarnings(\"unchecked\")\n+public JsonSerializer\u003cObject\u003e createSerializer(SerializationConfig config, JavaType origType, BeanProperty property) throws JsonMappingException {\n+    BasicBeanDescription beanDesc \u003d config.introspect(origType);\n+    JsonSerializer\u003c?\u003e ser \u003d findSerializerFromAnnotation(config, beanDesc.getClassInfo(), property);\n+    if (ser !\u003d null) {\n+        return (JsonSerializer\u003cObject\u003e) ser;\n+    }\n+    JavaType type \u003d modifyTypeByAnnotation(config, beanDesc.getClassInfo(), origType);\n+    boolean staticTyping \u003d (type !\u003d origType);\n+    if (origType.isContainerType()) {\n+        return (JsonSerializer\u003cObject\u003e) buildContainerSerializer(config, type, beanDesc, property, staticTyping);\n+    }\n+    for (Serializers serializers : _factoryConfig.serializers()) {\n+        ser \u003d serializers.findSerializer(config, type, beanDesc, property);\n+        if (ser !\u003d null) {\n+            return (JsonSerializer\u003cObject\u003e) ser;\n+        }\n+    }\n+    ser \u003d findSerializerByLookup(type, config, beanDesc, property, staticTyping);\n+    if (ser \u003d\u003d null) {\n+        ser \u003d findSerializerByPrimaryType(type, config, beanDesc, property, staticTyping);\n+        if (ser \u003d\u003d null) {\n+            ser \u003d findBeanSerializer(config, type, beanDesc, property);\n+            if (ser \u003d\u003d null) {\n+                ser \u003d findSerializerByAddonType(config, type, beanDesc, property, staticTyping);\n+            }\n+        }\n+    }\n+    return (JsonSerializer\u003cObject\u003e) ser;\n+}\n\\ No newline at end of file\n",
      "actualSource": "@Override\n@SuppressWarnings(\"unchecked\")\npublic JsonSerializer\u003cObject\u003e createSerializer(SerializationConfig config, JavaType origType, BeanProperty property) throws JsonMappingException {\n    BasicBeanDescription beanDesc \u003d config.introspect(origType);\n    JsonSerializer\u003c?\u003e ser \u003d findSerializerFromAnnotation(config, beanDesc.getClassInfo(), property);\n    if (ser !\u003d null) {\n        return (JsonSerializer\u003cObject\u003e) ser;\n    }\n    JavaType type \u003d modifyTypeByAnnotation(config, beanDesc.getClassInfo(), origType);\n    boolean staticTyping \u003d (type !\u003d origType);\n    if (origType.isContainerType()) {\n        return (JsonSerializer\u003cObject\u003e) buildContainerSerializer(config, type, beanDesc, property, staticTyping);\n    }\n    for (Serializers serializers : _factoryConfig.serializers()) {\n        ser \u003d serializers.findSerializer(config, type, beanDesc, property);\n        if (ser !\u003d null) {\n            return (JsonSerializer\u003cObject\u003e) ser;\n        }\n    }\n    ser \u003d findSerializerByLookup(type, config, beanDesc, property, staticTyping);\n    if (ser \u003d\u003d null) {\n        ser \u003d findSerializerByPrimaryType(type, config, beanDesc, property, staticTyping);\n        if (ser \u003d\u003d null) {\n            ser \u003d findBeanSerializer(config, type, beanDesc, property);\n            if (ser \u003d\u003d null) {\n                ser \u003d findSerializerByAddonType(config, type, beanDesc, property, staticTyping);\n            }\n        }\n    }\n    return (JsonSerializer\u003cObject\u003e) ser;\n}",
      "path": "src/main/java/com/fasterxml/jackson/databind/ser/BeanSerializerFactory.java",
      "functionStartLine": 247,
      "functionName": "createSerializer",
      "functionAnnotation": "@Override,@SuppressWarnings(\"unchecked\")",
      "functionDoc": "Main serializer constructor method. We will have to be careful\nwith respect to ordering of various method calls: essentially\nwe want to reliably figure out which classes are standard types,\nand which are beans. The problem is that some bean Classes may\nimplement standard interfaces (say, {@link java.lang.Iterable}.\n\u003cp\u003e\nNote: sub-classes may choose to complete replace implementation,\nif they want to alter priority of serializer lookups.\n"
    }
  }
}