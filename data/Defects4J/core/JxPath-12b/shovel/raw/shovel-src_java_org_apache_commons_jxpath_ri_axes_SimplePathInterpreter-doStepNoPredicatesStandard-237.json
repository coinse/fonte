{
  "origin": "codeshovel",
  "repositoryName": "JxPath-12b",
  "repositoryPath": "/tmp/JxPath-12b//.git",
  "startCommitName": "HEAD",
  "sourceFileName": "SimplePathInterpreter.java",
  "functionName": "doStepNoPredicatesStandard",
  "functionId": "doStepNoPredicatesStandard___context-EvalContext__parentPointer-NodePointer__steps-Step[]__currentStep-int",
  "sourceFilePath": "src/java/org/apache/commons/jxpath/ri/axes/SimplePathInterpreter.java",
  "functionAnnotation": "",
  "functionDoc": "A path that starts with a standard InfoSet node (e.g. DOM Node) and\nhas no predicates.  Get a child iterator and apply the tail of\nthe path to each element until we find a match. If we don\u0027t find\na perfect match, we should return the \"best quality\" pointer, which\nhas the longest chain of steps mapping to existing nodes and the shortes\ntail of Null* pointers.\n",
  "functionStartLine": 237,
  "functionEndLine": 271,
  "numCommitsSeen": 30,
  "timeTaken": 1336,
  "changeHistory": [
    "30e4fdde61866403ce8912dfb8afe328502c4d20",
    "b1e1383fd8c33fc246ee253e6a9f7a047d3da38a",
    "2327c42440cd4927ac5fc91ed93756cb0c87c96d",
    "d5a51635e77e49efbf18c5b51834f533e7972953",
    "e6b562c6eca79b82a57a4532768d775d76f48694"
  ],
  "changeHistoryShort": {
    "30e4fdde61866403ce8912dfb8afe328502c4d20": "Ybodychange",
    "b1e1383fd8c33fc246ee253e6a9f7a047d3da38a": "Ybodychange",
    "2327c42440cd4927ac5fc91ed93756cb0c87c96d": "Ymultichange(Yrename,Yparameterchange,Ybodychange)",
    "d5a51635e77e49efbf18c5b51834f533e7972953": "Ybodychange",
    "e6b562c6eca79b82a57a4532768d775d76f48694": "Yintroduced"
  },
  "changeHistoryDetails": {
    "30e4fdde61866403ce8912dfb8afe328502c4d20": {
      "type": "Ybodychange",
      "commitMessage": "bulled through JXPath codebase to get a little better familiarity; tiny refactorings and removals of unnecessary elses, etc. along the way\n\ngit-svn-id: https://svn.apache.org/repos/asf/jakarta/commons/proper/jxpath/trunk@509378 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "2/19/07, 3:24 PM",
      "commitName": "30e4fdde61866403ce8912dfb8afe328502c4d20",
      "commitAuthor": "Matthew Jason Benson",
      "commitDateOld": "11/28/06, 9:37 PM",
      "commitNameOld": "a78dc45a3795e3b9666daed8c13ccc7f4ff48806",
      "commitAuthorOld": "Henri Yandell",
      "daysBetweenCommits": 82.74,
      "commitsBetweenForRepo": 26,
      "commitsBetweenForFile": 1,
      "actualSource": "private static NodePointer doStepNoPredicatesStandard(EvalContext context, NodePointer parentPointer, Step[] steps, int currentStep) {\n    Step step \u003d steps[currentStep];\n    if (step.getAxis() \u003d\u003d Compiler.AXIS_SELF) {\n        return doStep(context, parentPointer, steps, currentStep + 1);\n    }\n    int bestQuality \u003d 0;\n    NodePointer bestMatch \u003d null;\n    NodeIterator it \u003d getNodeIterator(context, parentPointer, step);\n    if (it !\u003d null) {\n        for (int i \u003d 1; it.setPosition(i); i++) {\n            NodePointer childPointer \u003d it.getNodePointer();\n            if (steps.length \u003d\u003d currentStep + 1) {\n                return childPointer;\n            }\n            NodePointer pointer \u003d doStep(context, childPointer, steps, currentStep + 1);\n            int quality \u003d computeQuality(pointer);\n            if (quality \u003d\u003d PERFECT_MATCH) {\n                return pointer;\n            }\n            if (quality \u003e bestQuality) {\n                bestQuality \u003d quality;\n                bestMatch \u003d (NodePointer) pointer.clone();\n            }\n        }\n    }\n    return bestMatch !\u003d null ? bestMatch : createNullPointer(context, parentPointer, steps, currentStep);\n}",
      "path": "src/java/org/apache/commons/jxpath/ri/axes/SimplePathInterpreter.java",
      "functionStartLine": 237,
      "functionName": "doStepNoPredicatesStandard",
      "functionAnnotation": "",
      "functionDoc": "A path that starts with a standard InfoSet node (e.g. DOM Node) and\nhas no predicates.  Get a child iterator and apply the tail of\nthe path to each element until we find a match. If we don\u0027t find\na perfect match, we should return the \"best quality\" pointer, which\nhas the longest chain of steps mapping to existing nodes and the shortes\ntail of Null* pointers.\n",
      "diff": "@@ -1,29 +1,27 @@\n private static NodePointer doStepNoPredicatesStandard(EvalContext context, NodePointer parentPointer, Step[] steps, int currentStep) {\n     Step step \u003d steps[currentStep];\n     if (step.getAxis() \u003d\u003d Compiler.AXIS_SELF) {\n         return doStep(context, parentPointer, steps, currentStep + 1);\n     }\n     int bestQuality \u003d 0;\n     NodePointer bestMatch \u003d null;\n     NodeIterator it \u003d getNodeIterator(context, parentPointer, step);\n     if (it !\u003d null) {\n         for (int i \u003d 1; it.setPosition(i); i++) {\n             NodePointer childPointer \u003d it.getNodePointer();\n             if (steps.length \u003d\u003d currentStep + 1) {\n                 return childPointer;\n             }\n             NodePointer pointer \u003d doStep(context, childPointer, steps, currentStep + 1);\n             int quality \u003d computeQuality(pointer);\n             if (quality \u003d\u003d PERFECT_MATCH) {\n                 return pointer;\n-            } else if (quality \u003e bestQuality) {\n+            }\n+            if (quality \u003e bestQuality) {\n                 bestQuality \u003d quality;\n                 bestMatch \u003d (NodePointer) pointer.clone();\n             }\n         }\n     }\n-    if (bestMatch !\u003d null) {\n-        return bestMatch;\n-    }\n-    return createNullPointer(context, parentPointer, steps, currentStep);\n+    return bestMatch !\u003d null ? bestMatch : createNullPointer(context, parentPointer, steps, currentStep);\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "b1e1383fd8c33fc246ee253e6a9f7a047d3da38a": {
      "type": "Ybodychange",
      "commitMessage": "Introduced prefix registration with JXPathContext\nFixed a number or problems with namespace matching\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/jakarta/commons/proper/jxpath/trunk@136904 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "3/31/04, 6:55 PM",
      "commitName": "b1e1383fd8c33fc246ee253e6a9f7a047d3da38a",
      "commitAuthor": "Dmitri Plotnikov",
      "commitDateOld": "3/24/04, 7:49 PM",
      "commitNameOld": "a0849ed9a4368948696a472afb57ba6938007e88",
      "commitAuthorOld": "Dmitri Plotnikov",
      "daysBetweenCommits": 6.96,
      "commitsBetweenForRepo": 4,
      "commitsBetweenForFile": 1,
      "actualSource": "private static NodePointer doStepNoPredicatesStandard(EvalContext context, NodePointer parentPointer, Step[] steps, int currentStep) {\n    Step step \u003d steps[currentStep];\n    if (step.getAxis() \u003d\u003d Compiler.AXIS_SELF) {\n        return doStep(context, parentPointer, steps, currentStep + 1);\n    }\n    int bestQuality \u003d 0;\n    NodePointer bestMatch \u003d null;\n    NodeIterator it \u003d getNodeIterator(context, parentPointer, step);\n    if (it !\u003d null) {\n        for (int i \u003d 1; it.setPosition(i); i++) {\n            NodePointer childPointer \u003d it.getNodePointer();\n            if (steps.length \u003d\u003d currentStep + 1) {\n                return childPointer;\n            }\n            NodePointer pointer \u003d doStep(context, childPointer, steps, currentStep + 1);\n            int quality \u003d computeQuality(pointer);\n            if (quality \u003d\u003d PERFECT_MATCH) {\n                return pointer;\n            } else if (quality \u003e bestQuality) {\n                bestQuality \u003d quality;\n                bestMatch \u003d (NodePointer) pointer.clone();\n            }\n        }\n    }\n    if (bestMatch !\u003d null) {\n        return bestMatch;\n    }\n    return createNullPointer(context, parentPointer, steps, currentStep);\n}",
      "path": "src/java/org/apache/commons/jxpath/ri/axes/SimplePathInterpreter.java",
      "functionStartLine": 244,
      "functionName": "doStepNoPredicatesStandard",
      "functionAnnotation": "",
      "functionDoc": "A path that starts with a standard InfoSet node (e.g. DOM Node) and\nhas no predicates.  Get a child iterator and apply the tail of\nthe path to each element until we find a match. If we don\u0027t find\na perfect match, we should return the \"best quality\" pointer, which\nhas the longest chain of steps mapping to existing nodes and the shortes\ntail of Null* pointers.\n",
      "diff": "@@ -1,29 +1,29 @@\n private static NodePointer doStepNoPredicatesStandard(EvalContext context, NodePointer parentPointer, Step[] steps, int currentStep) {\n     Step step \u003d steps[currentStep];\n     if (step.getAxis() \u003d\u003d Compiler.AXIS_SELF) {\n         return doStep(context, parentPointer, steps, currentStep + 1);\n     }\n     int bestQuality \u003d 0;\n     NodePointer bestMatch \u003d null;\n-    NodeIterator it \u003d getNodeIterator(parentPointer, step);\n+    NodeIterator it \u003d getNodeIterator(context, parentPointer, step);\n     if (it !\u003d null) {\n         for (int i \u003d 1; it.setPosition(i); i++) {\n             NodePointer childPointer \u003d it.getNodePointer();\n             if (steps.length \u003d\u003d currentStep + 1) {\n                 return childPointer;\n             }\n             NodePointer pointer \u003d doStep(context, childPointer, steps, currentStep + 1);\n             int quality \u003d computeQuality(pointer);\n             if (quality \u003d\u003d PERFECT_MATCH) {\n                 return pointer;\n             } else if (quality \u003e bestQuality) {\n                 bestQuality \u003d quality;\n                 bestMatch \u003d (NodePointer) pointer.clone();\n             }\n         }\n     }\n     if (bestMatch !\u003d null) {\n         return bestMatch;\n     }\n     return createNullPointer(context, parentPointer, steps, currentStep);\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "2327c42440cd4927ac5fc91ed93756cb0c87c96d": {
      "type": "Ymultichange(Yrename,Yparameterchange,Ybodychange)",
      "commitMessage": "Checkstyle, be happy!\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/jakarta/commons/proper/jxpath/trunk@136834 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "1/10/03, 9:41 PM",
      "commitName": "2327c42440cd4927ac5fc91ed93756cb0c87c96d",
      "commitAuthor": "Dmitri Plotnikov",
      "subchanges": [
        {
          "type": "Yrename",
          "commitMessage": "Checkstyle, be happy!\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/jakarta/commons/proper/jxpath/trunk@136834 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "1/10/03, 9:41 PM",
          "commitName": "2327c42440cd4927ac5fc91ed93756cb0c87c96d",
          "commitAuthor": "Dmitri Plotnikov",
          "commitDateOld": "11/25/02, 5:20 PM",
          "commitNameOld": "430fdd01e75a5e681274aa65adeb2d9826ee45a8",
          "commitAuthorOld": "Dmitri Plotnikov",
          "daysBetweenCommits": 46.18,
          "commitsBetweenForRepo": 8,
          "commitsBetweenForFile": 1,
          "actualSource": "private static NodePointer doStepNoPredicatesStandard(EvalContext context, NodePointer parentPointer, Step[] steps, int currentStep) {\n    Step step \u003d steps[currentStep];\n    if (step.getAxis() \u003d\u003d Compiler.AXIS_SELF) {\n        return doStep(context, parentPointer, steps, currentStep + 1);\n    }\n    int bestQuality \u003d 0;\n    NodePointer bestMatch \u003d null;\n    NodeIterator it \u003d getNodeIterator(parentPointer, step);\n    if (it !\u003d null) {\n        for (int i \u003d 1; it.setPosition(i); i++) {\n            NodePointer childPointer \u003d it.getNodePointer();\n            if (steps.length \u003d\u003d currentStep + 1) {\n                return childPointer;\n            }\n            NodePointer pointer \u003d doStep(context, childPointer, steps, currentStep + 1);\n            int quality \u003d computeQuality(pointer);\n            if (quality \u003d\u003d PERFECT_MATCH) {\n                return pointer;\n            } else if (quality \u003e bestQuality) {\n                bestQuality \u003d quality;\n                bestMatch \u003d (NodePointer) pointer.clone();\n            }\n        }\n    }\n    if (bestMatch !\u003d null) {\n        return bestMatch;\n    }\n    return createNullPointer(context, parentPointer, steps, currentStep);\n}",
          "path": "src/java/org/apache/commons/jxpath/ri/axes/SimplePathInterpreter.java",
          "functionStartLine": 288,
          "functionName": "doStepNoPredicatesStandard",
          "functionAnnotation": "",
          "functionDoc": "A path that starts with a standard InfoSet node (e.g. DOM Node) and\nhas no predicates.  Get a child iterator and apply the tail of\nthe path to each element until we find a match. If we don\u0027t find\na perfect match, we should return the \"best quality\" pointer, which\nhas the longest chain of steps mapping to existing nodes and the shortes\ntail of Null* pointers.\n",
          "diff": "@@ -1,29 +1,29 @@\n-private static NodePointer doStep_noPredicates_standard(EvalContext context, NodePointer parentPointer, Step[] steps, int current_step) {\n-    Step step \u003d steps[current_step];\n+private static NodePointer doStepNoPredicatesStandard(EvalContext context, NodePointer parentPointer, Step[] steps, int currentStep) {\n+    Step step \u003d steps[currentStep];\n     if (step.getAxis() \u003d\u003d Compiler.AXIS_SELF) {\n-        return doStep(context, parentPointer, steps, current_step + 1);\n+        return doStep(context, parentPointer, steps, currentStep + 1);\n     }\n     int bestQuality \u003d 0;\n     NodePointer bestMatch \u003d null;\n     NodeIterator it \u003d getNodeIterator(parentPointer, step);\n     if (it !\u003d null) {\n         for (int i \u003d 1; it.setPosition(i); i++) {\n             NodePointer childPointer \u003d it.getNodePointer();\n-            if (steps.length \u003d\u003d current_step + 1) {\n+            if (steps.length \u003d\u003d currentStep + 1) {\n                 return childPointer;\n             }\n-            NodePointer pointer \u003d doStep(context, childPointer, steps, current_step + 1);\n+            NodePointer pointer \u003d doStep(context, childPointer, steps, currentStep + 1);\n             int quality \u003d computeQuality(pointer);\n             if (quality \u003d\u003d PERFECT_MATCH) {\n                 return pointer;\n             } else if (quality \u003e bestQuality) {\n                 bestQuality \u003d quality;\n                 bestMatch \u003d (NodePointer) pointer.clone();\n             }\n         }\n     }\n     if (bestMatch !\u003d null) {\n         return bestMatch;\n     }\n-    return createNullPointer(context, parentPointer, steps, current_step);\n+    return createNullPointer(context, parentPointer, steps, currentStep);\n }\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldValue": "doStep_noPredicates_standard",
            "newValue": "doStepNoPredicatesStandard"
          }
        },
        {
          "type": "Yparameterchange",
          "commitMessage": "Checkstyle, be happy!\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/jakarta/commons/proper/jxpath/trunk@136834 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "1/10/03, 9:41 PM",
          "commitName": "2327c42440cd4927ac5fc91ed93756cb0c87c96d",
          "commitAuthor": "Dmitri Plotnikov",
          "commitDateOld": "11/25/02, 5:20 PM",
          "commitNameOld": "430fdd01e75a5e681274aa65adeb2d9826ee45a8",
          "commitAuthorOld": "Dmitri Plotnikov",
          "daysBetweenCommits": 46.18,
          "commitsBetweenForRepo": 8,
          "commitsBetweenForFile": 1,
          "actualSource": "private static NodePointer doStepNoPredicatesStandard(EvalContext context, NodePointer parentPointer, Step[] steps, int currentStep) {\n    Step step \u003d steps[currentStep];\n    if (step.getAxis() \u003d\u003d Compiler.AXIS_SELF) {\n        return doStep(context, parentPointer, steps, currentStep + 1);\n    }\n    int bestQuality \u003d 0;\n    NodePointer bestMatch \u003d null;\n    NodeIterator it \u003d getNodeIterator(parentPointer, step);\n    if (it !\u003d null) {\n        for (int i \u003d 1; it.setPosition(i); i++) {\n            NodePointer childPointer \u003d it.getNodePointer();\n            if (steps.length \u003d\u003d currentStep + 1) {\n                return childPointer;\n            }\n            NodePointer pointer \u003d doStep(context, childPointer, steps, currentStep + 1);\n            int quality \u003d computeQuality(pointer);\n            if (quality \u003d\u003d PERFECT_MATCH) {\n                return pointer;\n            } else if (quality \u003e bestQuality) {\n                bestQuality \u003d quality;\n                bestMatch \u003d (NodePointer) pointer.clone();\n            }\n        }\n    }\n    if (bestMatch !\u003d null) {\n        return bestMatch;\n    }\n    return createNullPointer(context, parentPointer, steps, currentStep);\n}",
          "path": "src/java/org/apache/commons/jxpath/ri/axes/SimplePathInterpreter.java",
          "functionStartLine": 288,
          "functionName": "doStepNoPredicatesStandard",
          "functionAnnotation": "",
          "functionDoc": "A path that starts with a standard InfoSet node (e.g. DOM Node) and\nhas no predicates.  Get a child iterator and apply the tail of\nthe path to each element until we find a match. If we don\u0027t find\na perfect match, we should return the \"best quality\" pointer, which\nhas the longest chain of steps mapping to existing nodes and the shortes\ntail of Null* pointers.\n",
          "diff": "@@ -1,29 +1,29 @@\n-private static NodePointer doStep_noPredicates_standard(EvalContext context, NodePointer parentPointer, Step[] steps, int current_step) {\n-    Step step \u003d steps[current_step];\n+private static NodePointer doStepNoPredicatesStandard(EvalContext context, NodePointer parentPointer, Step[] steps, int currentStep) {\n+    Step step \u003d steps[currentStep];\n     if (step.getAxis() \u003d\u003d Compiler.AXIS_SELF) {\n-        return doStep(context, parentPointer, steps, current_step + 1);\n+        return doStep(context, parentPointer, steps, currentStep + 1);\n     }\n     int bestQuality \u003d 0;\n     NodePointer bestMatch \u003d null;\n     NodeIterator it \u003d getNodeIterator(parentPointer, step);\n     if (it !\u003d null) {\n         for (int i \u003d 1; it.setPosition(i); i++) {\n             NodePointer childPointer \u003d it.getNodePointer();\n-            if (steps.length \u003d\u003d current_step + 1) {\n+            if (steps.length \u003d\u003d currentStep + 1) {\n                 return childPointer;\n             }\n-            NodePointer pointer \u003d doStep(context, childPointer, steps, current_step + 1);\n+            NodePointer pointer \u003d doStep(context, childPointer, steps, currentStep + 1);\n             int quality \u003d computeQuality(pointer);\n             if (quality \u003d\u003d PERFECT_MATCH) {\n                 return pointer;\n             } else if (quality \u003e bestQuality) {\n                 bestQuality \u003d quality;\n                 bestMatch \u003d (NodePointer) pointer.clone();\n             }\n         }\n     }\n     if (bestMatch !\u003d null) {\n         return bestMatch;\n     }\n-    return createNullPointer(context, parentPointer, steps, current_step);\n+    return createNullPointer(context, parentPointer, steps, currentStep);\n }\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldValue": "[context-EvalContext, parentPointer-NodePointer, steps-Step[], current_step-int]",
            "newValue": "[context-EvalContext, parentPointer-NodePointer, steps-Step[], currentStep-int]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "Checkstyle, be happy!\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/jakarta/commons/proper/jxpath/trunk@136834 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "1/10/03, 9:41 PM",
          "commitName": "2327c42440cd4927ac5fc91ed93756cb0c87c96d",
          "commitAuthor": "Dmitri Plotnikov",
          "commitDateOld": "11/25/02, 5:20 PM",
          "commitNameOld": "430fdd01e75a5e681274aa65adeb2d9826ee45a8",
          "commitAuthorOld": "Dmitri Plotnikov",
          "daysBetweenCommits": 46.18,
          "commitsBetweenForRepo": 8,
          "commitsBetweenForFile": 1,
          "actualSource": "private static NodePointer doStepNoPredicatesStandard(EvalContext context, NodePointer parentPointer, Step[] steps, int currentStep) {\n    Step step \u003d steps[currentStep];\n    if (step.getAxis() \u003d\u003d Compiler.AXIS_SELF) {\n        return doStep(context, parentPointer, steps, currentStep + 1);\n    }\n    int bestQuality \u003d 0;\n    NodePointer bestMatch \u003d null;\n    NodeIterator it \u003d getNodeIterator(parentPointer, step);\n    if (it !\u003d null) {\n        for (int i \u003d 1; it.setPosition(i); i++) {\n            NodePointer childPointer \u003d it.getNodePointer();\n            if (steps.length \u003d\u003d currentStep + 1) {\n                return childPointer;\n            }\n            NodePointer pointer \u003d doStep(context, childPointer, steps, currentStep + 1);\n            int quality \u003d computeQuality(pointer);\n            if (quality \u003d\u003d PERFECT_MATCH) {\n                return pointer;\n            } else if (quality \u003e bestQuality) {\n                bestQuality \u003d quality;\n                bestMatch \u003d (NodePointer) pointer.clone();\n            }\n        }\n    }\n    if (bestMatch !\u003d null) {\n        return bestMatch;\n    }\n    return createNullPointer(context, parentPointer, steps, currentStep);\n}",
          "path": "src/java/org/apache/commons/jxpath/ri/axes/SimplePathInterpreter.java",
          "functionStartLine": 288,
          "functionName": "doStepNoPredicatesStandard",
          "functionAnnotation": "",
          "functionDoc": "A path that starts with a standard InfoSet node (e.g. DOM Node) and\nhas no predicates.  Get a child iterator and apply the tail of\nthe path to each element until we find a match. If we don\u0027t find\na perfect match, we should return the \"best quality\" pointer, which\nhas the longest chain of steps mapping to existing nodes and the shortes\ntail of Null* pointers.\n",
          "diff": "@@ -1,29 +1,29 @@\n-private static NodePointer doStep_noPredicates_standard(EvalContext context, NodePointer parentPointer, Step[] steps, int current_step) {\n-    Step step \u003d steps[current_step];\n+private static NodePointer doStepNoPredicatesStandard(EvalContext context, NodePointer parentPointer, Step[] steps, int currentStep) {\n+    Step step \u003d steps[currentStep];\n     if (step.getAxis() \u003d\u003d Compiler.AXIS_SELF) {\n-        return doStep(context, parentPointer, steps, current_step + 1);\n+        return doStep(context, parentPointer, steps, currentStep + 1);\n     }\n     int bestQuality \u003d 0;\n     NodePointer bestMatch \u003d null;\n     NodeIterator it \u003d getNodeIterator(parentPointer, step);\n     if (it !\u003d null) {\n         for (int i \u003d 1; it.setPosition(i); i++) {\n             NodePointer childPointer \u003d it.getNodePointer();\n-            if (steps.length \u003d\u003d current_step + 1) {\n+            if (steps.length \u003d\u003d currentStep + 1) {\n                 return childPointer;\n             }\n-            NodePointer pointer \u003d doStep(context, childPointer, steps, current_step + 1);\n+            NodePointer pointer \u003d doStep(context, childPointer, steps, currentStep + 1);\n             int quality \u003d computeQuality(pointer);\n             if (quality \u003d\u003d PERFECT_MATCH) {\n                 return pointer;\n             } else if (quality \u003e bestQuality) {\n                 bestQuality \u003d quality;\n                 bestMatch \u003d (NodePointer) pointer.clone();\n             }\n         }\n     }\n     if (bestMatch !\u003d null) {\n         return bestMatch;\n     }\n-    return createNullPointer(context, parentPointer, steps, current_step);\n+    return createNullPointer(context, parentPointer, steps, currentStep);\n }\n\\ No newline at end of file\n",
          "extendedDetails": {}
        }
      ]
    },
    "d5a51635e77e49efbf18c5b51834f533e7972953": {
      "type": "Ybodychange",
      "commitMessage": "1. Now bean\u0027s properties can be accessed either with the child:: or the attribute:: axis.\n2. Missing attributes can be created with an AbstractFactory\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/jakarta/commons/proper/jxpath/trunk@136812 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "10/12/02, 7:59 PM",
      "commitName": "d5a51635e77e49efbf18c5b51834f533e7972953",
      "commitAuthor": "Dmitri Plotnikov",
      "commitDateOld": "8/9/02, 6:35 PM",
      "commitNameOld": "e6b562c6eca79b82a57a4532768d775d76f48694",
      "commitAuthorOld": "Dmitri Plotnikov",
      "daysBetweenCommits": 64.06,
      "commitsBetweenForRepo": 22,
      "commitsBetweenForFile": 1,
      "actualSource": "private static NodePointer doStep_noPredicates_standard(EvalContext context, NodePointer parentPointer, Step[] steps, int current_step) {\n    Step step \u003d steps[current_step];\n    if (step.getAxis() \u003d\u003d Compiler.AXIS_SELF) {\n        return doStep(context, parentPointer, steps, current_step + 1);\n    }\n    int bestQuality \u003d 0;\n    NodePointer bestMatch \u003d null;\n    NodeIterator it \u003d getNodeIterator(parentPointer, step);\n    if (it !\u003d null) {\n        for (int i \u003d 1; it.setPosition(i); i++) {\n            NodePointer childPointer \u003d it.getNodePointer();\n            if (steps.length \u003d\u003d current_step + 1) {\n                return childPointer;\n            }\n            NodePointer pointer \u003d doStep(context, childPointer, steps, current_step + 1);\n            int quality \u003d computeQuality(pointer);\n            if (quality \u003d\u003d PERFECT_MATCH) {\n                return pointer;\n            } else if (quality \u003e bestQuality) {\n                bestQuality \u003d quality;\n                bestMatch \u003d (NodePointer) pointer.clone();\n            }\n        }\n    }\n    if (bestMatch !\u003d null) {\n        return bestMatch;\n    }\n    return createNullPointer(context, parentPointer, steps, current_step);\n}",
      "path": "src/java/org/apache/commons/jxpath/ri/axes/SimplePathInterpreter.java",
      "functionStartLine": 260,
      "functionName": "doStep_noPredicates_standard",
      "functionAnnotation": "",
      "functionDoc": "A path that starts with a standard InfoSet node (e.g. DOM Node) and\nhas no predicates.  Get a child iterator and apply the tail of\nthe path to each element until we find a match. If we don\u0027t find\na perfect match, we should return the \"best quality\" pointer, which\nhas the longest chain of steps mapping to existing nodes and the shortes\ntail of Null* pointers.\n",
      "diff": "@@ -1,26 +1,29 @@\n private static NodePointer doStep_noPredicates_standard(EvalContext context, NodePointer parentPointer, Step[] steps, int current_step) {\n     Step step \u003d steps[current_step];\n+    if (step.getAxis() \u003d\u003d Compiler.AXIS_SELF) {\n+        return doStep(context, parentPointer, steps, current_step + 1);\n+    }\n     int bestQuality \u003d 0;\n     NodePointer bestMatch \u003d null;\n-    NodeIterator it \u003d parentPointer.childIterator(step.getNodeTest(), false, null);\n+    NodeIterator it \u003d getNodeIterator(parentPointer, step);\n     if (it !\u003d null) {\n         for (int i \u003d 1; it.setPosition(i); i++) {\n             NodePointer childPointer \u003d it.getNodePointer();\n             if (steps.length \u003d\u003d current_step + 1) {\n                 return childPointer;\n             }\n             NodePointer pointer \u003d doStep(context, childPointer, steps, current_step + 1);\n             int quality \u003d computeQuality(pointer);\n             if (quality \u003d\u003d PERFECT_MATCH) {\n                 return pointer;\n             } else if (quality \u003e bestQuality) {\n                 bestQuality \u003d quality;\n                 bestMatch \u003d (NodePointer) pointer.clone();\n             }\n         }\n     }\n     if (bestMatch !\u003d null) {\n         return bestMatch;\n     }\n     return createNullPointer(context, parentPointer, steps, current_step);\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "e6b562c6eca79b82a57a4532768d775d76f48694": {
      "type": "Yintroduced",
      "commitMessage": "A complete re-write to address multiple additional use cases\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/jakarta/commons/proper/jxpath/trunk@136790 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "8/9/02, 6:35 PM",
      "commitName": "e6b562c6eca79b82a57a4532768d775d76f48694",
      "commitAuthor": "Dmitri Plotnikov",
      "diff": "@@ -0,0 +1,26 @@\n+private static NodePointer doStep_noPredicates_standard(EvalContext context, NodePointer parentPointer, Step[] steps, int current_step) {\n+    Step step \u003d steps[current_step];\n+    int bestQuality \u003d 0;\n+    NodePointer bestMatch \u003d null;\n+    NodeIterator it \u003d parentPointer.childIterator(step.getNodeTest(), false, null);\n+    if (it !\u003d null) {\n+        for (int i \u003d 1; it.setPosition(i); i++) {\n+            NodePointer childPointer \u003d it.getNodePointer();\n+            if (steps.length \u003d\u003d current_step + 1) {\n+                return childPointer;\n+            }\n+            NodePointer pointer \u003d doStep(context, childPointer, steps, current_step + 1);\n+            int quality \u003d computeQuality(pointer);\n+            if (quality \u003d\u003d PERFECT_MATCH) {\n+                return pointer;\n+            } else if (quality \u003e bestQuality) {\n+                bestQuality \u003d quality;\n+                bestMatch \u003d (NodePointer) pointer.clone();\n+            }\n+        }\n+    }\n+    if (bestMatch !\u003d null) {\n+        return bestMatch;\n+    }\n+    return createNullPointer(context, parentPointer, steps, current_step);\n+}\n\\ No newline at end of file\n",
      "actualSource": "private static NodePointer doStep_noPredicates_standard(EvalContext context, NodePointer parentPointer, Step[] steps, int current_step) {\n    Step step \u003d steps[current_step];\n    int bestQuality \u003d 0;\n    NodePointer bestMatch \u003d null;\n    NodeIterator it \u003d parentPointer.childIterator(step.getNodeTest(), false, null);\n    if (it !\u003d null) {\n        for (int i \u003d 1; it.setPosition(i); i++) {\n            NodePointer childPointer \u003d it.getNodePointer();\n            if (steps.length \u003d\u003d current_step + 1) {\n                return childPointer;\n            }\n            NodePointer pointer \u003d doStep(context, childPointer, steps, current_step + 1);\n            int quality \u003d computeQuality(pointer);\n            if (quality \u003d\u003d PERFECT_MATCH) {\n                return pointer;\n            } else if (quality \u003e bestQuality) {\n                bestQuality \u003d quality;\n                bestMatch \u003d (NodePointer) pointer.clone();\n            }\n        }\n    }\n    if (bestMatch !\u003d null) {\n        return bestMatch;\n    }\n    return createNullPointer(context, parentPointer, steps, current_step);\n}",
      "path": "src/java/org/apache/commons/jxpath/ri/axes/SimplePathInterpreter.java",
      "functionStartLine": 270,
      "functionName": "doStep_noPredicates_standard",
      "functionAnnotation": "",
      "functionDoc": "A path that starts with a standard InfoSet node (e.g. DOM Node) and\nhas no predicates.  Get a child iterator and apply the tail of\nthe path to each element until we find a match. If we don\u0027t find\na perfect match, we should return the \"best quality\" pointer, which\nhas the longest chain of steps mapping to existing nodes and the shortes\ntail of Null* pointers.\n"
    }
  }
}