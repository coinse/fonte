{
  "origin": "codeshovel",
  "repositoryName": "JxPath-21b",
  "repositoryPath": "/tmp/JxPath-21b//.git",
  "startCommitName": "HEAD",
  "sourceFileName": "ExpressionPath.java",
  "functionName": "expressionPath",
  "functionId": "expressionPath___evalContext-EvalContext__firstMatch-boolean",
  "sourceFilePath": "src/java/org/apache/commons/jxpath/ri/compiler/ExpressionPath.java",
  "functionAnnotation": "",
  "functionDoc": "Walks an expression path (a path that starts with an expression)\n\n@param evalContext base context\n@param firstMatch whether to return the first match found\n@return Object found\n",
  "functionStartLine": 149,
  "functionEndLine": 195,
  "numCommitsSeen": 39,
  "timeTaken": 2190,
  "changeHistory": [
    "00d67383c2e842626710831782f7ec768d1ddc1c",
    "21f932ed07fe75a5ca053ee1418b2db6cb99dc05",
    "4218f8bb9c6947e58ed8d2df53e927f81517b310",
    "30e4fdde61866403ce8912dfb8afe328502c4d20",
    "301243c9ea777977c3c37172b746d3a65b8ad949",
    "77af585d9f0e629db4ecf8d468ef7b71c9d98e39",
    "2327c42440cd4927ac5fc91ed93756cb0c87c96d",
    "a3e590e95b0200e58068cab4b1ea91c5313d46ee",
    "323e8b214459b3977973c01a048a979dc778f100",
    "112774edae824e6e07ed9d64f637b4b7c19cea3b",
    "b8780b1aa2eff978c3612fa43b58efb5b9ca50a0",
    "989fbe2e44ad4e994dc810fa54290636a7339712",
    "a6e246c774fb91eefeadf28c46a10e768ac8cc7b",
    "34b7a47ae949c763178a457582a5df2cb564f53d",
    "bc53a66311b9b22e471dd74860c7df75eebe9837"
  ],
  "changeHistoryShort": {
    "00d67383c2e842626710831782f7ec768d1ddc1c": "Ydocchange",
    "21f932ed07fe75a5ca053ee1418b2db6cb99dc05": "Yformatchange",
    "4218f8bb9c6947e58ed8d2df53e927f81517b310": "Ybodychange",
    "30e4fdde61866403ce8912dfb8afe328502c4d20": "Ybodychange",
    "301243c9ea777977c3c37172b746d3a65b8ad949": "Ybodychange",
    "77af585d9f0e629db4ecf8d468ef7b71c9d98e39": "Ybodychange",
    "2327c42440cd4927ac5fc91ed93756cb0c87c96d": "Ybodychange",
    "a3e590e95b0200e58068cab4b1ea91c5313d46ee": "Ybodychange",
    "323e8b214459b3977973c01a048a979dc778f100": "Ymultichange(Ymovefromfile,Ybodychange,Yparameterchange)",
    "112774edae824e6e07ed9d64f637b4b7c19cea3b": "Ybodychange",
    "b8780b1aa2eff978c3612fa43b58efb5b9ca50a0": "Ybodychange",
    "989fbe2e44ad4e994dc810fa54290636a7339712": "Ybodychange",
    "a6e246c774fb91eefeadf28c46a10e768ac8cc7b": "Ybodychange",
    "34b7a47ae949c763178a457582a5df2cb564f53d": "Ymultichange(Yparameterchange,Ybodychange)",
    "bc53a66311b9b22e471dd74860c7df75eebe9837": "Yintroduced"
  },
  "changeHistoryDetails": {
    "00d67383c2e842626710831782f7ec768d1ddc1c": {
      "type": "Ydocchange",
      "commitMessage": "checkstyle\n\ngit-svn-id: https://svn.apache.org/repos/asf/commons/proper/jxpath/trunk@618149 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "2/3/08, 6:04 PM",
      "commitName": "00d67383c2e842626710831782f7ec768d1ddc1c",
      "commitAuthor": "Matthew Jason Benson",
      "commitDateOld": "12/16/07, 11:29 PM",
      "commitNameOld": "21f932ed07fe75a5ca053ee1418b2db6cb99dc05",
      "commitAuthorOld": "Matthew Jason Benson",
      "daysBetweenCommits": 48.77,
      "commitsBetweenForRepo": 25,
      "commitsBetweenForFile": 1,
      "actualSource": "protected Object expressionPath(EvalContext evalContext, boolean firstMatch) {\n    Object value \u003d expression.compute(evalContext);\n    EvalContext context;\n    if (value instanceof InitialContext) {\n        context \u003d (InitialContext) value;\n    } else if (value instanceof EvalContext) {\n        context \u003d new UnionContext(evalContext, new EvalContext[] { (EvalContext) value });\n    } else {\n        context \u003d evalContext.getRootContext().getConstantContext(value);\n    }\n    if (firstMatch \u0026\u0026 isSimpleExpressionPath() \u0026\u0026 !(context instanceof NodeSetContext)) {\n        EvalContext ctx \u003d context;\n        NodePointer ptr \u003d (NodePointer) ctx.getSingleNodePointer();\n        if (ptr !\u003d null \u0026\u0026 (ptr.getIndex() \u003d\u003d NodePointer.WHOLE_COLLECTION || predicates \u003d\u003d null || predicates.length \u003d\u003d 0)) {\n            return SimplePathInterpreter.interpretSimpleExpressionPath(evalContext, ptr, predicates, getSteps());\n        }\n    }\n    if (predicates !\u003d null) {\n        for (int j \u003d 0; j \u003c predicates.length; j++) {\n            if (j !\u003d 0) {\n                context \u003d new UnionContext(context, new EvalContext[] { context });\n            }\n            context \u003d new PredicateContext(context, predicates[j]);\n        }\n    }\n    return firstMatch ? (Object) getSingleNodePointerForSteps(context) : evalSteps(context);\n}",
      "path": "src/java/org/apache/commons/jxpath/ri/compiler/ExpressionPath.java",
      "functionStartLine": 158,
      "functionName": "expressionPath",
      "functionAnnotation": "",
      "functionDoc": "Walks an expression path (a path that starts with an expression)\n\n@param evalContext base context\n@param firstMatch whether to return the first match found\n@return Object found\n",
      "diff": "",
      "extendedDetails": {
        "oldValue": "Walks an expression path (a path that starts with an expression)\n",
        "newValue": "Walks an expression path (a path that starts with an expression)\n\n@param evalContext base context\n@param firstMatch whether to return the first match found\n@return Object found\n"
      }
    },
    "21f932ed07fe75a5ca053ee1418b2db6cb99dc05": {
      "type": "Yformatchange",
      "commitMessage": "checkstyle\n\ngit-svn-id: https://svn.apache.org/repos/asf/commons/proper/jxpath/trunk@604783 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "12/16/07, 11:29 PM",
      "commitName": "21f932ed07fe75a5ca053ee1418b2db6cb99dc05",
      "commitAuthor": "Matthew Jason Benson",
      "commitDateOld": "2/27/07, 7:35 AM",
      "commitNameOld": "4218f8bb9c6947e58ed8d2df53e927f81517b310",
      "commitAuthorOld": "Matthew Jason Benson",
      "daysBetweenCommits": 292.66,
      "commitsBetweenForRepo": 111,
      "commitsBetweenForFile": 1,
      "actualSource": "protected Object expressionPath(EvalContext evalContext, boolean firstMatch) {\n    Object value \u003d expression.compute(evalContext);\n    EvalContext context;\n    if (value instanceof InitialContext) {\n        context \u003d (InitialContext) value;\n    } else if (value instanceof EvalContext) {\n        context \u003d new UnionContext(evalContext, new EvalContext[] { (EvalContext) value });\n    } else {\n        context \u003d evalContext.getRootContext().getConstantContext(value);\n    }\n    if (firstMatch \u0026\u0026 isSimpleExpressionPath() \u0026\u0026 !(context instanceof NodeSetContext)) {\n        EvalContext ctx \u003d context;\n        NodePointer ptr \u003d (NodePointer) ctx.getSingleNodePointer();\n        if (ptr !\u003d null \u0026\u0026 (ptr.getIndex() \u003d\u003d NodePointer.WHOLE_COLLECTION || predicates \u003d\u003d null || predicates.length \u003d\u003d 0)) {\n            return SimplePathInterpreter.interpretSimpleExpressionPath(evalContext, ptr, predicates, getSteps());\n        }\n    }\n    if (predicates !\u003d null) {\n        for (int j \u003d 0; j \u003c predicates.length; j++) {\n            if (j !\u003d 0) {\n                context \u003d new UnionContext(context, new EvalContext[] { context });\n            }\n            context \u003d new PredicateContext(context, predicates[j]);\n        }\n    }\n    return firstMatch ? (Object) getSingleNodePointerForSteps(context) : evalSteps(context);\n}",
      "path": "src/java/org/apache/commons/jxpath/ri/compiler/ExpressionPath.java",
      "functionStartLine": 136,
      "functionName": "expressionPath",
      "functionAnnotation": "",
      "functionDoc": "Walks an expression path (a path that starts with an expression)\n",
      "diff": "",
      "extendedDetails": {}
    },
    "4218f8bb9c6947e58ed8d2df53e927f81517b310": {
      "type": "Ybodychange",
      "commitMessage": "fix broken nightlies that compile fine on JDK 5 but not below due to my excessive fascination with the ternary operator. :|\n\ngit-svn-id: https://svn.apache.org/repos/asf/jakarta/commons/proper/jxpath/trunk@512283 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "2/27/07, 7:35 AM",
      "commitName": "4218f8bb9c6947e58ed8d2df53e927f81517b310",
      "commitAuthor": "Matthew Jason Benson",
      "commitDateOld": "2/19/07, 3:24 PM",
      "commitNameOld": "30e4fdde61866403ce8912dfb8afe328502c4d20",
      "commitAuthorOld": "Matthew Jason Benson",
      "daysBetweenCommits": 7.67,
      "commitsBetweenForRepo": 3,
      "commitsBetweenForFile": 1,
      "actualSource": "protected Object expressionPath(EvalContext evalContext, boolean firstMatch) {\n    Object value \u003d expression.compute(evalContext);\n    EvalContext context;\n    if (value instanceof InitialContext) {\n        context \u003d (InitialContext) value;\n    } else if (value instanceof EvalContext) {\n        context \u003d new UnionContext(evalContext, new EvalContext[] { (EvalContext) value });\n    } else {\n        context \u003d evalContext.getRootContext().getConstantContext(value);\n    }\n    if (firstMatch \u0026\u0026 isSimpleExpressionPath() \u0026\u0026 !(context instanceof NodeSetContext)) {\n        EvalContext ctx \u003d context;\n        NodePointer ptr \u003d (NodePointer) ctx.getSingleNodePointer();\n        if (ptr !\u003d null \u0026\u0026 (ptr.getIndex() \u003d\u003d NodePointer.WHOLE_COLLECTION || predicates \u003d\u003d null || predicates.length \u003d\u003d 0)) {\n            return SimplePathInterpreter.interpretSimpleExpressionPath(evalContext, ptr, predicates, getSteps());\n        }\n    }\n    if (predicates !\u003d null) {\n        for (int j \u003d 0; j \u003c predicates.length; j++) {\n            if (j !\u003d 0) {\n                context \u003d new UnionContext(context, new EvalContext[] { context });\n            }\n            context \u003d new PredicateContext(context, predicates[j]);\n        }\n    }\n    return firstMatch ? (Object) getSingleNodePointerForSteps(context) : evalSteps(context);\n}",
      "path": "src/java/org/apache/commons/jxpath/ri/compiler/ExpressionPath.java",
      "functionStartLine": 136,
      "functionName": "expressionPath",
      "functionAnnotation": "",
      "functionDoc": "Walks an expression path (a path that starts with an expression)\n",
      "diff": "@@ -1,27 +1,27 @@\n protected Object expressionPath(EvalContext evalContext, boolean firstMatch) {\n     Object value \u003d expression.compute(evalContext);\n     EvalContext context;\n     if (value instanceof InitialContext) {\n         context \u003d (InitialContext) value;\n     } else if (value instanceof EvalContext) {\n         context \u003d new UnionContext(evalContext, new EvalContext[] { (EvalContext) value });\n     } else {\n         context \u003d evalContext.getRootContext().getConstantContext(value);\n     }\n     if (firstMatch \u0026\u0026 isSimpleExpressionPath() \u0026\u0026 !(context instanceof NodeSetContext)) {\n         EvalContext ctx \u003d context;\n         NodePointer ptr \u003d (NodePointer) ctx.getSingleNodePointer();\n         if (ptr !\u003d null \u0026\u0026 (ptr.getIndex() \u003d\u003d NodePointer.WHOLE_COLLECTION || predicates \u003d\u003d null || predicates.length \u003d\u003d 0)) {\n             return SimplePathInterpreter.interpretSimpleExpressionPath(evalContext, ptr, predicates, getSteps());\n         }\n     }\n     if (predicates !\u003d null) {\n         for (int j \u003d 0; j \u003c predicates.length; j++) {\n             if (j !\u003d 0) {\n                 context \u003d new UnionContext(context, new EvalContext[] { context });\n             }\n             context \u003d new PredicateContext(context, predicates[j]);\n         }\n     }\n-    return firstMatch ? getSingleNodePointerForSteps(context) : evalSteps(context);\n+    return firstMatch ? (Object) getSingleNodePointerForSteps(context) : evalSteps(context);\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "30e4fdde61866403ce8912dfb8afe328502c4d20": {
      "type": "Ybodychange",
      "commitMessage": "bulled through JXPath codebase to get a little better familiarity; tiny refactorings and removals of unnecessary elses, etc. along the way\n\ngit-svn-id: https://svn.apache.org/repos/asf/jakarta/commons/proper/jxpath/trunk@509378 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "2/19/07, 3:24 PM",
      "commitName": "30e4fdde61866403ce8912dfb8afe328502c4d20",
      "commitAuthor": "Matthew Jason Benson",
      "commitDateOld": "1/31/07, 9:24 AM",
      "commitNameOld": "ce272ae94782474f58d0c18e0f1a8c9a7a8dda42",
      "commitAuthorOld": "Matthew Jason Benson",
      "daysBetweenCommits": 19.25,
      "commitsBetweenForRepo": 3,
      "commitsBetweenForFile": 1,
      "actualSource": "protected Object expressionPath(EvalContext evalContext, boolean firstMatch) {\n    Object value \u003d expression.compute(evalContext);\n    EvalContext context;\n    if (value instanceof InitialContext) {\n        context \u003d (InitialContext) value;\n    } else if (value instanceof EvalContext) {\n        context \u003d new UnionContext(evalContext, new EvalContext[] { (EvalContext) value });\n    } else {\n        context \u003d evalContext.getRootContext().getConstantContext(value);\n    }\n    if (firstMatch \u0026\u0026 isSimpleExpressionPath() \u0026\u0026 !(context instanceof NodeSetContext)) {\n        EvalContext ctx \u003d context;\n        NodePointer ptr \u003d (NodePointer) ctx.getSingleNodePointer();\n        if (ptr !\u003d null \u0026\u0026 (ptr.getIndex() \u003d\u003d NodePointer.WHOLE_COLLECTION || predicates \u003d\u003d null || predicates.length \u003d\u003d 0)) {\n            return SimplePathInterpreter.interpretSimpleExpressionPath(evalContext, ptr, predicates, getSteps());\n        }\n    }\n    if (predicates !\u003d null) {\n        for (int j \u003d 0; j \u003c predicates.length; j++) {\n            if (j !\u003d 0) {\n                context \u003d new UnionContext(context, new EvalContext[] { context });\n            }\n            context \u003d new PredicateContext(context, predicates[j]);\n        }\n    }\n    return firstMatch ? getSingleNodePointerForSteps(context) : evalSteps(context);\n}",
      "path": "src/java/org/apache/commons/jxpath/ri/compiler/ExpressionPath.java",
      "functionStartLine": 136,
      "functionName": "expressionPath",
      "functionAnnotation": "",
      "functionDoc": "Walks an expression path (a path that starts with an expression)\n",
      "diff": "@@ -1,31 +1,27 @@\n protected Object expressionPath(EvalContext evalContext, boolean firstMatch) {\n     Object value \u003d expression.compute(evalContext);\n     EvalContext context;\n     if (value instanceof InitialContext) {\n         context \u003d (InitialContext) value;\n     } else if (value instanceof EvalContext) {\n         context \u003d new UnionContext(evalContext, new EvalContext[] { (EvalContext) value });\n     } else {\n         context \u003d evalContext.getRootContext().getConstantContext(value);\n     }\n     if (firstMatch \u0026\u0026 isSimpleExpressionPath() \u0026\u0026 !(context instanceof NodeSetContext)) {\n         EvalContext ctx \u003d context;\n         NodePointer ptr \u003d (NodePointer) ctx.getSingleNodePointer();\n         if (ptr !\u003d null \u0026\u0026 (ptr.getIndex() \u003d\u003d NodePointer.WHOLE_COLLECTION || predicates \u003d\u003d null || predicates.length \u003d\u003d 0)) {\n             return SimplePathInterpreter.interpretSimpleExpressionPath(evalContext, ptr, predicates, getSteps());\n         }\n     }\n     if (predicates !\u003d null) {\n         for (int j \u003d 0; j \u003c predicates.length; j++) {\n             if (j !\u003d 0) {\n                 context \u003d new UnionContext(context, new EvalContext[] { context });\n             }\n             context \u003d new PredicateContext(context, predicates[j]);\n         }\n     }\n-    if (firstMatch) {\n-        return getSingleNodePointerForSteps(context);\n-    } else {\n-        return evalSteps(context);\n-    }\n+    return firstMatch ? getSingleNodePointerForSteps(context) : evalSteps(context);\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "301243c9ea777977c3c37172b746d3a65b8ad949": {
      "type": "Ybodychange",
      "commitMessage": "Corrected behavior of chained predicates.  \nEach predicate is supposed to form its own node set.\n\ngit-svn-id: https://svn.apache.org/repos/asf/jakarta/commons/proper/jxpath/trunk@329513 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "10/29/05, 8:07 PM",
      "commitName": "301243c9ea777977c3c37172b746d3a65b8ad949",
      "commitAuthor": "Dmitri Plotnikov",
      "commitDateOld": "2/26/05, 5:07 AM",
      "commitNameOld": "ecb571fc93e4a7bed9545a295c177d1ab4b1f4bf",
      "commitAuthorOld": "Dirk Verbeeck",
      "daysBetweenCommits": 245.58,
      "commitsBetweenForRepo": 15,
      "commitsBetweenForFile": 1,
      "actualSource": "protected Object expressionPath(EvalContext evalContext, boolean firstMatch) {\n    Object value \u003d expression.compute(evalContext);\n    EvalContext context;\n    if (value instanceof InitialContext) {\n        context \u003d (InitialContext) value;\n    } else if (value instanceof EvalContext) {\n        context \u003d new UnionContext(evalContext, new EvalContext[] { (EvalContext) value });\n    } else {\n        context \u003d evalContext.getRootContext().getConstantContext(value);\n    }\n    if (firstMatch \u0026\u0026 isSimpleExpressionPath() \u0026\u0026 !(context instanceof NodeSetContext)) {\n        EvalContext ctx \u003d context;\n        NodePointer ptr \u003d (NodePointer) ctx.getSingleNodePointer();\n        if (ptr !\u003d null \u0026\u0026 (ptr.getIndex() \u003d\u003d NodePointer.WHOLE_COLLECTION || predicates \u003d\u003d null || predicates.length \u003d\u003d 0)) {\n            return SimplePathInterpreter.interpretSimpleExpressionPath(evalContext, ptr, predicates, getSteps());\n        }\n    }\n    if (predicates !\u003d null) {\n        for (int j \u003d 0; j \u003c predicates.length; j++) {\n            if (j !\u003d 0) {\n                context \u003d new UnionContext(context, new EvalContext[] { context });\n            }\n            context \u003d new PredicateContext(context, predicates[j]);\n        }\n    }\n    if (firstMatch) {\n        return getSingleNodePointerForSteps(context);\n    } else {\n        return evalSteps(context);\n    }\n}",
      "path": "src/java/org/apache/commons/jxpath/ri/compiler/ExpressionPath.java",
      "functionStartLine": 136,
      "functionName": "expressionPath",
      "functionAnnotation": "",
      "functionDoc": "Walks an expression path (a path that starts with an expression)\n",
      "diff": "@@ -1,28 +1,31 @@\n protected Object expressionPath(EvalContext evalContext, boolean firstMatch) {\n     Object value \u003d expression.compute(evalContext);\n     EvalContext context;\n     if (value instanceof InitialContext) {\n         context \u003d (InitialContext) value;\n     } else if (value instanceof EvalContext) {\n         context \u003d new UnionContext(evalContext, new EvalContext[] { (EvalContext) value });\n     } else {\n         context \u003d evalContext.getRootContext().getConstantContext(value);\n     }\n     if (firstMatch \u0026\u0026 isSimpleExpressionPath() \u0026\u0026 !(context instanceof NodeSetContext)) {\n         EvalContext ctx \u003d context;\n         NodePointer ptr \u003d (NodePointer) ctx.getSingleNodePointer();\n         if (ptr !\u003d null \u0026\u0026 (ptr.getIndex() \u003d\u003d NodePointer.WHOLE_COLLECTION || predicates \u003d\u003d null || predicates.length \u003d\u003d 0)) {\n             return SimplePathInterpreter.interpretSimpleExpressionPath(evalContext, ptr, predicates, getSteps());\n         }\n     }\n     if (predicates !\u003d null) {\n         for (int j \u003d 0; j \u003c predicates.length; j++) {\n+            if (j !\u003d 0) {\n+                context \u003d new UnionContext(context, new EvalContext[] { context });\n+            }\n             context \u003d new PredicateContext(context, predicates[j]);\n         }\n     }\n     if (firstMatch) {\n         return getSingleNodePointerForSteps(context);\n     } else {\n         return evalSteps(context);\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "77af585d9f0e629db4ecf8d468ef7b71c9d98e39": {
      "type": "Ybodychange",
      "commitMessage": "Fixed collection as return value of extension function\nReduced the amount of cloning\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/jakarta/commons/proper/jxpath/trunk@136860 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "3/24/03, 6:41 PM",
      "commitName": "77af585d9f0e629db4ecf8d468ef7b71c9d98e39",
      "commitAuthor": "Dmitri Plotnikov",
      "commitDateOld": "3/10/03, 4:59 PM",
      "commitNameOld": "bdf423f27a76d2006ffe1058d6530eebf619c877",
      "commitAuthorOld": "Dmitri Plotnikov",
      "daysBetweenCommits": 14.07,
      "commitsBetweenForRepo": 3,
      "commitsBetweenForFile": 1,
      "actualSource": "protected Object expressionPath(EvalContext evalContext, boolean firstMatch) {\n    Object value \u003d expression.compute(evalContext);\n    EvalContext context;\n    if (value instanceof InitialContext) {\n        context \u003d (InitialContext) value;\n    } else if (value instanceof EvalContext) {\n        context \u003d new UnionContext(evalContext, new EvalContext[] { (EvalContext) value });\n    } else {\n        context \u003d evalContext.getRootContext().getConstantContext(value);\n    }\n    if (firstMatch \u0026\u0026 isSimpleExpressionPath() \u0026\u0026 !(context instanceof NodeSetContext)) {\n        EvalContext ctx \u003d context;\n        NodePointer ptr \u003d (NodePointer) ctx.getSingleNodePointer();\n        if (ptr !\u003d null \u0026\u0026 (ptr.getIndex() \u003d\u003d NodePointer.WHOLE_COLLECTION || predicates \u003d\u003d null || predicates.length \u003d\u003d 0)) {\n            return SimplePathInterpreter.interpretSimpleExpressionPath(evalContext, ptr, predicates, getSteps());\n        }\n    }\n    if (predicates !\u003d null) {\n        for (int j \u003d 0; j \u003c predicates.length; j++) {\n            context \u003d new PredicateContext(context, predicates[j]);\n        }\n    }\n    if (firstMatch) {\n        return getSingleNodePointerForSteps(context);\n    } else {\n        return evalSteps(context);\n    }\n}",
      "path": "src/java/org/apache/commons/jxpath/ri/compiler/ExpressionPath.java",
      "functionStartLine": 181,
      "functionName": "expressionPath",
      "functionAnnotation": "",
      "functionDoc": "Walks an expression path (a path that starts with an expression)\n",
      "diff": "@@ -1,28 +1,28 @@\n protected Object expressionPath(EvalContext evalContext, boolean firstMatch) {\n     Object value \u003d expression.compute(evalContext);\n     EvalContext context;\n     if (value instanceof InitialContext) {\n         context \u003d (InitialContext) value;\n     } else if (value instanceof EvalContext) {\n         context \u003d new UnionContext(evalContext, new EvalContext[] { (EvalContext) value });\n     } else {\n         context \u003d evalContext.getRootContext().getConstantContext(value);\n     }\n-    if (firstMatch \u0026\u0026 isSimpleExpressionPath() \u0026\u0026 !(context instanceof UnionContext)) {\n+    if (firstMatch \u0026\u0026 isSimpleExpressionPath() \u0026\u0026 !(context instanceof NodeSetContext)) {\n         EvalContext ctx \u003d context;\n         NodePointer ptr \u003d (NodePointer) ctx.getSingleNodePointer();\n         if (ptr !\u003d null \u0026\u0026 (ptr.getIndex() \u003d\u003d NodePointer.WHOLE_COLLECTION || predicates \u003d\u003d null || predicates.length \u003d\u003d 0)) {\n             return SimplePathInterpreter.interpretSimpleExpressionPath(evalContext, ptr, predicates, getSteps());\n         }\n     }\n     if (predicates !\u003d null) {\n         for (int j \u003d 0; j \u003c predicates.length; j++) {\n             context \u003d new PredicateContext(context, predicates[j]);\n         }\n     }\n     if (firstMatch) {\n         return getSingleNodePointerForSteps(context);\n     } else {\n         return evalSteps(context);\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "2327c42440cd4927ac5fc91ed93756cb0c87c96d": {
      "type": "Ybodychange",
      "commitMessage": "Checkstyle, be happy!\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/jakarta/commons/proper/jxpath/trunk@136834 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "1/10/03, 9:41 PM",
      "commitName": "2327c42440cd4927ac5fc91ed93756cb0c87c96d",
      "commitAuthor": "Dmitri Plotnikov",
      "commitDateOld": "8/9/02, 6:39 PM",
      "commitNameOld": "a3e590e95b0200e58068cab4b1ea91c5313d46ee",
      "commitAuthorOld": "Dmitri Plotnikov",
      "daysBetweenCommits": 154.17,
      "commitsBetweenForRepo": 42,
      "commitsBetweenForFile": 1,
      "actualSource": "protected Object expressionPath(EvalContext evalContext, boolean firstMatch) {\n    Object value \u003d expression.compute(evalContext);\n    EvalContext context;\n    if (value instanceof InitialContext) {\n        context \u003d (InitialContext) value;\n    } else if (value instanceof EvalContext) {\n        context \u003d new UnionContext(evalContext, new EvalContext[] { (EvalContext) value });\n    } else {\n        context \u003d evalContext.getRootContext().getConstantContext(value);\n    }\n    if (firstMatch \u0026\u0026 isSimpleExpressionPath() \u0026\u0026 !(context instanceof UnionContext)) {\n        EvalContext ctx \u003d context;\n        NodePointer ptr \u003d (NodePointer) ctx.getSingleNodePointer();\n        if (ptr !\u003d null \u0026\u0026 (ptr.getIndex() \u003d\u003d NodePointer.WHOLE_COLLECTION || predicates \u003d\u003d null || predicates.length \u003d\u003d 0)) {\n            return SimplePathInterpreter.interpretSimpleExpressionPath(evalContext, ptr, predicates, getSteps());\n        }\n    }\n    if (predicates !\u003d null) {\n        for (int j \u003d 0; j \u003c predicates.length; j++) {\n            context \u003d new PredicateContext(context, predicates[j]);\n        }\n    }\n    if (firstMatch) {\n        return getSingleNodePointerForSteps(context);\n    } else {\n        return evalSteps(context);\n    }\n}",
      "path": "src/java/org/apache/commons/jxpath/ri/compiler/ExpressionPath.java",
      "functionStartLine": 178,
      "functionName": "expressionPath",
      "functionAnnotation": "",
      "functionDoc": "Walks an expression path (a path that starts with an expression)\n",
      "diff": "",
      "extendedDetails": {}
    },
    "a3e590e95b0200e58068cab4b1ea91c5313d46ee": {
      "type": "Ybodychange",
      "commitMessage": "Changed to new SimplePathInterpreter APIs\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/jakarta/commons/proper/jxpath/trunk@136792 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "8/9/02, 6:39 PM",
      "commitName": "a3e590e95b0200e58068cab4b1ea91c5313d46ee",
      "commitAuthor": "Dmitri Plotnikov",
      "commitDateOld": "5/7/02, 5:40 PM",
      "commitNameOld": "323e8b214459b3977973c01a048a979dc778f100",
      "commitAuthorOld": "Dmitri Plotnikov",
      "daysBetweenCommits": 94.04,
      "commitsBetweenForRepo": 47,
      "commitsBetweenForFile": 1,
      "actualSource": "protected Object expressionPath(EvalContext evalContext, boolean firstMatch) {\n    Object value \u003d expression.compute(evalContext);\n    EvalContext context;\n    if (value instanceof InitialContext) {\n        context \u003d (InitialContext) value;\n    } else if (value instanceof EvalContext) {\n        context \u003d new UnionContext(evalContext, new EvalContext[] { (EvalContext) value });\n    } else {\n        context \u003d evalContext.getRootContext().getConstantContext(value);\n    }\n    if (firstMatch \u0026\u0026 isSimpleExpressionPath() \u0026\u0026 !(context instanceof UnionContext)) {\n        EvalContext ctx \u003d context;\n        NodePointer ptr \u003d (NodePointer) ctx.getSingleNodePointer();\n        if (ptr !\u003d null \u0026\u0026 (ptr.getIndex() \u003d\u003d NodePointer.WHOLE_COLLECTION || predicates \u003d\u003d null || predicates.length \u003d\u003d 0)) {\n            return SimplePathInterpreter.interpretSimpleExpressionPath(evalContext, ptr, predicates, getSteps());\n        }\n    }\n    if (predicates !\u003d null) {\n        for (int j \u003d 0; j \u003c predicates.length; j++) {\n            context \u003d new PredicateContext(context, predicates[j]);\n        }\n    }\n    if (firstMatch) {\n        return getSingleNodePointerForSteps(context);\n    } else {\n        return evalSteps(context);\n    }\n}",
      "path": "src/java/org/apache/commons/jxpath/ri/compiler/ExpressionPath.java",
      "functionStartLine": 170,
      "functionName": "expressionPath",
      "functionAnnotation": "",
      "functionDoc": "Walks an expression path (a path that starts with an expression)\n",
      "diff": "@@ -1,29 +1,28 @@\n protected Object expressionPath(EvalContext evalContext, boolean firstMatch) {\n     Object value \u003d expression.compute(evalContext);\n     EvalContext context;\n     if (value instanceof InitialContext) {\n         context \u003d (InitialContext) value;\n     } else if (value instanceof EvalContext) {\n         context \u003d new UnionContext(evalContext, new EvalContext[] { (EvalContext) value });\n     } else {\n         context \u003d evalContext.getRootContext().getConstantContext(value);\n     }\n     if (firstMatch \u0026\u0026 isSimpleExpressionPath() \u0026\u0026 !(context instanceof UnionContext)) {\n         EvalContext ctx \u003d context;\n         NodePointer ptr \u003d (NodePointer) ctx.getSingleNodePointer();\n         if (ptr !\u003d null \u0026\u0026 (ptr.getIndex() \u003d\u003d NodePointer.WHOLE_COLLECTION || predicates \u003d\u003d null || predicates.length \u003d\u003d 0)) {\n-            NodePointer pointer \u003d SimplePathInterpreter.interpretPredicates(evalContext, ptr, predicates);\n-            return SimplePathInterpreter.interpretPath(evalContext, pointer, getSteps());\n+            return SimplePathInterpreter.interpretSimpleExpressionPath(evalContext, ptr, predicates, getSteps());\n         }\n     }\n     if (predicates !\u003d null) {\n         for (int j \u003d 0; j \u003c predicates.length; j++) {\n             context \u003d new PredicateContext(context, predicates[j]);\n         }\n     }\n     if (firstMatch) {\n         return getSingleNodePointerForSteps(context);\n     } else {\n         return evalSteps(context);\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "323e8b214459b3977973c01a048a979dc778f100": {
      "type": "Ymultichange(Ymovefromfile,Ybodychange,Yparameterchange)",
      "commitMessage": "Refactoring\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/jakarta/commons/proper/jxpath/trunk@136743 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "5/7/02, 5:40 PM",
      "commitName": "323e8b214459b3977973c01a048a979dc778f100",
      "commitAuthor": "Dmitri Plotnikov",
      "subchanges": [
        {
          "type": "Ymovefromfile",
          "commitMessage": "Refactoring\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/jakarta/commons/proper/jxpath/trunk@136743 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "5/7/02, 5:40 PM",
          "commitName": "323e8b214459b3977973c01a048a979dc778f100",
          "commitAuthor": "Dmitri Plotnikov",
          "commitDateOld": "5/7/02, 5:39 PM",
          "commitNameOld": "c6d36b46057b4d441556e6275bcd7d13d242fa02",
          "commitAuthorOld": "Dmitri Plotnikov",
          "daysBetweenCommits": 0.0,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "actualSource": "protected Object expressionPath(EvalContext evalContext, boolean firstMatch) {\n    Object value \u003d expression.compute(evalContext);\n    EvalContext context;\n    if (value instanceof InitialContext) {\n        context \u003d (InitialContext) value;\n    } else if (value instanceof EvalContext) {\n        context \u003d new UnionContext(evalContext, new EvalContext[] { (EvalContext) value });\n    } else {\n        context \u003d evalContext.getRootContext().getConstantContext(value);\n    }\n    if (firstMatch \u0026\u0026 isSimpleExpressionPath() \u0026\u0026 !(context instanceof UnionContext)) {\n        EvalContext ctx \u003d context;\n        NodePointer ptr \u003d (NodePointer) ctx.getSingleNodePointer();\n        if (ptr !\u003d null \u0026\u0026 (ptr.getIndex() \u003d\u003d NodePointer.WHOLE_COLLECTION || predicates \u003d\u003d null || predicates.length \u003d\u003d 0)) {\n            NodePointer pointer \u003d SimplePathInterpreter.interpretPredicates(evalContext, ptr, predicates);\n            return SimplePathInterpreter.interpretPath(evalContext, pointer, getSteps());\n        }\n    }\n    if (predicates !\u003d null) {\n        for (int j \u003d 0; j \u003c predicates.length; j++) {\n            context \u003d new PredicateContext(context, predicates[j]);\n        }\n    }\n    if (firstMatch) {\n        return getSingleNodePointerForSteps(context);\n    } else {\n        return evalSteps(context);\n    }\n}",
          "path": "src/java/org/apache/commons/jxpath/ri/compiler/ExpressionPath.java",
          "functionStartLine": 172,
          "functionName": "expressionPath",
          "functionAnnotation": "",
          "functionDoc": "Walks an expression path (a path that starts with an expression)\n",
          "diff": "@@ -1,31 +1,29 @@\n-protected Object expressionPath(ExpressionPath path, boolean firstMatch) {\n-    Expression expression \u003d path.getExpression();\n-    Object value \u003d eval(expression, false);\n+protected Object expressionPath(EvalContext evalContext, boolean firstMatch) {\n+    Object value \u003d expression.compute(evalContext);\n     EvalContext context;\n     if (value instanceof InitialContext) {\n         context \u003d (InitialContext) value;\n     } else if (value instanceof EvalContext) {\n-        context \u003d new UnionContext(this, new EvalContext[] { (EvalContext) value });\n+        context \u003d new UnionContext(evalContext, new EvalContext[] { (EvalContext) value });\n     } else {\n-        context \u003d getRootContext().getConstantContext(value);\n+        context \u003d evalContext.getRootContext().getConstantContext(value);\n     }\n-    Expression[] predicates \u003d path.getPredicates();\n-    if (firstMatch \u0026\u0026 path.getEvaluationHint(ExpressionPath.BASIC_PREDICATES_HINT).equals(Boolean.TRUE) \u0026\u0026 !(context instanceof UnionContext)) {\n+    if (firstMatch \u0026\u0026 isSimpleExpressionPath() \u0026\u0026 !(context instanceof UnionContext)) {\n         EvalContext ctx \u003d context;\n         NodePointer ptr \u003d (NodePointer) ctx.getSingleNodePointer();\n         if (ptr !\u003d null \u0026\u0026 (ptr.getIndex() \u003d\u003d NodePointer.WHOLE_COLLECTION || predicates \u003d\u003d null || predicates.length \u003d\u003d 0)) {\n-            NodePointer pointer \u003d SimplePathInterpreter.interpretPredicates(this, ptr, predicates);\n-            return SimplePathInterpreter.interpretPath(this, pointer, path.getSteps());\n+            NodePointer pointer \u003d SimplePathInterpreter.interpretPredicates(evalContext, ptr, predicates);\n+            return SimplePathInterpreter.interpretPath(evalContext, pointer, getSteps());\n         }\n     }\n     if (predicates !\u003d null) {\n         for (int j \u003d 0; j \u003c predicates.length; j++) {\n             context \u003d new PredicateContext(context, predicates[j]);\n         }\n     }\n     if (firstMatch) {\n-        return getSingleNodePointerForSteps(context, path);\n+        return getSingleNodePointerForSteps(context);\n     } else {\n-        return evalSteps(context, path);\n+        return evalSteps(context);\n     }\n }\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldPath": "src/java/org/apache/commons/jxpath/ri/EvalContext.java",
            "newPath": "src/java/org/apache/commons/jxpath/ri/compiler/ExpressionPath.java",
            "oldMethodName": "expressionPath",
            "newMethodName": "expressionPath"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "Refactoring\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/jakarta/commons/proper/jxpath/trunk@136743 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "5/7/02, 5:40 PM",
          "commitName": "323e8b214459b3977973c01a048a979dc778f100",
          "commitAuthor": "Dmitri Plotnikov",
          "commitDateOld": "5/7/02, 5:39 PM",
          "commitNameOld": "c6d36b46057b4d441556e6275bcd7d13d242fa02",
          "commitAuthorOld": "Dmitri Plotnikov",
          "daysBetweenCommits": 0.0,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "actualSource": "protected Object expressionPath(EvalContext evalContext, boolean firstMatch) {\n    Object value \u003d expression.compute(evalContext);\n    EvalContext context;\n    if (value instanceof InitialContext) {\n        context \u003d (InitialContext) value;\n    } else if (value instanceof EvalContext) {\n        context \u003d new UnionContext(evalContext, new EvalContext[] { (EvalContext) value });\n    } else {\n        context \u003d evalContext.getRootContext().getConstantContext(value);\n    }\n    if (firstMatch \u0026\u0026 isSimpleExpressionPath() \u0026\u0026 !(context instanceof UnionContext)) {\n        EvalContext ctx \u003d context;\n        NodePointer ptr \u003d (NodePointer) ctx.getSingleNodePointer();\n        if (ptr !\u003d null \u0026\u0026 (ptr.getIndex() \u003d\u003d NodePointer.WHOLE_COLLECTION || predicates \u003d\u003d null || predicates.length \u003d\u003d 0)) {\n            NodePointer pointer \u003d SimplePathInterpreter.interpretPredicates(evalContext, ptr, predicates);\n            return SimplePathInterpreter.interpretPath(evalContext, pointer, getSteps());\n        }\n    }\n    if (predicates !\u003d null) {\n        for (int j \u003d 0; j \u003c predicates.length; j++) {\n            context \u003d new PredicateContext(context, predicates[j]);\n        }\n    }\n    if (firstMatch) {\n        return getSingleNodePointerForSteps(context);\n    } else {\n        return evalSteps(context);\n    }\n}",
          "path": "src/java/org/apache/commons/jxpath/ri/compiler/ExpressionPath.java",
          "functionStartLine": 172,
          "functionName": "expressionPath",
          "functionAnnotation": "",
          "functionDoc": "Walks an expression path (a path that starts with an expression)\n",
          "diff": "@@ -1,31 +1,29 @@\n-protected Object expressionPath(ExpressionPath path, boolean firstMatch) {\n-    Expression expression \u003d path.getExpression();\n-    Object value \u003d eval(expression, false);\n+protected Object expressionPath(EvalContext evalContext, boolean firstMatch) {\n+    Object value \u003d expression.compute(evalContext);\n     EvalContext context;\n     if (value instanceof InitialContext) {\n         context \u003d (InitialContext) value;\n     } else if (value instanceof EvalContext) {\n-        context \u003d new UnionContext(this, new EvalContext[] { (EvalContext) value });\n+        context \u003d new UnionContext(evalContext, new EvalContext[] { (EvalContext) value });\n     } else {\n-        context \u003d getRootContext().getConstantContext(value);\n+        context \u003d evalContext.getRootContext().getConstantContext(value);\n     }\n-    Expression[] predicates \u003d path.getPredicates();\n-    if (firstMatch \u0026\u0026 path.getEvaluationHint(ExpressionPath.BASIC_PREDICATES_HINT).equals(Boolean.TRUE) \u0026\u0026 !(context instanceof UnionContext)) {\n+    if (firstMatch \u0026\u0026 isSimpleExpressionPath() \u0026\u0026 !(context instanceof UnionContext)) {\n         EvalContext ctx \u003d context;\n         NodePointer ptr \u003d (NodePointer) ctx.getSingleNodePointer();\n         if (ptr !\u003d null \u0026\u0026 (ptr.getIndex() \u003d\u003d NodePointer.WHOLE_COLLECTION || predicates \u003d\u003d null || predicates.length \u003d\u003d 0)) {\n-            NodePointer pointer \u003d SimplePathInterpreter.interpretPredicates(this, ptr, predicates);\n-            return SimplePathInterpreter.interpretPath(this, pointer, path.getSteps());\n+            NodePointer pointer \u003d SimplePathInterpreter.interpretPredicates(evalContext, ptr, predicates);\n+            return SimplePathInterpreter.interpretPath(evalContext, pointer, getSteps());\n         }\n     }\n     if (predicates !\u003d null) {\n         for (int j \u003d 0; j \u003c predicates.length; j++) {\n             context \u003d new PredicateContext(context, predicates[j]);\n         }\n     }\n     if (firstMatch) {\n-        return getSingleNodePointerForSteps(context, path);\n+        return getSingleNodePointerForSteps(context);\n     } else {\n-        return evalSteps(context, path);\n+        return evalSteps(context);\n     }\n }\n\\ No newline at end of file\n",
          "extendedDetails": {}
        },
        {
          "type": "Yparameterchange",
          "commitMessage": "Refactoring\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/jakarta/commons/proper/jxpath/trunk@136743 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "5/7/02, 5:40 PM",
          "commitName": "323e8b214459b3977973c01a048a979dc778f100",
          "commitAuthor": "Dmitri Plotnikov",
          "commitDateOld": "5/7/02, 5:39 PM",
          "commitNameOld": "c6d36b46057b4d441556e6275bcd7d13d242fa02",
          "commitAuthorOld": "Dmitri Plotnikov",
          "daysBetweenCommits": 0.0,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "actualSource": "protected Object expressionPath(EvalContext evalContext, boolean firstMatch) {\n    Object value \u003d expression.compute(evalContext);\n    EvalContext context;\n    if (value instanceof InitialContext) {\n        context \u003d (InitialContext) value;\n    } else if (value instanceof EvalContext) {\n        context \u003d new UnionContext(evalContext, new EvalContext[] { (EvalContext) value });\n    } else {\n        context \u003d evalContext.getRootContext().getConstantContext(value);\n    }\n    if (firstMatch \u0026\u0026 isSimpleExpressionPath() \u0026\u0026 !(context instanceof UnionContext)) {\n        EvalContext ctx \u003d context;\n        NodePointer ptr \u003d (NodePointer) ctx.getSingleNodePointer();\n        if (ptr !\u003d null \u0026\u0026 (ptr.getIndex() \u003d\u003d NodePointer.WHOLE_COLLECTION || predicates \u003d\u003d null || predicates.length \u003d\u003d 0)) {\n            NodePointer pointer \u003d SimplePathInterpreter.interpretPredicates(evalContext, ptr, predicates);\n            return SimplePathInterpreter.interpretPath(evalContext, pointer, getSteps());\n        }\n    }\n    if (predicates !\u003d null) {\n        for (int j \u003d 0; j \u003c predicates.length; j++) {\n            context \u003d new PredicateContext(context, predicates[j]);\n        }\n    }\n    if (firstMatch) {\n        return getSingleNodePointerForSteps(context);\n    } else {\n        return evalSteps(context);\n    }\n}",
          "path": "src/java/org/apache/commons/jxpath/ri/compiler/ExpressionPath.java",
          "functionStartLine": 172,
          "functionName": "expressionPath",
          "functionAnnotation": "",
          "functionDoc": "Walks an expression path (a path that starts with an expression)\n",
          "diff": "@@ -1,31 +1,29 @@\n-protected Object expressionPath(ExpressionPath path, boolean firstMatch) {\n-    Expression expression \u003d path.getExpression();\n-    Object value \u003d eval(expression, false);\n+protected Object expressionPath(EvalContext evalContext, boolean firstMatch) {\n+    Object value \u003d expression.compute(evalContext);\n     EvalContext context;\n     if (value instanceof InitialContext) {\n         context \u003d (InitialContext) value;\n     } else if (value instanceof EvalContext) {\n-        context \u003d new UnionContext(this, new EvalContext[] { (EvalContext) value });\n+        context \u003d new UnionContext(evalContext, new EvalContext[] { (EvalContext) value });\n     } else {\n-        context \u003d getRootContext().getConstantContext(value);\n+        context \u003d evalContext.getRootContext().getConstantContext(value);\n     }\n-    Expression[] predicates \u003d path.getPredicates();\n-    if (firstMatch \u0026\u0026 path.getEvaluationHint(ExpressionPath.BASIC_PREDICATES_HINT).equals(Boolean.TRUE) \u0026\u0026 !(context instanceof UnionContext)) {\n+    if (firstMatch \u0026\u0026 isSimpleExpressionPath() \u0026\u0026 !(context instanceof UnionContext)) {\n         EvalContext ctx \u003d context;\n         NodePointer ptr \u003d (NodePointer) ctx.getSingleNodePointer();\n         if (ptr !\u003d null \u0026\u0026 (ptr.getIndex() \u003d\u003d NodePointer.WHOLE_COLLECTION || predicates \u003d\u003d null || predicates.length \u003d\u003d 0)) {\n-            NodePointer pointer \u003d SimplePathInterpreter.interpretPredicates(this, ptr, predicates);\n-            return SimplePathInterpreter.interpretPath(this, pointer, path.getSteps());\n+            NodePointer pointer \u003d SimplePathInterpreter.interpretPredicates(evalContext, ptr, predicates);\n+            return SimplePathInterpreter.interpretPath(evalContext, pointer, getSteps());\n         }\n     }\n     if (predicates !\u003d null) {\n         for (int j \u003d 0; j \u003c predicates.length; j++) {\n             context \u003d new PredicateContext(context, predicates[j]);\n         }\n     }\n     if (firstMatch) {\n-        return getSingleNodePointerForSteps(context, path);\n+        return getSingleNodePointerForSteps(context);\n     } else {\n-        return evalSteps(context, path);\n+        return evalSteps(context);\n     }\n }\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldValue": "[path-ExpressionPath, firstMatch-boolean]",
            "newValue": "[evalContext-EvalContext, firstMatch-boolean]"
          }
        }
      ]
    },
    "112774edae824e6e07ed9d64f637b4b7c19cea3b": {
      "type": "Ybodychange",
      "commitMessage": "Now implements Iterator\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/jakarta/commons/proper/jxpath/trunk@136734 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "4/27/02, 9:36 PM",
      "commitName": "112774edae824e6e07ed9d64f637b4b7c19cea3b",
      "commitAuthor": "Dmitri Plotnikov",
      "commitDateOld": "4/25/02, 8:28 PM",
      "commitNameOld": "34d1c6cad33a94c24e55d456b550302db4914130",
      "commitAuthorOld": "Dmitri Plotnikov",
      "daysBetweenCommits": 2.05,
      "commitsBetweenForRepo": 3,
      "commitsBetweenForFile": 1,
      "actualSource": "protected Object expressionPath(ExpressionPath path, boolean firstMatch) {\n    Expression expression \u003d path.getExpression();\n    Object value \u003d eval(expression, false);\n    EvalContext context;\n    if (value instanceof InitialContext) {\n        context \u003d (InitialContext) value;\n    } else if (value instanceof EvalContext) {\n        context \u003d new UnionContext(this, new EvalContext[] { (EvalContext) value });\n    } else {\n        context \u003d getRootContext().getConstantContext(value);\n    }\n    Expression[] predicates \u003d path.getPredicates();\n    if (firstMatch \u0026\u0026 path.getEvaluationHint(ExpressionPath.BASIC_PREDICATES_HINT).equals(Boolean.TRUE) \u0026\u0026 !(context instanceof UnionContext)) {\n        EvalContext ctx \u003d context;\n        NodePointer ptr \u003d (NodePointer) ctx.getSingleNodePointer();\n        if (ptr !\u003d null \u0026\u0026 (ptr.getIndex() \u003d\u003d NodePointer.WHOLE_COLLECTION || predicates \u003d\u003d null || predicates.length \u003d\u003d 0)) {\n            NodePointer pointer \u003d SimplePathInterpreter.interpretPredicates(this, ptr, predicates);\n            return SimplePathInterpreter.interpretPath(this, pointer, path.getSteps());\n        }\n    }\n    if (predicates !\u003d null) {\n        for (int j \u003d 0; j \u003c predicates.length; j++) {\n            context \u003d new PredicateContext(context, predicates[j]);\n        }\n    }\n    if (firstMatch) {\n        return getSingleNodePointerForSteps(context, path);\n    } else {\n        return evalSteps(context, path);\n    }\n}",
      "path": "src/java/org/apache/commons/jxpath/ri/EvalContext.java",
      "functionStartLine": 856,
      "functionName": "expressionPath",
      "functionAnnotation": "",
      "functionDoc": "Walks an expression path (a path that starts with an expression)\n",
      "diff": "@@ -1,27 +1,31 @@\n protected Object expressionPath(ExpressionPath path, boolean firstMatch) {\n     Expression expression \u003d path.getExpression();\n     Object value \u003d eval(expression, false);\n     EvalContext context;\n     if (value instanceof InitialContext) {\n         context \u003d (InitialContext) value;\n     } else if (value instanceof EvalContext) {\n         context \u003d new UnionContext(this, new EvalContext[] { (EvalContext) value });\n     } else {\n         context \u003d getRootContext().getConstantContext(value);\n     }\n     Expression[] predicates \u003d path.getPredicates();\n     if (firstMatch \u0026\u0026 path.getEvaluationHint(ExpressionPath.BASIC_PREDICATES_HINT).equals(Boolean.TRUE) \u0026\u0026 !(context instanceof UnionContext)) {\n         EvalContext ctx \u003d context;\n         NodePointer ptr \u003d (NodePointer) ctx.getSingleNodePointer();\n         if (ptr !\u003d null \u0026\u0026 (ptr.getIndex() \u003d\u003d NodePointer.WHOLE_COLLECTION || predicates \u003d\u003d null || predicates.length \u003d\u003d 0)) {\n             NodePointer pointer \u003d SimplePathInterpreter.interpretPredicates(this, ptr, predicates);\n             return SimplePathInterpreter.interpretPath(this, pointer, path.getSteps());\n         }\n     }\n     if (predicates !\u003d null) {\n         for (int j \u003d 0; j \u003c predicates.length; j++) {\n             context \u003d new PredicateContext(context, predicates[j]);\n         }\n     }\n-    return evalSteps(context, path, firstMatch);\n+    if (firstMatch) {\n+        return getSingleNodePointerForSteps(context, path);\n+    } else {\n+        return evalSteps(context, path);\n+    }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "b8780b1aa2eff978c3612fa43b58efb5b9ca50a0": {
      "type": "Ybodychange",
      "commitMessage": "Added pointer comparison to ensure document order\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/jakarta/commons/proper/jxpath/trunk@136730 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "4/25/02, 6:00 PM",
      "commitName": "b8780b1aa2eff978c3612fa43b58efb5b9ca50a0",
      "commitAuthor": "Dmitri Plotnikov",
      "commitDateOld": "4/23/02, 9:06 PM",
      "commitNameOld": "3b6b30adb846a9f2f0fa070f9c8c848f04d8b37f",
      "commitAuthorOld": "Dmitri Plotnikov",
      "daysBetweenCommits": 1.87,
      "commitsBetweenForRepo": 2,
      "commitsBetweenForFile": 1,
      "actualSource": "protected Object expressionPath(ExpressionPath path, boolean firstMatch) {\n    Expression expression \u003d path.getExpression();\n    Object value \u003d eval(expression, false);\n    EvalContext context;\n    if (value instanceof InitialContext) {\n        context \u003d (InitialContext) value;\n    } else if (value instanceof EvalContext) {\n        context \u003d new UnionContext(this, new EvalContext[] { (EvalContext) value });\n    } else {\n        context \u003d getRootContext().getConstantContext(value);\n    }\n    Expression[] predicates \u003d path.getPredicates();\n    if (firstMatch \u0026\u0026 path.getEvaluationHint(ExpressionPath.BASIC_PREDICATES_HINT).equals(Boolean.TRUE) \u0026\u0026 !(context instanceof UnionContext)) {\n        EvalContext ctx \u003d context;\n        NodePointer ptr \u003d (NodePointer) ctx.getSingleNodePointer();\n        if (ptr !\u003d null \u0026\u0026 (ptr.getIndex() \u003d\u003d NodePointer.WHOLE_COLLECTION || predicates \u003d\u003d null || predicates.length \u003d\u003d 0)) {\n            NodePointer pointer \u003d SimplePathInterpreter.interpretPredicates(this, ptr, predicates);\n            return SimplePathInterpreter.interpretPath(this, pointer, path.getSteps());\n        }\n    }\n    if (predicates !\u003d null) {\n        for (int j \u003d 0; j \u003c predicates.length; j++) {\n            context \u003d new PredicateContext(context, predicates[j]);\n        }\n    }\n    return evalSteps(context, path, firstMatch);\n}",
      "path": "src/java/org/apache/commons/jxpath/ri/EvalContext.java",
      "functionStartLine": 769,
      "functionName": "expressionPath",
      "functionAnnotation": "",
      "functionDoc": "Walks an expression path (a path that starts with an expression)\n",
      "diff": "@@ -1,27 +1,27 @@\n protected Object expressionPath(ExpressionPath path, boolean firstMatch) {\n     Expression expression \u003d path.getExpression();\n     Object value \u003d eval(expression, false);\n     EvalContext context;\n     if (value instanceof InitialContext) {\n         context \u003d (InitialContext) value;\n     } else if (value instanceof EvalContext) {\n         context \u003d new UnionContext(this, new EvalContext[] { (EvalContext) value });\n     } else {\n         context \u003d getRootContext().getConstantContext(value);\n     }\n     Expression[] predicates \u003d path.getPredicates();\n     if (firstMatch \u0026\u0026 path.getEvaluationHint(ExpressionPath.BASIC_PREDICATES_HINT).equals(Boolean.TRUE) \u0026\u0026 !(context instanceof UnionContext)) {\n         EvalContext ctx \u003d context;\n         NodePointer ptr \u003d (NodePointer) ctx.getSingleNodePointer();\n         if (ptr !\u003d null \u0026\u0026 (ptr.getIndex() \u003d\u003d NodePointer.WHOLE_COLLECTION || predicates \u003d\u003d null || predicates.length \u003d\u003d 0)) {\n-            NodePointer pointer \u003d interpretBasicPredicates(ptr, predicates);\n-            return interpretBasicPath(pointer, path.getSteps());\n+            NodePointer pointer \u003d SimplePathInterpreter.interpretPredicates(this, ptr, predicates);\n+            return SimplePathInterpreter.interpretPath(this, pointer, path.getSteps());\n         }\n     }\n     if (predicates !\u003d null) {\n         for (int j \u003d 0; j \u003c predicates.length; j++) {\n             context \u003d new PredicateContext(context, predicates[j]);\n         }\n     }\n     return evalSteps(context, path, firstMatch);\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "989fbe2e44ad4e994dc810fa54290636a7339712": {
      "type": "Ybodychange",
      "commitMessage": "Simplified ExpressionContext implementation\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/jakarta/commons/proper/jxpath/trunk@136727 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "4/23/02, 8:32 PM",
      "commitName": "989fbe2e44ad4e994dc810fa54290636a7339712",
      "commitAuthor": "Dmitri Plotnikov",
      "commitDateOld": "4/21/02, 2:52 PM",
      "commitNameOld": "a6e246c774fb91eefeadf28c46a10e768ac8cc7b",
      "commitAuthorOld": "Dmitri Plotnikov",
      "daysBetweenCommits": 2.24,
      "commitsBetweenForRepo": 6,
      "commitsBetweenForFile": 1,
      "actualSource": "protected Object expressionPath(ExpressionPath path, boolean firstMatch) {\n    Expression expression \u003d path.getExpression();\n    Object value \u003d eval(expression, false);\n    EvalContext context;\n    if (value instanceof InitialContext) {\n        context \u003d (InitialContext) value;\n    } else if (value instanceof EvalContext) {\n        context \u003d new UnionContext(this, new EvalContext[] { (EvalContext) value });\n    } else {\n        context \u003d getRootContext().getConstantContext(value);\n    }\n    Expression[] predicates \u003d path.getPredicates();\n    if (firstMatch \u0026\u0026 path.getEvaluationHint(ExpressionPath.BASIC_PREDICATES_HINT).equals(Boolean.TRUE) \u0026\u0026 !(context instanceof UnionContext)) {\n        EvalContext ctx \u003d context;\n        NodePointer ptr \u003d (NodePointer) ctx.getSingleNodePointer();\n        if (ptr !\u003d null \u0026\u0026 (ptr.getIndex() \u003d\u003d NodePointer.WHOLE_COLLECTION || predicates \u003d\u003d null || predicates.length \u003d\u003d 0)) {\n            NodePointer pointer \u003d interpretBasicPredicates(ptr, predicates);\n            return interpretBasicPath(pointer, path.getSteps());\n        }\n    }\n    if (predicates !\u003d null) {\n        for (int j \u003d 0; j \u003c predicates.length; j++) {\n            context \u003d new PredicateContext(context, predicates[j]);\n        }\n    }\n    return evalSteps(context, path, firstMatch);\n}",
      "path": "src/java/org/apache/commons/jxpath/ri/EvalContext.java",
      "functionStartLine": 937,
      "functionName": "expressionPath",
      "functionAnnotation": "",
      "functionDoc": "Walks an expression path (a path that starts with an expression)\n",
      "diff": "@@ -1,27 +1,27 @@\n protected Object expressionPath(ExpressionPath path, boolean firstMatch) {\n     Expression expression \u003d path.getExpression();\n     Object value \u003d eval(expression, false);\n     EvalContext context;\n     if (value instanceof InitialContext) {\n         context \u003d (InitialContext) value;\n     } else if (value instanceof EvalContext) {\n         context \u003d new UnionContext(this, new EvalContext[] { (EvalContext) value });\n     } else {\n         context \u003d getRootContext().getConstantContext(value);\n     }\n     Expression[] predicates \u003d path.getPredicates();\n     if (firstMatch \u0026\u0026 path.getEvaluationHint(ExpressionPath.BASIC_PREDICATES_HINT).equals(Boolean.TRUE) \u0026\u0026 !(context instanceof UnionContext)) {\n         EvalContext ctx \u003d context;\n-        NodePointer ptr \u003d (NodePointer) ctx.getContextNodePointer();\n+        NodePointer ptr \u003d (NodePointer) ctx.getSingleNodePointer();\n         if (ptr !\u003d null \u0026\u0026 (ptr.getIndex() \u003d\u003d NodePointer.WHOLE_COLLECTION || predicates \u003d\u003d null || predicates.length \u003d\u003d 0)) {\n             NodePointer pointer \u003d interpretBasicPredicates(ptr, predicates);\n             return interpretBasicPath(pointer, path.getSteps());\n         }\n     }\n     if (predicates !\u003d null) {\n         for (int j \u003d 0; j \u003c predicates.length; j++) {\n             context \u003d new PredicateContext(context, predicates[j]);\n         }\n     }\n     return evalSteps(context, path, firstMatch);\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "a6e246c774fb91eefeadf28c46a10e768ac8cc7b": {
      "type": "Ybodychange",
      "commitMessage": "Major refactoring\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/jakarta/commons/proper/jxpath/trunk@136721 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "4/21/02, 2:52 PM",
      "commitName": "a6e246c774fb91eefeadf28c46a10e768ac8cc7b",
      "commitAuthor": "Dmitri Plotnikov",
      "commitDateOld": "4/11/02, 7:28 PM",
      "commitNameOld": "65bf4da7590edc460ec68e18f35d201ec685bf86",
      "commitAuthorOld": "Dmitri Plotnikov",
      "daysBetweenCommits": 9.81,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "protected Object expressionPath(ExpressionPath path, boolean firstMatch) {\n    Expression expression \u003d path.getExpression();\n    Object value \u003d eval(expression, false);\n    EvalContext context;\n    if (value instanceof InitialContext) {\n        context \u003d (InitialContext) value;\n    } else if (value instanceof EvalContext) {\n        context \u003d new UnionContext(this, new EvalContext[] { (EvalContext) value });\n    } else {\n        context \u003d getRootContext().getConstantContext(value);\n    }\n    Expression[] predicates \u003d path.getPredicates();\n    if (firstMatch \u0026\u0026 path.getEvaluationHint(ExpressionPath.BASIC_PREDICATES_HINT).equals(Boolean.TRUE) \u0026\u0026 !(context instanceof UnionContext)) {\n        EvalContext ctx \u003d context;\n        NodePointer ptr \u003d (NodePointer) ctx.getContextNodePointer();\n        if (ptr !\u003d null \u0026\u0026 (ptr.getIndex() \u003d\u003d NodePointer.WHOLE_COLLECTION || predicates \u003d\u003d null || predicates.length \u003d\u003d 0)) {\n            NodePointer pointer \u003d interpretBasicPredicates(ptr, predicates);\n            return interpretBasicPath(pointer, path.getSteps());\n        }\n    }\n    if (predicates !\u003d null) {\n        for (int j \u003d 0; j \u003c predicates.length; j++) {\n            context \u003d new PredicateContext(context, predicates[j]);\n        }\n    }\n    return evalSteps(context, path, firstMatch);\n}",
      "path": "src/java/org/apache/commons/jxpath/ri/EvalContext.java",
      "functionStartLine": 964,
      "functionName": "expressionPath",
      "functionAnnotation": "",
      "functionDoc": "Walks an expression path (a path that starts with an expression)\n",
      "diff": "@@ -1,34 +1,27 @@\n protected Object expressionPath(ExpressionPath path, boolean firstMatch) {\n     Expression expression \u003d path.getExpression();\n     Object value \u003d eval(expression, false);\n     EvalContext context;\n     if (value instanceof InitialContext) {\n         context \u003d (InitialContext) value;\n     } else if (value instanceof EvalContext) {\n         context \u003d new UnionContext(this, new EvalContext[] { (EvalContext) value });\n     } else {\n         context \u003d getRootContext().getConstantContext(value);\n     }\n     Expression[] predicates \u003d path.getPredicates();\n-    if (firstMatch) {\n-        if (path.getEvaluationHint(ExpressionPath.BASIC_PREDICATES_HINT).equals(Boolean.TRUE)) {\n-            EvalContext ctx \u003d new InitialContext(context);\n-            NodePointer ptr \u003d (NodePointer) ctx.getContextNodePointer();\n-            if (ptr !\u003d null \u0026\u0026 (ptr.getIndex() \u003d\u003d NodePointer.WHOLE_COLLECTION || predicates \u003d\u003d null || predicates.length \u003d\u003d 0)) {\n-                NodePointer pointer \u003d processBasicPredicates(ptr, predicates);\n-                if (pointer !\u003d null) {\n-                    Object result \u003d tryBasicPath(pointer, path.getSteps());\n-                    if (result !\u003d FAILURE) {\n-                        return result;\n-                    }\n-                }\n-            }\n+    if (firstMatch \u0026\u0026 path.getEvaluationHint(ExpressionPath.BASIC_PREDICATES_HINT).equals(Boolean.TRUE) \u0026\u0026 !(context instanceof UnionContext)) {\n+        EvalContext ctx \u003d context;\n+        NodePointer ptr \u003d (NodePointer) ctx.getContextNodePointer();\n+        if (ptr !\u003d null \u0026\u0026 (ptr.getIndex() \u003d\u003d NodePointer.WHOLE_COLLECTION || predicates \u003d\u003d null || predicates.length \u003d\u003d 0)) {\n+            NodePointer pointer \u003d interpretBasicPredicates(ptr, predicates);\n+            return interpretBasicPath(pointer, path.getSteps());\n         }\n     }\n     if (predicates !\u003d null) {\n         for (int j \u003d 0; j \u003c predicates.length; j++) {\n             context \u003d new PredicateContext(context, predicates[j]);\n         }\n     }\n     return evalSteps(context, path, firstMatch);\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "34b7a47ae949c763178a457582a5df2cb564f53d": {
      "type": "Ymultichange(Yparameterchange,Ybodychange)",
      "commitMessage": "Multiple changes\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/jakarta/commons/proper/jxpath/trunk@136712 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "4/9/02, 8:40 PM",
      "commitName": "34b7a47ae949c763178a457582a5df2cb564f53d",
      "commitAuthor": "Dmitri Plotnikov",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "Multiple changes\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/jakarta/commons/proper/jxpath/trunk@136712 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "4/9/02, 8:40 PM",
          "commitName": "34b7a47ae949c763178a457582a5df2cb564f53d",
          "commitAuthor": "Dmitri Plotnikov",
          "commitDateOld": "9/26/01, 4:37 PM",
          "commitNameOld": "d0a64d141367867db5b745734f5c7330644b71ca",
          "commitAuthorOld": "Dmitri Plotnikov",
          "daysBetweenCommits": 195.17,
          "commitsBetweenForRepo": 2,
          "commitsBetweenForFile": 1,
          "actualSource": "protected Object expressionPath(ExpressionPath path, boolean firstMatch) {\n    Expression expression \u003d path.getExpression();\n    Object value \u003d eval(expression, false);\n    EvalContext context;\n    if (value instanceof InitialContext) {\n        context \u003d (InitialContext) value;\n    } else if (value instanceof EvalContext) {\n        context \u003d new UnionContext(this, new EvalContext[] { (EvalContext) value });\n    } else {\n        context \u003d getRootContext().getConstantContext(value);\n    }\n    Expression[] predicates \u003d path.getPredicates();\n    if (firstMatch) {\n        if (path.getEvaluationHint(ExpressionPath.BASIC_PREDICATES_HINT).equals(Boolean.TRUE)) {\n            EvalContext ctx \u003d new InitialContext(context);\n            NodePointer ptr \u003d (NodePointer) ctx.getContextNodePointer();\n            if (ptr !\u003d null \u0026\u0026 (ptr.getIndex() \u003d\u003d NodePointer.WHOLE_COLLECTION || predicates \u003d\u003d null || predicates.length \u003d\u003d 0)) {\n                NodePointer pointer \u003d processBasicPredicates(ptr, predicates);\n                if (pointer !\u003d null) {\n                    Object result \u003d tryBasicPath(pointer, path.getSteps());\n                    if (result !\u003d FAILURE) {\n                        return result;\n                    }\n                }\n            }\n        }\n    }\n    if (predicates !\u003d null) {\n        for (int j \u003d 0; j \u003c predicates.length; j++) {\n            context \u003d new PredicateContext(context, predicates[j]);\n        }\n    }\n    return evalSteps(context, path, firstMatch);\n}",
          "path": "src/java/org/apache/commons/jxpath/ri/EvalContext.java",
          "functionStartLine": 898,
          "functionName": "expressionPath",
          "functionAnnotation": "",
          "functionDoc": "Walks an expression path (a path that starts with an expression)\n",
          "diff": "@@ -1,17 +1,34 @@\n-protected Object expressionPath(Expression expression, Expression[] predicates, Step[] steps, boolean firstMatch) {\n+protected Object expressionPath(ExpressionPath path, boolean firstMatch) {\n+    Expression expression \u003d path.getExpression();\n     Object value \u003d eval(expression, false);\n     EvalContext context;\n     if (value instanceof InitialContext) {\n         context \u003d (InitialContext) value;\n     } else if (value instanceof EvalContext) {\n         context \u003d new UnionContext(this, new EvalContext[] { (EvalContext) value });\n     } else {\n         context \u003d getRootContext().getConstantContext(value);\n     }\n+    Expression[] predicates \u003d path.getPredicates();\n+    if (firstMatch) {\n+        if (path.getEvaluationHint(ExpressionPath.BASIC_PREDICATES_HINT).equals(Boolean.TRUE)) {\n+            EvalContext ctx \u003d new InitialContext(context);\n+            NodePointer ptr \u003d (NodePointer) ctx.getContextNodePointer();\n+            if (ptr !\u003d null \u0026\u0026 (ptr.getIndex() \u003d\u003d NodePointer.WHOLE_COLLECTION || predicates \u003d\u003d null || predicates.length \u003d\u003d 0)) {\n+                NodePointer pointer \u003d processBasicPredicates(ptr, predicates);\n+                if (pointer !\u003d null) {\n+                    Object result \u003d tryBasicPath(pointer, path.getSteps());\n+                    if (result !\u003d FAILURE) {\n+                        return result;\n+                    }\n+                }\n+            }\n+        }\n+    }\n     if (predicates !\u003d null) {\n         for (int j \u003d 0; j \u003c predicates.length; j++) {\n             context \u003d new PredicateContext(context, predicates[j]);\n         }\n     }\n-    return evalSteps(context, steps, firstMatch);\n+    return evalSteps(context, path, firstMatch);\n }\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldValue": "[expression-Expression, predicates-Expression[], steps-Step[], firstMatch-boolean]",
            "newValue": "[path-ExpressionPath, firstMatch-boolean]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "Multiple changes\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/jakarta/commons/proper/jxpath/trunk@136712 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "4/9/02, 8:40 PM",
          "commitName": "34b7a47ae949c763178a457582a5df2cb564f53d",
          "commitAuthor": "Dmitri Plotnikov",
          "commitDateOld": "9/26/01, 4:37 PM",
          "commitNameOld": "d0a64d141367867db5b745734f5c7330644b71ca",
          "commitAuthorOld": "Dmitri Plotnikov",
          "daysBetweenCommits": 195.17,
          "commitsBetweenForRepo": 2,
          "commitsBetweenForFile": 1,
          "actualSource": "protected Object expressionPath(ExpressionPath path, boolean firstMatch) {\n    Expression expression \u003d path.getExpression();\n    Object value \u003d eval(expression, false);\n    EvalContext context;\n    if (value instanceof InitialContext) {\n        context \u003d (InitialContext) value;\n    } else if (value instanceof EvalContext) {\n        context \u003d new UnionContext(this, new EvalContext[] { (EvalContext) value });\n    } else {\n        context \u003d getRootContext().getConstantContext(value);\n    }\n    Expression[] predicates \u003d path.getPredicates();\n    if (firstMatch) {\n        if (path.getEvaluationHint(ExpressionPath.BASIC_PREDICATES_HINT).equals(Boolean.TRUE)) {\n            EvalContext ctx \u003d new InitialContext(context);\n            NodePointer ptr \u003d (NodePointer) ctx.getContextNodePointer();\n            if (ptr !\u003d null \u0026\u0026 (ptr.getIndex() \u003d\u003d NodePointer.WHOLE_COLLECTION || predicates \u003d\u003d null || predicates.length \u003d\u003d 0)) {\n                NodePointer pointer \u003d processBasicPredicates(ptr, predicates);\n                if (pointer !\u003d null) {\n                    Object result \u003d tryBasicPath(pointer, path.getSteps());\n                    if (result !\u003d FAILURE) {\n                        return result;\n                    }\n                }\n            }\n        }\n    }\n    if (predicates !\u003d null) {\n        for (int j \u003d 0; j \u003c predicates.length; j++) {\n            context \u003d new PredicateContext(context, predicates[j]);\n        }\n    }\n    return evalSteps(context, path, firstMatch);\n}",
          "path": "src/java/org/apache/commons/jxpath/ri/EvalContext.java",
          "functionStartLine": 898,
          "functionName": "expressionPath",
          "functionAnnotation": "",
          "functionDoc": "Walks an expression path (a path that starts with an expression)\n",
          "diff": "@@ -1,17 +1,34 @@\n-protected Object expressionPath(Expression expression, Expression[] predicates, Step[] steps, boolean firstMatch) {\n+protected Object expressionPath(ExpressionPath path, boolean firstMatch) {\n+    Expression expression \u003d path.getExpression();\n     Object value \u003d eval(expression, false);\n     EvalContext context;\n     if (value instanceof InitialContext) {\n         context \u003d (InitialContext) value;\n     } else if (value instanceof EvalContext) {\n         context \u003d new UnionContext(this, new EvalContext[] { (EvalContext) value });\n     } else {\n         context \u003d getRootContext().getConstantContext(value);\n     }\n+    Expression[] predicates \u003d path.getPredicates();\n+    if (firstMatch) {\n+        if (path.getEvaluationHint(ExpressionPath.BASIC_PREDICATES_HINT).equals(Boolean.TRUE)) {\n+            EvalContext ctx \u003d new InitialContext(context);\n+            NodePointer ptr \u003d (NodePointer) ctx.getContextNodePointer();\n+            if (ptr !\u003d null \u0026\u0026 (ptr.getIndex() \u003d\u003d NodePointer.WHOLE_COLLECTION || predicates \u003d\u003d null || predicates.length \u003d\u003d 0)) {\n+                NodePointer pointer \u003d processBasicPredicates(ptr, predicates);\n+                if (pointer !\u003d null) {\n+                    Object result \u003d tryBasicPath(pointer, path.getSteps());\n+                    if (result !\u003d FAILURE) {\n+                        return result;\n+                    }\n+                }\n+            }\n+        }\n+    }\n     if (predicates !\u003d null) {\n         for (int j \u003d 0; j \u003c predicates.length; j++) {\n             context \u003d new PredicateContext(context, predicates[j]);\n         }\n     }\n-    return evalSteps(context, steps, firstMatch);\n+    return evalSteps(context, path, firstMatch);\n }\n\\ No newline at end of file\n",
          "extendedDetails": {}
        }
      ]
    },
    "bc53a66311b9b22e471dd74860c7df75eebe9837": {
      "type": "Yintroduced",
      "commitMessage": "Initial submission\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/jakarta/commons/proper/jxpath/trunk@136698 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "8/22/01, 5:47 PM",
      "commitName": "bc53a66311b9b22e471dd74860c7df75eebe9837",
      "commitAuthor": "Dmitri Plotnikov",
      "diff": "@@ -0,0 +1,17 @@\n+protected Object expressionPath(Expression expression, Expression[] predicates, Step[] steps, boolean firstMatch) {\n+    Object value \u003d eval(expression, false);\n+    EvalContext context;\n+    if (value instanceof InitialContext) {\n+        context \u003d (InitialContext) value;\n+    } else if (value instanceof EvalContext) {\n+        context \u003d new UnionContext(this, new EvalContext[] { (EvalContext) value });\n+    } else {\n+        context \u003d getRootContext().getConstantContext(value);\n+    }\n+    if (predicates !\u003d null) {\n+        for (int j \u003d 0; j \u003c predicates.length; j++) {\n+            context \u003d new PredicateContext(context, predicates[j]);\n+        }\n+    }\n+    return evalSteps(context, steps, firstMatch);\n+}\n\\ No newline at end of file\n",
      "actualSource": "protected Object expressionPath(Expression expression, Expression[] predicates, Step[] steps, boolean firstMatch) {\n    Object value \u003d eval(expression, false);\n    EvalContext context;\n    if (value instanceof InitialContext) {\n        context \u003d (InitialContext) value;\n    } else if (value instanceof EvalContext) {\n        context \u003d new UnionContext(this, new EvalContext[] { (EvalContext) value });\n    } else {\n        context \u003d getRootContext().getConstantContext(value);\n    }\n    if (predicates !\u003d null) {\n        for (int j \u003d 0; j \u003c predicates.length; j++) {\n            context \u003d new PredicateContext(context, predicates[j]);\n        }\n    }\n    return evalSteps(context, steps, firstMatch);\n}",
      "path": "src/java/org/apache/commons/jxpath/ri/EvalContext.java",
      "functionStartLine": 741,
      "functionName": "expressionPath",
      "functionAnnotation": "",
      "functionDoc": "Walks an expression path (a path that starts with an expression)\n"
    }
  }
}