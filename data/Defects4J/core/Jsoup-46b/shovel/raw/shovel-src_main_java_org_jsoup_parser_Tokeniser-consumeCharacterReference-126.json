{
  "origin": "codeshovel",
  "repositoryName": "Jsoup-46b",
  "repositoryPath": "/tmp/Jsoup-46b//.git",
  "startCommitName": "HEAD",
  "sourceFileName": "Tokeniser.java",
  "functionName": "consumeCharacterReference",
  "functionId": "consumeCharacterReference___additionalAllowedCharacter-Character__inAttribute-boolean",
  "sourceFilePath": "src/main/java/org/jsoup/parser/Tokeniser.java",
  "functionAnnotation": "",
  "functionDoc": "",
  "functionStartLine": 126,
  "functionEndLine": 188,
  "numCommitsSeen": 20,
  "timeTaken": 1431,
  "changeHistory": [
    "18948588c456d31a0e5c58c48a8e20953366e077",
    "8e524450bbaf0eb3210f0f0d2fff3cc4d54cb0a7",
    "4de5fe88eab987f8ac5b2df32d5574e2615ae306",
    "a31ec08e102fd3832f3ff4449e9163440f0afb2c",
    "3e284b6ce28acdf41d7a7cc8ead881d6ab54a8f9",
    "1d37cef1d8367af963fee4dc99164708f5d3c6f8",
    "be94f5547d6b8f15ee48117afe46ae302c361464",
    "d0418222830f42f4f0c770e406f71454ea50e56d",
    "8749726a79c22451b1f01b14fb2137f734e926b4"
  ],
  "changeHistoryShort": {
    "18948588c456d31a0e5c58c48a8e20953366e077": "Ybodychange",
    "8e524450bbaf0eb3210f0f0d2fff3cc4d54cb0a7": "Ybodychange",
    "4de5fe88eab987f8ac5b2df32d5574e2615ae306": "Ymultichange(Yreturntypechange,Ybodychange)",
    "a31ec08e102fd3832f3ff4449e9163440f0afb2c": "Ybodychange",
    "3e284b6ce28acdf41d7a7cc8ead881d6ab54a8f9": "Ybodychange",
    "1d37cef1d8367af963fee4dc99164708f5d3c6f8": "Ybodychange",
    "be94f5547d6b8f15ee48117afe46ae302c361464": "Ybodychange",
    "d0418222830f42f4f0c770e406f71454ea50e56d": "Ybodychange",
    "8749726a79c22451b1f01b14fb2137f734e926b4": "Yintroduced"
  },
  "changeHistoryDetails": {
    "18948588c456d31a0e5c58c48a8e20953366e077": {
      "type": "Ybodychange",
      "commitMessage": "Don\u0027t allocate new char[]s for every character reference\n",
      "commitDate": "10/28/14, 10:34 PM",
      "commitName": "18948588c456d31a0e5c58c48a8e20953366e077",
      "commitAuthor": "Jonathan Hedley",
      "commitDateOld": "10/27/14, 9:29 PM",
      "commitNameOld": "e99193605b688e923d20054c13db897cff751607",
      "commitAuthorOld": "Jonathan Hedley",
      "daysBetweenCommits": 1.05,
      "commitsBetweenForRepo": 5,
      "commitsBetweenForFile": 1,
      "actualSource": "char[] consumeCharacterReference(Character additionalAllowedCharacter, boolean inAttribute) {\n    if (reader.isEmpty())\n        return null;\n    if (additionalAllowedCharacter !\u003d null \u0026\u0026 additionalAllowedCharacter \u003d\u003d reader.current())\n        return null;\n    if (reader.matchesAnySorted(notCharRefCharsSorted))\n        return null;\n    final char[] charRef \u003d charRefHolder;\n    reader.mark();\n    if (reader.matchConsume(\"#\")) {\n        boolean isHexMode \u003d reader.matchConsumeIgnoreCase(\"X\");\n        String numRef \u003d isHexMode ? reader.consumeHexSequence() : reader.consumeDigitSequence();\n        if (numRef.length() \u003d\u003d 0) {\n            characterReferenceError(\"numeric reference with no numerals\");\n            reader.rewindToMark();\n            return null;\n        }\n        if (!reader.matchConsume(\";\"))\n            characterReferenceError(\"missing semicolon\");\n        int charval \u003d -1;\n        try {\n            int base \u003d isHexMode ? 16 : 10;\n            charval \u003d Integer.valueOf(numRef, base);\n        } catch (NumberFormatException e) {\n        }\n        if (charval \u003d\u003d -1 || (charval \u003e\u003d 0xD800 \u0026\u0026 charval \u003c\u003d 0xDFFF) || charval \u003e 0x10FFFF) {\n            characterReferenceError(\"character outside of valid range\");\n            charRef[0] \u003d replacementChar;\n            return charRef;\n        } else {\n            if (charval \u003c Character.MIN_SUPPLEMENTARY_CODE_POINT) {\n                charRef[0] \u003d (char) charval;\n                return charRef;\n            } else\n                return Character.toChars(charval);\n        }\n    } else {\n        String nameRef \u003d reader.consumeLetterThenDigitSequence();\n        boolean looksLegit \u003d reader.matches(\u0027;\u0027);\n        boolean found \u003d (Entities.isBaseNamedEntity(nameRef) || (Entities.isNamedEntity(nameRef) \u0026\u0026 looksLegit));\n        if (!found) {\n            reader.rewindToMark();\n            if (looksLegit)\n                characterReferenceError(String.format(\"invalid named referenece \u0027%s\u0027\", nameRef));\n            return null;\n        }\n        if (inAttribute \u0026\u0026 (reader.matchesLetter() || reader.matchesDigit() || reader.matchesAny(\u0027\u003d\u0027, \u0027-\u0027, \u0027_\u0027))) {\n            reader.rewindToMark();\n            return null;\n        }\n        if (!reader.matchConsume(\";\"))\n            characterReferenceError(\"missing semicolon\");\n        charRef[0] \u003d Entities.getCharacterByName(nameRef);\n        return charRef;\n    }\n}",
      "path": "src/main/java/org/jsoup/parser/Tokeniser.java",
      "functionStartLine": 127,
      "functionName": "consumeCharacterReference",
      "functionAnnotation": "",
      "functionDoc": "",
      "diff": "@@ -1,49 +1,56 @@\n char[] consumeCharacterReference(Character additionalAllowedCharacter, boolean inAttribute) {\n     if (reader.isEmpty())\n         return null;\n     if (additionalAllowedCharacter !\u003d null \u0026\u0026 additionalAllowedCharacter \u003d\u003d reader.current())\n         return null;\n     if (reader.matchesAnySorted(notCharRefCharsSorted))\n         return null;\n+    final char[] charRef \u003d charRefHolder;\n     reader.mark();\n     if (reader.matchConsume(\"#\")) {\n         boolean isHexMode \u003d reader.matchConsumeIgnoreCase(\"X\");\n         String numRef \u003d isHexMode ? reader.consumeHexSequence() : reader.consumeDigitSequence();\n         if (numRef.length() \u003d\u003d 0) {\n             characterReferenceError(\"numeric reference with no numerals\");\n             reader.rewindToMark();\n             return null;\n         }\n         if (!reader.matchConsume(\";\"))\n             characterReferenceError(\"missing semicolon\");\n         int charval \u003d -1;\n         try {\n             int base \u003d isHexMode ? 16 : 10;\n             charval \u003d Integer.valueOf(numRef, base);\n         } catch (NumberFormatException e) {\n         }\n         if (charval \u003d\u003d -1 || (charval \u003e\u003d 0xD800 \u0026\u0026 charval \u003c\u003d 0xDFFF) || charval \u003e 0x10FFFF) {\n             characterReferenceError(\"character outside of valid range\");\n-            return new char[] { replacementChar };\n+            charRef[0] \u003d replacementChar;\n+            return charRef;\n         } else {\n-            return Character.toChars(charval);\n+            if (charval \u003c Character.MIN_SUPPLEMENTARY_CODE_POINT) {\n+                charRef[0] \u003d (char) charval;\n+                return charRef;\n+            } else\n+                return Character.toChars(charval);\n         }\n     } else {\n         String nameRef \u003d reader.consumeLetterThenDigitSequence();\n         boolean looksLegit \u003d reader.matches(\u0027;\u0027);\n         boolean found \u003d (Entities.isBaseNamedEntity(nameRef) || (Entities.isNamedEntity(nameRef) \u0026\u0026 looksLegit));\n         if (!found) {\n             reader.rewindToMark();\n             if (looksLegit)\n                 characterReferenceError(String.format(\"invalid named referenece \u0027%s\u0027\", nameRef));\n             return null;\n         }\n         if (inAttribute \u0026\u0026 (reader.matchesLetter() || reader.matchesDigit() || reader.matchesAny(\u0027\u003d\u0027, \u0027-\u0027, \u0027_\u0027))) {\n             reader.rewindToMark();\n             return null;\n         }\n         if (!reader.matchConsume(\";\"))\n             characterReferenceError(\"missing semicolon\");\n-        return new char[] { Entities.getCharacterByName(nameRef) };\n+        charRef[0] \u003d Entities.getCharacterByName(nameRef);\n+        return charRef;\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "8e524450bbaf0eb3210f0f0d2fff3cc4d54cb0a7": {
      "type": "Ybodychange",
      "commitMessage": "Optimized character reference searches\n",
      "commitDate": "10/26/14, 3:51 PM",
      "commitName": "8e524450bbaf0eb3210f0f0d2fff3cc4d54cb0a7",
      "commitAuthor": "Jonathan Hedley",
      "commitDateOld": "10/17/14, 1:11 PM",
      "commitNameOld": "e613360fa4f0cd3bdfdece02d2bc1b58be640cac",
      "commitAuthorOld": "offa",
      "daysBetweenCommits": 9.11,
      "commitsBetweenForRepo": 11,
      "commitsBetweenForFile": 1,
      "actualSource": "char[] consumeCharacterReference(Character additionalAllowedCharacter, boolean inAttribute) {\n    if (reader.isEmpty())\n        return null;\n    if (additionalAllowedCharacter !\u003d null \u0026\u0026 additionalAllowedCharacter \u003d\u003d reader.current())\n        return null;\n    if (reader.matchesAnySorted(notCharRefCharsSorted))\n        return null;\n    reader.mark();\n    if (reader.matchConsume(\"#\")) {\n        boolean isHexMode \u003d reader.matchConsumeIgnoreCase(\"X\");\n        String numRef \u003d isHexMode ? reader.consumeHexSequence() : reader.consumeDigitSequence();\n        if (numRef.length() \u003d\u003d 0) {\n            characterReferenceError(\"numeric reference with no numerals\");\n            reader.rewindToMark();\n            return null;\n        }\n        if (!reader.matchConsume(\";\"))\n            characterReferenceError(\"missing semicolon\");\n        int charval \u003d -1;\n        try {\n            int base \u003d isHexMode ? 16 : 10;\n            charval \u003d Integer.valueOf(numRef, base);\n        } catch (NumberFormatException e) {\n        }\n        if (charval \u003d\u003d -1 || (charval \u003e\u003d 0xD800 \u0026\u0026 charval \u003c\u003d 0xDFFF) || charval \u003e 0x10FFFF) {\n            characterReferenceError(\"character outside of valid range\");\n            return new char[] { replacementChar };\n        } else {\n            return Character.toChars(charval);\n        }\n    } else {\n        String nameRef \u003d reader.consumeLetterThenDigitSequence();\n        boolean looksLegit \u003d reader.matches(\u0027;\u0027);\n        boolean found \u003d (Entities.isBaseNamedEntity(nameRef) || (Entities.isNamedEntity(nameRef) \u0026\u0026 looksLegit));\n        if (!found) {\n            reader.rewindToMark();\n            if (looksLegit)\n                characterReferenceError(String.format(\"invalid named referenece \u0027%s\u0027\", nameRef));\n            return null;\n        }\n        if (inAttribute \u0026\u0026 (reader.matchesLetter() || reader.matchesDigit() || reader.matchesAny(\u0027\u003d\u0027, \u0027-\u0027, \u0027_\u0027))) {\n            reader.rewindToMark();\n            return null;\n        }\n        if (!reader.matchConsume(\";\"))\n            characterReferenceError(\"missing semicolon\");\n        return new char[] { Entities.getCharacterByName(nameRef) };\n    }\n}",
      "path": "src/main/java/org/jsoup/parser/Tokeniser.java",
      "functionStartLine": 108,
      "functionName": "consumeCharacterReference",
      "functionAnnotation": "",
      "functionDoc": "",
      "diff": "@@ -1,49 +1,49 @@\n char[] consumeCharacterReference(Character additionalAllowedCharacter, boolean inAttribute) {\n     if (reader.isEmpty())\n         return null;\n     if (additionalAllowedCharacter !\u003d null \u0026\u0026 additionalAllowedCharacter \u003d\u003d reader.current())\n         return null;\n-    if (reader.matchesAny(\u0027\\t\u0027, \u0027\\n\u0027, \u0027\\r\u0027, \u0027\\f\u0027, \u0027 \u0027, \u0027\u003c\u0027, \u0027\u0026\u0027))\n+    if (reader.matchesAnySorted(notCharRefCharsSorted))\n         return null;\n     reader.mark();\n     if (reader.matchConsume(\"#\")) {\n         boolean isHexMode \u003d reader.matchConsumeIgnoreCase(\"X\");\n         String numRef \u003d isHexMode ? reader.consumeHexSequence() : reader.consumeDigitSequence();\n         if (numRef.length() \u003d\u003d 0) {\n             characterReferenceError(\"numeric reference with no numerals\");\n             reader.rewindToMark();\n             return null;\n         }\n         if (!reader.matchConsume(\";\"))\n             characterReferenceError(\"missing semicolon\");\n         int charval \u003d -1;\n         try {\n             int base \u003d isHexMode ? 16 : 10;\n             charval \u003d Integer.valueOf(numRef, base);\n         } catch (NumberFormatException e) {\n         }\n         if (charval \u003d\u003d -1 || (charval \u003e\u003d 0xD800 \u0026\u0026 charval \u003c\u003d 0xDFFF) || charval \u003e 0x10FFFF) {\n             characterReferenceError(\"character outside of valid range\");\n             return new char[] { replacementChar };\n         } else {\n             return Character.toChars(charval);\n         }\n     } else {\n         String nameRef \u003d reader.consumeLetterThenDigitSequence();\n         boolean looksLegit \u003d reader.matches(\u0027;\u0027);\n         boolean found \u003d (Entities.isBaseNamedEntity(nameRef) || (Entities.isNamedEntity(nameRef) \u0026\u0026 looksLegit));\n         if (!found) {\n             reader.rewindToMark();\n             if (looksLegit)\n                 characterReferenceError(String.format(\"invalid named referenece \u0027%s\u0027\", nameRef));\n             return null;\n         }\n         if (inAttribute \u0026\u0026 (reader.matchesLetter() || reader.matchesDigit() || reader.matchesAny(\u0027\u003d\u0027, \u0027-\u0027, \u0027_\u0027))) {\n             reader.rewindToMark();\n             return null;\n         }\n         if (!reader.matchConsume(\";\"))\n             characterReferenceError(\"missing semicolon\");\n         return new char[] { Entities.getCharacterByName(nameRef) };\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "4de5fe88eab987f8ac5b2df32d5574e2615ae306": {
      "type": "Ymultichange(Yreturntypechange,Ybodychange)",
      "commitMessage": "changed return type of Tokeniser.consumeCharacterReference from Character to char[], and also changed TokeniserState accordingly\n",
      "commitDate": "1/25/13, 11:11 PM",
      "commitName": "4de5fe88eab987f8ac5b2df32d5574e2615ae306",
      "commitAuthor": "mingfai.ma",
      "subchanges": [
        {
          "type": "Yreturntypechange",
          "commitMessage": "changed return type of Tokeniser.consumeCharacterReference from Character to char[], and also changed TokeniserState accordingly\n",
          "commitDate": "1/25/13, 11:11 PM",
          "commitName": "4de5fe88eab987f8ac5b2df32d5574e2615ae306",
          "commitAuthor": "mingfai.ma",
          "commitDateOld": "9/23/12, 12:16 PM",
          "commitNameOld": "a31ec08e102fd3832f3ff4449e9163440f0afb2c",
          "commitAuthorOld": "Jonathan Hedley",
          "daysBetweenCommits": 124.5,
          "commitsBetweenForRepo": 25,
          "commitsBetweenForFile": 1,
          "actualSource": "char[] consumeCharacterReference(Character additionalAllowedCharacter, boolean inAttribute) {\n    if (reader.isEmpty())\n        return null;\n    if (additionalAllowedCharacter !\u003d null \u0026\u0026 additionalAllowedCharacter \u003d\u003d reader.current())\n        return null;\n    if (reader.matchesAny(\u0027\\t\u0027, \u0027\\n\u0027, \u0027\\r\u0027, \u0027\\f\u0027, \u0027 \u0027, \u0027\u003c\u0027, \u0027\u0026\u0027))\n        return null;\n    reader.mark();\n    if (reader.matchConsume(\"#\")) {\n        boolean isHexMode \u003d reader.matchConsumeIgnoreCase(\"X\");\n        String numRef \u003d isHexMode ? reader.consumeHexSequence() : reader.consumeDigitSequence();\n        if (numRef.length() \u003d\u003d 0) {\n            characterReferenceError(\"numeric reference with no numerals\");\n            reader.rewindToMark();\n            return null;\n        }\n        if (!reader.matchConsume(\";\"))\n            characterReferenceError(\"missing semicolon\");\n        int charval \u003d -1;\n        try {\n            int base \u003d isHexMode ? 16 : 10;\n            charval \u003d Integer.valueOf(numRef, base);\n        } catch (NumberFormatException e) {\n        }\n        if (charval \u003d\u003d -1 || (charval \u003e\u003d 0xD800 \u0026\u0026 charval \u003c\u003d 0xDFFF) || charval \u003e 0x10FFFF) {\n            characterReferenceError(\"character outside of valid range\");\n            return new char[] { replacementChar };\n        } else {\n            return Character.toChars(charval);\n        }\n    } else {\n        String nameRef \u003d reader.consumeLetterThenDigitSequence();\n        boolean looksLegit \u003d reader.matches(\u0027;\u0027);\n        boolean found \u003d (Entities.isBaseNamedEntity(nameRef) || (Entities.isNamedEntity(nameRef) \u0026\u0026 looksLegit));\n        if (!found) {\n            reader.rewindToMark();\n            if (looksLegit)\n                characterReferenceError(String.format(\"invalid named referenece \u0027%s\u0027\", nameRef));\n            return null;\n        }\n        if (inAttribute \u0026\u0026 (reader.matchesLetter() || reader.matchesDigit() || reader.matchesAny(\u0027\u003d\u0027, \u0027-\u0027, \u0027_\u0027))) {\n            reader.rewindToMark();\n            return null;\n        }\n        if (!reader.matchConsume(\";\"))\n            characterReferenceError(\"missing semicolon\");\n        return new char[] { Entities.getCharacterByName(nameRef) };\n    }\n}",
          "path": "src/main/java/org/jsoup/parser/Tokeniser.java",
          "functionStartLine": 100,
          "functionName": "consumeCharacterReference",
          "functionAnnotation": "",
          "functionDoc": "",
          "diff": "@@ -1,49 +1,49 @@\n-Character consumeCharacterReference(Character additionalAllowedCharacter, boolean inAttribute) {\n+char[] consumeCharacterReference(Character additionalAllowedCharacter, boolean inAttribute) {\n     if (reader.isEmpty())\n         return null;\n     if (additionalAllowedCharacter !\u003d null \u0026\u0026 additionalAllowedCharacter \u003d\u003d reader.current())\n         return null;\n     if (reader.matchesAny(\u0027\\t\u0027, \u0027\\n\u0027, \u0027\\r\u0027, \u0027\\f\u0027, \u0027 \u0027, \u0027\u003c\u0027, \u0027\u0026\u0027))\n         return null;\n     reader.mark();\n     if (reader.matchConsume(\"#\")) {\n         boolean isHexMode \u003d reader.matchConsumeIgnoreCase(\"X\");\n         String numRef \u003d isHexMode ? reader.consumeHexSequence() : reader.consumeDigitSequence();\n         if (numRef.length() \u003d\u003d 0) {\n             characterReferenceError(\"numeric reference with no numerals\");\n             reader.rewindToMark();\n             return null;\n         }\n         if (!reader.matchConsume(\";\"))\n             characterReferenceError(\"missing semicolon\");\n         int charval \u003d -1;\n         try {\n             int base \u003d isHexMode ? 16 : 10;\n             charval \u003d Integer.valueOf(numRef, base);\n         } catch (NumberFormatException e) {\n         }\n         if (charval \u003d\u003d -1 || (charval \u003e\u003d 0xD800 \u0026\u0026 charval \u003c\u003d 0xDFFF) || charval \u003e 0x10FFFF) {\n             characterReferenceError(\"character outside of valid range\");\n-            return replacementChar;\n+            return new char[] { replacementChar };\n         } else {\n-            return (char) charval;\n+            return Character.toChars(charval);\n         }\n     } else {\n         String nameRef \u003d reader.consumeLetterThenDigitSequence();\n         boolean looksLegit \u003d reader.matches(\u0027;\u0027);\n         boolean found \u003d (Entities.isBaseNamedEntity(nameRef) || (Entities.isNamedEntity(nameRef) \u0026\u0026 looksLegit));\n         if (!found) {\n             reader.rewindToMark();\n             if (looksLegit)\n                 characterReferenceError(String.format(\"invalid named referenece \u0027%s\u0027\", nameRef));\n             return null;\n         }\n         if (inAttribute \u0026\u0026 (reader.matchesLetter() || reader.matchesDigit() || reader.matchesAny(\u0027\u003d\u0027, \u0027-\u0027, \u0027_\u0027))) {\n             reader.rewindToMark();\n             return null;\n         }\n         if (!reader.matchConsume(\";\"))\n             characterReferenceError(\"missing semicolon\");\n-        return Entities.getCharacterByName(nameRef);\n+        return new char[] { Entities.getCharacterByName(nameRef) };\n     }\n }\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldValue": "Character",
            "newValue": "char[]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "changed return type of Tokeniser.consumeCharacterReference from Character to char[], and also changed TokeniserState accordingly\n",
          "commitDate": "1/25/13, 11:11 PM",
          "commitName": "4de5fe88eab987f8ac5b2df32d5574e2615ae306",
          "commitAuthor": "mingfai.ma",
          "commitDateOld": "9/23/12, 12:16 PM",
          "commitNameOld": "a31ec08e102fd3832f3ff4449e9163440f0afb2c",
          "commitAuthorOld": "Jonathan Hedley",
          "daysBetweenCommits": 124.5,
          "commitsBetweenForRepo": 25,
          "commitsBetweenForFile": 1,
          "actualSource": "char[] consumeCharacterReference(Character additionalAllowedCharacter, boolean inAttribute) {\n    if (reader.isEmpty())\n        return null;\n    if (additionalAllowedCharacter !\u003d null \u0026\u0026 additionalAllowedCharacter \u003d\u003d reader.current())\n        return null;\n    if (reader.matchesAny(\u0027\\t\u0027, \u0027\\n\u0027, \u0027\\r\u0027, \u0027\\f\u0027, \u0027 \u0027, \u0027\u003c\u0027, \u0027\u0026\u0027))\n        return null;\n    reader.mark();\n    if (reader.matchConsume(\"#\")) {\n        boolean isHexMode \u003d reader.matchConsumeIgnoreCase(\"X\");\n        String numRef \u003d isHexMode ? reader.consumeHexSequence() : reader.consumeDigitSequence();\n        if (numRef.length() \u003d\u003d 0) {\n            characterReferenceError(\"numeric reference with no numerals\");\n            reader.rewindToMark();\n            return null;\n        }\n        if (!reader.matchConsume(\";\"))\n            characterReferenceError(\"missing semicolon\");\n        int charval \u003d -1;\n        try {\n            int base \u003d isHexMode ? 16 : 10;\n            charval \u003d Integer.valueOf(numRef, base);\n        } catch (NumberFormatException e) {\n        }\n        if (charval \u003d\u003d -1 || (charval \u003e\u003d 0xD800 \u0026\u0026 charval \u003c\u003d 0xDFFF) || charval \u003e 0x10FFFF) {\n            characterReferenceError(\"character outside of valid range\");\n            return new char[] { replacementChar };\n        } else {\n            return Character.toChars(charval);\n        }\n    } else {\n        String nameRef \u003d reader.consumeLetterThenDigitSequence();\n        boolean looksLegit \u003d reader.matches(\u0027;\u0027);\n        boolean found \u003d (Entities.isBaseNamedEntity(nameRef) || (Entities.isNamedEntity(nameRef) \u0026\u0026 looksLegit));\n        if (!found) {\n            reader.rewindToMark();\n            if (looksLegit)\n                characterReferenceError(String.format(\"invalid named referenece \u0027%s\u0027\", nameRef));\n            return null;\n        }\n        if (inAttribute \u0026\u0026 (reader.matchesLetter() || reader.matchesDigit() || reader.matchesAny(\u0027\u003d\u0027, \u0027-\u0027, \u0027_\u0027))) {\n            reader.rewindToMark();\n            return null;\n        }\n        if (!reader.matchConsume(\";\"))\n            characterReferenceError(\"missing semicolon\");\n        return new char[] { Entities.getCharacterByName(nameRef) };\n    }\n}",
          "path": "src/main/java/org/jsoup/parser/Tokeniser.java",
          "functionStartLine": 100,
          "functionName": "consumeCharacterReference",
          "functionAnnotation": "",
          "functionDoc": "",
          "diff": "@@ -1,49 +1,49 @@\n-Character consumeCharacterReference(Character additionalAllowedCharacter, boolean inAttribute) {\n+char[] consumeCharacterReference(Character additionalAllowedCharacter, boolean inAttribute) {\n     if (reader.isEmpty())\n         return null;\n     if (additionalAllowedCharacter !\u003d null \u0026\u0026 additionalAllowedCharacter \u003d\u003d reader.current())\n         return null;\n     if (reader.matchesAny(\u0027\\t\u0027, \u0027\\n\u0027, \u0027\\r\u0027, \u0027\\f\u0027, \u0027 \u0027, \u0027\u003c\u0027, \u0027\u0026\u0027))\n         return null;\n     reader.mark();\n     if (reader.matchConsume(\"#\")) {\n         boolean isHexMode \u003d reader.matchConsumeIgnoreCase(\"X\");\n         String numRef \u003d isHexMode ? reader.consumeHexSequence() : reader.consumeDigitSequence();\n         if (numRef.length() \u003d\u003d 0) {\n             characterReferenceError(\"numeric reference with no numerals\");\n             reader.rewindToMark();\n             return null;\n         }\n         if (!reader.matchConsume(\";\"))\n             characterReferenceError(\"missing semicolon\");\n         int charval \u003d -1;\n         try {\n             int base \u003d isHexMode ? 16 : 10;\n             charval \u003d Integer.valueOf(numRef, base);\n         } catch (NumberFormatException e) {\n         }\n         if (charval \u003d\u003d -1 || (charval \u003e\u003d 0xD800 \u0026\u0026 charval \u003c\u003d 0xDFFF) || charval \u003e 0x10FFFF) {\n             characterReferenceError(\"character outside of valid range\");\n-            return replacementChar;\n+            return new char[] { replacementChar };\n         } else {\n-            return (char) charval;\n+            return Character.toChars(charval);\n         }\n     } else {\n         String nameRef \u003d reader.consumeLetterThenDigitSequence();\n         boolean looksLegit \u003d reader.matches(\u0027;\u0027);\n         boolean found \u003d (Entities.isBaseNamedEntity(nameRef) || (Entities.isNamedEntity(nameRef) \u0026\u0026 looksLegit));\n         if (!found) {\n             reader.rewindToMark();\n             if (looksLegit)\n                 characterReferenceError(String.format(\"invalid named referenece \u0027%s\u0027\", nameRef));\n             return null;\n         }\n         if (inAttribute \u0026\u0026 (reader.matchesLetter() || reader.matchesDigit() || reader.matchesAny(\u0027\u003d\u0027, \u0027-\u0027, \u0027_\u0027))) {\n             reader.rewindToMark();\n             return null;\n         }\n         if (!reader.matchConsume(\";\"))\n             characterReferenceError(\"missing semicolon\");\n-        return Entities.getCharacterByName(nameRef);\n+        return new char[] { Entities.getCharacterByName(nameRef) };\n     }\n }\n\\ No newline at end of file\n",
          "extendedDetails": {}
        }
      ]
    },
    "a31ec08e102fd3832f3ff4449e9163440f0afb2c": {
      "type": "Ybodychange",
      "commitMessage": "Refactored entity decoding.\n\nModified the heuristic entity decoder to be less greedy; does not\nrepeatedly chomp down the string until a match is found, and requires a\nsemicolon terminator for extended entities.\n\nUpdated Entities to use the entity decoder in Tokeniser, vs the legacy\ndecoder.\n\nFixes #224.\n",
      "commitDate": "9/23/12, 12:16 PM",
      "commitName": "a31ec08e102fd3832f3ff4449e9163440f0afb2c",
      "commitAuthor": "Jonathan Hedley",
      "commitDateOld": "6/3/12, 8:09 PM",
      "commitNameOld": "666275a54f3e6907b5244b612483815ee70a191d",
      "commitAuthorOld": "Jonathan Hedley",
      "daysBetweenCommits": 111.67,
      "commitsBetweenForRepo": 14,
      "commitsBetweenForFile": 1,
      "actualSource": "Character consumeCharacterReference(Character additionalAllowedCharacter, boolean inAttribute) {\n    if (reader.isEmpty())\n        return null;\n    if (additionalAllowedCharacter !\u003d null \u0026\u0026 additionalAllowedCharacter \u003d\u003d reader.current())\n        return null;\n    if (reader.matchesAny(\u0027\\t\u0027, \u0027\\n\u0027, \u0027\\r\u0027, \u0027\\f\u0027, \u0027 \u0027, \u0027\u003c\u0027, \u0027\u0026\u0027))\n        return null;\n    reader.mark();\n    if (reader.matchConsume(\"#\")) {\n        boolean isHexMode \u003d reader.matchConsumeIgnoreCase(\"X\");\n        String numRef \u003d isHexMode ? reader.consumeHexSequence() : reader.consumeDigitSequence();\n        if (numRef.length() \u003d\u003d 0) {\n            characterReferenceError(\"numeric reference with no numerals\");\n            reader.rewindToMark();\n            return null;\n        }\n        if (!reader.matchConsume(\";\"))\n            characterReferenceError(\"missing semicolon\");\n        int charval \u003d -1;\n        try {\n            int base \u003d isHexMode ? 16 : 10;\n            charval \u003d Integer.valueOf(numRef, base);\n        } catch (NumberFormatException e) {\n        }\n        if (charval \u003d\u003d -1 || (charval \u003e\u003d 0xD800 \u0026\u0026 charval \u003c\u003d 0xDFFF) || charval \u003e 0x10FFFF) {\n            characterReferenceError(\"character outside of valid range\");\n            return replacementChar;\n        } else {\n            return (char) charval;\n        }\n    } else {\n        String nameRef \u003d reader.consumeLetterThenDigitSequence();\n        boolean looksLegit \u003d reader.matches(\u0027;\u0027);\n        boolean found \u003d (Entities.isBaseNamedEntity(nameRef) || (Entities.isNamedEntity(nameRef) \u0026\u0026 looksLegit));\n        if (!found) {\n            reader.rewindToMark();\n            if (looksLegit)\n                characterReferenceError(String.format(\"invalid named referenece \u0027%s\u0027\", nameRef));\n            return null;\n        }\n        if (inAttribute \u0026\u0026 (reader.matchesLetter() || reader.matchesDigit() || reader.matchesAny(\u0027\u003d\u0027, \u0027-\u0027, \u0027_\u0027))) {\n            reader.rewindToMark();\n            return null;\n        }\n        if (!reader.matchConsume(\";\"))\n            characterReferenceError(\"missing semicolon\");\n        return Entities.getCharacterByName(nameRef);\n    }\n}",
      "path": "src/main/java/org/jsoup/parser/Tokeniser.java",
      "functionStartLine": 100,
      "functionName": "consumeCharacterReference",
      "functionAnnotation": "",
      "functionDoc": "",
      "diff": "@@ -1,58 +1,49 @@\n Character consumeCharacterReference(Character additionalAllowedCharacter, boolean inAttribute) {\n     if (reader.isEmpty())\n         return null;\n     if (additionalAllowedCharacter !\u003d null \u0026\u0026 additionalAllowedCharacter \u003d\u003d reader.current())\n         return null;\n     if (reader.matchesAny(\u0027\\t\u0027, \u0027\\n\u0027, \u0027\\r\u0027, \u0027\\f\u0027, \u0027 \u0027, \u0027\u003c\u0027, \u0027\u0026\u0027))\n         return null;\n     reader.mark();\n     if (reader.matchConsume(\"#\")) {\n         boolean isHexMode \u003d reader.matchConsumeIgnoreCase(\"X\");\n         String numRef \u003d isHexMode ? reader.consumeHexSequence() : reader.consumeDigitSequence();\n         if (numRef.length() \u003d\u003d 0) {\n             characterReferenceError(\"numeric reference with no numerals\");\n             reader.rewindToMark();\n             return null;\n         }\n         if (!reader.matchConsume(\";\"))\n             characterReferenceError(\"missing semicolon\");\n         int charval \u003d -1;\n         try {\n             int base \u003d isHexMode ? 16 : 10;\n             charval \u003d Integer.valueOf(numRef, base);\n         } catch (NumberFormatException e) {\n         }\n         if (charval \u003d\u003d -1 || (charval \u003e\u003d 0xD800 \u0026\u0026 charval \u003c\u003d 0xDFFF) || charval \u003e 0x10FFFF) {\n             characterReferenceError(\"character outside of valid range\");\n             return replacementChar;\n         } else {\n             return (char) charval;\n         }\n     } else {\n         String nameRef \u003d reader.consumeLetterThenDigitSequence();\n-        String origNameRef \u003d new String(nameRef);\n         boolean looksLegit \u003d reader.matches(\u0027;\u0027);\n-        boolean found \u003d false;\n-        while (nameRef.length() \u003e 0 \u0026\u0026 !found) {\n-            if (Entities.isNamedEntity(nameRef))\n-                found \u003d true;\n-            else {\n-                nameRef \u003d nameRef.substring(0, nameRef.length() - 1);\n-                reader.unconsume();\n-            }\n-        }\n+        boolean found \u003d (Entities.isBaseNamedEntity(nameRef) || (Entities.isNamedEntity(nameRef) \u0026\u0026 looksLegit));\n         if (!found) {\n-            if (looksLegit)\n-                characterReferenceError(String.format(\"invalid named referenece \u0027%s\u0027\", origNameRef));\n             reader.rewindToMark();\n+            if (looksLegit)\n+                characterReferenceError(String.format(\"invalid named referenece \u0027%s\u0027\", nameRef));\n             return null;\n         }\n         if (inAttribute \u0026\u0026 (reader.matchesLetter() || reader.matchesDigit() || reader.matchesAny(\u0027\u003d\u0027, \u0027-\u0027, \u0027_\u0027))) {\n             reader.rewindToMark();\n             return null;\n         }\n         if (!reader.matchConsume(\";\"))\n             characterReferenceError(\"missing semicolon\");\n         return Entities.getCharacterByName(nameRef);\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "3e284b6ce28acdf41d7a7cc8ead881d6ab54a8f9": {
      "type": "Ybodychange",
      "commitMessage": "No longer strip \\r before parsing.\n\nThis saves memory and CPU time at start of parse.\n",
      "commitDate": "5/28/12, 8:59 PM",
      "commitName": "3e284b6ce28acdf41d7a7cc8ead881d6ab54a8f9",
      "commitAuthor": "Jonathan Hedley",
      "commitDateOld": "5/26/12, 4:11 PM",
      "commitNameOld": "fa9d20a3fb3060daaaa4f183a4be5cf27caf2583",
      "commitAuthorOld": "Jonathan Hedley",
      "daysBetweenCommits": 2.2,
      "commitsBetweenForRepo": 13,
      "commitsBetweenForFile": 1,
      "actualSource": "Character consumeCharacterReference(Character additionalAllowedCharacter, boolean inAttribute) {\n    if (reader.isEmpty())\n        return null;\n    if (additionalAllowedCharacter !\u003d null \u0026\u0026 additionalAllowedCharacter \u003d\u003d reader.current())\n        return null;\n    if (reader.matchesAny(\u0027\\t\u0027, \u0027\\n\u0027, \u0027\\r\u0027, \u0027\\f\u0027, \u0027 \u0027, \u0027\u003c\u0027, \u0027\u0026\u0027))\n        return null;\n    reader.mark();\n    if (reader.matchConsume(\"#\")) {\n        boolean isHexMode \u003d reader.matchConsumeIgnoreCase(\"X\");\n        String numRef \u003d isHexMode ? reader.consumeHexSequence() : reader.consumeDigitSequence();\n        if (numRef.length() \u003d\u003d 0) {\n            characterReferenceError(\"numeric reference with no numerals\");\n            reader.rewindToMark();\n            return null;\n        }\n        if (!reader.matchConsume(\";\"))\n            characterReferenceError(\"missing semicolon\");\n        int charval \u003d -1;\n        try {\n            int base \u003d isHexMode ? 16 : 10;\n            charval \u003d Integer.valueOf(numRef, base);\n        } catch (NumberFormatException e) {\n        }\n        if (charval \u003d\u003d -1 || (charval \u003e\u003d 0xD800 \u0026\u0026 charval \u003c\u003d 0xDFFF) || charval \u003e 0x10FFFF) {\n            characterReferenceError(\"character outside of valid range\");\n            return replacementChar;\n        } else {\n            return (char) charval;\n        }\n    } else {\n        String nameRef \u003d reader.consumeLetterThenDigitSequence();\n        String origNameRef \u003d new String(nameRef);\n        boolean looksLegit \u003d reader.matches(\u0027;\u0027);\n        boolean found \u003d false;\n        while (nameRef.length() \u003e 0 \u0026\u0026 !found) {\n            if (Entities.isNamedEntity(nameRef))\n                found \u003d true;\n            else {\n                nameRef \u003d nameRef.substring(0, nameRef.length() - 1);\n                reader.unconsume();\n            }\n        }\n        if (!found) {\n            if (looksLegit)\n                characterReferenceError(String.format(\"invalid named referenece \u0027%s\u0027\", origNameRef));\n            reader.rewindToMark();\n            return null;\n        }\n        if (inAttribute \u0026\u0026 (reader.matchesLetter() || reader.matchesDigit() || reader.matchesAny(\u0027\u003d\u0027, \u0027-\u0027, \u0027_\u0027))) {\n            reader.rewindToMark();\n            return null;\n        }\n        if (!reader.matchConsume(\";\"))\n            characterReferenceError(\"missing semicolon\");\n        return Entities.getCharacterByName(nameRef);\n    }\n}",
      "path": "src/main/java/org/jsoup/parser/Tokeniser.java",
      "functionStartLine": 100,
      "functionName": "consumeCharacterReference",
      "functionAnnotation": "",
      "functionDoc": "",
      "diff": "@@ -1,58 +1,58 @@\n Character consumeCharacterReference(Character additionalAllowedCharacter, boolean inAttribute) {\n     if (reader.isEmpty())\n         return null;\n     if (additionalAllowedCharacter !\u003d null \u0026\u0026 additionalAllowedCharacter \u003d\u003d reader.current())\n         return null;\n-    if (reader.matchesAny(\u0027\\t\u0027, \u0027\\n\u0027, \u0027\\f\u0027, \u0027 \u0027, \u0027\u003c\u0027, \u0027\u0026\u0027))\n+    if (reader.matchesAny(\u0027\\t\u0027, \u0027\\n\u0027, \u0027\\r\u0027, \u0027\\f\u0027, \u0027 \u0027, \u0027\u003c\u0027, \u0027\u0026\u0027))\n         return null;\n     reader.mark();\n     if (reader.matchConsume(\"#\")) {\n         boolean isHexMode \u003d reader.matchConsumeIgnoreCase(\"X\");\n         String numRef \u003d isHexMode ? reader.consumeHexSequence() : reader.consumeDigitSequence();\n         if (numRef.length() \u003d\u003d 0) {\n             characterReferenceError(\"numeric reference with no numerals\");\n             reader.rewindToMark();\n             return null;\n         }\n         if (!reader.matchConsume(\";\"))\n             characterReferenceError(\"missing semicolon\");\n         int charval \u003d -1;\n         try {\n             int base \u003d isHexMode ? 16 : 10;\n             charval \u003d Integer.valueOf(numRef, base);\n         } catch (NumberFormatException e) {\n         }\n         if (charval \u003d\u003d -1 || (charval \u003e\u003d 0xD800 \u0026\u0026 charval \u003c\u003d 0xDFFF) || charval \u003e 0x10FFFF) {\n             characterReferenceError(\"character outside of valid range\");\n             return replacementChar;\n         } else {\n             return (char) charval;\n         }\n     } else {\n         String nameRef \u003d reader.consumeLetterThenDigitSequence();\n         String origNameRef \u003d new String(nameRef);\n         boolean looksLegit \u003d reader.matches(\u0027;\u0027);\n         boolean found \u003d false;\n         while (nameRef.length() \u003e 0 \u0026\u0026 !found) {\n             if (Entities.isNamedEntity(nameRef))\n                 found \u003d true;\n             else {\n                 nameRef \u003d nameRef.substring(0, nameRef.length() - 1);\n                 reader.unconsume();\n             }\n         }\n         if (!found) {\n             if (looksLegit)\n                 characterReferenceError(String.format(\"invalid named referenece \u0027%s\u0027\", origNameRef));\n             reader.rewindToMark();\n             return null;\n         }\n         if (inAttribute \u0026\u0026 (reader.matchesLetter() || reader.matchesDigit() || reader.matchesAny(\u0027\u003d\u0027, \u0027-\u0027, \u0027_\u0027))) {\n             reader.rewindToMark();\n             return null;\n         }\n         if (!reader.matchConsume(\";\"))\n             characterReferenceError(\"missing semicolon\");\n         return Entities.getCharacterByName(nameRef);\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "1d37cef1d8367af963fee4dc99164708f5d3c6f8": {
      "type": "Ybodychange",
      "commitMessage": "Fixed HTML entity parser to correctly parse entities like frac14 (letter + number combo).\n\nFixes #145\n",
      "commitDate": "4/14/12, 12:31 PM",
      "commitName": "1d37cef1d8367af963fee4dc99164708f5d3c6f8",
      "commitAuthor": "Jonathan Hedley",
      "commitDateOld": "3/20/12, 9:55 PM",
      "commitNameOld": "f8a5dfb037d363a6b6657fa71af59b66c6bec257",
      "commitAuthorOld": "Jonathan Hedley",
      "daysBetweenCommits": 24.61,
      "commitsBetweenForRepo": 15,
      "commitsBetweenForFile": 1,
      "actualSource": "Character consumeCharacterReference(Character additionalAllowedCharacter, boolean inAttribute) {\n    if (reader.isEmpty())\n        return null;\n    if (additionalAllowedCharacter !\u003d null \u0026\u0026 additionalAllowedCharacter \u003d\u003d reader.current())\n        return null;\n    if (reader.matchesAny(\u0027\\t\u0027, \u0027\\n\u0027, \u0027\\f\u0027, \u0027 \u0027, \u0027\u003c\u0027, \u0027\u0026\u0027))\n        return null;\n    reader.mark();\n    if (reader.matchConsume(\"#\")) {\n        boolean isHexMode \u003d reader.matchConsumeIgnoreCase(\"X\");\n        String numRef \u003d isHexMode ? reader.consumeHexSequence() : reader.consumeDigitSequence();\n        if (numRef.length() \u003d\u003d 0) {\n            characterReferenceError(\"numeric reference with no numerals\");\n            reader.rewindToMark();\n            return null;\n        }\n        if (!reader.matchConsume(\";\"))\n            characterReferenceError(\"missing semicolon\");\n        int charval \u003d -1;\n        try {\n            int base \u003d isHexMode ? 16 : 10;\n            charval \u003d Integer.valueOf(numRef, base);\n        } catch (NumberFormatException e) {\n        }\n        if (charval \u003d\u003d -1 || (charval \u003e\u003d 0xD800 \u0026\u0026 charval \u003c\u003d 0xDFFF) || charval \u003e 0x10FFFF) {\n            characterReferenceError(\"character outside of valid range\");\n            return replacementChar;\n        } else {\n            return (char) charval;\n        }\n    } else {\n        String nameRef \u003d reader.consumeLetterThenDigitSequence();\n        String origNameRef \u003d new String(nameRef);\n        boolean looksLegit \u003d reader.matches(\u0027;\u0027);\n        boolean found \u003d false;\n        while (nameRef.length() \u003e 0 \u0026\u0026 !found) {\n            if (Entities.isNamedEntity(nameRef))\n                found \u003d true;\n            else {\n                nameRef \u003d nameRef.substring(0, nameRef.length() - 1);\n                reader.unconsume();\n            }\n        }\n        if (!found) {\n            if (looksLegit)\n                characterReferenceError(String.format(\"invalid named referenece \u0027%s\u0027\", origNameRef));\n            reader.rewindToMark();\n            return null;\n        }\n        if (inAttribute \u0026\u0026 (reader.matchesLetter() || reader.matchesDigit() || reader.matchesAny(\u0027\u003d\u0027, \u0027-\u0027, \u0027_\u0027))) {\n            reader.rewindToMark();\n            return null;\n        }\n        if (!reader.matchConsume(\";\"))\n            characterReferenceError(\"missing semicolon\");\n        return Entities.getCharacterByName(nameRef);\n    }\n}",
      "path": "src/main/java/org/jsoup/parser/Tokeniser.java",
      "functionStartLine": 100,
      "functionName": "consumeCharacterReference",
      "functionAnnotation": "",
      "functionDoc": "",
      "diff": "@@ -1,58 +1,58 @@\n Character consumeCharacterReference(Character additionalAllowedCharacter, boolean inAttribute) {\n     if (reader.isEmpty())\n         return null;\n     if (additionalAllowedCharacter !\u003d null \u0026\u0026 additionalAllowedCharacter \u003d\u003d reader.current())\n         return null;\n     if (reader.matchesAny(\u0027\\t\u0027, \u0027\\n\u0027, \u0027\\f\u0027, \u0027 \u0027, \u0027\u003c\u0027, \u0027\u0026\u0027))\n         return null;\n     reader.mark();\n     if (reader.matchConsume(\"#\")) {\n         boolean isHexMode \u003d reader.matchConsumeIgnoreCase(\"X\");\n         String numRef \u003d isHexMode ? reader.consumeHexSequence() : reader.consumeDigitSequence();\n         if (numRef.length() \u003d\u003d 0) {\n             characterReferenceError(\"numeric reference with no numerals\");\n             reader.rewindToMark();\n             return null;\n         }\n         if (!reader.matchConsume(\";\"))\n             characterReferenceError(\"missing semicolon\");\n         int charval \u003d -1;\n         try {\n             int base \u003d isHexMode ? 16 : 10;\n             charval \u003d Integer.valueOf(numRef, base);\n         } catch (NumberFormatException e) {\n         }\n         if (charval \u003d\u003d -1 || (charval \u003e\u003d 0xD800 \u0026\u0026 charval \u003c\u003d 0xDFFF) || charval \u003e 0x10FFFF) {\n             characterReferenceError(\"character outside of valid range\");\n             return replacementChar;\n         } else {\n             return (char) charval;\n         }\n     } else {\n-        String nameRef \u003d reader.consumeLetterSequence();\n+        String nameRef \u003d reader.consumeLetterThenDigitSequence();\n         String origNameRef \u003d new String(nameRef);\n         boolean looksLegit \u003d reader.matches(\u0027;\u0027);\n         boolean found \u003d false;\n         while (nameRef.length() \u003e 0 \u0026\u0026 !found) {\n             if (Entities.isNamedEntity(nameRef))\n                 found \u003d true;\n             else {\n                 nameRef \u003d nameRef.substring(0, nameRef.length() - 1);\n                 reader.unconsume();\n             }\n         }\n         if (!found) {\n             if (looksLegit)\n                 characterReferenceError(String.format(\"invalid named referenece \u0027%s\u0027\", origNameRef));\n             reader.rewindToMark();\n             return null;\n         }\n         if (inAttribute \u0026\u0026 (reader.matchesLetter() || reader.matchesDigit() || reader.matchesAny(\u0027\u003d\u0027, \u0027-\u0027, \u0027_\u0027))) {\n             reader.rewindToMark();\n             return null;\n         }\n         if (!reader.matchConsume(\";\"))\n             characterReferenceError(\"missing semicolon\");\n         return Entities.getCharacterByName(nameRef);\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "be94f5547d6b8f15ee48117afe46ae302c361464": {
      "type": "Ybodychange",
      "commitMessage": "Added support to optionally keep track of errors while tokenising and tree-building.\n",
      "commitDate": "3/19/12, 9:02 PM",
      "commitName": "be94f5547d6b8f15ee48117afe46ae302c361464",
      "commitAuthor": "Jonathan Hedley",
      "commitDateOld": "8/27/11, 9:13 PM",
      "commitNameOld": "d0418222830f42f4f0c770e406f71454ea50e56d",
      "commitAuthorOld": "Jonathan Hedley",
      "daysBetweenCommits": 204.99,
      "commitsBetweenForRepo": 19,
      "commitsBetweenForFile": 1,
      "actualSource": "Character consumeCharacterReference(Character additionalAllowedCharacter, boolean inAttribute) {\n    if (reader.isEmpty())\n        return null;\n    if (additionalAllowedCharacter !\u003d null \u0026\u0026 additionalAllowedCharacter \u003d\u003d reader.current())\n        return null;\n    if (reader.matchesAny(\u0027\\t\u0027, \u0027\\n\u0027, \u0027\\f\u0027, \u0027 \u0027, \u0027\u003c\u0027, \u0027\u0026\u0027))\n        return null;\n    reader.mark();\n    if (reader.matchConsume(\"#\")) {\n        boolean isHexMode \u003d reader.matchConsumeIgnoreCase(\"X\");\n        String numRef \u003d isHexMode ? reader.consumeHexSequence() : reader.consumeDigitSequence();\n        if (numRef.length() \u003d\u003d 0) {\n            characterReferenceError(\"numeric reference with no numerals\");\n            reader.rewindToMark();\n            return null;\n        }\n        if (!reader.matchConsume(\";\"))\n            characterReferenceError(\"missing semicolon\");\n        int charval \u003d -1;\n        try {\n            int base \u003d isHexMode ? 16 : 10;\n            charval \u003d Integer.valueOf(numRef, base);\n        } catch (NumberFormatException e) {\n        }\n        if (charval \u003d\u003d -1 || (charval \u003e\u003d 0xD800 \u0026\u0026 charval \u003c\u003d 0xDFFF) || charval \u003e 0x10FFFF) {\n            characterReferenceError(\"character outside of valid range\");\n            return replacementChar;\n        } else {\n            return (char) charval;\n        }\n    } else {\n        String nameRef \u003d reader.consumeLetterSequence();\n        String origNameRef \u003d new String(nameRef);\n        boolean looksLegit \u003d reader.matches(\u0027;\u0027);\n        boolean found \u003d false;\n        while (nameRef.length() \u003e 0 \u0026\u0026 !found) {\n            if (Entities.isNamedEntity(nameRef))\n                found \u003d true;\n            else {\n                nameRef \u003d nameRef.substring(0, nameRef.length() - 1);\n                reader.unconsume();\n            }\n        }\n        if (!found) {\n            if (looksLegit)\n                characterReferenceError(String.format(\"invalid named referenece \u0027%s\u0027\", origNameRef));\n            reader.rewindToMark();\n            return null;\n        }\n        if (inAttribute \u0026\u0026 (reader.matchesLetter() || reader.matchesDigit() || reader.matchesAny(\u0027\u003d\u0027, \u0027-\u0027, \u0027_\u0027))) {\n            reader.rewindToMark();\n            return null;\n        }\n        if (!reader.matchConsume(\";\"))\n            characterReferenceError(\"missing semicolon\");\n        return Entities.getCharacterByName(nameRef);\n    }\n}",
      "path": "src/main/java/org/jsoup/parser/Tokeniser.java",
      "functionStartLine": 102,
      "functionName": "consumeCharacterReference",
      "functionAnnotation": "",
      "functionDoc": "",
      "diff": "@@ -1,57 +1,58 @@\n Character consumeCharacterReference(Character additionalAllowedCharacter, boolean inAttribute) {\n     if (reader.isEmpty())\n         return null;\n     if (additionalAllowedCharacter !\u003d null \u0026\u0026 additionalAllowedCharacter \u003d\u003d reader.current())\n         return null;\n     if (reader.matchesAny(\u0027\\t\u0027, \u0027\\n\u0027, \u0027\\f\u0027, \u0027 \u0027, \u0027\u003c\u0027, \u0027\u0026\u0027))\n         return null;\n     reader.mark();\n     if (reader.matchConsume(\"#\")) {\n         boolean isHexMode \u003d reader.matchConsumeIgnoreCase(\"X\");\n         String numRef \u003d isHexMode ? reader.consumeHexSequence() : reader.consumeDigitSequence();\n         if (numRef.length() \u003d\u003d 0) {\n-            characterReferenceError();\n+            characterReferenceError(\"numeric reference with no numerals\");\n             reader.rewindToMark();\n             return null;\n         }\n         if (!reader.matchConsume(\";\"))\n-            characterReferenceError();\n+            characterReferenceError(\"missing semicolon\");\n         int charval \u003d -1;\n         try {\n             int base \u003d isHexMode ? 16 : 10;\n             charval \u003d Integer.valueOf(numRef, base);\n         } catch (NumberFormatException e) {\n         }\n         if (charval \u003d\u003d -1 || (charval \u003e\u003d 0xD800 \u0026\u0026 charval \u003c\u003d 0xDFFF) || charval \u003e 0x10FFFF) {\n-            characterReferenceError();\n+            characterReferenceError(\"character outside of valid range\");\n             return replacementChar;\n         } else {\n             return (char) charval;\n         }\n     } else {\n         String nameRef \u003d reader.consumeLetterSequence();\n+        String origNameRef \u003d new String(nameRef);\n         boolean looksLegit \u003d reader.matches(\u0027;\u0027);\n         boolean found \u003d false;\n         while (nameRef.length() \u003e 0 \u0026\u0026 !found) {\n             if (Entities.isNamedEntity(nameRef))\n                 found \u003d true;\n             else {\n                 nameRef \u003d nameRef.substring(0, nameRef.length() - 1);\n                 reader.unconsume();\n             }\n         }\n         if (!found) {\n             if (looksLegit)\n-                characterReferenceError();\n+                characterReferenceError(String.format(\"invalid named referenece \u0027%s\u0027\", origNameRef));\n             reader.rewindToMark();\n             return null;\n         }\n         if (inAttribute \u0026\u0026 (reader.matchesLetter() || reader.matchesDigit() || reader.matchesAny(\u0027\u003d\u0027, \u0027-\u0027, \u0027_\u0027))) {\n             reader.rewindToMark();\n             return null;\n         }\n         if (!reader.matchConsume(\";\"))\n-            characterReferenceError();\n+            characterReferenceError(\"missing semicolon\");\n         return Entities.getCharacterByName(nameRef);\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "d0418222830f42f4f0c770e406f71454ea50e56d": {
      "type": "Ybodychange",
      "commitMessage": "Tweaked escaped entity detection in attributes to not treat \u0026entity_... as an entity form.\n",
      "commitDate": "8/27/11, 9:13 PM",
      "commitName": "d0418222830f42f4f0c770e406f71454ea50e56d",
      "commitAuthor": "Jonathan Hedley",
      "commitDateOld": "7/2/11, 4:12 AM",
      "commitNameOld": "437d8eca9f51dd0ed7af5b828412ee96ac192f17",
      "commitAuthorOld": "Jonathan Hedley",
      "daysBetweenCommits": 56.71,
      "commitsBetweenForRepo": 34,
      "commitsBetweenForFile": 1,
      "actualSource": "Character consumeCharacterReference(Character additionalAllowedCharacter, boolean inAttribute) {\n    if (reader.isEmpty())\n        return null;\n    if (additionalAllowedCharacter !\u003d null \u0026\u0026 additionalAllowedCharacter \u003d\u003d reader.current())\n        return null;\n    if (reader.matchesAny(\u0027\\t\u0027, \u0027\\n\u0027, \u0027\\f\u0027, \u0027 \u0027, \u0027\u003c\u0027, \u0027\u0026\u0027))\n        return null;\n    reader.mark();\n    if (reader.matchConsume(\"#\")) {\n        boolean isHexMode \u003d reader.matchConsumeIgnoreCase(\"X\");\n        String numRef \u003d isHexMode ? reader.consumeHexSequence() : reader.consumeDigitSequence();\n        if (numRef.length() \u003d\u003d 0) {\n            characterReferenceError();\n            reader.rewindToMark();\n            return null;\n        }\n        if (!reader.matchConsume(\";\"))\n            characterReferenceError();\n        int charval \u003d -1;\n        try {\n            int base \u003d isHexMode ? 16 : 10;\n            charval \u003d Integer.valueOf(numRef, base);\n        } catch (NumberFormatException e) {\n        }\n        if (charval \u003d\u003d -1 || (charval \u003e\u003d 0xD800 \u0026\u0026 charval \u003c\u003d 0xDFFF) || charval \u003e 0x10FFFF) {\n            characterReferenceError();\n            return replacementChar;\n        } else {\n            return (char) charval;\n        }\n    } else {\n        String nameRef \u003d reader.consumeLetterSequence();\n        boolean looksLegit \u003d reader.matches(\u0027;\u0027);\n        boolean found \u003d false;\n        while (nameRef.length() \u003e 0 \u0026\u0026 !found) {\n            if (Entities.isNamedEntity(nameRef))\n                found \u003d true;\n            else {\n                nameRef \u003d nameRef.substring(0, nameRef.length() - 1);\n                reader.unconsume();\n            }\n        }\n        if (!found) {\n            if (looksLegit)\n                characterReferenceError();\n            reader.rewindToMark();\n            return null;\n        }\n        if (inAttribute \u0026\u0026 (reader.matchesLetter() || reader.matchesDigit() || reader.matchesAny(\u0027\u003d\u0027, \u0027-\u0027, \u0027_\u0027))) {\n            reader.rewindToMark();\n            return null;\n        }\n        if (!reader.matchConsume(\";\"))\n            characterReferenceError();\n        return Entities.getCharacterByName(nameRef);\n    }\n}",
      "path": "src/main/java/org/jsoup/parser/Tokeniser.java",
      "functionStartLine": 100,
      "functionName": "consumeCharacterReference",
      "functionAnnotation": "",
      "functionDoc": "",
      "diff": "@@ -1,57 +1,57 @@\n Character consumeCharacterReference(Character additionalAllowedCharacter, boolean inAttribute) {\n     if (reader.isEmpty())\n         return null;\n     if (additionalAllowedCharacter !\u003d null \u0026\u0026 additionalAllowedCharacter \u003d\u003d reader.current())\n         return null;\n-    if (reader.matchesAny(\u0027\\t\u0027, \u0027\\n\u0027, \u0027\\f\u0027, \u0027\u003c\u0027, \u0027\u0026\u0027))\n+    if (reader.matchesAny(\u0027\\t\u0027, \u0027\\n\u0027, \u0027\\f\u0027, \u0027 \u0027, \u0027\u003c\u0027, \u0027\u0026\u0027))\n         return null;\n     reader.mark();\n     if (reader.matchConsume(\"#\")) {\n         boolean isHexMode \u003d reader.matchConsumeIgnoreCase(\"X\");\n         String numRef \u003d isHexMode ? reader.consumeHexSequence() : reader.consumeDigitSequence();\n         if (numRef.length() \u003d\u003d 0) {\n             characterReferenceError();\n             reader.rewindToMark();\n             return null;\n         }\n         if (!reader.matchConsume(\";\"))\n             characterReferenceError();\n         int charval \u003d -1;\n         try {\n             int base \u003d isHexMode ? 16 : 10;\n             charval \u003d Integer.valueOf(numRef, base);\n         } catch (NumberFormatException e) {\n         }\n         if (charval \u003d\u003d -1 || (charval \u003e\u003d 0xD800 \u0026\u0026 charval \u003c\u003d 0xDFFF) || charval \u003e 0x10FFFF) {\n             characterReferenceError();\n             return replacementChar;\n         } else {\n             return (char) charval;\n         }\n     } else {\n         String nameRef \u003d reader.consumeLetterSequence();\n         boolean looksLegit \u003d reader.matches(\u0027;\u0027);\n         boolean found \u003d false;\n         while (nameRef.length() \u003e 0 \u0026\u0026 !found) {\n             if (Entities.isNamedEntity(nameRef))\n                 found \u003d true;\n             else {\n                 nameRef \u003d nameRef.substring(0, nameRef.length() - 1);\n                 reader.unconsume();\n             }\n         }\n         if (!found) {\n             if (looksLegit)\n                 characterReferenceError();\n             reader.rewindToMark();\n             return null;\n         }\n-        if (inAttribute \u0026\u0026 (reader.matchesLetter() || reader.matchesDigit() || reader.matches(\u0027\u003d\u0027))) {\n+        if (inAttribute \u0026\u0026 (reader.matchesLetter() || reader.matchesDigit() || reader.matchesAny(\u0027\u003d\u0027, \u0027-\u0027, \u0027_\u0027))) {\n             reader.rewindToMark();\n             return null;\n         }\n         if (!reader.matchConsume(\";\"))\n             characterReferenceError();\n         return Entities.getCharacterByName(nameRef);\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "8749726a79c22451b1f01b14fb2137f734e926b4": {
      "type": "Yintroduced",
      "commitMessage": "Reimplementation of parser and tokeniser, to make jsoup a HTML5 conformat parser, against the\nhttp://whatwg.org/html spec.\n",
      "commitDate": "7/2/11, 4:12 AM",
      "commitName": "8749726a79c22451b1f01b14fb2137f734e926b4",
      "commitAuthor": "Jonathan Hedley",
      "diff": "@@ -0,0 +1,57 @@\n+Character consumeCharacterReference(Character additionalAllowedCharacter, boolean inAttribute) {\n+    if (reader.isEmpty())\n+        return null;\n+    if (additionalAllowedCharacter !\u003d null \u0026\u0026 additionalAllowedCharacter \u003d\u003d reader.current())\n+        return null;\n+    if (reader.matchesAny(\u0027\\t\u0027, \u0027\\n\u0027, \u0027\\f\u0027, \u0027\u003c\u0027, \u0027\u0026\u0027))\n+        return null;\n+    reader.mark();\n+    if (reader.matchConsume(\"#\")) {\n+        boolean isHexMode \u003d reader.matchConsumeIgnoreCase(\"X\");\n+        String numRef \u003d isHexMode ? reader.consumeHexSequence() : reader.consumeDigitSequence();\n+        if (numRef.length() \u003d\u003d 0) {\n+            characterReferenceError();\n+            reader.rewindToMark();\n+            return null;\n+        }\n+        if (!reader.matchConsume(\";\"))\n+            characterReferenceError();\n+        int charval \u003d -1;\n+        try {\n+            int base \u003d isHexMode ? 16 : 10;\n+            charval \u003d Integer.valueOf(numRef, base);\n+        } catch (NumberFormatException e) {\n+        }\n+        if (charval \u003d\u003d -1 || (charval \u003e\u003d 0xD800 \u0026\u0026 charval \u003c\u003d 0xDFFF) || charval \u003e 0x10FFFF) {\n+            characterReferenceError();\n+            return replacementChar;\n+        } else {\n+            return (char) charval;\n+        }\n+    } else {\n+        String nameRef \u003d reader.consumeLetterSequence();\n+        boolean looksLegit \u003d reader.matches(\u0027;\u0027);\n+        boolean found \u003d false;\n+        while (nameRef.length() \u003e 0 \u0026\u0026 !found) {\n+            if (Entities.isNamedEntity(nameRef))\n+                found \u003d true;\n+            else {\n+                nameRef \u003d nameRef.substring(0, nameRef.length() - 1);\n+                reader.unconsume();\n+            }\n+        }\n+        if (!found) {\n+            if (looksLegit)\n+                characterReferenceError();\n+            reader.rewindToMark();\n+            return null;\n+        }\n+        if (inAttribute \u0026\u0026 (reader.matchesLetter() || reader.matchesDigit() || reader.matches(\u0027\u003d\u0027))) {\n+            reader.rewindToMark();\n+            return null;\n+        }\n+        if (!reader.matchConsume(\";\"))\n+            characterReferenceError();\n+        return Entities.getCharacterByName(nameRef);\n+    }\n+}\n\\ No newline at end of file\n",
      "actualSource": "Character consumeCharacterReference(Character additionalAllowedCharacter, boolean inAttribute) {\n    if (reader.isEmpty())\n        return null;\n    if (additionalAllowedCharacter !\u003d null \u0026\u0026 additionalAllowedCharacter \u003d\u003d reader.current())\n        return null;\n    if (reader.matchesAny(\u0027\\t\u0027, \u0027\\n\u0027, \u0027\\f\u0027, \u0027\u003c\u0027, \u0027\u0026\u0027))\n        return null;\n    reader.mark();\n    if (reader.matchConsume(\"#\")) {\n        boolean isHexMode \u003d reader.matchConsumeIgnoreCase(\"X\");\n        String numRef \u003d isHexMode ? reader.consumeHexSequence() : reader.consumeDigitSequence();\n        if (numRef.length() \u003d\u003d 0) {\n            characterReferenceError();\n            reader.rewindToMark();\n            return null;\n        }\n        if (!reader.matchConsume(\";\"))\n            characterReferenceError();\n        int charval \u003d -1;\n        try {\n            int base \u003d isHexMode ? 16 : 10;\n            charval \u003d Integer.valueOf(numRef, base);\n        } catch (NumberFormatException e) {\n        }\n        if (charval \u003d\u003d -1 || (charval \u003e\u003d 0xD800 \u0026\u0026 charval \u003c\u003d 0xDFFF) || charval \u003e 0x10FFFF) {\n            characterReferenceError();\n            return replacementChar;\n        } else {\n            return (char) charval;\n        }\n    } else {\n        String nameRef \u003d reader.consumeLetterSequence();\n        boolean looksLegit \u003d reader.matches(\u0027;\u0027);\n        boolean found \u003d false;\n        while (nameRef.length() \u003e 0 \u0026\u0026 !found) {\n            if (Entities.isNamedEntity(nameRef))\n                found \u003d true;\n            else {\n                nameRef \u003d nameRef.substring(0, nameRef.length() - 1);\n                reader.unconsume();\n            }\n        }\n        if (!found) {\n            if (looksLegit)\n                characterReferenceError();\n            reader.rewindToMark();\n            return null;\n        }\n        if (inAttribute \u0026\u0026 (reader.matchesLetter() || reader.matchesDigit() || reader.matches(\u0027\u003d\u0027))) {\n            reader.rewindToMark();\n            return null;\n        }\n        if (!reader.matchConsume(\";\"))\n            characterReferenceError();\n        return Entities.getCharacterByName(nameRef);\n    }\n}",
      "path": "src/main/java/org/jsoup/parser/Tokeniser.java",
      "functionStartLine": 100,
      "functionName": "consumeCharacterReference",
      "functionAnnotation": "",
      "functionDoc": ""
    }
  }
}