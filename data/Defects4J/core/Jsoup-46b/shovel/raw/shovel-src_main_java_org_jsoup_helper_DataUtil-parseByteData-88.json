{
  "origin": "codeshovel",
  "repositoryName": "Jsoup-46b",
  "repositoryPath": "/tmp/Jsoup-46b//.git",
  "startCommitName": "HEAD",
  "sourceFileName": "DataUtil.java",
  "functionName": "parseByteData",
  "functionId": "parseByteData___byteData-ByteBuffer__charsetName-String__baseUri-String__parser-Parser",
  "sourceFilePath": "src/main/java/org/jsoup/helper/DataUtil.java",
  "functionAnnotation": "",
  "functionDoc": "",
  "functionStartLine": 88,
  "functionEndLine": 136,
  "numCommitsSeen": 37,
  "timeTaken": 746,
  "changeHistory": [
    "ee613b20b926b31f532cda4fb3ee115db950e9a1",
    "0993f66ce330ccfbd84a65005ed1b2f1ae167d81",
    "3f9f33d88355f22aefc7ea402da09fd1950289ce",
    "f052908ec90e12bdc6b67915ef2290aa9eefa48b",
    "398f9cf93414253c216585efdfca3b9f73f90d74",
    "1d31086acba06579c4e7d5928dbba9ca8a0128b1",
    "433d2f180058b8b73e1951c6cfbb986714e68b0f",
    "a14fb16d6430d8de4bf31c898d119ab713840c2d",
    "78d40f41b9567d7e8a0c891f31b7deee2b1f3f19",
    "ce843ec83988e3e3318fa7db38133b06be741a1f"
  ],
  "changeHistoryShort": {
    "ee613b20b926b31f532cda4fb3ee115db950e9a1": "Ybodychange",
    "0993f66ce330ccfbd84a65005ed1b2f1ae167d81": "Ybodychange",
    "3f9f33d88355f22aefc7ea402da09fd1950289ce": "Ybodychange",
    "f052908ec90e12bdc6b67915ef2290aa9eefa48b": "Ybodychange",
    "398f9cf93414253c216585efdfca3b9f73f90d74": "Ybodychange",
    "1d31086acba06579c4e7d5928dbba9ca8a0128b1": "Ybodychange",
    "433d2f180058b8b73e1951c6cfbb986714e68b0f": "Ymultichange(Yparameterchange,Ybodychange)",
    "a14fb16d6430d8de4bf31c898d119ab713840c2d": "Ybodychange",
    "78d40f41b9567d7e8a0c891f31b7deee2b1f3f19": "Ybodychange",
    "ce843ec83988e3e3318fa7db38133b06be741a1f": "Yintroduced"
  },
  "changeHistoryDetails": {
    "ee613b20b926b31f532cda4fb3ee115db950e9a1": {
      "type": "Ybodychange",
      "commitMessage": "Fixed UnsupportedCharsetException for meta charset tags with an unsupported charset.\n",
      "commitDate": "12/16/14, 12:58 PM",
      "commitName": "ee613b20b926b31f532cda4fb3ee115db950e9a1",
      "commitAuthor": "offa",
      "commitDateOld": "10/21/14, 8:46 AM",
      "commitNameOld": "0993f66ce330ccfbd84a65005ed1b2f1ae167d81",
      "commitAuthorOld": "offa",
      "daysBetweenCommits": 56.22,
      "commitsBetweenForRepo": 17,
      "commitsBetweenForFile": 1,
      "actualSource": "static Document parseByteData(ByteBuffer byteData, String charsetName, String baseUri, Parser parser) {\n    String docData;\n    Document doc \u003d null;\n    if (charsetName \u003d\u003d null) {\n        docData \u003d Charset.forName(defaultCharset).decode(byteData).toString();\n        doc \u003d parser.parseInput(docData, baseUri);\n        Element meta \u003d doc.select(\"meta[http-equiv\u003dcontent-type], meta[charset]\").first();\n        if (meta !\u003d null) {\n            String foundCharset \u003d null;\n            if (meta.hasAttr(\"http-equiv\")) {\n                foundCharset \u003d getCharsetFromContentType(meta.attr(\"content\"));\n            }\n            if (foundCharset \u003d\u003d null \u0026\u0026 meta.hasAttr(\"charset\")) {\n                try {\n                    if (Charset.isSupported(meta.attr(\"charset\"))) {\n                        foundCharset \u003d meta.attr(\"charset\");\n                    }\n                } catch (IllegalCharsetNameException e) {\n                    foundCharset \u003d null;\n                }\n            }\n            if (foundCharset !\u003d null \u0026\u0026 foundCharset.length() !\u003d 0 \u0026\u0026 !foundCharset.equals(defaultCharset)) {\n                foundCharset \u003d foundCharset.trim().replaceAll(\"[\\\"\u0027]\", \"\");\n                charsetName \u003d foundCharset;\n                byteData.rewind();\n                docData \u003d Charset.forName(foundCharset).decode(byteData).toString();\n                doc \u003d null;\n            }\n        }\n    } else {\n        Validate.notEmpty(charsetName, \"Must set charset arg to character set of file to parse. Set to null to attempt to detect from HTML\");\n        docData \u003d Charset.forName(charsetName).decode(byteData).toString();\n    }\n    if (docData.length() \u003e 0 \u0026\u0026 docData.charAt(0) \u003d\u003d UNICODE_BOM) {\n        byteData.rewind();\n        docData \u003d Charset.forName(defaultCharset).decode(byteData).toString();\n        docData \u003d docData.substring(1);\n        charsetName \u003d defaultCharset;\n        doc \u003d null;\n    }\n    if (doc \u003d\u003d null) {\n        doc \u003d parser.parseInput(docData, baseUri);\n        doc.outputSettings().charset(charsetName);\n    }\n    return doc;\n}",
      "path": "src/main/java/org/jsoup/helper/DataUtil.java",
      "functionStartLine": 88,
      "functionName": "parseByteData",
      "functionAnnotation": "",
      "functionDoc": "",
      "diff": "@@ -1,48 +1,46 @@\n static Document parseByteData(ByteBuffer byteData, String charsetName, String baseUri, Parser parser) {\n     String docData;\n     Document doc \u003d null;\n     if (charsetName \u003d\u003d null) {\n         docData \u003d Charset.forName(defaultCharset).decode(byteData).toString();\n         doc \u003d parser.parseInput(docData, baseUri);\n         Element meta \u003d doc.select(\"meta[http-equiv\u003dcontent-type], meta[charset]\").first();\n         if (meta !\u003d null) {\n-            String foundCharset;\n+            String foundCharset \u003d null;\n             if (meta.hasAttr(\"http-equiv\")) {\n                 foundCharset \u003d getCharsetFromContentType(meta.attr(\"content\"));\n-                if (foundCharset \u003d\u003d null \u0026\u0026 meta.hasAttr(\"charset\")) {\n-                    try {\n-                        if (Charset.isSupported(meta.attr(\"charset\"))) {\n-                            foundCharset \u003d meta.attr(\"charset\");\n-                        }\n-                    } catch (IllegalCharsetNameException e) {\n-                        foundCharset \u003d null;\n+            }\n+            if (foundCharset \u003d\u003d null \u0026\u0026 meta.hasAttr(\"charset\")) {\n+                try {\n+                    if (Charset.isSupported(meta.attr(\"charset\"))) {\n+                        foundCharset \u003d meta.attr(\"charset\");\n                     }\n+                } catch (IllegalCharsetNameException e) {\n+                    foundCharset \u003d null;\n                 }\n-            } else {\n-                foundCharset \u003d meta.attr(\"charset\");\n             }\n             if (foundCharset !\u003d null \u0026\u0026 foundCharset.length() !\u003d 0 \u0026\u0026 !foundCharset.equals(defaultCharset)) {\n                 foundCharset \u003d foundCharset.trim().replaceAll(\"[\\\"\u0027]\", \"\");\n                 charsetName \u003d foundCharset;\n                 byteData.rewind();\n                 docData \u003d Charset.forName(foundCharset).decode(byteData).toString();\n                 doc \u003d null;\n             }\n         }\n     } else {\n         Validate.notEmpty(charsetName, \"Must set charset arg to character set of file to parse. Set to null to attempt to detect from HTML\");\n         docData \u003d Charset.forName(charsetName).decode(byteData).toString();\n     }\n     if (docData.length() \u003e 0 \u0026\u0026 docData.charAt(0) \u003d\u003d UNICODE_BOM) {\n         byteData.rewind();\n         docData \u003d Charset.forName(defaultCharset).decode(byteData).toString();\n         docData \u003d docData.substring(1);\n         charsetName \u003d defaultCharset;\n         doc \u003d null;\n     }\n     if (doc \u003d\u003d null) {\n         doc \u003d parser.parseInput(docData, baseUri);\n         doc.outputSettings().charset(charsetName);\n     }\n     return doc;\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "0993f66ce330ccfbd84a65005ed1b2f1ae167d81": {
      "type": "Ybodychange",
      "commitMessage": "Replaced unicode BOM \"magic number\" with a constant.\n",
      "commitDate": "10/21/14, 8:46 AM",
      "commitName": "0993f66ce330ccfbd84a65005ed1b2f1ae167d81",
      "commitAuthor": "offa",
      "commitDateOld": "10/7/14, 10:26 PM",
      "commitNameOld": "549ed00198cabb4bc2c4b7989c902d1f1dc887e3",
      "commitAuthorOld": "Jonathan Hedley",
      "daysBetweenCommits": 13.43,
      "commitsBetweenForRepo": 21,
      "commitsBetweenForFile": 1,
      "actualSource": "static Document parseByteData(ByteBuffer byteData, String charsetName, String baseUri, Parser parser) {\n    String docData;\n    Document doc \u003d null;\n    if (charsetName \u003d\u003d null) {\n        docData \u003d Charset.forName(defaultCharset).decode(byteData).toString();\n        doc \u003d parser.parseInput(docData, baseUri);\n        Element meta \u003d doc.select(\"meta[http-equiv\u003dcontent-type], meta[charset]\").first();\n        if (meta !\u003d null) {\n            String foundCharset;\n            if (meta.hasAttr(\"http-equiv\")) {\n                foundCharset \u003d getCharsetFromContentType(meta.attr(\"content\"));\n                if (foundCharset \u003d\u003d null \u0026\u0026 meta.hasAttr(\"charset\")) {\n                    try {\n                        if (Charset.isSupported(meta.attr(\"charset\"))) {\n                            foundCharset \u003d meta.attr(\"charset\");\n                        }\n                    } catch (IllegalCharsetNameException e) {\n                        foundCharset \u003d null;\n                    }\n                }\n            } else {\n                foundCharset \u003d meta.attr(\"charset\");\n            }\n            if (foundCharset !\u003d null \u0026\u0026 foundCharset.length() !\u003d 0 \u0026\u0026 !foundCharset.equals(defaultCharset)) {\n                foundCharset \u003d foundCharset.trim().replaceAll(\"[\\\"\u0027]\", \"\");\n                charsetName \u003d foundCharset;\n                byteData.rewind();\n                docData \u003d Charset.forName(foundCharset).decode(byteData).toString();\n                doc \u003d null;\n            }\n        }\n    } else {\n        Validate.notEmpty(charsetName, \"Must set charset arg to character set of file to parse. Set to null to attempt to detect from HTML\");\n        docData \u003d Charset.forName(charsetName).decode(byteData).toString();\n    }\n    if (docData.length() \u003e 0 \u0026\u0026 docData.charAt(0) \u003d\u003d UNICODE_BOM) {\n        byteData.rewind();\n        docData \u003d Charset.forName(defaultCharset).decode(byteData).toString();\n        docData \u003d docData.substring(1);\n        charsetName \u003d defaultCharset;\n        doc \u003d null;\n    }\n    if (doc \u003d\u003d null) {\n        doc \u003d parser.parseInput(docData, baseUri);\n        doc.outputSettings().charset(charsetName);\n    }\n    return doc;\n}",
      "path": "src/main/java/org/jsoup/helper/DataUtil.java",
      "functionStartLine": 88,
      "functionName": "parseByteData",
      "functionAnnotation": "",
      "functionDoc": "",
      "diff": "@@ -1,48 +1,48 @@\n static Document parseByteData(ByteBuffer byteData, String charsetName, String baseUri, Parser parser) {\n     String docData;\n     Document doc \u003d null;\n     if (charsetName \u003d\u003d null) {\n         docData \u003d Charset.forName(defaultCharset).decode(byteData).toString();\n         doc \u003d parser.parseInput(docData, baseUri);\n         Element meta \u003d doc.select(\"meta[http-equiv\u003dcontent-type], meta[charset]\").first();\n         if (meta !\u003d null) {\n             String foundCharset;\n             if (meta.hasAttr(\"http-equiv\")) {\n                 foundCharset \u003d getCharsetFromContentType(meta.attr(\"content\"));\n                 if (foundCharset \u003d\u003d null \u0026\u0026 meta.hasAttr(\"charset\")) {\n                     try {\n                         if (Charset.isSupported(meta.attr(\"charset\"))) {\n                             foundCharset \u003d meta.attr(\"charset\");\n                         }\n                     } catch (IllegalCharsetNameException e) {\n                         foundCharset \u003d null;\n                     }\n                 }\n             } else {\n                 foundCharset \u003d meta.attr(\"charset\");\n             }\n             if (foundCharset !\u003d null \u0026\u0026 foundCharset.length() !\u003d 0 \u0026\u0026 !foundCharset.equals(defaultCharset)) {\n                 foundCharset \u003d foundCharset.trim().replaceAll(\"[\\\"\u0027]\", \"\");\n                 charsetName \u003d foundCharset;\n                 byteData.rewind();\n                 docData \u003d Charset.forName(foundCharset).decode(byteData).toString();\n                 doc \u003d null;\n             }\n         }\n     } else {\n         Validate.notEmpty(charsetName, \"Must set charset arg to character set of file to parse. Set to null to attempt to detect from HTML\");\n         docData \u003d Charset.forName(charsetName).decode(byteData).toString();\n     }\n-    if (docData.length() \u003e 0 \u0026\u0026 docData.charAt(0) \u003d\u003d 65279) {\n+    if (docData.length() \u003e 0 \u0026\u0026 docData.charAt(0) \u003d\u003d UNICODE_BOM) {\n         byteData.rewind();\n         docData \u003d Charset.forName(defaultCharset).decode(byteData).toString();\n         docData \u003d docData.substring(1);\n         charsetName \u003d defaultCharset;\n         doc \u003d null;\n     }\n     if (doc \u003d\u003d null) {\n         doc \u003d parser.parseInput(docData, baseUri);\n         doc.outputSettings().charset(charsetName);\n     }\n     return doc;\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "3f9f33d88355f22aefc7ea402da09fd1950289ce": {
      "type": "Ybodychange",
      "commitMessage": "Fix issue with UTF-8 BOM when charset only in HTML.\n\nFixes #348\n",
      "commitDate": "11/17/13, 9:12 PM",
      "commitName": "3f9f33d88355f22aefc7ea402da09fd1950289ce",
      "commitAuthor": "Jonathan Hedley",
      "commitDateOld": "11/10/13, 5:18 PM",
      "commitNameOld": "f052908ec90e12bdc6b67915ef2290aa9eefa48b",
      "commitAuthorOld": "fabse",
      "daysBetweenCommits": 7.16,
      "commitsBetweenForRepo": 15,
      "commitsBetweenForFile": 1,
      "actualSource": "static Document parseByteData(ByteBuffer byteData, String charsetName, String baseUri, Parser parser) {\n    String docData;\n    Document doc \u003d null;\n    if (charsetName \u003d\u003d null) {\n        docData \u003d Charset.forName(defaultCharset).decode(byteData).toString();\n        doc \u003d parser.parseInput(docData, baseUri);\n        Element meta \u003d doc.select(\"meta[http-equiv\u003dcontent-type], meta[charset]\").first();\n        if (meta !\u003d null) {\n            String foundCharset;\n            if (meta.hasAttr(\"http-equiv\")) {\n                foundCharset \u003d getCharsetFromContentType(meta.attr(\"content\"));\n                if (foundCharset \u003d\u003d null \u0026\u0026 meta.hasAttr(\"charset\")) {\n                    try {\n                        if (Charset.isSupported(meta.attr(\"charset\"))) {\n                            foundCharset \u003d meta.attr(\"charset\");\n                        }\n                    } catch (IllegalCharsetNameException e) {\n                        foundCharset \u003d null;\n                    }\n                }\n            } else {\n                foundCharset \u003d meta.attr(\"charset\");\n            }\n            if (foundCharset !\u003d null \u0026\u0026 foundCharset.length() !\u003d 0 \u0026\u0026 !foundCharset.equals(defaultCharset)) {\n                foundCharset \u003d foundCharset.trim().replaceAll(\"[\\\"\u0027]\", \"\");\n                charsetName \u003d foundCharset;\n                byteData.rewind();\n                docData \u003d Charset.forName(foundCharset).decode(byteData).toString();\n                doc \u003d null;\n            }\n        }\n    } else {\n        Validate.notEmpty(charsetName, \"Must set charset arg to character set of file to parse. Set to null to attempt to detect from HTML\");\n        docData \u003d Charset.forName(charsetName).decode(byteData).toString();\n    }\n    if (docData.length() \u003e 0 \u0026\u0026 docData.charAt(0) \u003d\u003d 65279) {\n        byteData.rewind();\n        docData \u003d Charset.forName(defaultCharset).decode(byteData).toString();\n        docData \u003d docData.substring(1);\n        charsetName \u003d defaultCharset;\n        doc \u003d null;\n    }\n    if (doc \u003d\u003d null) {\n        doc \u003d parser.parseInput(docData, baseUri);\n        doc.outputSettings().charset(charsetName);\n    }\n    return doc;\n}",
      "path": "src/main/java/org/jsoup/helper/DataUtil.java",
      "functionStartLine": 76,
      "functionName": "parseByteData",
      "functionAnnotation": "",
      "functionDoc": "",
      "diff": "@@ -1,43 +1,48 @@\n static Document parseByteData(ByteBuffer byteData, String charsetName, String baseUri, Parser parser) {\n     String docData;\n     Document doc \u003d null;\n     if (charsetName \u003d\u003d null) {\n         docData \u003d Charset.forName(defaultCharset).decode(byteData).toString();\n         doc \u003d parser.parseInput(docData, baseUri);\n         Element meta \u003d doc.select(\"meta[http-equiv\u003dcontent-type], meta[charset]\").first();\n         if (meta !\u003d null) {\n             String foundCharset;\n             if (meta.hasAttr(\"http-equiv\")) {\n                 foundCharset \u003d getCharsetFromContentType(meta.attr(\"content\"));\n                 if (foundCharset \u003d\u003d null \u0026\u0026 meta.hasAttr(\"charset\")) {\n                     try {\n                         if (Charset.isSupported(meta.attr(\"charset\"))) {\n                             foundCharset \u003d meta.attr(\"charset\");\n                         }\n                     } catch (IllegalCharsetNameException e) {\n                         foundCharset \u003d null;\n                     }\n                 }\n             } else {\n                 foundCharset \u003d meta.attr(\"charset\");\n             }\n             if (foundCharset !\u003d null \u0026\u0026 foundCharset.length() !\u003d 0 \u0026\u0026 !foundCharset.equals(defaultCharset)) {\n                 foundCharset \u003d foundCharset.trim().replaceAll(\"[\\\"\u0027]\", \"\");\n                 charsetName \u003d foundCharset;\n                 byteData.rewind();\n                 docData \u003d Charset.forName(foundCharset).decode(byteData).toString();\n                 doc \u003d null;\n             }\n         }\n     } else {\n         Validate.notEmpty(charsetName, \"Must set charset arg to character set of file to parse. Set to null to attempt to detect from HTML\");\n         docData \u003d Charset.forName(charsetName).decode(byteData).toString();\n     }\n+    if (docData.length() \u003e 0 \u0026\u0026 docData.charAt(0) \u003d\u003d 65279) {\n+        byteData.rewind();\n+        docData \u003d Charset.forName(defaultCharset).decode(byteData).toString();\n+        docData \u003d docData.substring(1);\n+        charsetName \u003d defaultCharset;\n+        doc \u003d null;\n+    }\n     if (doc \u003d\u003d null) {\n-        if (docData.length() \u003e 0 \u0026\u0026 docData.charAt(0) \u003d\u003d 65279)\n-            docData \u003d docData.substring(1);\n         doc \u003d parser.parseInput(docData, baseUri);\n         doc.outputSettings().charset(charsetName);\n     }\n     return doc;\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "f052908ec90e12bdc6b67915ef2290aa9eefa48b": {
      "type": "Ybodychange",
      "commitMessage": "Make http charset detection code more robust\n\nFixes #321\n",
      "commitDate": "11/10/13, 5:18 PM",
      "commitName": "f052908ec90e12bdc6b67915ef2290aa9eefa48b",
      "commitAuthor": "fabse",
      "commitDateOld": "12/11/12, 2:51 AM",
      "commitNameOld": "f9f37e19876202a1db257a9e59452b0f10035fbf",
      "commitAuthorOld": "Jonathan Hedley",
      "daysBetweenCommits": 334.6,
      "commitsBetweenForRepo": 52,
      "commitsBetweenForFile": 1,
      "actualSource": "static Document parseByteData(ByteBuffer byteData, String charsetName, String baseUri, Parser parser) {\n    String docData;\n    Document doc \u003d null;\n    if (charsetName \u003d\u003d null) {\n        docData \u003d Charset.forName(defaultCharset).decode(byteData).toString();\n        doc \u003d parser.parseInput(docData, baseUri);\n        Element meta \u003d doc.select(\"meta[http-equiv\u003dcontent-type], meta[charset]\").first();\n        if (meta !\u003d null) {\n            String foundCharset;\n            if (meta.hasAttr(\"http-equiv\")) {\n                foundCharset \u003d getCharsetFromContentType(meta.attr(\"content\"));\n                if (foundCharset \u003d\u003d null \u0026\u0026 meta.hasAttr(\"charset\")) {\n                    try {\n                        if (Charset.isSupported(meta.attr(\"charset\"))) {\n                            foundCharset \u003d meta.attr(\"charset\");\n                        }\n                    } catch (IllegalCharsetNameException e) {\n                        foundCharset \u003d null;\n                    }\n                }\n            } else {\n                foundCharset \u003d meta.attr(\"charset\");\n            }\n            if (foundCharset !\u003d null \u0026\u0026 foundCharset.length() !\u003d 0 \u0026\u0026 !foundCharset.equals(defaultCharset)) {\n                foundCharset \u003d foundCharset.trim().replaceAll(\"[\\\"\u0027]\", \"\");\n                charsetName \u003d foundCharset;\n                byteData.rewind();\n                docData \u003d Charset.forName(foundCharset).decode(byteData).toString();\n                doc \u003d null;\n            }\n        }\n    } else {\n        Validate.notEmpty(charsetName, \"Must set charset arg to character set of file to parse. Set to null to attempt to detect from HTML\");\n        docData \u003d Charset.forName(charsetName).decode(byteData).toString();\n    }\n    if (doc \u003d\u003d null) {\n        if (docData.length() \u003e 0 \u0026\u0026 docData.charAt(0) \u003d\u003d 65279)\n            docData \u003d docData.substring(1);\n        doc \u003d parser.parseInput(docData, baseUri);\n        doc.outputSettings().charset(charsetName);\n    }\n    return doc;\n}",
      "path": "src/main/java/org/jsoup/helper/DataUtil.java",
      "functionStartLine": 75,
      "functionName": "parseByteData",
      "functionAnnotation": "",
      "functionDoc": "",
      "diff": "@@ -1,28 +1,43 @@\n static Document parseByteData(ByteBuffer byteData, String charsetName, String baseUri, Parser parser) {\n     String docData;\n     Document doc \u003d null;\n     if (charsetName \u003d\u003d null) {\n         docData \u003d Charset.forName(defaultCharset).decode(byteData).toString();\n         doc \u003d parser.parseInput(docData, baseUri);\n         Element meta \u003d doc.select(\"meta[http-equiv\u003dcontent-type], meta[charset]\").first();\n         if (meta !\u003d null) {\n-            String foundCharset \u003d meta.hasAttr(\"http-equiv\") ? getCharsetFromContentType(meta.attr(\"content\")) : meta.attr(\"charset\");\n+            String foundCharset;\n+            if (meta.hasAttr(\"http-equiv\")) {\n+                foundCharset \u003d getCharsetFromContentType(meta.attr(\"content\"));\n+                if (foundCharset \u003d\u003d null \u0026\u0026 meta.hasAttr(\"charset\")) {\n+                    try {\n+                        if (Charset.isSupported(meta.attr(\"charset\"))) {\n+                            foundCharset \u003d meta.attr(\"charset\");\n+                        }\n+                    } catch (IllegalCharsetNameException e) {\n+                        foundCharset \u003d null;\n+                    }\n+                }\n+            } else {\n+                foundCharset \u003d meta.attr(\"charset\");\n+            }\n             if (foundCharset !\u003d null \u0026\u0026 foundCharset.length() !\u003d 0 \u0026\u0026 !foundCharset.equals(defaultCharset)) {\n+                foundCharset \u003d foundCharset.trim().replaceAll(\"[\\\"\u0027]\", \"\");\n                 charsetName \u003d foundCharset;\n                 byteData.rewind();\n                 docData \u003d Charset.forName(foundCharset).decode(byteData).toString();\n                 doc \u003d null;\n             }\n         }\n     } else {\n         Validate.notEmpty(charsetName, \"Must set charset arg to character set of file to parse. Set to null to attempt to detect from HTML\");\n         docData \u003d Charset.forName(charsetName).decode(byteData).toString();\n     }\n     if (doc \u003d\u003d null) {\n         if (docData.length() \u003e 0 \u0026\u0026 docData.charAt(0) \u003d\u003d 65279)\n             docData \u003d docData.substring(1);\n         doc \u003d parser.parseInput(docData, baseUri);\n         doc.outputSettings().charset(charsetName);\n     }\n     return doc;\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "398f9cf93414253c216585efdfca3b9f73f90d74": {
      "type": "Ybodychange",
      "commitMessage": "In DataUtil, check if body length \u003e 0 before looking at docData\n\nPrevents a string out of bounds exception.\n\nFixes #230\n",
      "commitDate": "9/21/12, 8:11 PM",
      "commitName": "398f9cf93414253c216585efdfca3b9f73f90d74",
      "commitAuthor": "Jonathan Hedley",
      "commitDateOld": "7/18/12, 10:33 PM",
      "commitNameOld": "8963e2ac79a97e694c388622e935a0471267e9eb",
      "commitAuthorOld": "Jonathan Hedley",
      "daysBetweenCommits": 64.9,
      "commitsBetweenForRepo": 3,
      "commitsBetweenForFile": 1,
      "actualSource": "static Document parseByteData(ByteBuffer byteData, String charsetName, String baseUri, Parser parser) {\n    String docData;\n    Document doc \u003d null;\n    if (charsetName \u003d\u003d null) {\n        docData \u003d Charset.forName(defaultCharset).decode(byteData).toString();\n        doc \u003d parser.parseInput(docData, baseUri);\n        Element meta \u003d doc.select(\"meta[http-equiv\u003dcontent-type], meta[charset]\").first();\n        if (meta !\u003d null) {\n            String foundCharset \u003d meta.hasAttr(\"http-equiv\") ? getCharsetFromContentType(meta.attr(\"content\")) : meta.attr(\"charset\");\n            if (foundCharset !\u003d null \u0026\u0026 foundCharset.length() !\u003d 0 \u0026\u0026 !foundCharset.equals(defaultCharset)) {\n                charsetName \u003d foundCharset;\n                byteData.rewind();\n                docData \u003d Charset.forName(foundCharset).decode(byteData).toString();\n                doc \u003d null;\n            }\n        }\n    } else {\n        Validate.notEmpty(charsetName, \"Must set charset arg to character set of file to parse. Set to null to attempt to detect from HTML\");\n        docData \u003d Charset.forName(charsetName).decode(byteData).toString();\n    }\n    if (doc \u003d\u003d null) {\n        if (docData.length() \u003e 0 \u0026\u0026 docData.charAt(0) \u003d\u003d 65279)\n            docData \u003d docData.substring(1);\n        doc \u003d parser.parseInput(docData, baseUri);\n        doc.outputSettings().charset(charsetName);\n    }\n    return doc;\n}",
      "path": "src/main/java/org/jsoup/helper/DataUtil.java",
      "functionStartLine": 74,
      "functionName": "parseByteData",
      "functionAnnotation": "",
      "functionDoc": "",
      "diff": "@@ -1,28 +1,28 @@\n static Document parseByteData(ByteBuffer byteData, String charsetName, String baseUri, Parser parser) {\n     String docData;\n     Document doc \u003d null;\n     if (charsetName \u003d\u003d null) {\n         docData \u003d Charset.forName(defaultCharset).decode(byteData).toString();\n         doc \u003d parser.parseInput(docData, baseUri);\n         Element meta \u003d doc.select(\"meta[http-equiv\u003dcontent-type], meta[charset]\").first();\n         if (meta !\u003d null) {\n             String foundCharset \u003d meta.hasAttr(\"http-equiv\") ? getCharsetFromContentType(meta.attr(\"content\")) : meta.attr(\"charset\");\n             if (foundCharset !\u003d null \u0026\u0026 foundCharset.length() !\u003d 0 \u0026\u0026 !foundCharset.equals(defaultCharset)) {\n                 charsetName \u003d foundCharset;\n                 byteData.rewind();\n                 docData \u003d Charset.forName(foundCharset).decode(byteData).toString();\n                 doc \u003d null;\n             }\n         }\n     } else {\n         Validate.notEmpty(charsetName, \"Must set charset arg to character set of file to parse. Set to null to attempt to detect from HTML\");\n         docData \u003d Charset.forName(charsetName).decode(byteData).toString();\n     }\n     if (doc \u003d\u003d null) {\n-        if (docData.charAt(0) \u003d\u003d 65279)\n+        if (docData.length() \u003e 0 \u0026\u0026 docData.charAt(0) \u003d\u003d 65279)\n             docData \u003d docData.substring(1);\n         doc \u003d parser.parseInput(docData, baseUri);\n         doc.outputSettings().charset(charsetName);\n     }\n     return doc;\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "1d31086acba06579c4e7d5928dbba9ca8a0128b1": {
      "type": "Ybodychange",
      "commitMessage": "Drop BOM at start of byte data if present after decode.\n\nFixes #134.\n",
      "commitDate": "3/25/12, 9:57 PM",
      "commitName": "1d31086acba06579c4e7d5928dbba9ca8a0128b1",
      "commitAuthor": "Jonathan Hedley",
      "commitDateOld": "2/27/12, 8:55 PM",
      "commitNameOld": "433d2f180058b8b73e1951c6cfbb986714e68b0f",
      "commitAuthorOld": "Jonathan Hedley",
      "daysBetweenCommits": 27.0,
      "commitsBetweenForRepo": 12,
      "commitsBetweenForFile": 1,
      "actualSource": "static Document parseByteData(ByteBuffer byteData, String charsetName, String baseUri, Parser parser) {\n    String docData;\n    Document doc \u003d null;\n    if (charsetName \u003d\u003d null) {\n        docData \u003d Charset.forName(defaultCharset).decode(byteData).toString();\n        doc \u003d parser.parseInput(docData, baseUri);\n        Element meta \u003d doc.select(\"meta[http-equiv\u003dcontent-type], meta[charset]\").first();\n        if (meta !\u003d null) {\n            String foundCharset \u003d meta.hasAttr(\"http-equiv\") ? getCharsetFromContentType(meta.attr(\"content\")) : meta.attr(\"charset\");\n            if (foundCharset !\u003d null \u0026\u0026 foundCharset.length() !\u003d 0 \u0026\u0026 !foundCharset.equals(defaultCharset)) {\n                charsetName \u003d foundCharset;\n                byteData.rewind();\n                docData \u003d Charset.forName(foundCharset).decode(byteData).toString();\n                doc \u003d null;\n            }\n        }\n    } else {\n        Validate.notEmpty(charsetName, \"Must set charset arg to character set of file to parse. Set to null to attempt to detect from HTML\");\n        docData \u003d Charset.forName(charsetName).decode(byteData).toString();\n    }\n    if (doc \u003d\u003d null) {\n        if (docData.charAt(0) \u003d\u003d 65279)\n            docData \u003d docData.substring(1);\n        doc \u003d parser.parseInput(docData, baseUri);\n        doc.outputSettings().charset(charsetName);\n    }\n    return doc;\n}",
      "path": "src/main/java/org/jsoup/helper/DataUtil.java",
      "functionStartLine": 73,
      "functionName": "parseByteData",
      "functionAnnotation": "",
      "functionDoc": "",
      "diff": "@@ -1,26 +1,28 @@\n static Document parseByteData(ByteBuffer byteData, String charsetName, String baseUri, Parser parser) {\n     String docData;\n     Document doc \u003d null;\n     if (charsetName \u003d\u003d null) {\n         docData \u003d Charset.forName(defaultCharset).decode(byteData).toString();\n         doc \u003d parser.parseInput(docData, baseUri);\n         Element meta \u003d doc.select(\"meta[http-equiv\u003dcontent-type], meta[charset]\").first();\n         if (meta !\u003d null) {\n             String foundCharset \u003d meta.hasAttr(\"http-equiv\") ? getCharsetFromContentType(meta.attr(\"content\")) : meta.attr(\"charset\");\n             if (foundCharset !\u003d null \u0026\u0026 foundCharset.length() !\u003d 0 \u0026\u0026 !foundCharset.equals(defaultCharset)) {\n                 charsetName \u003d foundCharset;\n                 byteData.rewind();\n                 docData \u003d Charset.forName(foundCharset).decode(byteData).toString();\n                 doc \u003d null;\n             }\n         }\n     } else {\n         Validate.notEmpty(charsetName, \"Must set charset arg to character set of file to parse. Set to null to attempt to detect from HTML\");\n         docData \u003d Charset.forName(charsetName).decode(byteData).toString();\n     }\n     if (doc \u003d\u003d null) {\n+        if (docData.charAt(0) \u003d\u003d 65279)\n+            docData \u003d docData.substring(1);\n         doc \u003d parser.parseInput(docData, baseUri);\n         doc.outputSettings().charset(charsetName);\n     }\n     return doc;\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "433d2f180058b8b73e1951c6cfbb986714e68b0f": {
      "type": "Ymultichange(Yparameterchange,Ybodychange)",
      "commitMessage": "Allow an alternate parser to be supplied for core use cases.\n",
      "commitDate": "2/27/12, 8:55 PM",
      "commitName": "433d2f180058b8b73e1951c6cfbb986714e68b0f",
      "commitAuthor": "Jonathan Hedley",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "Allow an alternate parser to be supplied for core use cases.\n",
          "commitDate": "2/27/12, 8:55 PM",
          "commitName": "433d2f180058b8b73e1951c6cfbb986714e68b0f",
          "commitAuthor": "Jonathan Hedley",
          "commitDateOld": "7/2/11, 4:12 AM",
          "commitNameOld": "912d3c14f98af2b3a77eeabf536617ebc9c6f665",
          "commitAuthorOld": "Jonathan Hedley",
          "daysBetweenCommits": 240.74,
          "commitsBetweenForRepo": 26,
          "commitsBetweenForFile": 1,
          "actualSource": "static Document parseByteData(ByteBuffer byteData, String charsetName, String baseUri, Parser parser) {\n    String docData;\n    Document doc \u003d null;\n    if (charsetName \u003d\u003d null) {\n        docData \u003d Charset.forName(defaultCharset).decode(byteData).toString();\n        doc \u003d parser.parseInput(docData, baseUri);\n        Element meta \u003d doc.select(\"meta[http-equiv\u003dcontent-type], meta[charset]\").first();\n        if (meta !\u003d null) {\n            String foundCharset \u003d meta.hasAttr(\"http-equiv\") ? getCharsetFromContentType(meta.attr(\"content\")) : meta.attr(\"charset\");\n            if (foundCharset !\u003d null \u0026\u0026 foundCharset.length() !\u003d 0 \u0026\u0026 !foundCharset.equals(defaultCharset)) {\n                charsetName \u003d foundCharset;\n                byteData.rewind();\n                docData \u003d Charset.forName(foundCharset).decode(byteData).toString();\n                doc \u003d null;\n            }\n        }\n    } else {\n        Validate.notEmpty(charsetName, \"Must set charset arg to character set of file to parse. Set to null to attempt to detect from HTML\");\n        docData \u003d Charset.forName(charsetName).decode(byteData).toString();\n    }\n    if (doc \u003d\u003d null) {\n        doc \u003d parser.parseInput(docData, baseUri);\n        doc.outputSettings().charset(charsetName);\n    }\n    return doc;\n}",
          "path": "src/main/java/org/jsoup/helper/DataUtil.java",
          "functionStartLine": 73,
          "functionName": "parseByteData",
          "functionAnnotation": "",
          "functionDoc": "",
          "diff": "@@ -1,26 +1,26 @@\n-static Document parseByteData(ByteBuffer byteData, String charsetName, String baseUri) {\n+static Document parseByteData(ByteBuffer byteData, String charsetName, String baseUri, Parser parser) {\n     String docData;\n     Document doc \u003d null;\n     if (charsetName \u003d\u003d null) {\n         docData \u003d Charset.forName(defaultCharset).decode(byteData).toString();\n-        doc \u003d Jsoup.parse(docData, baseUri);\n+        doc \u003d parser.parseInput(docData, baseUri);\n         Element meta \u003d doc.select(\"meta[http-equiv\u003dcontent-type], meta[charset]\").first();\n         if (meta !\u003d null) {\n             String foundCharset \u003d meta.hasAttr(\"http-equiv\") ? getCharsetFromContentType(meta.attr(\"content\")) : meta.attr(\"charset\");\n             if (foundCharset !\u003d null \u0026\u0026 foundCharset.length() !\u003d 0 \u0026\u0026 !foundCharset.equals(defaultCharset)) {\n                 charsetName \u003d foundCharset;\n                 byteData.rewind();\n                 docData \u003d Charset.forName(foundCharset).decode(byteData).toString();\n                 doc \u003d null;\n             }\n         }\n     } else {\n         Validate.notEmpty(charsetName, \"Must set charset arg to character set of file to parse. Set to null to attempt to detect from HTML\");\n         docData \u003d Charset.forName(charsetName).decode(byteData).toString();\n     }\n     if (doc \u003d\u003d null) {\n-        doc \u003d Jsoup.parse(docData, baseUri);\n+        doc \u003d parser.parseInput(docData, baseUri);\n         doc.outputSettings().charset(charsetName);\n     }\n     return doc;\n }\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldValue": "[byteData-ByteBuffer, charsetName-String, baseUri-String]",
            "newValue": "[byteData-ByteBuffer, charsetName-String, baseUri-String, parser-Parser]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "Allow an alternate parser to be supplied for core use cases.\n",
          "commitDate": "2/27/12, 8:55 PM",
          "commitName": "433d2f180058b8b73e1951c6cfbb986714e68b0f",
          "commitAuthor": "Jonathan Hedley",
          "commitDateOld": "7/2/11, 4:12 AM",
          "commitNameOld": "912d3c14f98af2b3a77eeabf536617ebc9c6f665",
          "commitAuthorOld": "Jonathan Hedley",
          "daysBetweenCommits": 240.74,
          "commitsBetweenForRepo": 26,
          "commitsBetweenForFile": 1,
          "actualSource": "static Document parseByteData(ByteBuffer byteData, String charsetName, String baseUri, Parser parser) {\n    String docData;\n    Document doc \u003d null;\n    if (charsetName \u003d\u003d null) {\n        docData \u003d Charset.forName(defaultCharset).decode(byteData).toString();\n        doc \u003d parser.parseInput(docData, baseUri);\n        Element meta \u003d doc.select(\"meta[http-equiv\u003dcontent-type], meta[charset]\").first();\n        if (meta !\u003d null) {\n            String foundCharset \u003d meta.hasAttr(\"http-equiv\") ? getCharsetFromContentType(meta.attr(\"content\")) : meta.attr(\"charset\");\n            if (foundCharset !\u003d null \u0026\u0026 foundCharset.length() !\u003d 0 \u0026\u0026 !foundCharset.equals(defaultCharset)) {\n                charsetName \u003d foundCharset;\n                byteData.rewind();\n                docData \u003d Charset.forName(foundCharset).decode(byteData).toString();\n                doc \u003d null;\n            }\n        }\n    } else {\n        Validate.notEmpty(charsetName, \"Must set charset arg to character set of file to parse. Set to null to attempt to detect from HTML\");\n        docData \u003d Charset.forName(charsetName).decode(byteData).toString();\n    }\n    if (doc \u003d\u003d null) {\n        doc \u003d parser.parseInput(docData, baseUri);\n        doc.outputSettings().charset(charsetName);\n    }\n    return doc;\n}",
          "path": "src/main/java/org/jsoup/helper/DataUtil.java",
          "functionStartLine": 73,
          "functionName": "parseByteData",
          "functionAnnotation": "",
          "functionDoc": "",
          "diff": "@@ -1,26 +1,26 @@\n-static Document parseByteData(ByteBuffer byteData, String charsetName, String baseUri) {\n+static Document parseByteData(ByteBuffer byteData, String charsetName, String baseUri, Parser parser) {\n     String docData;\n     Document doc \u003d null;\n     if (charsetName \u003d\u003d null) {\n         docData \u003d Charset.forName(defaultCharset).decode(byteData).toString();\n-        doc \u003d Jsoup.parse(docData, baseUri);\n+        doc \u003d parser.parseInput(docData, baseUri);\n         Element meta \u003d doc.select(\"meta[http-equiv\u003dcontent-type], meta[charset]\").first();\n         if (meta !\u003d null) {\n             String foundCharset \u003d meta.hasAttr(\"http-equiv\") ? getCharsetFromContentType(meta.attr(\"content\")) : meta.attr(\"charset\");\n             if (foundCharset !\u003d null \u0026\u0026 foundCharset.length() !\u003d 0 \u0026\u0026 !foundCharset.equals(defaultCharset)) {\n                 charsetName \u003d foundCharset;\n                 byteData.rewind();\n                 docData \u003d Charset.forName(foundCharset).decode(byteData).toString();\n                 doc \u003d null;\n             }\n         }\n     } else {\n         Validate.notEmpty(charsetName, \"Must set charset arg to character set of file to parse. Set to null to attempt to detect from HTML\");\n         docData \u003d Charset.forName(charsetName).decode(byteData).toString();\n     }\n     if (doc \u003d\u003d null) {\n-        doc \u003d Jsoup.parse(docData, baseUri);\n+        doc \u003d parser.parseInput(docData, baseUri);\n         doc.outputSettings().charset(charsetName);\n     }\n     return doc;\n }\n\\ No newline at end of file\n",
          "extendedDetails": {}
        }
      ]
    },
    "a14fb16d6430d8de4bf31c898d119ab713840c2d": {
      "type": "Ybodychange",
      "commitMessage": "Fixed issue with selector parser where some boolean AND + OR combined queries (e.g. \"meta[http-equiv], meta[content]\") were being parsed incorrectly as OR only queries (e.g. former as \"meta, [http-equiv], meta[content]\")\n\nFixed issue where a content-tye specified in a meta tag may not be reliably detected, due to the above issue.\n",
      "commitDate": "7/2/11, 4:12 AM",
      "commitName": "a14fb16d6430d8de4bf31c898d119ab713840c2d",
      "commitAuthor": "Jonathan Hedley",
      "commitDateOld": "7/2/11, 4:12 AM",
      "commitNameOld": "cacbbfb9604fc5ce565b3547f4a7de77c037013f",
      "commitAuthorOld": "Jonathan Hedley",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 76,
      "commitsBetweenForFile": 1,
      "actualSource": "static Document parseByteData(ByteBuffer byteData, String charsetName, String baseUri) {\n    String docData;\n    Document doc \u003d null;\n    if (charsetName \u003d\u003d null) {\n        docData \u003d Charset.forName(defaultCharset).decode(byteData).toString();\n        doc \u003d Jsoup.parse(docData, baseUri);\n        Element meta \u003d doc.select(\"meta[http-equiv\u003dcontent-type], meta[charset]\").first();\n        if (meta !\u003d null) {\n            String foundCharset \u003d meta.hasAttr(\"http-equiv\") ? getCharsetFromContentType(meta.attr(\"content\")) : meta.attr(\"charset\");\n            if (foundCharset !\u003d null \u0026\u0026 foundCharset.length() !\u003d 0 \u0026\u0026 !foundCharset.equals(defaultCharset)) {\n                charsetName \u003d foundCharset;\n                byteData.rewind();\n                docData \u003d Charset.forName(foundCharset).decode(byteData).toString();\n                doc \u003d null;\n            }\n        }\n    } else {\n        Validate.notEmpty(charsetName, \"Must set charset arg to character set of file to parse. Set to null to attempt to detect from HTML\");\n        docData \u003d Charset.forName(charsetName).decode(byteData).toString();\n    }\n    if (doc \u003d\u003d null) {\n        doc \u003d Jsoup.parse(docData, baseUri);\n        doc.outputSettings().charset(charsetName);\n    }\n    return doc;\n}",
      "path": "src/main/java/org/jsoup/helper/DataUtil.java",
      "functionStartLine": 58,
      "functionName": "parseByteData",
      "functionAnnotation": "",
      "functionDoc": "",
      "diff": "@@ -1,26 +1,26 @@\n static Document parseByteData(ByteBuffer byteData, String charsetName, String baseUri) {\n     String docData;\n     Document doc \u003d null;\n     if (charsetName \u003d\u003d null) {\n         docData \u003d Charset.forName(defaultCharset).decode(byteData).toString();\n         doc \u003d Jsoup.parse(docData, baseUri);\n         Element meta \u003d doc.select(\"meta[http-equiv\u003dcontent-type], meta[charset]\").first();\n         if (meta !\u003d null) {\n             String foundCharset \u003d meta.hasAttr(\"http-equiv\") ? getCharsetFromContentType(meta.attr(\"content\")) : meta.attr(\"charset\");\n-            if (foundCharset !\u003d null \u0026\u0026 !foundCharset.equals(defaultCharset)) {\n+            if (foundCharset !\u003d null \u0026\u0026 foundCharset.length() !\u003d 0 \u0026\u0026 !foundCharset.equals(defaultCharset)) {\n                 charsetName \u003d foundCharset;\n                 byteData.rewind();\n                 docData \u003d Charset.forName(foundCharset).decode(byteData).toString();\n                 doc \u003d null;\n             }\n         }\n     } else {\n         Validate.notEmpty(charsetName, \"Must set charset arg to character set of file to parse. Set to null to attempt to detect from HTML\");\n         docData \u003d Charset.forName(charsetName).decode(byteData).toString();\n     }\n     if (doc \u003d\u003d null) {\n         doc \u003d Jsoup.parse(docData, baseUri);\n         doc.outputSettings().charset(charsetName);\n     }\n     return doc;\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "78d40f41b9567d7e8a0c891f31b7deee2b1f3f19": {
      "type": "Ybodychange",
      "commitMessage": "Improved malformed table parsing by implementing ignorable end tags.\n",
      "commitDate": "7/2/11, 4:12 AM",
      "commitName": "78d40f41b9567d7e8a0c891f31b7deee2b1f3f19",
      "commitAuthor": "Jonathan Hedley",
      "commitDateOld": "7/2/11, 4:12 AM",
      "commitNameOld": "b57bab46e4241cd3cacce52cb6ff310bbf69eb7b",
      "commitAuthorOld": "Jonathan Hedley",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "static Document parseByteData(ByteBuffer byteData, String charsetName, String baseUri) {\n    String docData;\n    Document doc \u003d null;\n    if (charsetName \u003d\u003d null) {\n        docData \u003d Charset.forName(defaultCharset).decode(byteData).toString();\n        doc \u003d Jsoup.parse(docData, baseUri);\n        Element meta \u003d doc.select(\"meta[http-equiv\u003dcontent-type], meta[charset]\").first();\n        if (meta !\u003d null) {\n            String foundCharset \u003d meta.hasAttr(\"http-equiv\") ? getCharsetFromContentType(meta.attr(\"content\")) : meta.attr(\"charset\");\n            if (foundCharset !\u003d null \u0026\u0026 !foundCharset.equals(defaultCharset)) {\n                charsetName \u003d foundCharset;\n                byteData.rewind();\n                docData \u003d Charset.forName(foundCharset).decode(byteData).toString();\n                doc \u003d null;\n            }\n        }\n    } else {\n        Validate.notEmpty(charsetName, \"Must set charset arg to character set of file to parse. Set to null to attempt to detect from HTML\");\n        docData \u003d Charset.forName(charsetName).decode(byteData).toString();\n    }\n    if (doc \u003d\u003d null) {\n        doc \u003d Jsoup.parse(docData, baseUri);\n        doc.outputSettings().charset(charsetName);\n    }\n    return doc;\n}",
      "path": "src/main/java/org/jsoup/helper/DataUtil.java",
      "functionStartLine": 41,
      "functionName": "parseByteData",
      "functionAnnotation": "",
      "functionDoc": "",
      "diff": "@@ -1,25 +1,26 @@\n static Document parseByteData(ByteBuffer byteData, String charsetName, String baseUri) {\n     String docData;\n     Document doc \u003d null;\n     if (charsetName \u003d\u003d null) {\n         docData \u003d Charset.forName(defaultCharset).decode(byteData).toString();\n         doc \u003d Jsoup.parse(docData, baseUri);\n         Element meta \u003d doc.select(\"meta[http-equiv\u003dcontent-type], meta[charset]\").first();\n         if (meta !\u003d null) {\n             String foundCharset \u003d meta.hasAttr(\"http-equiv\") ? getCharsetFromContentType(meta.attr(\"content\")) : meta.attr(\"charset\");\n             if (foundCharset !\u003d null \u0026\u0026 !foundCharset.equals(defaultCharset)) {\n                 charsetName \u003d foundCharset;\n                 byteData.rewind();\n                 docData \u003d Charset.forName(foundCharset).decode(byteData).toString();\n                 doc \u003d null;\n             }\n         }\n     } else {\n+        Validate.notEmpty(charsetName, \"Must set charset arg to character set of file to parse. Set to null to attempt to detect from HTML\");\n         docData \u003d Charset.forName(charsetName).decode(byteData).toString();\n     }\n     if (doc \u003d\u003d null) {\n         doc \u003d Jsoup.parse(docData, baseUri);\n         doc.outputSettings().charset(charsetName);\n     }\n     return doc;\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "ce843ec83988e3e3318fa7db38133b06be741a1f": {
      "type": "Yintroduced",
      "commitMessage": "Initial implementation of Connection\n",
      "commitDate": "7/2/11, 4:11 AM",
      "commitName": "ce843ec83988e3e3318fa7db38133b06be741a1f",
      "commitAuthor": "Jonathan Hedley",
      "diff": "@@ -0,0 +1,25 @@\n+static Document parseByteData(ByteBuffer byteData, String charsetName, String baseUri) {\n+    String docData;\n+    Document doc \u003d null;\n+    if (charsetName \u003d\u003d null) {\n+        docData \u003d Charset.forName(defaultCharset).decode(byteData).toString();\n+        doc \u003d Jsoup.parse(docData, baseUri);\n+        Element meta \u003d doc.select(\"meta[http-equiv\u003dcontent-type], meta[charset]\").first();\n+        if (meta !\u003d null) {\n+            String foundCharset \u003d meta.hasAttr(\"http-equiv\") ? getCharsetFromContentType(meta.attr(\"content\")) : meta.attr(\"charset\");\n+            if (foundCharset !\u003d null \u0026\u0026 !foundCharset.equals(defaultCharset)) {\n+                charsetName \u003d foundCharset;\n+                byteData.rewind();\n+                docData \u003d Charset.forName(foundCharset).decode(byteData).toString();\n+                doc \u003d null;\n+            }\n+        }\n+    } else {\n+        docData \u003d Charset.forName(charsetName).decode(byteData).toString();\n+    }\n+    if (doc \u003d\u003d null) {\n+        doc \u003d Jsoup.parse(docData, baseUri);\n+        doc.outputSettings().charset(charsetName);\n+    }\n+    return doc;\n+}\n\\ No newline at end of file\n",
      "actualSource": "static Document parseByteData(ByteBuffer byteData, String charsetName, String baseUri) {\n    String docData;\n    Document doc \u003d null;\n    if (charsetName \u003d\u003d null) {\n        docData \u003d Charset.forName(defaultCharset).decode(byteData).toString();\n        doc \u003d Jsoup.parse(docData, baseUri);\n        Element meta \u003d doc.select(\"meta[http-equiv\u003dcontent-type], meta[charset]\").first();\n        if (meta !\u003d null) {\n            String foundCharset \u003d meta.hasAttr(\"http-equiv\") ? getCharsetFromContentType(meta.attr(\"content\")) : meta.attr(\"charset\");\n            if (foundCharset !\u003d null \u0026\u0026 !foundCharset.equals(defaultCharset)) {\n                charsetName \u003d foundCharset;\n                byteData.rewind();\n                docData \u003d Charset.forName(foundCharset).decode(byteData).toString();\n                doc \u003d null;\n            }\n        }\n    } else {\n        docData \u003d Charset.forName(charsetName).decode(byteData).toString();\n    }\n    if (doc \u003d\u003d null) {\n        doc \u003d Jsoup.parse(docData, baseUri);\n        doc.outputSettings().charset(charsetName);\n    }\n    return doc;\n}",
      "path": "src/main/java/org/jsoup/helper/DataUtil.java",
      "functionStartLine": 39,
      "functionName": "parseByteData",
      "functionAnnotation": "",
      "functionDoc": ""
    }
  }
}