{
  "origin": "codeshovel",
  "repositoryName": "Jsoup-2b",
  "repositoryPath": "/tmp/Jsoup-2b//.git",
  "startCommitName": "HEAD",
  "sourceFileName": "Parser.java",
  "functionName": "parse",
  "functionId": "parse",
  "sourceFilePath": "src/main/java/org/jsoup/parser/Parser.java",
  "functionAnnotation": "",
  "functionDoc": "",
  "functionStartLine": 66,
  "functionEndLine": 83,
  "numCommitsSeen": 37,
  "timeTaken": 779,
  "changeHistory": [
    "d24b485e252d9e86858207da7a57678d41d3f72c",
    "7649933bba7ad5960415065dd95cc99aada42240",
    "070396808fcb7cf41ff29ad52f7d1078aba99832",
    "03336ea9dd5d2aef2e31fe5e6402a04242f4d9f8",
    "2f0a7bf507020d98b3bdbf0a93bb1c753dd90268",
    "047443682327a75059c936fec9a323a0d27659a5",
    "c95216aa6e1f0dc5d39aea88624b05b953953d3d",
    "97f29aa3541dac70b811f766dd58ba47ac34d58c",
    "a657d090e2f127ebdce131f1f97e7758a8ddc463"
  ],
  "changeHistoryShort": {
    "d24b485e252d9e86858207da7a57678d41d3f72c": "Ybodychange",
    "7649933bba7ad5960415065dd95cc99aada42240": "Ymodifierchange",
    "070396808fcb7cf41ff29ad52f7d1078aba99832": "Ybodychange",
    "03336ea9dd5d2aef2e31fe5e6402a04242f4d9f8": "Ybodychange",
    "2f0a7bf507020d98b3bdbf0a93bb1c753dd90268": "Ybodychange",
    "047443682327a75059c936fec9a323a0d27659a5": "Ybodychange",
    "c95216aa6e1f0dc5d39aea88624b05b953953d3d": "Ybodychange",
    "97f29aa3541dac70b811f766dd58ba47ac34d58c": "Ybodychange",
    "a657d090e2f127ebdce131f1f97e7758a8ddc463": "Yintroduced"
  },
  "changeHistoryDetails": {
    "d24b485e252d9e86858207da7a57678d41d3f72c": {
      "type": "Ybodychange",
      "commitMessage": "Improved document normalisation.\n",
      "commitDate": "7/2/11, 4:11 AM",
      "commitName": "d24b485e252d9e86858207da7a57678d41d3f72c",
      "commitAuthor": "Jonathan Hedley",
      "commitDateOld": "7/2/11, 4:11 AM",
      "commitNameOld": "c01af2290073af0ea42eb02dfe965b4cda58e112",
      "commitAuthorOld": "Jonathan Hedley",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 16,
      "commitsBetweenForFile": 1,
      "actualSource": "private Document parse() {\n    while (!tq.isEmpty()) {\n        if (tq.matches(\"\u003c!--\")) {\n            parseComment();\n        } else if (tq.matches(\"\u003c![CDATA[\")) {\n            parseCdata();\n        } else if (tq.matches(\"\u003c?\") || tq.matches(\"\u003c!\")) {\n            parseXmlDecl();\n        } else if (tq.matches(\"\u003c/\")) {\n            parseEndTag();\n        } else if (tq.matches(\"\u003c\")) {\n            parseStartTag();\n        } else {\n            parseTextNode();\n        }\n    }\n    return doc.normalise();\n}",
      "path": "src/main/java/org/jsoup/parser/Parser.java",
      "functionStartLine": 65,
      "functionName": "parse",
      "functionAnnotation": "",
      "functionDoc": "",
      "diff": "@@ -1,18 +1,18 @@\n private Document parse() {\n     while (!tq.isEmpty()) {\n         if (tq.matches(\"\u003c!--\")) {\n             parseComment();\n         } else if (tq.matches(\"\u003c![CDATA[\")) {\n             parseCdata();\n         } else if (tq.matches(\"\u003c?\") || tq.matches(\"\u003c!\")) {\n             parseXmlDecl();\n         } else if (tq.matches(\"\u003c/\")) {\n             parseEndTag();\n         } else if (tq.matches(\"\u003c\")) {\n             parseStartTag();\n         } else {\n             parseTextNode();\n         }\n     }\n-    return doc;\n+    return doc.normalise();\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "7649933bba7ad5960415065dd95cc99aada42240": {
      "type": "Ymodifierchange",
      "commitMessage": "Adds Parser.parseBodyFragment method.\n",
      "commitDate": "7/2/11, 4:11 AM",
      "commitName": "7649933bba7ad5960415065dd95cc99aada42240",
      "commitAuthor": "Jonathan Hedley",
      "commitDateOld": "7/2/11, 4:11 AM",
      "commitNameOld": "6fcffa8f400ec9980b9fa30d3f737eceb46be234",
      "commitAuthorOld": "Jonathan Hedley",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 4,
      "commitsBetweenForFile": 1,
      "actualSource": "private Document parse() {\n    while (!tq.isEmpty()) {\n        if (tq.matches(\"\u003c!--\")) {\n            parseComment();\n        } else if (tq.matches(\"\u003c![CDATA[\")) {\n            parseCdata();\n        } else if (tq.matches(\"\u003c?\") || tq.matches(\"\u003c!\")) {\n            parseXmlDecl();\n        } else if (tq.matches(\"\u003c/\")) {\n            parseEndTag();\n        } else if (tq.matches(\"\u003c\")) {\n            parseStartTag();\n        } else {\n            parseTextNode();\n        }\n    }\n    return doc;\n}",
      "path": "src/main/java/org/jsoup/parser/Parser.java",
      "functionStartLine": 53,
      "functionName": "parse",
      "functionAnnotation": "",
      "functionDoc": "",
      "diff": "@@ -1,18 +1,18 @@\n-public Document parse() {\n+private Document parse() {\n     while (!tq.isEmpty()) {\n         if (tq.matches(\"\u003c!--\")) {\n             parseComment();\n         } else if (tq.matches(\"\u003c![CDATA[\")) {\n             parseCdata();\n         } else if (tq.matches(\"\u003c?\") || tq.matches(\"\u003c!\")) {\n             parseXmlDecl();\n         } else if (tq.matches(\"\u003c/\")) {\n             parseEndTag();\n         } else if (tq.matches(\"\u003c\")) {\n             parseStartTag();\n         } else {\n             parseTextNode();\n         }\n     }\n     return doc;\n }\n\\ No newline at end of file\n",
      "extendedDetails": {
        "oldValue": "[public]",
        "newValue": "[private]"
      }
    },
    "070396808fcb7cf41ff29ad52f7d1078aba99832": {
      "type": "Ybodychange",
      "commitMessage": "Parser updated to handle CDATA, and rogue \u003c in text nodes.\n",
      "commitDate": "7/2/11, 4:11 AM",
      "commitName": "070396808fcb7cf41ff29ad52f7d1078aba99832",
      "commitAuthor": "Jonathan Hedley",
      "commitDateOld": "7/2/11, 4:11 AM",
      "commitNameOld": "7b1a8763534bb06d5f83b03ed8f6abb3e6d4db80",
      "commitAuthorOld": "Jonathan Hedley",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 6,
      "commitsBetweenForFile": 1,
      "actualSource": "public Document parse() {\n    while (!tq.isEmpty()) {\n        if (tq.matches(\"\u003c!--\")) {\n            parseComment();\n        } else if (tq.matches(\"\u003c![CDATA[\")) {\n            parseCdata();\n        } else if (tq.matches(\"\u003c?\") || tq.matches(\"\u003c!\")) {\n            parseXmlDecl();\n        } else if (tq.matches(\"\u003c/\")) {\n            parseEndTag();\n        } else if (tq.matches(\"\u003c\")) {\n            parseStartTag();\n        } else {\n            parseTextNode();\n        }\n    }\n    return doc;\n}",
      "path": "src/main/java/org/jsoup/parser/Parser.java",
      "functionStartLine": 43,
      "functionName": "parse",
      "functionAnnotation": "",
      "functionDoc": "",
      "diff": "@@ -1,16 +1,18 @@\n public Document parse() {\n     while (!tq.isEmpty()) {\n         if (tq.matches(\"\u003c!--\")) {\n             parseComment();\n+        } else if (tq.matches(\"\u003c![CDATA[\")) {\n+            parseCdata();\n         } else if (tq.matches(\"\u003c?\") || tq.matches(\"\u003c!\")) {\n             parseXmlDecl();\n         } else if (tq.matches(\"\u003c/\")) {\n             parseEndTag();\n         } else if (tq.matches(\"\u003c\")) {\n             parseStartTag();\n         } else {\n             parseTextNode();\n         }\n     }\n     return doc;\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "03336ea9dd5d2aef2e31fe5e6402a04242f4d9f8": {
      "type": "Ybodychange",
      "commitMessage": "Pulled string matching stuff out of Parser ad into TokenQueue, for reuse in selector parser. Added som texts and corrected behaviour of parser.\n",
      "commitDate": "7/2/11, 4:11 AM",
      "commitName": "03336ea9dd5d2aef2e31fe5e6402a04242f4d9f8",
      "commitAuthor": "Jonathan Hedley",
      "commitDateOld": "7/2/11, 4:11 AM",
      "commitNameOld": "2f0a7bf507020d98b3bdbf0a93bb1c753dd90268",
      "commitAuthorOld": "Jonathan Hedley",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "public Document parse() {\n    while (!tq.isEmpty()) {\n        if (tq.matches(\"\u003c!--\")) {\n            parseComment();\n        } else if (tq.matches(\"\u003c?\") || tq.matches(\"\u003c!\")) {\n            parseXmlDecl();\n        } else if (tq.matches(\"\u003c/\")) {\n            parseEndTag();\n        } else if (tq.matches(\"\u003c\")) {\n            parseStartTag();\n        } else {\n            parseTextNode();\n        }\n    }\n    return doc;\n}",
      "path": "src/main/java/org/jsoup/parser/Parser.java",
      "functionStartLine": 43,
      "functionName": "parse",
      "functionAnnotation": "",
      "functionDoc": "",
      "diff": "@@ -1,16 +1,16 @@\n public Document parse() {\n-    while (!queue.isEmpty()) {\n-        if (matches(\"\u003c!--\")) {\n+    while (!tq.isEmpty()) {\n+        if (tq.matches(\"\u003c!--\")) {\n             parseComment();\n-        } else if (matches(\"\u003c?\") || matches(\"\u003c!\")) {\n+        } else if (tq.matches(\"\u003c?\") || tq.matches(\"\u003c!\")) {\n             parseXmlDecl();\n-        } else if (matches(\"\u003c/\")) {\n+        } else if (tq.matches(\"\u003c/\")) {\n             parseEndTag();\n-        } else if (matches(\"\u003c\")) {\n+        } else if (tq.matches(\"\u003c\")) {\n             parseStartTag();\n         } else {\n-            parseText();\n+            parseTextNode();\n         }\n     }\n     return doc;\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "2f0a7bf507020d98b3bdbf0a93bb1c753dd90268": {
      "type": "Ybodychange",
      "commitMessage": "Reimplemented parser.\n",
      "commitDate": "7/2/11, 4:11 AM",
      "commitName": "2f0a7bf507020d98b3bdbf0a93bb1c753dd90268",
      "commitAuthor": "Jonathan Hedley",
      "commitDateOld": "7/2/11, 4:11 AM",
      "commitNameOld": "9db51cf756951fa62a7670b70d314af2f0ffc197",
      "commitAuthorOld": "Jonathan Hedley",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 6,
      "commitsBetweenForFile": 1,
      "actualSource": "public Document parse() {\n    while (!queue.isEmpty()) {\n        if (matches(\"\u003c!--\")) {\n            parseComment();\n        } else if (matches(\"\u003c?\") || matches(\"\u003c!\")) {\n            parseXmlDecl();\n        } else if (matches(\"\u003c/\")) {\n            parseEndTag();\n        } else if (matches(\"\u003c\")) {\n            parseStartTag();\n        } else {\n            parseText();\n        }\n    }\n    return doc;\n}",
      "path": "src/main/java/org/jsoup/parser/Parser.java",
      "functionStartLine": 45,
      "functionName": "parse",
      "functionAnnotation": "",
      "functionDoc": "",
      "diff": "@@ -1,40 +1,16 @@\n public Document parse() {\n-    Document doc \u003d new Document();\n-    stack.add(doc);\n-    StringBuilder commentAccum \u003d null;\n-    while (tokenStream.hasNext()) {\n-        Token token \u003d tokenStream.next();\n-        if (token.isFullComment()) {\n-            Comment comment \u003d new Comment(token.getCommentData());\n-            stack.getLast().addChild(comment);\n-        } else if (token.isStartComment()) {\n-            commentAccum \u003d new StringBuilder(token.getCommentData());\n-        } else if (token.isEndComment() \u0026\u0026 commentAccum !\u003d null) {\n-            commentAccum.append(token.getCommentData());\n-            Comment comment \u003d new Comment(commentAccum.toString());\n-            stack.getLast().addChild(comment);\n-            commentAccum \u003d null;\n-        } else if (commentAccum !\u003d null) {\n-            commentAccum.append(token.getData());\n-        } else if (token.isStartTag()) {\n-            Attributes attributes \u003d attributeParser.parse(token.getAttributeString());\n-            Tag tag \u003d Tag.valueOf(token.getTagName());\n-            StartTag startTag \u003d new StartTag(tag, attributes);\n-            if (doc.getTag().equals(tag))\n-                continue;\n-            Element parent \u003d popStackToSuitableContainer(tag);\n-            Validate.notNull(parent, \"Should always have a viable container\");\n-            Element node \u003d new Element(startTag);\n-            parent.addChild(node);\n-            stack.add(node);\n-        }\n-        if (token.isEndTag() \u0026\u0026 commentAccum \u003d\u003d null) {\n-            stack.removeLast();\n-        } else if (token.isTextNode()) {\n-            String text \u003d token.getData();\n-            TextNode textNode \u003d new TextNode(text);\n-            stack.getLast().addChild(textNode);\n+    while (!queue.isEmpty()) {\n+        if (matches(\"\u003c!--\")) {\n+            parseComment();\n+        } else if (matches(\"\u003c?\") || matches(\"\u003c!\")) {\n+            parseXmlDecl();\n+        } else if (matches(\"\u003c/\")) {\n+            parseEndTag();\n+        } else if (matches(\"\u003c\")) {\n+            parseStartTag();\n+        } else {\n+            parseText();\n         }\n     }\n     return doc;\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "047443682327a75059c936fec9a323a0d27659a5": {
      "type": "Ybodychange",
      "commitMessage": "Set parent on add Child\n",
      "commitDate": "7/2/11, 4:11 AM",
      "commitName": "047443682327a75059c936fec9a323a0d27659a5",
      "commitAuthor": "Jonathan Hedley",
      "commitDateOld": "7/2/11, 4:11 AM",
      "commitNameOld": "c95216aa6e1f0dc5d39aea88624b05b953953d3d",
      "commitAuthorOld": "Jonathan Hedley",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 2,
      "commitsBetweenForFile": 1,
      "actualSource": "public Document parse() {\n    Document doc \u003d new Document();\n    stack.add(doc);\n    StringBuilder commentAccum \u003d null;\n    while (tokenStream.hasNext()) {\n        Token token \u003d tokenStream.next();\n        if (token.isFullComment()) {\n            Comment comment \u003d new Comment(token.getCommentData());\n            stack.getLast().addChild(comment);\n        } else if (token.isStartComment()) {\n            commentAccum \u003d new StringBuilder(token.getCommentData());\n        } else if (token.isEndComment() \u0026\u0026 commentAccum !\u003d null) {\n            commentAccum.append(token.getCommentData());\n            Comment comment \u003d new Comment(commentAccum.toString());\n            stack.getLast().addChild(comment);\n            commentAccum \u003d null;\n        } else if (commentAccum !\u003d null) {\n            commentAccum.append(token.getData());\n        } else if (token.isStartTag()) {\n            Attributes attributes \u003d attributeParser.parse(token.getAttributeString());\n            Tag tag \u003d Tag.valueOf(token.getTagName());\n            StartTag startTag \u003d new StartTag(tag, attributes);\n            if (doc.getTag().equals(tag))\n                continue;\n            Element parent \u003d popStackToSuitableContainer(tag);\n            Validate.notNull(parent, \"Should always have a viable container\");\n            Element node \u003d new Element(startTag);\n            parent.addChild(node);\n            stack.add(node);\n        }\n        if (token.isEndTag() \u0026\u0026 commentAccum \u003d\u003d null) {\n            stack.removeLast();\n        } else if (token.isTextNode()) {\n            String text \u003d token.getData();\n            TextNode textNode \u003d new TextNode(text);\n            stack.getLast().addChild(textNode);\n        }\n    }\n    return doc;\n}",
      "path": "src/main/java/org/jsoup/parser/Parser.java",
      "functionStartLine": 26,
      "functionName": "parse",
      "functionAnnotation": "",
      "functionDoc": "",
      "diff": "@@ -1,40 +1,40 @@\n public Document parse() {\n     Document doc \u003d new Document();\n     stack.add(doc);\n     StringBuilder commentAccum \u003d null;\n     while (tokenStream.hasNext()) {\n         Token token \u003d tokenStream.next();\n         if (token.isFullComment()) {\n-            Comment comment \u003d new Comment(stack.peek(), token.getCommentData());\n+            Comment comment \u003d new Comment(token.getCommentData());\n             stack.getLast().addChild(comment);\n         } else if (token.isStartComment()) {\n             commentAccum \u003d new StringBuilder(token.getCommentData());\n         } else if (token.isEndComment() \u0026\u0026 commentAccum !\u003d null) {\n             commentAccum.append(token.getCommentData());\n-            Comment comment \u003d new Comment(stack.peek(), commentAccum.toString());\n+            Comment comment \u003d new Comment(commentAccum.toString());\n             stack.getLast().addChild(comment);\n             commentAccum \u003d null;\n         } else if (commentAccum !\u003d null) {\n             commentAccum.append(token.getData());\n         } else if (token.isStartTag()) {\n             Attributes attributes \u003d attributeParser.parse(token.getAttributeString());\n             Tag tag \u003d Tag.valueOf(token.getTagName());\n             StartTag startTag \u003d new StartTag(tag, attributes);\n             if (doc.getTag().equals(tag))\n                 continue;\n             Element parent \u003d popStackToSuitableContainer(tag);\n             Validate.notNull(parent, \"Should always have a viable container\");\n-            Element node \u003d new Element(parent, startTag);\n+            Element node \u003d new Element(startTag);\n             parent.addChild(node);\n             stack.add(node);\n         }\n         if (token.isEndTag() \u0026\u0026 commentAccum \u003d\u003d null) {\n             stack.removeLast();\n         } else if (token.isTextNode()) {\n             String text \u003d token.getData();\n-            TextNode textNode \u003d new TextNode(stack.peek(), text);\n+            TextNode textNode \u003d new TextNode(text);\n             stack.getLast().addChild(textNode);\n         }\n     }\n     return doc;\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "c95216aa6e1f0dc5d39aea88624b05b953953d3d": {
      "type": "Ybodychange",
      "commitMessage": "Implemented comment handling.\n\nNot very happy with token and parser. Would like to reimplement with some kind of expect / consumeTo behavior. Getting a bit too hacky.\n",
      "commitDate": "7/2/11, 4:11 AM",
      "commitName": "c95216aa6e1f0dc5d39aea88624b05b953953d3d",
      "commitAuthor": "Jonathan Hedley",
      "commitDateOld": "7/2/11, 4:11 AM",
      "commitNameOld": "97f29aa3541dac70b811f766dd58ba47ac34d58c",
      "commitAuthorOld": "Jonathan Hedley",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 4,
      "commitsBetweenForFile": 1,
      "actualSource": "public Document parse() {\n    Document doc \u003d new Document();\n    stack.add(doc);\n    StringBuilder commentAccum \u003d null;\n    while (tokenStream.hasNext()) {\n        Token token \u003d tokenStream.next();\n        if (token.isFullComment()) {\n            Comment comment \u003d new Comment(stack.peek(), token.getCommentData());\n            stack.getLast().addChild(comment);\n        } else if (token.isStartComment()) {\n            commentAccum \u003d new StringBuilder(token.getCommentData());\n        } else if (token.isEndComment() \u0026\u0026 commentAccum !\u003d null) {\n            commentAccum.append(token.getCommentData());\n            Comment comment \u003d new Comment(stack.peek(), commentAccum.toString());\n            stack.getLast().addChild(comment);\n            commentAccum \u003d null;\n        } else if (commentAccum !\u003d null) {\n            commentAccum.append(token.getData());\n        } else if (token.isStartTag()) {\n            Attributes attributes \u003d attributeParser.parse(token.getAttributeString());\n            Tag tag \u003d Tag.valueOf(token.getTagName());\n            StartTag startTag \u003d new StartTag(tag, attributes);\n            if (doc.getTag().equals(tag))\n                continue;\n            Element parent \u003d popStackToSuitableContainer(tag);\n            Validate.notNull(parent, \"Should always have a viable container\");\n            Element node \u003d new Element(parent, startTag);\n            parent.addChild(node);\n            stack.add(node);\n        }\n        if (token.isEndTag() \u0026\u0026 commentAccum \u003d\u003d null) {\n            stack.removeLast();\n        } else if (token.isTextNode()) {\n            String text \u003d token.getData();\n            TextNode textNode \u003d new TextNode(stack.peek(), text);\n            stack.getLast().addChild(textNode);\n        }\n    }\n    return doc;\n}",
      "path": "src/main/java/org/jsoup/parser/Parser.java",
      "functionStartLine": 26,
      "functionName": "parse",
      "functionAnnotation": "",
      "functionDoc": "",
      "diff": "@@ -1,27 +1,40 @@\n public Document parse() {\n     Document doc \u003d new Document();\n     stack.add(doc);\n+    StringBuilder commentAccum \u003d null;\n     while (tokenStream.hasNext()) {\n         Token token \u003d tokenStream.next();\n-        if (token.isStartTag()) {\n+        if (token.isFullComment()) {\n+            Comment comment \u003d new Comment(stack.peek(), token.getCommentData());\n+            stack.getLast().addChild(comment);\n+        } else if (token.isStartComment()) {\n+            commentAccum \u003d new StringBuilder(token.getCommentData());\n+        } else if (token.isEndComment() \u0026\u0026 commentAccum !\u003d null) {\n+            commentAccum.append(token.getCommentData());\n+            Comment comment \u003d new Comment(stack.peek(), commentAccum.toString());\n+            stack.getLast().addChild(comment);\n+            commentAccum \u003d null;\n+        } else if (commentAccum !\u003d null) {\n+            commentAccum.append(token.getData());\n+        } else if (token.isStartTag()) {\n             Attributes attributes \u003d attributeParser.parse(token.getAttributeString());\n             Tag tag \u003d Tag.valueOf(token.getTagName());\n             StartTag startTag \u003d new StartTag(tag, attributes);\n             if (doc.getTag().equals(tag))\n                 continue;\n             Element parent \u003d popStackToSuitableContainer(tag);\n             Validate.notNull(parent, \"Should always have a viable container\");\n             Element node \u003d new Element(parent, startTag);\n             parent.addChild(node);\n             stack.add(node);\n         }\n-        if (token.isEndTag()) {\n+        if (token.isEndTag() \u0026\u0026 commentAccum \u003d\u003d null) {\n             stack.removeLast();\n         } else if (token.isTextNode()) {\n             String text \u003d token.getData();\n             TextNode textNode \u003d new TextNode(stack.peek(), text);\n             stack.getLast().addChild(textNode);\n         }\n     }\n     return doc;\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "97f29aa3541dac70b811f766dd58ba47ac34d58c": {
      "type": "Ybodychange",
      "commitMessage": "Ignore tag \"html\" in parse tree as created by doc\n",
      "commitDate": "7/2/11, 4:11 AM",
      "commitName": "97f29aa3541dac70b811f766dd58ba47ac34d58c",
      "commitAuthor": "Jonathan Hedley",
      "commitDateOld": "7/2/11, 4:11 AM",
      "commitNameOld": "80ca2f7994a5da3b502a639440128f3da7187711",
      "commitAuthorOld": "Jonathan Hedley",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "public Document parse() {\n    Document doc \u003d new Document();\n    stack.add(doc);\n    while (tokenStream.hasNext()) {\n        Token token \u003d tokenStream.next();\n        if (token.isStartTag()) {\n            Attributes attributes \u003d attributeParser.parse(token.getAttributeString());\n            Tag tag \u003d Tag.valueOf(token.getTagName());\n            StartTag startTag \u003d new StartTag(tag, attributes);\n            if (doc.getTag().equals(tag))\n                continue;\n            Element parent \u003d popStackToSuitableContainer(tag);\n            Validate.notNull(parent, \"Should always have a viable container\");\n            Element node \u003d new Element(parent, startTag);\n            parent.addChild(node);\n            stack.add(node);\n        }\n        if (token.isEndTag()) {\n            stack.removeLast();\n        } else if (token.isTextNode()) {\n            String text \u003d token.getData();\n            TextNode textNode \u003d new TextNode(stack.peek(), text);\n            stack.getLast().addChild(textNode);\n        }\n    }\n    return doc;\n}",
      "path": "src/main/java/org/jsoup/parser/Parser.java",
      "functionStartLine": 26,
      "functionName": "parse",
      "functionAnnotation": "",
      "functionDoc": "",
      "diff": "@@ -1,25 +1,27 @@\n public Document parse() {\n     Document doc \u003d new Document();\n     stack.add(doc);\n     while (tokenStream.hasNext()) {\n         Token token \u003d tokenStream.next();\n         if (token.isStartTag()) {\n             Attributes attributes \u003d attributeParser.parse(token.getAttributeString());\n             Tag tag \u003d Tag.valueOf(token.getTagName());\n             StartTag startTag \u003d new StartTag(tag, attributes);\n+            if (doc.getTag().equals(tag))\n+                continue;\n             Element parent \u003d popStackToSuitableContainer(tag);\n             Validate.notNull(parent, \"Should always have a viable container\");\n             Element node \u003d new Element(parent, startTag);\n             parent.addChild(node);\n             stack.add(node);\n         }\n         if (token.isEndTag()) {\n             stack.removeLast();\n         } else if (token.isTextNode()) {\n             String text \u003d token.getData();\n             TextNode textNode \u003d new TextNode(stack.peek(), text);\n             stack.getLast().addChild(textNode);\n         }\n     }\n     return doc;\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "a657d090e2f127ebdce131f1f97e7758a8ddc463": {
      "type": "Yintroduced",
      "commitMessage": "Draft implementation of Parser.\n",
      "commitDate": "7/2/11, 4:11 AM",
      "commitName": "a657d090e2f127ebdce131f1f97e7758a8ddc463",
      "commitAuthor": "Jonathan Hedley",
      "diff": "@@ -0,0 +1,25 @@\n+public Document parse() {\n+    Document doc \u003d new Document();\n+    stack.add(doc);\n+    while (tokenStream.hasNext()) {\n+        Token token \u003d tokenStream.next();\n+        if (token.isStartTag()) {\n+            Attributes attributes \u003d attributeParser.parse(token.getAttributeString());\n+            Tag tag \u003d Tag.valueOf(token.getTagName());\n+            StartTag startTag \u003d new StartTag(tag, attributes);\n+            Element parent \u003d popStackToSuitableContainer(tag);\n+            Validate.notNull(parent, \"Should always have a viable container\");\n+            Element node \u003d new Element(parent, startTag);\n+            parent.addChild(node);\n+            stack.add(node);\n+        }\n+        if (token.isEndTag()) {\n+            stack.removeLast();\n+        } else if (token.isTextNode()) {\n+            String text \u003d token.getData();\n+            TextNode textNode \u003d new TextNode(stack.peek(), text);\n+            stack.getLast().addChild(textNode);\n+        }\n+    }\n+    return doc;\n+}\n\\ No newline at end of file\n",
      "actualSource": "public Document parse() {\n    Document doc \u003d new Document();\n    stack.add(doc);\n    while (tokenStream.hasNext()) {\n        Token token \u003d tokenStream.next();\n        if (token.isStartTag()) {\n            Attributes attributes \u003d attributeParser.parse(token.getAttributeString());\n            Tag tag \u003d Tag.valueOf(token.getTagName());\n            StartTag startTag \u003d new StartTag(tag, attributes);\n            Element parent \u003d popStackToSuitableContainer(tag);\n            Validate.notNull(parent, \"Should always have a viable container\");\n            Element node \u003d new Element(parent, startTag);\n            parent.addChild(node);\n            stack.add(node);\n        }\n        if (token.isEndTag()) {\n            stack.removeLast();\n        } else if (token.isTextNode()) {\n            String text \u003d token.getData();\n            TextNode textNode \u003d new TextNode(stack.peek(), text);\n            stack.getLast().addChild(textNode);\n        }\n    }\n    return doc;\n}",
      "path": "src/main/java/org/jsoup/parser/Parser.java",
      "functionStartLine": 26,
      "functionName": "parse",
      "functionAnnotation": "",
      "functionDoc": ""
    }
  }
}