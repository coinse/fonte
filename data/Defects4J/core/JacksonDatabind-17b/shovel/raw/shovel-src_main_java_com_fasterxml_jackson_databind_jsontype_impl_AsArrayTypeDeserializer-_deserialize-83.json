{
  "origin": "codeshovel",
  "repositoryName": "JacksonDatabind-17b",
  "repositoryPath": "/tmp/JacksonDatabind-17b//.git",
  "startCommitName": "HEAD",
  "sourceFileName": "AsArrayTypeDeserializer.java",
  "functionName": "_deserialize",
  "functionId": "_deserialize___jp-JsonParser__ctxt-DeserializationContext",
  "sourceFilePath": "src/main/java/com/fasterxml/jackson/databind/jsontype/impl/AsArrayTypeDeserializer.java",
  "functionAnnotation": "@SuppressWarnings(\"resource\")",
  "functionDoc": "Method that handles type information wrapper, locates actual\nsubtype deserializer to use, and calls it to do actual\ndeserialization.\n",
  "functionStartLine": 83,
  "functionEndLine": 112,
  "numCommitsSeen": 15,
  "timeTaken": 681,
  "changeHistory": [
    "5bdafdc05628efcca7384bcd384be264dc9dcb23",
    "b6da866bd0b7e06ae3cc3739f3fd3d04fbe2d726",
    "10af6d3a3e816f9717c112e97a912fef9a4eeadd",
    "767ecb29a5a79f799113d13eb137389ff5a4c2c5",
    "8b5fd608767e1a267308e58bfb7eb409c75c1daf",
    "fcbbccccff541e3492ebf5425ed5223581f77641",
    "8ba07ccfb014690281668eb46e5be6bd1883e61a",
    "8958048f38c5914bda894174f2d17b96828996b4",
    "ba0470fba09489f0fd97f2718e064b5105cafad7",
    "e4f23bb6779d434d88a7c4335f92d13ea639b373"
  ],
  "changeHistoryShort": {
    "5bdafdc05628efcca7384bcd384be264dc9dcb23": "Ybodychange",
    "b6da866bd0b7e06ae3cc3739f3fd3d04fbe2d726": "Ybodychange",
    "10af6d3a3e816f9717c112e97a912fef9a4eeadd": "Yexceptionschange",
    "767ecb29a5a79f799113d13eb137389ff5a4c2c5": "Ybodychange",
    "8b5fd608767e1a267308e58bfb7eb409c75c1daf": "Ybodychange",
    "fcbbccccff541e3492ebf5425ed5223581f77641": "Ymultichange(Ybodychange,Yannotationchange)",
    "8ba07ccfb014690281668eb46e5be6bd1883e61a": "Ybodychange",
    "8958048f38c5914bda894174f2d17b96828996b4": "Ybodychange",
    "ba0470fba09489f0fd97f2718e064b5105cafad7": "Ybodychange",
    "e4f23bb6779d434d88a7c4335f92d13ea639b373": "Yintroduced"
  },
  "changeHistoryDetails": {
    "5bdafdc05628efcca7384bcd384be264dc9dcb23": {
      "type": "Ybodychange",
      "commitMessage": "One minor change to handling of native type ids; allow coercion from empty string to null if `DeserializationFeature.ACCEPT_EMPTY_STRING_AS_NULL_OBJECT` is set\n",
      "commitDate": "5/4/14, 7:52 PM",
      "commitName": "5bdafdc05628efcca7384bcd384be264dc9dcb23",
      "commitAuthor": "Tatu Saloranta",
      "commitDateOld": "5/4/14, 6:49 PM",
      "commitNameOld": "b6da866bd0b7e06ae3cc3739f3fd3d04fbe2d726",
      "commitAuthorOld": "Tatu Saloranta",
      "daysBetweenCommits": 0.04,
      "commitsBetweenForRepo": 2,
      "commitsBetweenForFile": 1,
      "actualSource": "@SuppressWarnings(\"resource\")\nprivate final Object _deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException {\n    if (jp.canReadTypeId()) {\n        Object typeId \u003d jp.getTypeId();\n        if (typeId !\u003d null) {\n            return _deserializeWithNativeTypeId(jp, ctxt, typeId);\n        }\n    }\n    boolean hadStartArray \u003d jp.isExpectedStartArrayToken();\n    String typeId \u003d _locateTypeId(jp, ctxt);\n    JsonDeserializer\u003cObject\u003e deser \u003d _findDeserializer(ctxt, typeId);\n    if (_typeIdVisible \u0026\u0026 jp.getCurrentToken() \u003d\u003d JsonToken.START_OBJECT) {\n        TokenBuffer tb \u003d new TokenBuffer(null, false);\n        tb.writeStartObject();\n        tb.writeFieldName(_typePropertyName);\n        tb.writeString(typeId);\n        jp \u003d JsonParserSequence.createFlattened(tb.asParser(jp), jp);\n        jp.nextToken();\n    }\n    Object value \u003d deser.deserialize(jp, ctxt);\n    if (hadStartArray \u0026\u0026 jp.nextToken() !\u003d JsonToken.END_ARRAY) {\n        throw ctxt.wrongTokenException(jp, JsonToken.END_ARRAY, \"expected closing END_ARRAY after type information and deserialized value\");\n    }\n    return value;\n}",
      "path": "src/main/java/com/fasterxml/jackson/databind/jsontype/impl/AsArrayTypeDeserializer.java",
      "functionStartLine": 83,
      "functionName": "_deserialize",
      "functionAnnotation": "@SuppressWarnings(\"resource\")",
      "functionDoc": "Method that handles type information wrapper, locates actual\nsubtype deserializer to use, and calls it to do actual\ndeserialization.\n",
      "diff": "@@ -1,28 +1,25 @@\n @SuppressWarnings(\"resource\")\n private final Object _deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException {\n     if (jp.canReadTypeId()) {\n         Object typeId \u003d jp.getTypeId();\n         if (typeId !\u003d null) {\n-            Object ob \u003d _deserializeWithNativeTypeId(jp, ctxt, typeId);\n-            if (ob !\u003d null) {\n-                return ob;\n-            }\n+            return _deserializeWithNativeTypeId(jp, ctxt, typeId);\n         }\n     }\n     boolean hadStartArray \u003d jp.isExpectedStartArrayToken();\n     String typeId \u003d _locateTypeId(jp, ctxt);\n     JsonDeserializer\u003cObject\u003e deser \u003d _findDeserializer(ctxt, typeId);\n     if (_typeIdVisible \u0026\u0026 jp.getCurrentToken() \u003d\u003d JsonToken.START_OBJECT) {\n         TokenBuffer tb \u003d new TokenBuffer(null, false);\n         tb.writeStartObject();\n         tb.writeFieldName(_typePropertyName);\n         tb.writeString(typeId);\n         jp \u003d JsonParserSequence.createFlattened(tb.asParser(jp), jp);\n         jp.nextToken();\n     }\n     Object value \u003d deser.deserialize(jp, ctxt);\n     if (hadStartArray \u0026\u0026 jp.nextToken() !\u003d JsonToken.END_ARRAY) {\n         throw ctxt.wrongTokenException(jp, JsonToken.END_ARRAY, \"expected closing END_ARRAY after type information and deserialized value\");\n     }\n     return value;\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "b6da866bd0b7e06ae3cc3739f3fd3d04fbe2d726": {
      "type": "Ybodychange",
      "commitMessage": "Improve handling of native type ids; use non-native type ids as fallback\n",
      "commitDate": "5/4/14, 6:49 PM",
      "commitName": "b6da866bd0b7e06ae3cc3739f3fd3d04fbe2d726",
      "commitAuthor": "Tatu Saloranta",
      "commitDateOld": "12/31/13, 10:27 PM",
      "commitNameOld": "10af6d3a3e816f9717c112e97a912fef9a4eeadd",
      "commitAuthorOld": "Tatu Saloranta",
      "daysBetweenCommits": 123.81,
      "commitsBetweenForRepo": 213,
      "commitsBetweenForFile": 1,
      "actualSource": "@SuppressWarnings(\"resource\")\nprivate final Object _deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException {\n    if (jp.canReadTypeId()) {\n        Object typeId \u003d jp.getTypeId();\n        if (typeId !\u003d null) {\n            Object ob \u003d _deserializeWithNativeTypeId(jp, ctxt, typeId);\n            if (ob !\u003d null) {\n                return ob;\n            }\n        }\n    }\n    boolean hadStartArray \u003d jp.isExpectedStartArrayToken();\n    String typeId \u003d _locateTypeId(jp, ctxt);\n    JsonDeserializer\u003cObject\u003e deser \u003d _findDeserializer(ctxt, typeId);\n    if (_typeIdVisible \u0026\u0026 jp.getCurrentToken() \u003d\u003d JsonToken.START_OBJECT) {\n        TokenBuffer tb \u003d new TokenBuffer(null, false);\n        tb.writeStartObject();\n        tb.writeFieldName(_typePropertyName);\n        tb.writeString(typeId);\n        jp \u003d JsonParserSequence.createFlattened(tb.asParser(jp), jp);\n        jp.nextToken();\n    }\n    Object value \u003d deser.deserialize(jp, ctxt);\n    if (hadStartArray \u0026\u0026 jp.nextToken() !\u003d JsonToken.END_ARRAY) {\n        throw ctxt.wrongTokenException(jp, JsonToken.END_ARRAY, \"expected closing END_ARRAY after type information and deserialized value\");\n    }\n    return value;\n}",
      "path": "src/main/java/com/fasterxml/jackson/databind/jsontype/impl/AsArrayTypeDeserializer.java",
      "functionStartLine": 83,
      "functionName": "_deserialize",
      "functionAnnotation": "@SuppressWarnings(\"resource\")",
      "functionDoc": "Method that handles type information wrapper, locates actual\nsubtype deserializer to use, and calls it to do actual\ndeserialization.\n",
      "diff": "@@ -1,22 +1,28 @@\n @SuppressWarnings(\"resource\")\n private final Object _deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException {\n     if (jp.canReadTypeId()) {\n-        return _deserializeWithNativeTypeId(jp, ctxt);\n+        Object typeId \u003d jp.getTypeId();\n+        if (typeId !\u003d null) {\n+            Object ob \u003d _deserializeWithNativeTypeId(jp, ctxt, typeId);\n+            if (ob !\u003d null) {\n+                return ob;\n+            }\n+        }\n     }\n     boolean hadStartArray \u003d jp.isExpectedStartArrayToken();\n     String typeId \u003d _locateTypeId(jp, ctxt);\n     JsonDeserializer\u003cObject\u003e deser \u003d _findDeserializer(ctxt, typeId);\n     if (_typeIdVisible \u0026\u0026 jp.getCurrentToken() \u003d\u003d JsonToken.START_OBJECT) {\n         TokenBuffer tb \u003d new TokenBuffer(null, false);\n         tb.writeStartObject();\n         tb.writeFieldName(_typePropertyName);\n         tb.writeString(typeId);\n         jp \u003d JsonParserSequence.createFlattened(tb.asParser(jp), jp);\n         jp.nextToken();\n     }\n     Object value \u003d deser.deserialize(jp, ctxt);\n     if (hadStartArray \u0026\u0026 jp.nextToken() !\u003d JsonToken.END_ARRAY) {\n         throw ctxt.wrongTokenException(jp, JsonToken.END_ARRAY, \"expected closing END_ARRAY after type information and deserialized value\");\n     }\n     return value;\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "10af6d3a3e816f9717c112e97a912fef9a4eeadd": {
      "type": "Yexceptionschange",
      "commitMessage": "Yet more refactorign\n",
      "commitDate": "12/31/13, 10:27 PM",
      "commitName": "10af6d3a3e816f9717c112e97a912fef9a4eeadd",
      "commitAuthor": "Tatu Saloranta",
      "commitDateOld": "8/4/13, 5:17 PM",
      "commitNameOld": "767ecb29a5a79f799113d13eb137389ff5a4c2c5",
      "commitAuthorOld": "Tatu Saloranta",
      "daysBetweenCommits": 149.26,
      "commitsBetweenForRepo": 189,
      "commitsBetweenForFile": 1,
      "actualSource": "@SuppressWarnings(\"resource\")\nprivate final Object _deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException {\n    if (jp.canReadTypeId()) {\n        return _deserializeWithNativeTypeId(jp, ctxt);\n    }\n    boolean hadStartArray \u003d jp.isExpectedStartArrayToken();\n    String typeId \u003d _locateTypeId(jp, ctxt);\n    JsonDeserializer\u003cObject\u003e deser \u003d _findDeserializer(ctxt, typeId);\n    if (_typeIdVisible \u0026\u0026 jp.getCurrentToken() \u003d\u003d JsonToken.START_OBJECT) {\n        TokenBuffer tb \u003d new TokenBuffer(null, false);\n        tb.writeStartObject();\n        tb.writeFieldName(_typePropertyName);\n        tb.writeString(typeId);\n        jp \u003d JsonParserSequence.createFlattened(tb.asParser(jp), jp);\n        jp.nextToken();\n    }\n    Object value \u003d deser.deserialize(jp, ctxt);\n    if (hadStartArray \u0026\u0026 jp.nextToken() !\u003d JsonToken.END_ARRAY) {\n        throw ctxt.wrongTokenException(jp, JsonToken.END_ARRAY, \"expected closing END_ARRAY after type information and deserialized value\");\n    }\n    return value;\n}",
      "path": "src/main/java/com/fasterxml/jackson/databind/jsontype/impl/AsArrayTypeDeserializer.java",
      "functionStartLine": 83,
      "functionName": "_deserialize",
      "functionAnnotation": "@SuppressWarnings(\"resource\")",
      "functionDoc": "Method that handles type information wrapper, locates actual\nsubtype deserializer to use, and calls it to do actual\ndeserialization.\n",
      "diff": "@@ -1,22 +1,22 @@\n @SuppressWarnings(\"resource\")\n-private final Object _deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException {\n+private final Object _deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException {\n     if (jp.canReadTypeId()) {\n         return _deserializeWithNativeTypeId(jp, ctxt);\n     }\n     boolean hadStartArray \u003d jp.isExpectedStartArrayToken();\n     String typeId \u003d _locateTypeId(jp, ctxt);\n     JsonDeserializer\u003cObject\u003e deser \u003d _findDeserializer(ctxt, typeId);\n     if (_typeIdVisible \u0026\u0026 jp.getCurrentToken() \u003d\u003d JsonToken.START_OBJECT) {\n         TokenBuffer tb \u003d new TokenBuffer(null, false);\n         tb.writeStartObject();\n         tb.writeFieldName(_typePropertyName);\n         tb.writeString(typeId);\n         jp \u003d JsonParserSequence.createFlattened(tb.asParser(jp), jp);\n         jp.nextToken();\n     }\n     Object value \u003d deser.deserialize(jp, ctxt);\n     if (hadStartArray \u0026\u0026 jp.nextToken() !\u003d JsonToken.END_ARRAY) {\n         throw ctxt.wrongTokenException(jp, JsonToken.END_ARRAY, \"expected closing END_ARRAY after type information and deserialized value\");\n     }\n     return value;\n }\n\\ No newline at end of file\n",
      "extendedDetails": {
        "oldValue": "[IOException, JsonProcessingException]",
        "newValue": "[IOException]"
      }
    },
    "767ecb29a5a79f799113d13eb137389ff5a4c2c5": {
      "type": "Ybodychange",
      "commitMessage": "Try to add support for retaining type ids via TokenBuffer\n",
      "commitDate": "8/4/13, 5:17 PM",
      "commitName": "767ecb29a5a79f799113d13eb137389ff5a4c2c5",
      "commitAuthor": "Tatu Saloranta",
      "commitDateOld": "8/3/13, 1:41 PM",
      "commitNameOld": "8b5fd608767e1a267308e58bfb7eb409c75c1daf",
      "commitAuthorOld": "Tatu Saloranta",
      "daysBetweenCommits": 1.15,
      "commitsBetweenForRepo": 2,
      "commitsBetweenForFile": 1,
      "actualSource": "@SuppressWarnings(\"resource\")\nprivate final Object _deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException {\n    if (jp.canReadTypeId()) {\n        return _deserializeWithNativeTypeId(jp, ctxt);\n    }\n    boolean hadStartArray \u003d jp.isExpectedStartArrayToken();\n    String typeId \u003d _locateTypeId(jp, ctxt);\n    JsonDeserializer\u003cObject\u003e deser \u003d _findDeserializer(ctxt, typeId);\n    if (_typeIdVisible \u0026\u0026 jp.getCurrentToken() \u003d\u003d JsonToken.START_OBJECT) {\n        TokenBuffer tb \u003d new TokenBuffer(null, false);\n        tb.writeStartObject();\n        tb.writeFieldName(_typePropertyName);\n        tb.writeString(typeId);\n        jp \u003d JsonParserSequence.createFlattened(tb.asParser(jp), jp);\n        jp.nextToken();\n    }\n    Object value \u003d deser.deserialize(jp, ctxt);\n    if (hadStartArray \u0026\u0026 jp.nextToken() !\u003d JsonToken.END_ARRAY) {\n        throw ctxt.wrongTokenException(jp, JsonToken.END_ARRAY, \"expected closing END_ARRAY after type information and deserialized value\");\n    }\n    return value;\n}",
      "path": "src/main/java/com/fasterxml/jackson/databind/jsontype/impl/AsArrayTypeDeserializer.java",
      "functionStartLine": 95,
      "functionName": "_deserialize",
      "functionAnnotation": "@SuppressWarnings(\"resource\")",
      "functionDoc": "Method that handles type information wrapper, locates actual\nsubtype deserializer to use, and calls it to do actual\ndeserialization.\n",
      "diff": "@@ -1,22 +1,22 @@\n @SuppressWarnings(\"resource\")\n private final Object _deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException {\n     if (jp.canReadTypeId()) {\n         return _deserializeWithNativeTypeId(jp, ctxt);\n     }\n     boolean hadStartArray \u003d jp.isExpectedStartArrayToken();\n     String typeId \u003d _locateTypeId(jp, ctxt);\n     JsonDeserializer\u003cObject\u003e deser \u003d _findDeserializer(ctxt, typeId);\n     if (_typeIdVisible \u0026\u0026 jp.getCurrentToken() \u003d\u003d JsonToken.START_OBJECT) {\n-        TokenBuffer tb \u003d new TokenBuffer(null);\n+        TokenBuffer tb \u003d new TokenBuffer(null, false);\n         tb.writeStartObject();\n         tb.writeFieldName(_typePropertyName);\n         tb.writeString(typeId);\n         jp \u003d JsonParserSequence.createFlattened(tb.asParser(jp), jp);\n         jp.nextToken();\n     }\n     Object value \u003d deser.deserialize(jp, ctxt);\n     if (hadStartArray \u0026\u0026 jp.nextToken() !\u003d JsonToken.END_ARRAY) {\n         throw ctxt.wrongTokenException(jp, JsonToken.END_ARRAY, \"expected closing END_ARRAY after type information and deserialized value\");\n     }\n     return value;\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "8b5fd608767e1a267308e58bfb7eb409c75c1daf": {
      "type": "Ybodychange",
      "commitMessage": "Add support for polymorphic deserialization using native type ids: initially needed by YAML module\n",
      "commitDate": "8/3/13, 1:41 PM",
      "commitName": "8b5fd608767e1a267308e58bfb7eb409c75c1daf",
      "commitAuthor": "Tatu Saloranta",
      "commitDateOld": "7/25/13, 10:42 PM",
      "commitNameOld": "fcbbccccff541e3492ebf5425ed5223581f77641",
      "commitAuthorOld": "Tatu Saloranta",
      "daysBetweenCommits": 8.62,
      "commitsBetweenForRepo": 13,
      "commitsBetweenForFile": 1,
      "actualSource": "@SuppressWarnings(\"resource\")\nprivate final Object _deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException {\n    if (jp.canReadTypeId()) {\n        return _deserializeWithNativeTypeId(jp, ctxt);\n    }\n    boolean hadStartArray \u003d jp.isExpectedStartArrayToken();\n    String typeId \u003d _locateTypeId(jp, ctxt);\n    JsonDeserializer\u003cObject\u003e deser \u003d _findDeserializer(ctxt, typeId);\n    if (_typeIdVisible \u0026\u0026 jp.getCurrentToken() \u003d\u003d JsonToken.START_OBJECT) {\n        TokenBuffer tb \u003d new TokenBuffer(null);\n        tb.writeStartObject();\n        tb.writeFieldName(_typePropertyName);\n        tb.writeString(typeId);\n        jp \u003d JsonParserSequence.createFlattened(tb.asParser(jp), jp);\n        jp.nextToken();\n    }\n    Object value \u003d deser.deserialize(jp, ctxt);\n    if (hadStartArray \u0026\u0026 jp.nextToken() !\u003d JsonToken.END_ARRAY) {\n        throw ctxt.wrongTokenException(jp, JsonToken.END_ARRAY, \"expected closing END_ARRAY after type information and deserialized value\");\n    }\n    return value;\n}",
      "path": "src/main/java/com/fasterxml/jackson/databind/jsontype/impl/AsArrayTypeDeserializer.java",
      "functionStartLine": 95,
      "functionName": "_deserialize",
      "functionAnnotation": "@SuppressWarnings(\"resource\")",
      "functionDoc": "Method that handles type information wrapper, locates actual\nsubtype deserializer to use, and calls it to do actual\ndeserialization.\n",
      "diff": "@@ -1,19 +1,22 @@\n @SuppressWarnings(\"resource\")\n private final Object _deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException {\n+    if (jp.canReadTypeId()) {\n+        return _deserializeWithNativeTypeId(jp, ctxt);\n+    }\n     boolean hadStartArray \u003d jp.isExpectedStartArrayToken();\n     String typeId \u003d _locateTypeId(jp, ctxt);\n     JsonDeserializer\u003cObject\u003e deser \u003d _findDeserializer(ctxt, typeId);\n     if (_typeIdVisible \u0026\u0026 jp.getCurrentToken() \u003d\u003d JsonToken.START_OBJECT) {\n         TokenBuffer tb \u003d new TokenBuffer(null);\n         tb.writeStartObject();\n         tb.writeFieldName(_typePropertyName);\n         tb.writeString(typeId);\n         jp \u003d JsonParserSequence.createFlattened(tb.asParser(jp), jp);\n         jp.nextToken();\n     }\n     Object value \u003d deser.deserialize(jp, ctxt);\n     if (hadStartArray \u0026\u0026 jp.nextToken() !\u003d JsonToken.END_ARRAY) {\n         throw ctxt.wrongTokenException(jp, JsonToken.END_ARRAY, \"expected closing END_ARRAY after type information and deserialized value\");\n     }\n     return value;\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "fcbbccccff541e3492ebf5425ed5223581f77641": {
      "type": "Ymultichange(Ybodychange,Yannotationchange)",
      "commitMessage": "cleanup\n",
      "commitDate": "7/25/13, 10:42 PM",
      "commitName": "fcbbccccff541e3492ebf5425ed5223581f77641",
      "commitAuthor": "Tatu Saloranta",
      "subchanges": [
        {
          "type": "Ybodychange",
          "commitMessage": "cleanup\n",
          "commitDate": "7/25/13, 10:42 PM",
          "commitName": "fcbbccccff541e3492ebf5425ed5223581f77641",
          "commitAuthor": "Tatu Saloranta",
          "commitDateOld": "11/15/12, 10:31 PM",
          "commitNameOld": "8ba07ccfb014690281668eb46e5be6bd1883e61a",
          "commitAuthorOld": "Tatu Saloranta",
          "daysBetweenCommits": 251.97,
          "commitsBetweenForRepo": 285,
          "commitsBetweenForFile": 1,
          "actualSource": "@SuppressWarnings(\"resource\")\nprivate final Object _deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException {\n    boolean hadStartArray \u003d jp.isExpectedStartArrayToken();\n    String typeId \u003d _locateTypeId(jp, ctxt);\n    JsonDeserializer\u003cObject\u003e deser \u003d _findDeserializer(ctxt, typeId);\n    if (_typeIdVisible \u0026\u0026 jp.getCurrentToken() \u003d\u003d JsonToken.START_OBJECT) {\n        TokenBuffer tb \u003d new TokenBuffer(null);\n        tb.writeStartObject();\n        tb.writeFieldName(_typePropertyName);\n        tb.writeString(typeId);\n        jp \u003d JsonParserSequence.createFlattened(tb.asParser(jp), jp);\n        jp.nextToken();\n    }\n    Object value \u003d deser.deserialize(jp, ctxt);\n    if (hadStartArray \u0026\u0026 jp.nextToken() !\u003d JsonToken.END_ARRAY) {\n        throw ctxt.wrongTokenException(jp, JsonToken.END_ARRAY, \"expected closing END_ARRAY after type information and deserialized value\");\n    }\n    return value;\n}",
          "path": "src/main/java/com/fasterxml/jackson/databind/jsontype/impl/AsArrayTypeDeserializer.java",
          "functionStartLine": 95,
          "functionName": "_deserialize",
          "functionAnnotation": "@SuppressWarnings(\"resource\")",
          "functionDoc": "Method that handles type information wrapper, locates actual\nsubtype deserializer to use, and calls it to do actual\ndeserialization.\n",
          "diff": "@@ -1,18 +1,19 @@\n+@SuppressWarnings(\"resource\")\n private final Object _deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException {\n     boolean hadStartArray \u003d jp.isExpectedStartArrayToken();\n     String typeId \u003d _locateTypeId(jp, ctxt);\n     JsonDeserializer\u003cObject\u003e deser \u003d _findDeserializer(ctxt, typeId);\n     if (_typeIdVisible \u0026\u0026 jp.getCurrentToken() \u003d\u003d JsonToken.START_OBJECT) {\n-        @SuppressWarnings(\"resource\") TokenBuffer tb \u003d new TokenBuffer(null);\n+        TokenBuffer tb \u003d new TokenBuffer(null);\n         tb.writeStartObject();\n         tb.writeFieldName(_typePropertyName);\n         tb.writeString(typeId);\n         jp \u003d JsonParserSequence.createFlattened(tb.asParser(jp), jp);\n         jp.nextToken();\n     }\n     Object value \u003d deser.deserialize(jp, ctxt);\n     if (hadStartArray \u0026\u0026 jp.nextToken() !\u003d JsonToken.END_ARRAY) {\n         throw ctxt.wrongTokenException(jp, JsonToken.END_ARRAY, \"expected closing END_ARRAY after type information and deserialized value\");\n     }\n     return value;\n }\n\\ No newline at end of file\n",
          "extendedDetails": {}
        },
        {
          "type": "Yannotationchange",
          "commitMessage": "cleanup\n",
          "commitDate": "7/25/13, 10:42 PM",
          "commitName": "fcbbccccff541e3492ebf5425ed5223581f77641",
          "commitAuthor": "Tatu Saloranta",
          "commitDateOld": "11/15/12, 10:31 PM",
          "commitNameOld": "8ba07ccfb014690281668eb46e5be6bd1883e61a",
          "commitAuthorOld": "Tatu Saloranta",
          "daysBetweenCommits": 251.97,
          "commitsBetweenForRepo": 285,
          "commitsBetweenForFile": 1,
          "actualSource": "@SuppressWarnings(\"resource\")\nprivate final Object _deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException {\n    boolean hadStartArray \u003d jp.isExpectedStartArrayToken();\n    String typeId \u003d _locateTypeId(jp, ctxt);\n    JsonDeserializer\u003cObject\u003e deser \u003d _findDeserializer(ctxt, typeId);\n    if (_typeIdVisible \u0026\u0026 jp.getCurrentToken() \u003d\u003d JsonToken.START_OBJECT) {\n        TokenBuffer tb \u003d new TokenBuffer(null);\n        tb.writeStartObject();\n        tb.writeFieldName(_typePropertyName);\n        tb.writeString(typeId);\n        jp \u003d JsonParserSequence.createFlattened(tb.asParser(jp), jp);\n        jp.nextToken();\n    }\n    Object value \u003d deser.deserialize(jp, ctxt);\n    if (hadStartArray \u0026\u0026 jp.nextToken() !\u003d JsonToken.END_ARRAY) {\n        throw ctxt.wrongTokenException(jp, JsonToken.END_ARRAY, \"expected closing END_ARRAY after type information and deserialized value\");\n    }\n    return value;\n}",
          "path": "src/main/java/com/fasterxml/jackson/databind/jsontype/impl/AsArrayTypeDeserializer.java",
          "functionStartLine": 95,
          "functionName": "_deserialize",
          "functionAnnotation": "@SuppressWarnings(\"resource\")",
          "functionDoc": "Method that handles type information wrapper, locates actual\nsubtype deserializer to use, and calls it to do actual\ndeserialization.\n",
          "diff": "@@ -1,18 +1,19 @@\n+@SuppressWarnings(\"resource\")\n private final Object _deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException {\n     boolean hadStartArray \u003d jp.isExpectedStartArrayToken();\n     String typeId \u003d _locateTypeId(jp, ctxt);\n     JsonDeserializer\u003cObject\u003e deser \u003d _findDeserializer(ctxt, typeId);\n     if (_typeIdVisible \u0026\u0026 jp.getCurrentToken() \u003d\u003d JsonToken.START_OBJECT) {\n-        @SuppressWarnings(\"resource\") TokenBuffer tb \u003d new TokenBuffer(null);\n+        TokenBuffer tb \u003d new TokenBuffer(null);\n         tb.writeStartObject();\n         tb.writeFieldName(_typePropertyName);\n         tb.writeString(typeId);\n         jp \u003d JsonParserSequence.createFlattened(tb.asParser(jp), jp);\n         jp.nextToken();\n     }\n     Object value \u003d deser.deserialize(jp, ctxt);\n     if (hadStartArray \u0026\u0026 jp.nextToken() !\u003d JsonToken.END_ARRAY) {\n         throw ctxt.wrongTokenException(jp, JsonToken.END_ARRAY, \"expected closing END_ARRAY after type information and deserialized value\");\n     }\n     return value;\n }\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldValue": "",
            "newValue": "@SuppressWarnings(\"resource\")"
          }
        }
      ]
    },
    "8ba07ccfb014690281668eb46e5be6bd1883e61a": {
      "type": "Ybodychange",
      "commitMessage": "Exposing JsonMappingException through schema visitor interfaces; should simplify visitor implementation\n",
      "commitDate": "11/15/12, 10:31 PM",
      "commitName": "8ba07ccfb014690281668eb46e5be6bd1883e61a",
      "commitAuthor": "Tatu Saloranta",
      "commitDateOld": "10/26/12, 6:19 PM",
      "commitNameOld": "231be531579336ce5528ebc6ead81c09e5c5138b",
      "commitAuthorOld": "Tatu Saloranta",
      "daysBetweenCommits": 20.22,
      "commitsBetweenForRepo": 31,
      "commitsBetweenForFile": 1,
      "actualSource": "private final Object _deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException {\n    boolean hadStartArray \u003d jp.isExpectedStartArrayToken();\n    String typeId \u003d _locateTypeId(jp, ctxt);\n    JsonDeserializer\u003cObject\u003e deser \u003d _findDeserializer(ctxt, typeId);\n    if (_typeIdVisible \u0026\u0026 jp.getCurrentToken() \u003d\u003d JsonToken.START_OBJECT) {\n        @SuppressWarnings(\"resource\") TokenBuffer tb \u003d new TokenBuffer(null);\n        tb.writeStartObject();\n        tb.writeFieldName(_typePropertyName);\n        tb.writeString(typeId);\n        jp \u003d JsonParserSequence.createFlattened(tb.asParser(jp), jp);\n        jp.nextToken();\n    }\n    Object value \u003d deser.deserialize(jp, ctxt);\n    if (hadStartArray \u0026\u0026 jp.nextToken() !\u003d JsonToken.END_ARRAY) {\n        throw ctxt.wrongTokenException(jp, JsonToken.END_ARRAY, \"expected closing END_ARRAY after type information and deserialized value\");\n    }\n    return value;\n}",
      "path": "src/main/java/com/fasterxml/jackson/databind/jsontype/impl/AsArrayTypeDeserializer.java",
      "functionStartLine": 97,
      "functionName": "_deserialize",
      "functionAnnotation": "",
      "functionDoc": "Method that handles type information wrapper, locates actual\nsubtype deserializer to use, and calls it to do actual\ndeserialization.\n",
      "diff": "@@ -1,18 +1,18 @@\n private final Object _deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException {\n     boolean hadStartArray \u003d jp.isExpectedStartArrayToken();\n     String typeId \u003d _locateTypeId(jp, ctxt);\n     JsonDeserializer\u003cObject\u003e deser \u003d _findDeserializer(ctxt, typeId);\n     if (_typeIdVisible \u0026\u0026 jp.getCurrentToken() \u003d\u003d JsonToken.START_OBJECT) {\n-        TokenBuffer tb \u003d new TokenBuffer(null);\n+        @SuppressWarnings(\"resource\") TokenBuffer tb \u003d new TokenBuffer(null);\n         tb.writeStartObject();\n         tb.writeFieldName(_typePropertyName);\n         tb.writeString(typeId);\n         jp \u003d JsonParserSequence.createFlattened(tb.asParser(jp), jp);\n         jp.nextToken();\n     }\n     Object value \u003d deser.deserialize(jp, ctxt);\n     if (hadStartArray \u0026\u0026 jp.nextToken() !\u003d JsonToken.END_ARRAY) {\n         throw ctxt.wrongTokenException(jp, JsonToken.END_ARRAY, \"expected closing END_ARRAY after type information and deserialized value\");\n     }\n     return value;\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "8958048f38c5914bda894174f2d17b96828996b4": {
      "type": "Ybodychange",
      "commitMessage": "Implemented [JACKSON-437]; allow type id to be passed to POJO (via @JsonTypeInfo.visible\u003dtrue)\n",
      "commitDate": "1/20/12, 10:08 PM",
      "commitName": "8958048f38c5914bda894174f2d17b96828996b4",
      "commitAuthor": "Tatu Saloranta",
      "commitDateOld": "12/29/11, 10:14 PM",
      "commitNameOld": "ba0470fba09489f0fd97f2718e064b5105cafad7",
      "commitAuthorOld": "Tatu Saloranta",
      "daysBetweenCommits": 22.0,
      "commitsBetweenForRepo": 62,
      "commitsBetweenForFile": 1,
      "actualSource": "private final Object _deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException {\n    boolean hadStartArray \u003d jp.isExpectedStartArrayToken();\n    String typeId \u003d _locateTypeId(jp, ctxt);\n    JsonDeserializer\u003cObject\u003e deser \u003d _findDeserializer(ctxt, typeId);\n    if (_typeIdVisible \u0026\u0026 jp.getCurrentToken() \u003d\u003d JsonToken.START_OBJECT) {\n        TokenBuffer tb \u003d new TokenBuffer(null);\n        tb.writeStartObject();\n        tb.writeFieldName(_typePropertyName);\n        tb.writeString(typeId);\n        jp \u003d JsonParserSequence.createFlattened(tb.asParser(jp), jp);\n        jp.nextToken();\n    }\n    Object value \u003d deser.deserialize(jp, ctxt);\n    if (hadStartArray \u0026\u0026 jp.nextToken() !\u003d JsonToken.END_ARRAY) {\n        throw ctxt.wrongTokenException(jp, JsonToken.END_ARRAY, \"expected closing END_ARRAY after type information and deserialized value\");\n    }\n    return value;\n}",
      "path": "src/main/java/com/fasterxml/jackson/databind/jsontype/impl/AsArrayTypeDeserializer.java",
      "functionStartLine": 80,
      "functionName": "_deserialize",
      "functionAnnotation": "",
      "functionDoc": "Method that handles type information wrapper, locates actual\nsubtype deserializer to use, and calls it to do actual\ndeserialization.\n",
      "diff": "@@ -1,9 +1,18 @@\n private final Object _deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException {\n     boolean hadStartArray \u003d jp.isExpectedStartArrayToken();\n-    JsonDeserializer\u003cObject\u003e deser \u003d _findDeserializer(ctxt, _locateTypeId(jp, ctxt));\n+    String typeId \u003d _locateTypeId(jp, ctxt);\n+    JsonDeserializer\u003cObject\u003e deser \u003d _findDeserializer(ctxt, typeId);\n+    if (_typeIdVisible \u0026\u0026 jp.getCurrentToken() \u003d\u003d JsonToken.START_OBJECT) {\n+        TokenBuffer tb \u003d new TokenBuffer(null);\n+        tb.writeStartObject();\n+        tb.writeFieldName(_typePropertyName);\n+        tb.writeString(typeId);\n+        jp \u003d JsonParserSequence.createFlattened(tb.asParser(jp), jp);\n+        jp.nextToken();\n+    }\n     Object value \u003d deser.deserialize(jp, ctxt);\n     if (hadStartArray \u0026\u0026 jp.nextToken() !\u003d JsonToken.END_ARRAY) {\n         throw ctxt.wrongTokenException(jp, JsonToken.END_ARRAY, \"expected closing END_ARRAY after type information and deserialized value\");\n     }\n     return value;\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "ba0470fba09489f0fd97f2718e064b5105cafad7": {
      "type": "Ybodychange",
      "commitMessage": "Merged [JACKSON-712] fix in, with proper 2.0 changes\n",
      "commitDate": "12/29/11, 10:14 PM",
      "commitName": "ba0470fba09489f0fd97f2718e064b5105cafad7",
      "commitAuthor": "Tatu Saloranta",
      "commitDateOld": "12/23/11, 6:23 PM",
      "commitNameOld": "d92c1ed454e8474103e7eb698b0a855e7850dbb5",
      "commitAuthorOld": "Tatu Saloranta",
      "daysBetweenCommits": 6.16,
      "commitsBetweenForRepo": 28,
      "commitsBetweenForFile": 1,
      "actualSource": "private final Object _deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException {\n    boolean hadStartArray \u003d jp.isExpectedStartArrayToken();\n    JsonDeserializer\u003cObject\u003e deser \u003d _findDeserializer(ctxt, _locateTypeId(jp, ctxt));\n    Object value \u003d deser.deserialize(jp, ctxt);\n    if (hadStartArray \u0026\u0026 jp.nextToken() !\u003d JsonToken.END_ARRAY) {\n        throw ctxt.wrongTokenException(jp, JsonToken.END_ARRAY, \"expected closing END_ARRAY after type information and deserialized value\");\n    }\n    return value;\n}",
      "path": "src/main/java/com/fasterxml/jackson/databind/jsontype/impl/AsArrayTypeDeserializer.java",
      "functionStartLine": 78,
      "functionName": "_deserialize",
      "functionAnnotation": "",
      "functionDoc": "Method that handles type information wrapper, locates actual\nsubtype deserializer to use, and calls it to do actual\ndeserialization.\n",
      "diff": "@@ -1,8 +1,9 @@\n private final Object _deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException {\n+    boolean hadStartArray \u003d jp.isExpectedStartArrayToken();\n     JsonDeserializer\u003cObject\u003e deser \u003d _findDeserializer(ctxt, _locateTypeId(jp, ctxt));\n     Object value \u003d deser.deserialize(jp, ctxt);\n-    if (jp.nextToken() !\u003d JsonToken.END_ARRAY) {\n+    if (hadStartArray \u0026\u0026 jp.nextToken() !\u003d JsonToken.END_ARRAY) {\n         throw ctxt.wrongTokenException(jp, JsonToken.END_ARRAY, \"expected closing END_ARRAY after type information and deserialized value\");\n     }\n     return value;\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "e4f23bb6779d434d88a7c4335f92d13ea639b373": {
      "type": "Yintroduced",
      "commitMessage": "First check-in, tons of compilation errors to resolve\n",
      "commitDate": "12/23/11, 12:31 AM",
      "commitName": "e4f23bb6779d434d88a7c4335f92d13ea639b373",
      "commitAuthor": "Tatu Saloranta",
      "diff": "@@ -0,0 +1,8 @@\n+private final Object _deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException {\n+    JsonDeserializer\u003cObject\u003e deser \u003d _findDeserializer(ctxt, _locateTypeId(jp, ctxt));\n+    Object value \u003d deser.deserialize(jp, ctxt);\n+    if (jp.nextToken() !\u003d JsonToken.END_ARRAY) {\n+        throw ctxt.wrongTokenException(jp, JsonToken.END_ARRAY, \"expected closing END_ARRAY after type information and deserialized value\");\n+    }\n+    return value;\n+}\n\\ No newline at end of file\n",
      "actualSource": "private final Object _deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException {\n    JsonDeserializer\u003cObject\u003e deser \u003d _findDeserializer(ctxt, _locateTypeId(jp, ctxt));\n    Object value \u003d deser.deserialize(jp, ctxt);\n    if (jp.nextToken() !\u003d JsonToken.END_ARRAY) {\n        throw ctxt.wrongTokenException(jp, JsonToken.END_ARRAY, \"expected closing END_ARRAY after type information and deserialized value\");\n    }\n    return value;\n}",
      "path": "src/main/java/com/fasterxml/jackson/databind/jsontype/impl/AsArrayTypeDeserializer.java",
      "functionStartLine": 84,
      "functionName": "_deserialize",
      "functionAnnotation": "",
      "functionDoc": "Method that handles type information wrapper, locates actual\nsubtype deserializer to use, and calls it to do actual\ndeserialization.\n"
    }
  }
}