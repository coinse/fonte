{
	"Time-1b": [
		{
			"class_file": "org/joda/time/field/UnsupportedDurationField.java",
			"method_name": "compareTo",
			"arg_types": "Lorg/joda/time/DurationField;",
			"type": "method",
			"signature": "org.joda.time.field.UnsupportedDurationField.compareTo(org.joda.time.DurationField)",
			"begin_line": 226,
			"end_line": 231,
			"comment": "\n     * Always returns zero, indicating that sort order is not relevent.\n     *\n     * @return zero always\n     "
		},
		{
			"class_file": "org/joda/time/Partial.java",
			"method_name": "<init>",
			"arg_types": "[Lorg/joda/time/DateTimeFieldType;[ILorg/joda/time/Chronology;",
			"type": "constructor",
			"signature": "org.joda.time.Partial.Partial(org.joda.time.DateTimeFieldType[], int[], org.joda.time.Chronology)",
			"begin_line": 189,
			"end_line": 251,
			"comment": "\n     * Constructs a Partial with the specified fields and values.\n     * The fields must be specified in the order largest to smallest.\n     * <p>\n     * The constructor uses the specified chronology.\n     * \n     * @param types  the types to create the partial from, not null\n     * @param values  the values to store, not null\n     * @param chronology  the chronology, null means ISO\n     * @throws IllegalArgumentException if the types or values are invalid\n     "
		}
	],
	"Time-2b": [
		{
			"class_file": "org/joda/time/Partial.java",
			"method_name": "with",
			"arg_types": "Lorg/joda/time/DateTimeFieldType;I",
			"type": "method",
			"signature": "org.joda.time.Partial.with(org.joda.time.DateTimeFieldType, int)",
			"begin_line": 428,
			"end_line": 476,
			"comment": "\n     * Gets a copy of this date with the specified field set to a new value.\n     * <p>\n     * If this partial did not previously support the field, the new one will.\n     * Contrast this behaviour with {@link #withField(DateTimeFieldType, int)}.\n     * <p>\n     * For example, if the field type is <code>dayOfMonth</code> then the day\n     * would be changed/added in the returned instance.\n     *\n     * @param fieldType  the field type to set, not null\n     * @param value  the value to set\n     * @return a copy of this instance with the field set\n     * @throws IllegalArgumentException if the value is null or invalid\n     "
		},
		{
			"class_file": "org/joda/time/field/UnsupportedDurationField.java",
			"method_name": "compareTo",
			"arg_types": "Lorg/joda/time/DurationField;",
			"type": "method",
			"signature": "org.joda.time.field.UnsupportedDurationField.compareTo(org.joda.time.DurationField)",
			"begin_line": 226,
			"end_line": 228,
			"comment": "\n     * Always returns zero, indicating that sort order is not relevent.\n     *\n     * @return zero always\n     "
		},
		{
			"class_file": "org/joda/time/Partial.java",
			"method_name": "<init>",
			"arg_types": "[Lorg/joda/time/DateTimeFieldType;[ILorg/joda/time/Chronology;",
			"type": "constructor",
			"signature": "org.joda.time.Partial.Partial(org.joda.time.DateTimeFieldType[], int[], org.joda.time.Chronology)",
			"begin_line": 189,
			"end_line": 251,
			"comment": "\n     * Constructs a Partial with the specified fields and values.\n     * The fields must be specified in the order largest to smallest.\n     * <p>\n     * The constructor uses the specified chronology.\n     * \n     * @param types  the types to create the partial from, not null\n     * @param values  the values to store, not null\n     * @param chronology  the chronology, null means ISO\n     * @throws IllegalArgumentException if the types or values are invalid\n     "
		}
	],
	"Time-3b": [
		{
			"class_file": "org/joda/time/MutableDateTime.java",
			"method_name": "addHours",
			"arg_types": "I",
			"type": "method",
			"signature": "org.joda.time.MutableDateTime.addHours(int)",
			"begin_line": 784,
			"end_line": 786,
			"comment": "\n     * Add a number of hours to the date.\n     *\n     * @param hours  the hours to add\n     * @throws IllegalArgumentException if the value is invalid\n     "
		},
		{
			"class_file": "org/joda/time/MutableDateTime.java",
			"method_name": "addMinutes",
			"arg_types": "I",
			"type": "method",
			"signature": "org.joda.time.MutableDateTime.addMinutes(int)",
			"begin_line": 815,
			"end_line": 817,
			"comment": "\n     * Add a number of minutes to the date.\n     *\n     * @param minutes  the minutes to add\n     * @throws IllegalArgumentException if the value is invalid\n     "
		},
		{
			"class_file": "org/joda/time/MutableDateTime.java",
			"method_name": "addYears",
			"arg_types": "I",
			"type": "method",
			"signature": "org.joda.time.MutableDateTime.addYears(int)",
			"begin_line": 659,
			"end_line": 661,
			"comment": "\n     * Add a number of years to the date.\n     *\n     * @param years  the years to add\n     * @throws IllegalArgumentException if the value is invalid\n     "
		},
		{
			"class_file": "org/joda/time/MutableDateTime.java",
			"method_name": "addWeekyears",
			"arg_types": "I",
			"type": "method",
			"signature": "org.joda.time.MutableDateTime.addWeekyears(int)",
			"begin_line": 680,
			"end_line": 682,
			"comment": "\n     * Add a number of weekyears to the date.\n     *\n     * @param weekyears  the weekyears to add\n     * @throws IllegalArgumentException if the value is invalid\n     "
		},
		{
			"class_file": "org/joda/time/MutableDateTime.java",
			"method_name": "addMonths",
			"arg_types": "I",
			"type": "method",
			"signature": "org.joda.time.MutableDateTime.addMonths(int)",
			"begin_line": 701,
			"end_line": 703,
			"comment": "\n     * Add a number of months to the date.\n     *\n     * @param months  the months to add\n     * @throws IllegalArgumentException if the value is invalid\n     "
		},
		{
			"class_file": "org/joda/time/MutableDateTime.java",
			"method_name": "add",
			"arg_types": "Lorg/joda/time/DurationFieldType;I",
			"type": "method",
			"signature": "org.joda.time.MutableDateTime.add(org.joda.time.DurationFieldType, int)",
			"begin_line": 635,
			"end_line": 640,
			"comment": "\n     * Adds to the instant specifying the duration and multiple to add.\n     *\n     * @param type  a field type, usually obtained from DateTimeFieldType, not null\n     * @param amount  the amount to add of this duration\n     * @throws IllegalArgumentException if the value is null or invalid\n     * @throws ArithmeticException if the result exceeds the capacity of the instant\n     "
		},
		{
			"class_file": "org/joda/time/MutableDateTime.java",
			"method_name": "addMillis",
			"arg_types": "I",
			"type": "method",
			"signature": "org.joda.time.MutableDateTime.addMillis(int)",
			"begin_line": 879,
			"end_line": 881,
			"comment": "\n     * Add a number of milliseconds to the date. The implementation of this\n     * method differs from the {@link #add(long)} method in that a\n     * DateTimeField performs the addition.\n     *\n     * @param millis  the milliseconds to add\n     * @throws IllegalArgumentException if the value is invalid\n     "
		},
		{
			"class_file": "org/joda/time/MutableDateTime.java",
			"method_name": "addSeconds",
			"arg_types": "I",
			"type": "method",
			"signature": "org.joda.time.MutableDateTime.addSeconds(int)",
			"begin_line": 846,
			"end_line": 848,
			"comment": "\n     * Add a number of seconds to the date.\n     *\n     * @param seconds  the seconds to add\n     * @throws IllegalArgumentException if the value is invalid\n     "
		},
		{
			"class_file": "org/joda/time/MutableDateTime.java",
			"method_name": "addWeeks",
			"arg_types": "I",
			"type": "method",
			"signature": "org.joda.time.MutableDateTime.addWeeks(int)",
			"begin_line": 722,
			"end_line": 724,
			"comment": "\n     * Add a number of weeks to the date.\n     *\n     * @param weeks  the weeks to add\n     * @throws IllegalArgumentException if the value is invalid\n     "
		},
		{
			"class_file": "org/joda/time/MutableDateTime.java",
			"method_name": "addDays",
			"arg_types": "I",
			"type": "method",
			"signature": "org.joda.time.MutableDateTime.addDays(int)",
			"begin_line": 763,
			"end_line": 765,
			"comment": "\n     * Add a number of days to the date.\n     *\n     * @param days  the days to add\n     * @throws IllegalArgumentException if the value is invalid\n     "
		}
	],
	"Time-4b": [
		{
			"class_file": "org/joda/time/Partial.java",
			"method_name": "with",
			"arg_types": "Lorg/joda/time/DateTimeFieldType;I",
			"type": "method",
			"signature": "org.joda.time.Partial.with(org.joda.time.DateTimeFieldType, int)",
			"begin_line": 426,
			"end_line": 474,
			"comment": "\n     * Gets a copy of this date with the specified field set to a new value.\n     * <p>\n     * If this partial did not previously support the field, the new one will.\n     * Contrast this behaviour with {@link #withField(DateTimeFieldType, int)}.\n     * <p>\n     * For example, if the field type is <code>dayOfMonth</code> then the day\n     * would be changed/added in the returned instance.\n     *\n     * @param fieldType  the field type to set, not null\n     * @param value  the value to set\n     * @return a copy of this instance with the field set\n     * @throws IllegalArgumentException if the value is null or invalid\n     "
		}
	],
	"Time-5b": [
		{
			"class_file": "org/joda/time/Period.java",
			"method_name": "normalizedStandard",
			"arg_types": "Lorg/joda/time/PeriodType;",
			"type": "method",
			"signature": "org.joda.time.Period.normalizedStandard(org.joda.time.PeriodType)",
			"begin_line": 1616,
			"end_line": 1638,
			"comment": "\n     * Normalizes this period using standard rules, assuming a 12 month year,\n     * 7 day week, 24 hour day, 60 minute hour and 60 second minute,\n     * providing control over how the result is split into fields.\n     * <p>\n     * This method allows you to normalize a period.\n     * However to achieve this it makes the assumption that all years are\n     * 12 months, all weeks are 7 days, all days are 24 hours,\n     * all hours are 60 minutes and all minutes are 60 seconds. This is not\n     * true when daylight savings time is considered, and may also not be true\n     * for some chronologies. However, it is included as it is a useful operation\n     * for many applications and business rules.\n     * <p>\n     * If the period contains years or months, then the months will be\n     * normalized to be between 0 and 11. The days field and below will be\n     * normalized as necessary, however this will not overflow into the months\n     * field. Thus a period of 1 year 15 months will normalize to 2 years 3 months.\n     * But a period of 1 month 40 days will remain as 1 month 40 days.\n     * <p>\n     * The PeriodType parameter controls how the result is created. It allows\n     * you to omit certain fields from the result if desired. For example,\n     * you may not want the result to include weeks, in which case you pass\n     * in <code>PeriodType.yearMonthDayTime()</code>.\n     * \n     * @param type  the period type of the new period, null means standard type\n     * @return a normalized period equivalent to this period\n     * @throws ArithmeticException if any field is too large to be represented\n     * @throws UnsupportedOperationException if this period contains non-zero\n     *  years or months but the specified period type does not support them\n     * @since 1.5\n     "
		}
	],
	"Time-6b": [
		{
			"class_file": "org/joda/time/chrono/GJChronology.java",
			"method_name": "add",
			"arg_types": "JI",
			"type": "method",
			"signature": "org.joda.time.chrono.GJChronology.ImpreciseCutoverField.add(long, int)",
			"begin_line": 973,
			"end_line": 993,
			"comment": ""
		},
		{
			"class_file": "org/joda/time/chrono/GJChronology.java",
			"method_name": "add",
			"arg_types": "JJ",
			"type": "method",
			"signature": "org.joda.time.chrono.GJChronology.ImpreciseCutoverField.add(long, long)",
			"begin_line": 995,
			"end_line": 1015,
			"comment": ""
		},
		{
			"class_file": "org/joda/time/chrono/GJChronology.java",
			"method_name": "getInstance",
			"arg_types": "Lorg/joda/time/DateTimeZone;Lorg/joda/time/ReadableInstant;I",
			"type": "method",
			"signature": "org.joda.time.chrono.GJChronology.getInstance(org.joda.time.DateTimeZone, org.joda.time.ReadableInstant, int)",
			"begin_line": 185,
			"end_line": 230,
			"comment": "\n     * Factory method returns instances of the GJ cutover chronology. Any\n     * cutover date may be specified.\n     *\n     * @param zone  the time zone to use, null is default\n     * @param gregorianCutover  the cutover to use, null means default\n     * @param minDaysInFirstWeek  minimum number of days in first week of the year; default is 4\n     "
		}
	],
	"Time-7b": [
		{
			"class_file": "org/joda/time/format/DateTimeFormatter.java",
			"method_name": "parseInto",
			"arg_types": "Lorg/joda/time/ReadWritableInstant;Ljava/lang/String;I",
			"type": "method",
			"signature": "org.joda.time.format.DateTimeFormatter.parseInto(org.joda.time.ReadWritableInstant, java.lang.String, int)",
			"begin_line": 700,
			"end_line": 728,
			"comment": "\n     * Parses a datetime from the given text, at the given position, saving the\n     * result into the fields of the given ReadWritableInstant. If the parse\n     * succeeds, the return value is the new text position. Note that the parse\n     * may succeed without fully reading the text and in this case those fields\n     * that were read will be set.\n     * <p>\n     * Only those fields present in the string will be changed in the specified\n     * instant. All other fields will remain unaltered. Thus if the string only\n     * contains a year and a month, then the day and time will be retained from\n     * the input instant. If this is not the behaviour you want, then reset the\n     * fields before calling this method, or use {@link #parseDateTime(String)}\n     * or {@link #parseMutableDateTime(String)}.\n     * <p>\n     * If it fails, the return value is negative, but the instant may still be\n     * modified. To determine the position where the parse failed, apply the\n     * one's complement operator (~) on the return value.\n     * <p>\n     * This parse method ignores the {@link #getDefaultYear() default year} and\n     * parses using the year from the supplied instant based on the chronology\n     * and time-zone of the supplied instant.\n     * <p>\n     * The parse will use the chronology of the instant.\n     *\n     * @param instant  an instant that will be modified, not null\n     * @param text  the text to parse\n     * @param position  position to start parsing from\n     * @return new position, negative value means parse failed -\n     *  apply complement operator (~) to get position of failure\n     * @throws UnsupportedOperationException if parsing is not supported\n     * @throws IllegalArgumentException if the instant is null\n     * @throws IllegalArgumentException if any field is out of range\n     "
		}
	],
	"Time-8b": [
		{
			"class_file": "org/joda/time/DateTimeZone.java",
			"method_name": "forOffsetHoursMinutes",
			"arg_types": "II",
			"type": "method",
			"signature": "org.joda.time.DateTimeZone.forOffsetHoursMinutes(int, int)",
			"begin_line": 272,
			"end_line": 295,
			"comment": "\n     * Gets a time zone instance for the specified offset to UTC in hours and minutes.\n     * This method assumes 60 minutes in an hour, and standard length minutes.\n     * <p>\n     * This factory is a convenient way of constructing zones with a fixed offset.\n     * The hours value must be in the range -23 to +23.\n     * The minutes value must be in the range -59 to +59.\n     * The following combinations of sign for the hour and minute are possible:\n     * <pre>\n     *  Hour    Minute    Example    Result\n     * \n     *  +ve     +ve       (2, 15)    +02:15\n     *  +ve     zero      (2, 0)     +02:00\n     *  +ve     -ve       (2, -15)   IllegalArgumentException\n     * \n     *  zero    +ve       (0, 15)    +00:15\n     *  zero    zero      (0, 0)     +00:00\n     *  zero    -ve       (0, -15)   -00:15\n     * \n     *  -ve     +ve       (-2, 15)   -02:15\n     *  -ve     zero      (-2, 0)    -02:00\n     *  -ve     -ve       (-2, -15)  -02:15\n     * </pre>\n     * Note that in versions before 2.3, the minutes had to be zero or positive.\n     * \n     * @param hoursOffset  the offset in hours from UTC, from -23 to +23\n     * @param minutesOffset  the offset in minutes from UTC, from -59 to +59\n     * @return the DateTimeZone object for the offset\n     * @throws IllegalArgumentException if any value is out of range, the minutes are negative\n     *  when the hours are positive, or the resulting offset exceeds +/- 23:59:59.000\n     "
		}
	],
	"Time-9b": [
		{
			"class_file": "org/joda/time/DateTimeZone.java",
			"method_name": "forOffsetHoursMinutes",
			"arg_types": "II",
			"type": "method",
			"signature": "org.joda.time.DateTimeZone.forOffsetHoursMinutes(int, int)",
			"begin_line": 253,
			"end_line": 273,
			"comment": "\n     * Gets a time zone instance for the specified offset to UTC in hours and minutes.\n     * This method assumes 60 minutes in an hour, and standard length minutes.\n     * <p>\n     * This factory is a convenient way of constructing zones with a fixed offset.\n     * The minutes value is always positive and in the range 0 to 59.\n     * If constructed with the values (-2, 30), the resulting zone is '-02:30'.\n     * \n     * @param hoursOffset  the offset in hours from UTC, from -23 to +23\n     * @param minutesOffset  the offset in minutes from UTC, must be between 0 and 59 inclusive\n     * @return the DateTimeZone object for the offset\n     * @throws IllegalArgumentException if the offset or minute is too large or too small\n     "
		},
		{
			"class_file": "org/joda/time/DateTimeZone.java",
			"method_name": "forOffsetMillis",
			"arg_types": "I",
			"type": "method",
			"signature": "org.joda.time.DateTimeZone.forOffsetMillis(int)",
			"begin_line": 281,
			"end_line": 284,
			"comment": "\n     * Gets a time zone instance for the specified offset to UTC in milliseconds.\n     *\n     * @param millisOffset  the offset in millis from UTC, from -23:59:59.999 to +23:59:59.999\n     * @return the DateTimeZone object for the offset\n     "
		}
	],
	"Time-10b": [
		{
			"class_file": "org/joda/time/base/BaseSingleFieldPeriod.java",
			"method_name": "between",
			"arg_types": "Lorg/joda/time/ReadablePartial;Lorg/joda/time/ReadablePartial;Lorg/joda/time/ReadablePeriod;",
			"type": "method",
			"signature": "org.joda.time.base.BaseSingleFieldPeriod.between(org.joda.time.ReadablePartial, org.joda.time.ReadablePartial, org.joda.time.ReadablePeriod)",
			"begin_line": 88,
			"end_line": 106,
			"comment": "\n     * Calculates the number of whole units between the two specified partial datetimes.\n     * <p>\n     * The two partials must contain the same fields, for example you can specify\n     * two <code>LocalDate</code> objects.\n     *\n     * @param start  the start partial date, validated to not be null\n     * @param end  the end partial date, validated to not be null\n     * @param zeroInstance  the zero instance constant, must not be null\n     * @return the period\n     * @throws IllegalArgumentException if the partials are null or invalid\n     "
		}
	],
	"Time-11b": [
		{
			"class_file": "org/joda/time/tz/ZoneInfoCompiler.java",
			"method_name": "<clinit>",
			"arg_types": "",
			"type": "field",
			"varNames": [
				"cVerbose"
			],
			"begin_line": 68,
			"end_line": 68,
			"comment": ""
		}
	],
	"Time-12b": [
		{
			"class_file": "org/joda/time/LocalDate.java",
			"method_name": "fromDateFields",
			"arg_types": "Ljava/util/Date;",
			"type": "method",
			"signature": "org.joda.time.LocalDate.fromDateFields(java.util.Date)",
			"begin_line": 238,
			"end_line": 249,
			"comment": "\n     * Constructs a LocalDate from a <code>java.util.Date</code>\n     * using exactly the same field values.\n     * <p>\n     * Each field is queried from the Date and assigned to the LocalDate.\n     * This is useful if you have been using the Date as a local date,\n     * ignoring the zone.\n     * <p>\n     * One advantage of this method is that this method is unaffected if the\n     * version of the time zone data differs between the JDK and Joda-Time.\n     * That is because the local field values are transferred, calculated using\n     * the JDK time zone data and without using the Joda-Time time zone data.\n     * <p>\n     * This factory method always creates a LocalDate with ISO chronology.\n     *\n     * @param date  the Date to extract fields from, not null\n     * @return the created local date, not null\n     * @throws IllegalArgumentException if the calendar is null\n     * @throws IllegalArgumentException if the date is invalid for the ISO chronology\n     "
		},
		{
			"class_file": "org/joda/time/LocalDateTime.java",
			"method_name": "fromCalendarFields",
			"arg_types": "Ljava/util/Calendar;",
			"type": "method",
			"signature": "org.joda.time.LocalDateTime.fromCalendarFields(java.util.Calendar)",
			"begin_line": 195,
			"end_line": 209,
			"comment": "\n     * Constructs a LocalDateTime from a <code>java.util.Calendar</code>\n     * using exactly the same field values.\n     * <p>\n     * Each field is queried from the Calendar and assigned to the LocalDateTime.\n     * This is useful if you have been using the Calendar as a local date,\n     * ignoring the zone.\n     * <p>\n     * One advantage of this method is that this method is unaffected if the\n     * version of the time zone data differs between the JDK and Joda-Time.\n     * That is because the local field values are transferred, calculated using\n     * the JDK time zone data and without using the Joda-Time time zone data.\n     * <p>\n     * This factory method ignores the type of the calendar and always\n     * creates a LocalDateTime with ISO chronology. It is expected that you\n     * will only pass in instances of <code>GregorianCalendar</code> however\n     * this is not validated.\n     *\n     * @param calendar  the Calendar to extract fields from, not null\n     * @return the created local date-time, not null\n     * @throws IllegalArgumentException if the calendar is null\n     * @throws IllegalArgumentException if the date is invalid for the ISO chronology\n     "
		},
		{
			"class_file": "org/joda/time/LocalDateTime.java",
			"method_name": "fromDateFields",
			"arg_types": "Ljava/util/Date;",
			"type": "method",
			"signature": "org.joda.time.LocalDateTime.fromDateFields(java.util.Date)",
			"begin_line": 231,
			"end_line": 246,
			"comment": "\n     * Constructs a LocalDateTime from a <code>java.util.Date</code>\n     * using exactly the same field values.\n     * <p>\n     * Each field is queried from the Date and assigned to the LocalDateTime.\n     * This is useful if you have been using the Date as a local date,\n     * ignoring the zone.\n     * <p>\n     * One advantage of this method is that this method is unaffected if the\n     * version of the time zone data differs between the JDK and Joda-Time.\n     * That is because the local field values are transferred, calculated using\n     * the JDK time zone data and without using the Joda-Time time zone data.\n     * <p>\n     * This factory method always creates a LocalDateTime with ISO chronology.\n     *\n     * @param date  the Date to extract fields from, not null\n     * @return the created local date-time, not null\n     * @throws IllegalArgumentException if the calendar is null\n     * @throws IllegalArgumentException if the date is invalid for the ISO chronology\n     "
		},
		{
			"class_file": "org/joda/time/LocalDate.java",
			"method_name": "fromCalendarFields",
			"arg_types": "Ljava/util/Calendar;",
			"type": "method",
			"signature": "org.joda.time.LocalDate.fromCalendarFields(java.util.Calendar)",
			"begin_line": 206,
			"end_line": 216,
			"comment": "\n     * Constructs a LocalDate from a <code>java.util.Calendar</code>\n     * using exactly the same field values.\n     * <p>\n     * Each field is queried from the Calendar and assigned to the LocalDate.\n     * This is useful if you have been using the Calendar as a local date,\n     * ignoring the zone.\n     * <p>\n     * One advantage of this method is that this method is unaffected if the\n     * version of the time zone data differs between the JDK and Joda-Time.\n     * That is because the local field values are transferred, calculated using\n     * the JDK time zone data and without using the Joda-Time time zone data.\n     * <p>\n     * This factory method ignores the type of the calendar and always\n     * creates a LocalDate with ISO chronology. It is expected that you\n     * will only pass in instances of <code>GregorianCalendar</code> however\n     * this is not validated.\n     *\n     * @param calendar  the Calendar to extract fields from, not null\n     * @return the created local date, not null\n     * @throws IllegalArgumentException if the calendar is null\n     * @throws IllegalArgumentException if the date is invalid for the ISO chronology\n     "
		}
	],
	"Time-13b": [
		{
			"class_file": "org/joda/time/format/PeriodFormatterBuilder.java",
			"method_name": "calculatePrintedLength",
			"arg_types": "Lorg/joda/time/ReadablePeriod;Ljava/util/Locale;",
			"type": "method",
			"signature": "org.joda.time.format.PeriodFormatterBuilder.FieldFormatter.calculatePrintedLength(org.joda.time.ReadablePeriod, java.util.Locale)",
			"begin_line": 1088,
			"end_line": 1118,
			"comment": ""
		},
		{
			"class_file": "org/joda/time/format/PeriodFormatterBuilder.java",
			"method_name": "printTo",
			"arg_types": "Ljava/lang/StringBuffer;Lorg/joda/time/ReadablePeriod;Ljava/util/Locale;",
			"type": "method",
			"signature": "org.joda.time.format.PeriodFormatterBuilder.FieldFormatter.printTo(java.lang.StringBuffer, org.joda.time.ReadablePeriod, java.util.Locale)",
			"begin_line": 1120,
			"end_line": 1149,
			"comment": ""
		}
	],
	"Time-14b": [
		{
			"class_file": "org/joda/time/chrono/BasicMonthOfYearDateTimeField.java",
			"method_name": "add",
			"arg_types": "Lorg/joda/time/ReadablePartial;I[II",
			"type": "method",
			"signature": "org.joda.time.chrono.BasicMonthOfYearDateTimeField.add(org.joda.time.ReadablePartial, int, int[], int)",
			"begin_line": 203,
			"end_line": 220,
			"comment": "-----------------------------------------------------------------------"
		}
	],
	"Time-15b": [
		{
			"class_file": "org/joda/time/field/FieldUtils.java",
			"method_name": "safeMultiply",
			"arg_types": "JI",
			"type": "method",
			"signature": "org.joda.time.field.FieldUtils.safeMultiply(long, int)",
			"begin_line": 135,
			"end_line": 149,
			"comment": "\n     * Multiply two values throwing an exception if overflow occurs.\n     * \n     * @param val1  the first value\n     * @param val2  the second value\n     * @return the new total\n     * @throws ArithmeticException if the value is too big or too small\n     * @since 1.2\n     "
		}
	],
	"Time-16b": [
		{
			"class_file": "org/joda/time/format/DateTimeFormatter.java",
			"method_name": "parseInto",
			"arg_types": "Lorg/joda/time/ReadWritableInstant;Ljava/lang/String;I",
			"type": "method",
			"signature": "org.joda.time.format.DateTimeFormatter.parseInto(org.joda.time.ReadWritableInstant, java.lang.String, int)",
			"begin_line": 697,
			"end_line": 724,
			"comment": "\n     * Parses a datetime from the given text, at the given position, saving the\n     * result into the fields of the given ReadWritableInstant. If the parse\n     * succeeds, the return value is the new text position. Note that the parse\n     * may succeed without fully reading the text and in this case those fields\n     * that were read will be set.\n     * <p>\n     * Only those fields present in the string will be changed in the specified\n     * instant. All other fields will remain unaltered. Thus if the string only\n     * contains a year and a month, then the day and time will be retained from\n     * the input instant. If this is not the behaviour you want, then reset the\n     * fields before calling this method, or use {@link #parseDateTime(String)}\n     * or {@link #parseMutableDateTime(String)}.\n     * <p>\n     * If it fails, the return value is negative, but the instant may still be\n     * modified. To determine the position where the parse failed, apply the\n     * one's complement operator (~) on the return value.\n     * <p>\n     * This parse method ignores the {@link #getDefaultYear() default year} and\n     * parses using the year from the supplied instant as the default.\n     * <p>\n     * The parse will use the chronology of the instant.\n     *\n     * @param instant  an instant that will be modified, not null\n     * @param text  the text to parse\n     * @param position  position to start parsing from\n     * @return new position, negative value means parse failed -\n     *  apply complement operator (~) to get position of failure\n     * @throws UnsupportedOperationException if parsing is not supported\n     * @throws IllegalArgumentException if the instant is null\n     * @throws IllegalArgumentException if any field is out of range\n     "
		}
	],
	"Time-17b": [
		{
			"class_file": "org/joda/time/DateTimeZone.java",
			"method_name": "adjustOffset",
			"arg_types": "JZ",
			"type": "method",
			"signature": "org.joda.time.DateTimeZone.adjustOffset(long, boolean)",
			"begin_line": 1163,
			"end_line": 1180,
			"comment": "\n     * Adjusts the offset to be the earlier or later one during an overlap.\n     * \n     * @param instant  the instant to adjust\n     * @param earlierOrLater  false for earlier, true for later\n     * @return the adjusted instant millis\n     "
		}
	],
	"Time-18b": [
		{
			"class_file": "org/joda/time/chrono/GJChronology.java",
			"method_name": "getDateTimeMillis",
			"arg_types": "IIIIIII",
			"type": "method",
			"signature": "org.joda.time.chrono.GJChronology.getDateTimeMillis(int, int, int, int, int, int, int)",
			"begin_line": 350,
			"end_line": 378,
			"comment": ""
		}
	],
	"Time-19b": [
		{
			"class_file": "org/joda/time/DateTimeZone.java",
			"method_name": "getOffsetFromLocal",
			"arg_types": "J",
			"type": "method",
			"signature": "org.joda.time.DateTimeZone.getOffsetFromLocal(long)",
			"begin_line": 880,
			"end_line": 911,
			"comment": "\n     * Gets the millisecond offset to subtract from local time to get UTC time.\n     * This offset can be used to undo adding the offset obtained by getOffset.\n     *\n     * <pre>\n     * millisLocal == millisUTC   + getOffset(millisUTC)\n     * millisUTC   == millisLocal - getOffsetFromLocal(millisLocal)\n     * </pre>\n     *\n     * NOTE: After calculating millisLocal, some error may be introduced. At\n     * offset transitions (due to DST or other historical changes), ranges of\n     * local times may map to different UTC times.\n     * <p>\n     * This method will return an offset suitable for calculating an instant\n     * after any DST gap. For example, consider a zone with a cutover\n     * from 01:00 to 01:59:<br />\n     * Input: 00:00  Output: 00:00<br />\n     * Input: 00:30  Output: 00:30<br />\n     * Input: 01:00  Output: 02:00<br />\n     * Input: 01:30  Output: 02:30<br />\n     * Input: 02:00  Output: 02:00<br />\n     * Input: 02:30  Output: 02:30<br />\n     * <p>\n     * During a DST overlap (where the local time is ambiguous) this method will return\n     * the earlier instant. The combination of these two rules is to always favour\n     * daylight (summer) time over standard (winter) time.\n     * <p>\n     * NOTE: Prior to v2.0, the DST overlap behaviour was not defined and varied by hemisphere.\n     * Prior to v1.5, the DST gap behaviour was also not defined.\n     *\n     * @param instantLocal  the millisecond instant, relative to this time zone, to get the offset for\n     * @return the millisecond offset to subtract from local time to get UTC time\n     "
		}
	],
	"Time-20b": [
		{
			"class_file": "org/joda/time/format/DateTimeFormatterBuilder.java",
			"method_name": "parseInto",
			"arg_types": "Lorg/joda/time/format/DateTimeParserBucket;Ljava/lang/String;I",
			"type": "method",
			"signature": "org.joda.time.format.DateTimeFormatterBuilder.TimeZoneId.parseInto(org.joda.time.format.DateTimeParserBucket, java.lang.String, int)",
			"begin_line": 2540,
			"end_line": 2549,
			"comment": ""
		}
	],
	"Time-22b": [
		{
			"class_file": "org/joda/time/base/BasePeriod.java",
			"method_name": "<init>",
			"arg_types": "J",
			"type": "constructor",
			"signature": "org.joda.time.base.BasePeriod.BasePeriod(long)",
			"begin_line": 221,
			"end_line": 224,
			"comment": "\n     * Creates a period from the given millisecond duration with the standard period type\n     * and ISO rules, ensuring that the calculation is performed with the time-only period type.\n     * <p>\n     * The calculation uses the hour, minute, second and millisecond fields.\n     *\n     * @param duration  the duration, in milliseconds\n     "
		}
	],
	"Time-23b": [
		{
			"class_file": "org/joda/time/DateTimeZone.java",
			"method_name": "getConvertedId",
			"arg_types": "Ljava/lang/String;",
			"type": "method",
			"signature": "org.joda.time.DateTimeZone.getConvertedId(java.lang.String)",
			"begin_line": 558,
			"end_line": 598,
			"comment": "\n     * Converts an old style id to a new style id.\n     * \n     * @param id  the old style id\n     * @return the new style id, null if not found\n     "
		}
	],
	"Time-24b": [
		{
			"class_file": "org/joda/time/format/DateTimeParserBucket.java",
			"method_name": "computeMillis",
			"arg_types": "ZLjava/lang/String;",
			"type": "method",
			"signature": "org.joda.time.format.DateTimeParserBucket.computeMillis(boolean, java.lang.String)",
			"begin_line": 331,
			"end_line": 378,
			"comment": "\n     * Computes the parsed datetime by setting the saved fields.\n     * This method is idempotent, but it is not thread-safe.\n     *\n     * @param resetFields false by default, but when true, unsaved field values are cleared\n     * @param text optional text being parsed, to be included in any error message\n     * @return milliseconds since 1970-01-01T00:00:00Z\n     * @throws IllegalArgumentException if any field is out of range\n     * @since 1.3\n     "
		}
	],
	"Time-25b": [
		{
			"class_file": "org/joda/time/DateTimeZone.java",
			"method_name": "getOffsetFromLocal",
			"arg_types": "J",
			"type": "method",
			"signature": "org.joda.time.DateTimeZone.getOffsetFromLocal(long)",
			"begin_line": 879,
			"end_line": 901,
			"comment": "\n     * Gets the millisecond offset to subtract from local time to get UTC time.\n     * This offset can be used to undo adding the offset obtained by getOffset.\n     *\n     * <pre>\n     * millisLocal == millisUTC   + getOffset(millisUTC)\n     * millisUTC   == millisLocal - getOffsetFromLocal(millisLocal)\n     * </pre>\n     *\n     * NOTE: After calculating millisLocal, some error may be introduced. At\n     * offset transitions (due to DST or other historical changes), ranges of\n     * local times may map to different UTC times.\n     * <p>\n     * This method will return an offset suitable for calculating an instant\n     * after any DST gap. For example, consider a zone with a cutover\n     * from 01:00 to 01:59:<br />\n     * Input: 00:00  Output: 00:00<br />\n     * Input: 00:30  Output: 00:30<br />\n     * Input: 01:00  Output: 02:00<br />\n     * Input: 01:30  Output: 02:30<br />\n     * Input: 02:00  Output: 02:00<br />\n     * Input: 02:30  Output: 02:30<br />\n     * <p>\n     * During a DST overlap (where the local time is ambiguous) this method will return\n     * the earlier instant. The combination of these two rules is to always favour\n     * daylight (summer) time over standard (winter) time.\n     * <p>\n     * NOTE: Prior to v2.0, the DST overlap behaviour was not defined and varied by hemisphere.\n     * Prior to v1.5, the DST gap behaviour was also not defined.\n     *\n     * @param instantLocal  the millisecond instant, relative to this time zone, to get the offset for\n     * @return the millisecond offset to subtract from local time to get UTC time\n     "
		}
	],
	"Time-26b": [
		{
			"class_file": "org/joda/time/chrono/ZonedChronology.java",
			"method_name": "addWrapField",
			"arg_types": "JI",
			"type": "method",
			"signature": "org.joda.time.chrono.ZonedChronology.ZonedDateTimeField.addWrapField(long, int)",
			"begin_line": 452,
			"end_line": 462,
			"comment": ""
		},
		{
			"class_file": "org/joda/time/field/LenientDateTimeField.java",
			"method_name": "set",
			"arg_types": "JI",
			"type": "method",
			"signature": "org.joda.time.field.LenientDateTimeField.set(long, int)",
			"begin_line": 69,
			"end_line": 76,
			"comment": "\n     * Set values which may be out of bounds by adding the difference between\n     * the new value and the current value.\n     "
		},
		{
			"class_file": "org/joda/time/chrono/ZonedChronology.java",
			"method_name": "add",
			"arg_types": "JI",
			"type": "method",
			"signature": "org.joda.time.chrono.ZonedChronology.ZonedDateTimeField.add(long, int)",
			"begin_line": 428,
			"end_line": 438,
			"comment": ""
		},
		{
			"class_file": "org/joda/time/chrono/ZonedChronology.java",
			"method_name": "roundFloor",
			"arg_types": "J",
			"type": "method",
			"signature": "org.joda.time.chrono.ZonedChronology.ZonedDateTimeField.roundFloor(long)",
			"begin_line": 520,
			"end_line": 530,
			"comment": ""
		},
		{
			"class_file": "org/joda/time/chrono/ZonedChronology.java",
			"method_name": "set",
			"arg_types": "JI",
			"type": "method",
			"signature": "org.joda.time.chrono.ZonedChronology.ZonedDateTimeField.set(long, int)",
			"begin_line": 464,
			"end_line": 475,
			"comment": ""
		},
		{
			"class_file": "org/joda/time/chrono/ZonedChronology.java",
			"method_name": "roundCeiling",
			"arg_types": "J",
			"type": "method",
			"signature": "org.joda.time.chrono.ZonedChronology.ZonedDateTimeField.roundCeiling(long)",
			"begin_line": 532,
			"end_line": 542,
			"comment": ""
		},
		{
			"class_file": "org/joda/time/chrono/ZonedChronology.java",
			"method_name": "add",
			"arg_types": "JJ",
			"type": "method",
			"signature": "org.joda.time.chrono.ZonedChronology.ZonedDateTimeField.add(long, long)",
			"begin_line": 440,
			"end_line": 450,
			"comment": ""
		},
		{
			"class_file": "org/joda/time/chrono/ZonedChronology.java",
			"method_name": "set",
			"arg_types": "JLjava/lang/String;Ljava/util/Locale;",
			"type": "method",
			"signature": "org.joda.time.chrono.ZonedChronology.ZonedDateTimeField.set(long, java.lang.String, java.util.Locale)",
			"begin_line": 477,
			"end_line": 482,
			"comment": ""
		}
	],
	"Time-27b": [
		{
			"class_file": "org/joda/time/format/PeriodFormatterBuilder.java",
			"method_name": "toFormatter",
			"arg_types": "Ljava/util/List;ZZ",
			"type": "method",
			"signature": "org.joda.time.format.PeriodFormatterBuilder.toFormatter(java.util.List<java.lang.Object>, boolean, boolean)",
			"begin_line": 794,
			"end_line": 813,
			"comment": "-----------------------------------------------------------------------"
		}
	]
}